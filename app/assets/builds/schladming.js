(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));

  // node_modules/@rails/actioncable/src/adapters.js
  var adapters_default;
  var init_adapters = __esm({
    "node_modules/@rails/actioncable/src/adapters.js"() {
      adapters_default = {
        logger: typeof console !== "undefined" ? console : void 0,
        WebSocket: typeof WebSocket !== "undefined" ? WebSocket : void 0
      };
    }
  });

  // node_modules/@rails/actioncable/src/logger.js
  var logger_default;
  var init_logger = __esm({
    "node_modules/@rails/actioncable/src/logger.js"() {
      init_adapters();
      logger_default = {
        log(...messages) {
          if (this.enabled) {
            messages.push(Date.now());
            adapters_default.logger.log("[ActionCable]", ...messages);
          }
        }
      };
    }
  });

  // node_modules/@rails/actioncable/src/connection_monitor.js
  var now, secondsSince, ConnectionMonitor, connection_monitor_default;
  var init_connection_monitor = __esm({
    "node_modules/@rails/actioncable/src/connection_monitor.js"() {
      init_logger();
      now = /* @__PURE__ */ __name(() => (/* @__PURE__ */ new Date()).getTime(), "now");
      secondsSince = /* @__PURE__ */ __name((time) => (now() - time) / 1e3, "secondsSince");
      ConnectionMonitor = class {
        static {
          __name(this, "ConnectionMonitor");
        }
        constructor(connection) {
          this.visibilityDidChange = this.visibilityDidChange.bind(this);
          this.connection = connection;
          this.reconnectAttempts = 0;
        }
        start() {
          if (!this.isRunning()) {
            this.startedAt = now();
            delete this.stoppedAt;
            this.startPolling();
            addEventListener("visibilitychange", this.visibilityDidChange);
            logger_default.log(`ConnectionMonitor started. stale threshold = ${this.constructor.staleThreshold} s`);
          }
        }
        stop() {
          if (this.isRunning()) {
            this.stoppedAt = now();
            this.stopPolling();
            removeEventListener("visibilitychange", this.visibilityDidChange);
            logger_default.log("ConnectionMonitor stopped");
          }
        }
        isRunning() {
          return this.startedAt && !this.stoppedAt;
        }
        recordPing() {
          this.pingedAt = now();
        }
        recordConnect() {
          this.reconnectAttempts = 0;
          this.recordPing();
          delete this.disconnectedAt;
          logger_default.log("ConnectionMonitor recorded connect");
        }
        recordDisconnect() {
          this.disconnectedAt = now();
          logger_default.log("ConnectionMonitor recorded disconnect");
        }
        // Private
        startPolling() {
          this.stopPolling();
          this.poll();
        }
        stopPolling() {
          clearTimeout(this.pollTimeout);
        }
        poll() {
          this.pollTimeout = setTimeout(
            () => {
              this.reconnectIfStale();
              this.poll();
            },
            this.getPollInterval()
          );
        }
        getPollInterval() {
          const { staleThreshold, reconnectionBackoffRate } = this.constructor;
          const backoff = Math.pow(1 + reconnectionBackoffRate, Math.min(this.reconnectAttempts, 10));
          const jitterMax = this.reconnectAttempts === 0 ? 1 : reconnectionBackoffRate;
          const jitter = jitterMax * Math.random();
          return staleThreshold * 1e3 * backoff * (1 + jitter);
        }
        reconnectIfStale() {
          if (this.connectionIsStale()) {
            logger_default.log(`ConnectionMonitor detected stale connection. reconnectAttempts = ${this.reconnectAttempts}, time stale = ${secondsSince(this.refreshedAt)} s, stale threshold = ${this.constructor.staleThreshold} s`);
            this.reconnectAttempts++;
            if (this.disconnectedRecently()) {
              logger_default.log(`ConnectionMonitor skipping reopening recent disconnect. time disconnected = ${secondsSince(this.disconnectedAt)} s`);
            } else {
              logger_default.log("ConnectionMonitor reopening");
              this.connection.reopen();
            }
          }
        }
        get refreshedAt() {
          return this.pingedAt ? this.pingedAt : this.startedAt;
        }
        connectionIsStale() {
          return secondsSince(this.refreshedAt) > this.constructor.staleThreshold;
        }
        disconnectedRecently() {
          return this.disconnectedAt && secondsSince(this.disconnectedAt) < this.constructor.staleThreshold;
        }
        visibilityDidChange() {
          if (document.visibilityState === "visible") {
            setTimeout(
              () => {
                if (this.connectionIsStale() || !this.connection.isOpen()) {
                  logger_default.log(`ConnectionMonitor reopening stale connection on visibilitychange. visibilityState = ${document.visibilityState}`);
                  this.connection.reopen();
                }
              },
              200
            );
          }
        }
      };
      ConnectionMonitor.staleThreshold = 6;
      ConnectionMonitor.reconnectionBackoffRate = 0.15;
      connection_monitor_default = ConnectionMonitor;
    }
  });

  // node_modules/@rails/actioncable/src/internal.js
  var internal_default;
  var init_internal = __esm({
    "node_modules/@rails/actioncable/src/internal.js"() {
      internal_default = {
        "message_types": {
          "welcome": "welcome",
          "disconnect": "disconnect",
          "ping": "ping",
          "confirmation": "confirm_subscription",
          "rejection": "reject_subscription"
        },
        "disconnect_reasons": {
          "unauthorized": "unauthorized",
          "invalid_request": "invalid_request",
          "server_restart": "server_restart",
          "remote": "remote"
        },
        "default_mount_path": "/cable",
        "protocols": [
          "actioncable-v1-json",
          "actioncable-unsupported"
        ]
      };
    }
  });

  // node_modules/@rails/actioncable/src/connection.js
  var message_types, protocols, supportedProtocols, indexOf, Connection, connection_default;
  var init_connection = __esm({
    "node_modules/@rails/actioncable/src/connection.js"() {
      init_adapters();
      init_connection_monitor();
      init_internal();
      init_logger();
      ({ message_types, protocols } = internal_default);
      supportedProtocols = protocols.slice(0, protocols.length - 1);
      indexOf = [].indexOf;
      Connection = class {
        static {
          __name(this, "Connection");
        }
        constructor(consumer2) {
          this.open = this.open.bind(this);
          this.consumer = consumer2;
          this.subscriptions = this.consumer.subscriptions;
          this.monitor = new connection_monitor_default(this);
          this.disconnected = true;
        }
        send(data) {
          if (this.isOpen()) {
            this.webSocket.send(JSON.stringify(data));
            return true;
          } else {
            return false;
          }
        }
        open() {
          if (this.isActive()) {
            logger_default.log(`Attempted to open WebSocket, but existing socket is ${this.getState()}`);
            return false;
          } else {
            const socketProtocols = [...protocols, ...this.consumer.subprotocols || []];
            logger_default.log(`Opening WebSocket, current state is ${this.getState()}, subprotocols: ${socketProtocols}`);
            if (this.webSocket) {
              this.uninstallEventHandlers();
            }
            this.webSocket = new adapters_default.WebSocket(this.consumer.url, socketProtocols);
            this.installEventHandlers();
            this.monitor.start();
            return true;
          }
        }
        close({ allowReconnect } = { allowReconnect: true }) {
          if (!allowReconnect) {
            this.monitor.stop();
          }
          if (this.isOpen()) {
            return this.webSocket.close();
          }
        }
        reopen() {
          logger_default.log(`Reopening WebSocket, current state is ${this.getState()}`);
          if (this.isActive()) {
            try {
              return this.close();
            } catch (error) {
              logger_default.log("Failed to reopen WebSocket", error);
            } finally {
              logger_default.log(`Reopening WebSocket in ${this.constructor.reopenDelay}ms`);
              setTimeout(this.open, this.constructor.reopenDelay);
            }
          } else {
            return this.open();
          }
        }
        getProtocol() {
          if (this.webSocket) {
            return this.webSocket.protocol;
          }
        }
        isOpen() {
          return this.isState("open");
        }
        isActive() {
          return this.isState("open", "connecting");
        }
        triedToReconnect() {
          return this.monitor.reconnectAttempts > 0;
        }
        // Private
        isProtocolSupported() {
          return indexOf.call(supportedProtocols, this.getProtocol()) >= 0;
        }
        isState(...states) {
          return indexOf.call(states, this.getState()) >= 0;
        }
        getState() {
          if (this.webSocket) {
            for (let state in adapters_default.WebSocket) {
              if (adapters_default.WebSocket[state] === this.webSocket.readyState) {
                return state.toLowerCase();
              }
            }
          }
          return null;
        }
        installEventHandlers() {
          for (let eventName in this.events) {
            const handler = this.events[eventName].bind(this);
            this.webSocket[`on${eventName}`] = handler;
          }
        }
        uninstallEventHandlers() {
          for (let eventName in this.events) {
            this.webSocket[`on${eventName}`] = function() {
            };
          }
        }
      };
      Connection.reopenDelay = 500;
      Connection.prototype.events = {
        message(event) {
          if (!this.isProtocolSupported()) {
            return;
          }
          const { identifier, message, reason, reconnect, type } = JSON.parse(event.data);
          switch (type) {
            case message_types.welcome:
              if (this.triedToReconnect()) {
                this.reconnectAttempted = true;
              }
              this.monitor.recordConnect();
              return this.subscriptions.reload();
            case message_types.disconnect:
              logger_default.log(`Disconnecting. Reason: ${reason}`);
              return this.close({ allowReconnect: reconnect });
            case message_types.ping:
              return this.monitor.recordPing();
            case message_types.confirmation:
              this.subscriptions.confirmSubscription(identifier);
              if (this.reconnectAttempted) {
                this.reconnectAttempted = false;
                return this.subscriptions.notify(identifier, "connected", { reconnected: true });
              } else {
                return this.subscriptions.notify(identifier, "connected", { reconnected: false });
              }
            case message_types.rejection:
              return this.subscriptions.reject(identifier);
            default:
              return this.subscriptions.notify(identifier, "received", message);
          }
        },
        open() {
          logger_default.log(`WebSocket onopen event, using '${this.getProtocol()}' subprotocol`);
          this.disconnected = false;
          if (!this.isProtocolSupported()) {
            logger_default.log("Protocol is unsupported. Stopping monitor and disconnecting.");
            return this.close({ allowReconnect: false });
          }
        },
        close(event) {
          logger_default.log("WebSocket onclose event");
          if (this.disconnected) {
            return;
          }
          this.disconnected = true;
          this.monitor.recordDisconnect();
          return this.subscriptions.notifyAll("disconnected", { willAttemptReconnect: this.monitor.isRunning() });
        },
        error() {
          logger_default.log("WebSocket onerror event");
        }
      };
      connection_default = Connection;
    }
  });

  // node_modules/@rails/actioncable/src/subscription.js
  var extend, Subscription;
  var init_subscription = __esm({
    "node_modules/@rails/actioncable/src/subscription.js"() {
      extend = /* @__PURE__ */ __name(function(object, properties) {
        if (properties != null) {
          for (let key in properties) {
            const value = properties[key];
            object[key] = value;
          }
        }
        return object;
      }, "extend");
      Subscription = class {
        static {
          __name(this, "Subscription");
        }
        constructor(consumer2, params = {}, mixin) {
          this.consumer = consumer2;
          this.identifier = JSON.stringify(params);
          extend(this, mixin);
        }
        // Perform a channel action with the optional data passed as an attribute
        perform(action, data = {}) {
          data.action = action;
          return this.send(data);
        }
        send(data) {
          return this.consumer.send({ command: "message", identifier: this.identifier, data: JSON.stringify(data) });
        }
        unsubscribe() {
          return this.consumer.subscriptions.remove(this);
        }
      };
    }
  });

  // node_modules/@rails/actioncable/src/subscription_guarantor.js
  var SubscriptionGuarantor, subscription_guarantor_default;
  var init_subscription_guarantor = __esm({
    "node_modules/@rails/actioncable/src/subscription_guarantor.js"() {
      init_logger();
      SubscriptionGuarantor = class {
        static {
          __name(this, "SubscriptionGuarantor");
        }
        constructor(subscriptions) {
          this.subscriptions = subscriptions;
          this.pendingSubscriptions = [];
        }
        guarantee(subscription) {
          if (this.pendingSubscriptions.indexOf(subscription) == -1) {
            logger_default.log(`SubscriptionGuarantor guaranteeing ${subscription.identifier}`);
            this.pendingSubscriptions.push(subscription);
          } else {
            logger_default.log(`SubscriptionGuarantor already guaranteeing ${subscription.identifier}`);
          }
          this.startGuaranteeing();
        }
        forget(subscription) {
          logger_default.log(`SubscriptionGuarantor forgetting ${subscription.identifier}`);
          this.pendingSubscriptions = this.pendingSubscriptions.filter((s2) => s2 !== subscription);
        }
        startGuaranteeing() {
          this.stopGuaranteeing();
          this.retrySubscribing();
        }
        stopGuaranteeing() {
          clearTimeout(this.retryTimeout);
        }
        retrySubscribing() {
          this.retryTimeout = setTimeout(
            () => {
              if (this.subscriptions && typeof this.subscriptions.subscribe === "function") {
                this.pendingSubscriptions.map((subscription) => {
                  logger_default.log(`SubscriptionGuarantor resubscribing ${subscription.identifier}`);
                  this.subscriptions.subscribe(subscription);
                });
              }
            },
            500
          );
        }
      };
      subscription_guarantor_default = SubscriptionGuarantor;
    }
  });

  // node_modules/@rails/actioncable/src/subscriptions.js
  var Subscriptions;
  var init_subscriptions = __esm({
    "node_modules/@rails/actioncable/src/subscriptions.js"() {
      init_subscription();
      init_subscription_guarantor();
      init_logger();
      Subscriptions = class {
        static {
          __name(this, "Subscriptions");
        }
        constructor(consumer2) {
          this.consumer = consumer2;
          this.guarantor = new subscription_guarantor_default(this);
          this.subscriptions = [];
        }
        create(channelName, mixin) {
          const channel = channelName;
          const params = typeof channel === "object" ? channel : { channel };
          const subscription = new Subscription(this.consumer, params, mixin);
          return this.add(subscription);
        }
        // Private
        add(subscription) {
          this.subscriptions.push(subscription);
          this.consumer.ensureActiveConnection();
          this.notify(subscription, "initialized");
          this.subscribe(subscription);
          return subscription;
        }
        remove(subscription) {
          this.forget(subscription);
          if (!this.findAll(subscription.identifier).length) {
            this.sendCommand(subscription, "unsubscribe");
          }
          return subscription;
        }
        reject(identifier) {
          return this.findAll(identifier).map((subscription) => {
            this.forget(subscription);
            this.notify(subscription, "rejected");
            return subscription;
          });
        }
        forget(subscription) {
          this.guarantor.forget(subscription);
          this.subscriptions = this.subscriptions.filter((s2) => s2 !== subscription);
          return subscription;
        }
        findAll(identifier) {
          return this.subscriptions.filter((s2) => s2.identifier === identifier);
        }
        reload() {
          return this.subscriptions.map((subscription) => this.subscribe(subscription));
        }
        notifyAll(callbackName, ...args) {
          return this.subscriptions.map((subscription) => this.notify(subscription, callbackName, ...args));
        }
        notify(subscription, callbackName, ...args) {
          let subscriptions;
          if (typeof subscription === "string") {
            subscriptions = this.findAll(subscription);
          } else {
            subscriptions = [subscription];
          }
          return subscriptions.map((subscription2) => typeof subscription2[callbackName] === "function" ? subscription2[callbackName](...args) : void 0);
        }
        subscribe(subscription) {
          if (this.sendCommand(subscription, "subscribe")) {
            this.guarantor.guarantee(subscription);
          }
        }
        confirmSubscription(identifier) {
          logger_default.log(`Subscription confirmed ${identifier}`);
          this.findAll(identifier).map((subscription) => this.guarantor.forget(subscription));
        }
        sendCommand(subscription, command) {
          const { identifier } = subscription;
          return this.consumer.send({ command, identifier });
        }
      };
    }
  });

  // node_modules/@rails/actioncable/src/consumer.js
  function createWebSocketURL(url) {
    if (typeof url === "function") {
      url = url();
    }
    if (url && !/^wss?:/i.test(url)) {
      const a2 = document.createElement("a");
      a2.href = url;
      a2.href = a2.href;
      a2.protocol = a2.protocol.replace("http", "ws");
      return a2.href;
    } else {
      return url;
    }
  }
  var Consumer;
  var init_consumer = __esm({
    "node_modules/@rails/actioncable/src/consumer.js"() {
      init_connection();
      init_subscriptions();
      Consumer = class {
        static {
          __name(this, "Consumer");
        }
        constructor(url) {
          this._url = url;
          this.subscriptions = new Subscriptions(this);
          this.connection = new connection_default(this);
          this.subprotocols = [];
        }
        get url() {
          return createWebSocketURL(this._url);
        }
        send(data) {
          return this.connection.send(data);
        }
        connect() {
          return this.connection.open();
        }
        disconnect() {
          return this.connection.close({ allowReconnect: false });
        }
        ensureActiveConnection() {
          if (!this.connection.isActive()) {
            return this.connection.open();
          }
        }
        addSubProtocol(subprotocol) {
          this.subprotocols = [...this.subprotocols, subprotocol];
        }
      };
      __name(createWebSocketURL, "createWebSocketURL");
    }
  });

  // node_modules/@rails/actioncable/src/index.js
  var src_exports = {};
  __export(src_exports, {
    Connection: () => connection_default,
    ConnectionMonitor: () => connection_monitor_default,
    Consumer: () => Consumer,
    INTERNAL: () => internal_default,
    Subscription: () => Subscription,
    SubscriptionGuarantor: () => subscription_guarantor_default,
    Subscriptions: () => Subscriptions,
    adapters: () => adapters_default,
    createConsumer: () => createConsumer,
    createWebSocketURL: () => createWebSocketURL,
    getConfig: () => getConfig,
    logger: () => logger_default
  });
  function createConsumer(url = getConfig("url") || internal_default.default_mount_path) {
    return new Consumer(url);
  }
  function getConfig(name) {
    const element = document.head.querySelector(`meta[name='action-cable-${name}']`);
    if (element) {
      return element.getAttribute("content");
    }
  }
  var init_src = __esm({
    "node_modules/@rails/actioncable/src/index.js"() {
      init_connection();
      init_connection_monitor();
      init_consumer();
      init_internal();
      init_subscription();
      init_subscriptions();
      init_subscription_guarantor();
      init_adapters();
      init_logger();
      __name(createConsumer, "createConsumer");
      __name(getConfig, "getConfig");
    }
  });

  // node_modules/debounce/index.js
  var require_debounce = __commonJS({
    "node_modules/debounce/index.js"(exports2, module2) {
      function debounce5(function_, wait = 100, options = {}) {
        if (typeof function_ !== "function") {
          throw new TypeError(`Expected the first parameter to be a function, got \`${typeof function_}\`.`);
        }
        if (wait < 0) {
          throw new RangeError("`wait` must not be negative.");
        }
        const { immediate } = typeof options === "boolean" ? { immediate: options } : options;
        let storedContext;
        let storedArguments;
        let timeoutId;
        let timestamp;
        let result;
        function later() {
          const last = Date.now() - timestamp;
          if (last < wait && last >= 0) {
            timeoutId = setTimeout(later, wait - last);
          } else {
            timeoutId = void 0;
            if (!immediate) {
              const callContext = storedContext;
              const callArguments = storedArguments;
              storedContext = void 0;
              storedArguments = void 0;
              result = function_.apply(callContext, callArguments);
            }
          }
        }
        __name(later, "later");
        const debounced = /* @__PURE__ */ __name(function(...arguments_) {
          if (storedContext && this !== storedContext) {
            throw new Error("Debounced method called with different contexts.");
          }
          storedContext = this;
          storedArguments = arguments_;
          timestamp = Date.now();
          const callNow = immediate && !timeoutId;
          if (!timeoutId) {
            timeoutId = setTimeout(later, wait);
          }
          if (callNow) {
            const callContext = storedContext;
            const callArguments = storedArguments;
            storedContext = void 0;
            storedArguments = void 0;
            result = function_.apply(callContext, callArguments);
          }
          return result;
        }, "debounced");
        debounced.clear = () => {
          if (!timeoutId) {
            return;
          }
          clearTimeout(timeoutId);
          timeoutId = void 0;
        };
        debounced.flush = () => {
          if (!timeoutId) {
            return;
          }
          const callContext = storedContext;
          const callArguments = storedArguments;
          storedContext = void 0;
          storedArguments = void 0;
          result = function_.apply(callContext, callArguments);
          clearTimeout(timeoutId);
          timeoutId = void 0;
        };
        return debounced;
      }
      __name(debounce5, "debounce");
      module2.exports.debounce = debounce5;
      module2.exports = debounce5;
    }
  });

  // node_modules/fast-diff/diff.js
  var require_diff = __commonJS({
    "node_modules/fast-diff/diff.js"(exports2, module2) {
      var DIFF_DELETE = -1;
      var DIFF_INSERT = 1;
      var DIFF_EQUAL = 0;
      function diff_main(text1, text2, cursor_pos, cleanup, _fix_unicode) {
        if (text1 === text2) {
          if (text1) {
            return [[DIFF_EQUAL, text1]];
          }
          return [];
        }
        if (cursor_pos != null) {
          var editdiff = find_cursor_edit_diff(text1, text2, cursor_pos);
          if (editdiff) {
            return editdiff;
          }
        }
        var commonlength = diff_commonPrefix(text1, text2);
        var commonprefix = text1.substring(0, commonlength);
        text1 = text1.substring(commonlength);
        text2 = text2.substring(commonlength);
        commonlength = diff_commonSuffix(text1, text2);
        var commonsuffix = text1.substring(text1.length - commonlength);
        text1 = text1.substring(0, text1.length - commonlength);
        text2 = text2.substring(0, text2.length - commonlength);
        var diffs = diff_compute_(text1, text2);
        if (commonprefix) {
          diffs.unshift([DIFF_EQUAL, commonprefix]);
        }
        if (commonsuffix) {
          diffs.push([DIFF_EQUAL, commonsuffix]);
        }
        diff_cleanupMerge(diffs, _fix_unicode);
        if (cleanup) {
          diff_cleanupSemantic(diffs);
        }
        return diffs;
      }
      __name(diff_main, "diff_main");
      function diff_compute_(text1, text2) {
        var diffs;
        if (!text1) {
          return [[DIFF_INSERT, text2]];
        }
        if (!text2) {
          return [[DIFF_DELETE, text1]];
        }
        var longtext = text1.length > text2.length ? text1 : text2;
        var shorttext = text1.length > text2.length ? text2 : text1;
        var i2 = longtext.indexOf(shorttext);
        if (i2 !== -1) {
          diffs = [
            [DIFF_INSERT, longtext.substring(0, i2)],
            [DIFF_EQUAL, shorttext],
            [DIFF_INSERT, longtext.substring(i2 + shorttext.length)]
          ];
          if (text1.length > text2.length) {
            diffs[0][0] = diffs[2][0] = DIFF_DELETE;
          }
          return diffs;
        }
        if (shorttext.length === 1) {
          return [
            [DIFF_DELETE, text1],
            [DIFF_INSERT, text2]
          ];
        }
        var hm = diff_halfMatch_(text1, text2);
        if (hm) {
          var text1_a = hm[0];
          var text1_b = hm[1];
          var text2_a = hm[2];
          var text2_b = hm[3];
          var mid_common = hm[4];
          var diffs_a = diff_main(text1_a, text2_a);
          var diffs_b = diff_main(text1_b, text2_b);
          return diffs_a.concat([[DIFF_EQUAL, mid_common]], diffs_b);
        }
        return diff_bisect_(text1, text2);
      }
      __name(diff_compute_, "diff_compute_");
      function diff_bisect_(text1, text2) {
        var text1_length = text1.length;
        var text2_length = text2.length;
        var max_d = Math.ceil((text1_length + text2_length) / 2);
        var v_offset = max_d;
        var v_length = 2 * max_d;
        var v1 = new Array(v_length);
        var v2 = new Array(v_length);
        for (var x2 = 0; x2 < v_length; x2++) {
          v1[x2] = -1;
          v2[x2] = -1;
        }
        v1[v_offset + 1] = 0;
        v2[v_offset + 1] = 0;
        var delta = text1_length - text2_length;
        var front = delta % 2 !== 0;
        var k1start = 0;
        var k1end = 0;
        var k2start = 0;
        var k2end = 0;
        for (var d2 = 0; d2 < max_d; d2++) {
          for (var k1 = -d2 + k1start; k1 <= d2 - k1end; k1 += 2) {
            var k1_offset = v_offset + k1;
            var x1;
            if (k1 === -d2 || k1 !== d2 && v1[k1_offset - 1] < v1[k1_offset + 1]) {
              x1 = v1[k1_offset + 1];
            } else {
              x1 = v1[k1_offset - 1] + 1;
            }
            var y1 = x1 - k1;
            while (x1 < text1_length && y1 < text2_length && text1.charAt(x1) === text2.charAt(y1)) {
              x1++;
              y1++;
            }
            v1[k1_offset] = x1;
            if (x1 > text1_length) {
              k1end += 2;
            } else if (y1 > text2_length) {
              k1start += 2;
            } else if (front) {
              var k2_offset = v_offset + delta - k1;
              if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] !== -1) {
                var x22 = text1_length - v2[k2_offset];
                if (x1 >= x22) {
                  return diff_bisectSplit_(text1, text2, x1, y1);
                }
              }
            }
          }
          for (var k2 = -d2 + k2start; k2 <= d2 - k2end; k2 += 2) {
            var k2_offset = v_offset + k2;
            var x22;
            if (k2 === -d2 || k2 !== d2 && v2[k2_offset - 1] < v2[k2_offset + 1]) {
              x22 = v2[k2_offset + 1];
            } else {
              x22 = v2[k2_offset - 1] + 1;
            }
            var y2 = x22 - k2;
            while (x22 < text1_length && y2 < text2_length && text1.charAt(text1_length - x22 - 1) === text2.charAt(text2_length - y2 - 1)) {
              x22++;
              y2++;
            }
            v2[k2_offset] = x22;
            if (x22 > text1_length) {
              k2end += 2;
            } else if (y2 > text2_length) {
              k2start += 2;
            } else if (!front) {
              var k1_offset = v_offset + delta - k2;
              if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] !== -1) {
                var x1 = v1[k1_offset];
                var y1 = v_offset + x1 - k1_offset;
                x22 = text1_length - x22;
                if (x1 >= x22) {
                  return diff_bisectSplit_(text1, text2, x1, y1);
                }
              }
            }
          }
        }
        return [
          [DIFF_DELETE, text1],
          [DIFF_INSERT, text2]
        ];
      }
      __name(diff_bisect_, "diff_bisect_");
      function diff_bisectSplit_(text1, text2, x2, y2) {
        var text1a = text1.substring(0, x2);
        var text2a = text2.substring(0, y2);
        var text1b = text1.substring(x2);
        var text2b = text2.substring(y2);
        var diffs = diff_main(text1a, text2a);
        var diffsb = diff_main(text1b, text2b);
        return diffs.concat(diffsb);
      }
      __name(diff_bisectSplit_, "diff_bisectSplit_");
      function diff_commonPrefix(text1, text2) {
        if (!text1 || !text2 || text1.charAt(0) !== text2.charAt(0)) {
          return 0;
        }
        var pointermin = 0;
        var pointermax = Math.min(text1.length, text2.length);
        var pointermid = pointermax;
        var pointerstart = 0;
        while (pointermin < pointermid) {
          if (text1.substring(pointerstart, pointermid) == text2.substring(pointerstart, pointermid)) {
            pointermin = pointermid;
            pointerstart = pointermin;
          } else {
            pointermax = pointermid;
          }
          pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
        }
        if (is_surrogate_pair_start(text1.charCodeAt(pointermid - 1))) {
          pointermid--;
        }
        return pointermid;
      }
      __name(diff_commonPrefix, "diff_commonPrefix");
      function diff_commonOverlap_(text1, text2) {
        var text1_length = text1.length;
        var text2_length = text2.length;
        if (text1_length == 0 || text2_length == 0) {
          return 0;
        }
        if (text1_length > text2_length) {
          text1 = text1.substring(text1_length - text2_length);
        } else if (text1_length < text2_length) {
          text2 = text2.substring(0, text1_length);
        }
        var text_length = Math.min(text1_length, text2_length);
        if (text1 == text2) {
          return text_length;
        }
        var best = 0;
        var length = 1;
        while (true) {
          var pattern = text1.substring(text_length - length);
          var found = text2.indexOf(pattern);
          if (found == -1) {
            return best;
          }
          length += found;
          if (found == 0 || text1.substring(text_length - length) == text2.substring(0, length)) {
            best = length;
            length++;
          }
        }
      }
      __name(diff_commonOverlap_, "diff_commonOverlap_");
      function diff_commonSuffix(text1, text2) {
        if (!text1 || !text2 || text1.slice(-1) !== text2.slice(-1)) {
          return 0;
        }
        var pointermin = 0;
        var pointermax = Math.min(text1.length, text2.length);
        var pointermid = pointermax;
        var pointerend = 0;
        while (pointermin < pointermid) {
          if (text1.substring(text1.length - pointermid, text1.length - pointerend) == text2.substring(text2.length - pointermid, text2.length - pointerend)) {
            pointermin = pointermid;
            pointerend = pointermin;
          } else {
            pointermax = pointermid;
          }
          pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
        }
        if (is_surrogate_pair_end(text1.charCodeAt(text1.length - pointermid))) {
          pointermid--;
        }
        return pointermid;
      }
      __name(diff_commonSuffix, "diff_commonSuffix");
      function diff_halfMatch_(text1, text2) {
        var longtext = text1.length > text2.length ? text1 : text2;
        var shorttext = text1.length > text2.length ? text2 : text1;
        if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {
          return null;
        }
        function diff_halfMatchI_(longtext2, shorttext2, i2) {
          var seed = longtext2.substring(i2, i2 + Math.floor(longtext2.length / 4));
          var j2 = -1;
          var best_common = "";
          var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;
          while ((j2 = shorttext2.indexOf(seed, j2 + 1)) !== -1) {
            var prefixLength = diff_commonPrefix(
              longtext2.substring(i2),
              shorttext2.substring(j2)
            );
            var suffixLength = diff_commonSuffix(
              longtext2.substring(0, i2),
              shorttext2.substring(0, j2)
            );
            if (best_common.length < suffixLength + prefixLength) {
              best_common = shorttext2.substring(j2 - suffixLength, j2) + shorttext2.substring(j2, j2 + prefixLength);
              best_longtext_a = longtext2.substring(0, i2 - suffixLength);
              best_longtext_b = longtext2.substring(i2 + prefixLength);
              best_shorttext_a = shorttext2.substring(0, j2 - suffixLength);
              best_shorttext_b = shorttext2.substring(j2 + prefixLength);
            }
          }
          if (best_common.length * 2 >= longtext2.length) {
            return [
              best_longtext_a,
              best_longtext_b,
              best_shorttext_a,
              best_shorttext_b,
              best_common
            ];
          } else {
            return null;
          }
        }
        __name(diff_halfMatchI_, "diff_halfMatchI_");
        var hm1 = diff_halfMatchI_(
          longtext,
          shorttext,
          Math.ceil(longtext.length / 4)
        );
        var hm2 = diff_halfMatchI_(
          longtext,
          shorttext,
          Math.ceil(longtext.length / 2)
        );
        var hm;
        if (!hm1 && !hm2) {
          return null;
        } else if (!hm2) {
          hm = hm1;
        } else if (!hm1) {
          hm = hm2;
        } else {
          hm = hm1[4].length > hm2[4].length ? hm1 : hm2;
        }
        var text1_a, text1_b, text2_a, text2_b;
        if (text1.length > text2.length) {
          text1_a = hm[0];
          text1_b = hm[1];
          text2_a = hm[2];
          text2_b = hm[3];
        } else {
          text2_a = hm[0];
          text2_b = hm[1];
          text1_a = hm[2];
          text1_b = hm[3];
        }
        var mid_common = hm[4];
        return [text1_a, text1_b, text2_a, text2_b, mid_common];
      }
      __name(diff_halfMatch_, "diff_halfMatch_");
      function diff_cleanupSemantic(diffs) {
        var changes = false;
        var equalities = [];
        var equalitiesLength = 0;
        var lastequality = null;
        var pointer = 0;
        var length_insertions1 = 0;
        var length_deletions1 = 0;
        var length_insertions2 = 0;
        var length_deletions2 = 0;
        while (pointer < diffs.length) {
          if (diffs[pointer][0] == DIFF_EQUAL) {
            equalities[equalitiesLength++] = pointer;
            length_insertions1 = length_insertions2;
            length_deletions1 = length_deletions2;
            length_insertions2 = 0;
            length_deletions2 = 0;
            lastequality = diffs[pointer][1];
          } else {
            if (diffs[pointer][0] == DIFF_INSERT) {
              length_insertions2 += diffs[pointer][1].length;
            } else {
              length_deletions2 += diffs[pointer][1].length;
            }
            if (lastequality && lastequality.length <= Math.max(length_insertions1, length_deletions1) && lastequality.length <= Math.max(length_insertions2, length_deletions2)) {
              diffs.splice(equalities[equalitiesLength - 1], 0, [
                DIFF_DELETE,
                lastequality
              ]);
              diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;
              equalitiesLength--;
              equalitiesLength--;
              pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;
              length_insertions1 = 0;
              length_deletions1 = 0;
              length_insertions2 = 0;
              length_deletions2 = 0;
              lastequality = null;
              changes = true;
            }
          }
          pointer++;
        }
        if (changes) {
          diff_cleanupMerge(diffs);
        }
        diff_cleanupSemanticLossless(diffs);
        pointer = 1;
        while (pointer < diffs.length) {
          if (diffs[pointer - 1][0] == DIFF_DELETE && diffs[pointer][0] == DIFF_INSERT) {
            var deletion = diffs[pointer - 1][1];
            var insertion = diffs[pointer][1];
            var overlap_length1 = diff_commonOverlap_(deletion, insertion);
            var overlap_length2 = diff_commonOverlap_(insertion, deletion);
            if (overlap_length1 >= overlap_length2) {
              if (overlap_length1 >= deletion.length / 2 || overlap_length1 >= insertion.length / 2) {
                diffs.splice(pointer, 0, [
                  DIFF_EQUAL,
                  insertion.substring(0, overlap_length1)
                ]);
                diffs[pointer - 1][1] = deletion.substring(
                  0,
                  deletion.length - overlap_length1
                );
                diffs[pointer + 1][1] = insertion.substring(overlap_length1);
                pointer++;
              }
            } else {
              if (overlap_length2 >= deletion.length / 2 || overlap_length2 >= insertion.length / 2) {
                diffs.splice(pointer, 0, [
                  DIFF_EQUAL,
                  deletion.substring(0, overlap_length2)
                ]);
                diffs[pointer - 1][0] = DIFF_INSERT;
                diffs[pointer - 1][1] = insertion.substring(
                  0,
                  insertion.length - overlap_length2
                );
                diffs[pointer + 1][0] = DIFF_DELETE;
                diffs[pointer + 1][1] = deletion.substring(overlap_length2);
                pointer++;
              }
            }
            pointer++;
          }
          pointer++;
        }
      }
      __name(diff_cleanupSemantic, "diff_cleanupSemantic");
      var nonAlphaNumericRegex_ = /[^a-zA-Z0-9]/;
      var whitespaceRegex_ = /\s/;
      var linebreakRegex_ = /[\r\n]/;
      var blanklineEndRegex_ = /\n\r?\n$/;
      var blanklineStartRegex_ = /^\r?\n\r?\n/;
      function diff_cleanupSemanticLossless(diffs) {
        function diff_cleanupSemanticScore_(one, two) {
          if (!one || !two) {
            return 6;
          }
          var char1 = one.charAt(one.length - 1);
          var char2 = two.charAt(0);
          var nonAlphaNumeric1 = char1.match(nonAlphaNumericRegex_);
          var nonAlphaNumeric2 = char2.match(nonAlphaNumericRegex_);
          var whitespace1 = nonAlphaNumeric1 && char1.match(whitespaceRegex_);
          var whitespace2 = nonAlphaNumeric2 && char2.match(whitespaceRegex_);
          var lineBreak1 = whitespace1 && char1.match(linebreakRegex_);
          var lineBreak2 = whitespace2 && char2.match(linebreakRegex_);
          var blankLine1 = lineBreak1 && one.match(blanklineEndRegex_);
          var blankLine2 = lineBreak2 && two.match(blanklineStartRegex_);
          if (blankLine1 || blankLine2) {
            return 5;
          } else if (lineBreak1 || lineBreak2) {
            return 4;
          } else if (nonAlphaNumeric1 && !whitespace1 && whitespace2) {
            return 3;
          } else if (whitespace1 || whitespace2) {
            return 2;
          } else if (nonAlphaNumeric1 || nonAlphaNumeric2) {
            return 1;
          }
          return 0;
        }
        __name(diff_cleanupSemanticScore_, "diff_cleanupSemanticScore_");
        var pointer = 1;
        while (pointer < diffs.length - 1) {
          if (diffs[pointer - 1][0] == DIFF_EQUAL && diffs[pointer + 1][0] == DIFF_EQUAL) {
            var equality1 = diffs[pointer - 1][1];
            var edit = diffs[pointer][1];
            var equality2 = diffs[pointer + 1][1];
            var commonOffset = diff_commonSuffix(equality1, edit);
            if (commonOffset) {
              var commonString = edit.substring(edit.length - commonOffset);
              equality1 = equality1.substring(0, equality1.length - commonOffset);
              edit = commonString + edit.substring(0, edit.length - commonOffset);
              equality2 = commonString + equality2;
            }
            var bestEquality1 = equality1;
            var bestEdit = edit;
            var bestEquality2 = equality2;
            var bestScore = diff_cleanupSemanticScore_(equality1, edit) + diff_cleanupSemanticScore_(edit, equality2);
            while (edit.charAt(0) === equality2.charAt(0)) {
              equality1 += edit.charAt(0);
              edit = edit.substring(1) + equality2.charAt(0);
              equality2 = equality2.substring(1);
              var score = diff_cleanupSemanticScore_(equality1, edit) + diff_cleanupSemanticScore_(edit, equality2);
              if (score >= bestScore) {
                bestScore = score;
                bestEquality1 = equality1;
                bestEdit = edit;
                bestEquality2 = equality2;
              }
            }
            if (diffs[pointer - 1][1] != bestEquality1) {
              if (bestEquality1) {
                diffs[pointer - 1][1] = bestEquality1;
              } else {
                diffs.splice(pointer - 1, 1);
                pointer--;
              }
              diffs[pointer][1] = bestEdit;
              if (bestEquality2) {
                diffs[pointer + 1][1] = bestEquality2;
              } else {
                diffs.splice(pointer + 1, 1);
                pointer--;
              }
            }
          }
          pointer++;
        }
      }
      __name(diff_cleanupSemanticLossless, "diff_cleanupSemanticLossless");
      function diff_cleanupMerge(diffs, fix_unicode) {
        diffs.push([DIFF_EQUAL, ""]);
        var pointer = 0;
        var count_delete = 0;
        var count_insert = 0;
        var text_delete = "";
        var text_insert = "";
        var commonlength;
        while (pointer < diffs.length) {
          if (pointer < diffs.length - 1 && !diffs[pointer][1]) {
            diffs.splice(pointer, 1);
            continue;
          }
          switch (diffs[pointer][0]) {
            case DIFF_INSERT:
              count_insert++;
              text_insert += diffs[pointer][1];
              pointer++;
              break;
            case DIFF_DELETE:
              count_delete++;
              text_delete += diffs[pointer][1];
              pointer++;
              break;
            case DIFF_EQUAL:
              var previous_equality = pointer - count_insert - count_delete - 1;
              if (fix_unicode) {
                if (previous_equality >= 0 && ends_with_pair_start(diffs[previous_equality][1])) {
                  var stray = diffs[previous_equality][1].slice(-1);
                  diffs[previous_equality][1] = diffs[previous_equality][1].slice(
                    0,
                    -1
                  );
                  text_delete = stray + text_delete;
                  text_insert = stray + text_insert;
                  if (!diffs[previous_equality][1]) {
                    diffs.splice(previous_equality, 1);
                    pointer--;
                    var k2 = previous_equality - 1;
                    if (diffs[k2] && diffs[k2][0] === DIFF_INSERT) {
                      count_insert++;
                      text_insert = diffs[k2][1] + text_insert;
                      k2--;
                    }
                    if (diffs[k2] && diffs[k2][0] === DIFF_DELETE) {
                      count_delete++;
                      text_delete = diffs[k2][1] + text_delete;
                      k2--;
                    }
                    previous_equality = k2;
                  }
                }
                if (starts_with_pair_end(diffs[pointer][1])) {
                  var stray = diffs[pointer][1].charAt(0);
                  diffs[pointer][1] = diffs[pointer][1].slice(1);
                  text_delete += stray;
                  text_insert += stray;
                }
              }
              if (pointer < diffs.length - 1 && !diffs[pointer][1]) {
                diffs.splice(pointer, 1);
                break;
              }
              if (text_delete.length > 0 || text_insert.length > 0) {
                if (text_delete.length > 0 && text_insert.length > 0) {
                  commonlength = diff_commonPrefix(text_insert, text_delete);
                  if (commonlength !== 0) {
                    if (previous_equality >= 0) {
                      diffs[previous_equality][1] += text_insert.substring(
                        0,
                        commonlength
                      );
                    } else {
                      diffs.splice(0, 0, [
                        DIFF_EQUAL,
                        text_insert.substring(0, commonlength)
                      ]);
                      pointer++;
                    }
                    text_insert = text_insert.substring(commonlength);
                    text_delete = text_delete.substring(commonlength);
                  }
                  commonlength = diff_commonSuffix(text_insert, text_delete);
                  if (commonlength !== 0) {
                    diffs[pointer][1] = text_insert.substring(text_insert.length - commonlength) + diffs[pointer][1];
                    text_insert = text_insert.substring(
                      0,
                      text_insert.length - commonlength
                    );
                    text_delete = text_delete.substring(
                      0,
                      text_delete.length - commonlength
                    );
                  }
                }
                var n2 = count_insert + count_delete;
                if (text_delete.length === 0 && text_insert.length === 0) {
                  diffs.splice(pointer - n2, n2);
                  pointer = pointer - n2;
                } else if (text_delete.length === 0) {
                  diffs.splice(pointer - n2, n2, [DIFF_INSERT, text_insert]);
                  pointer = pointer - n2 + 1;
                } else if (text_insert.length === 0) {
                  diffs.splice(pointer - n2, n2, [DIFF_DELETE, text_delete]);
                  pointer = pointer - n2 + 1;
                } else {
                  diffs.splice(
                    pointer - n2,
                    n2,
                    [DIFF_DELETE, text_delete],
                    [DIFF_INSERT, text_insert]
                  );
                  pointer = pointer - n2 + 2;
                }
              }
              if (pointer !== 0 && diffs[pointer - 1][0] === DIFF_EQUAL) {
                diffs[pointer - 1][1] += diffs[pointer][1];
                diffs.splice(pointer, 1);
              } else {
                pointer++;
              }
              count_insert = 0;
              count_delete = 0;
              text_delete = "";
              text_insert = "";
              break;
          }
        }
        if (diffs[diffs.length - 1][1] === "") {
          diffs.pop();
        }
        var changes = false;
        pointer = 1;
        while (pointer < diffs.length - 1) {
          if (diffs[pointer - 1][0] === DIFF_EQUAL && diffs[pointer + 1][0] === DIFF_EQUAL) {
            if (diffs[pointer][1].substring(
              diffs[pointer][1].length - diffs[pointer - 1][1].length
            ) === diffs[pointer - 1][1]) {
              diffs[pointer][1] = diffs[pointer - 1][1] + diffs[pointer][1].substring(
                0,
                diffs[pointer][1].length - diffs[pointer - 1][1].length
              );
              diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];
              diffs.splice(pointer - 1, 1);
              changes = true;
            } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) == diffs[pointer + 1][1]) {
              diffs[pointer - 1][1] += diffs[pointer + 1][1];
              diffs[pointer][1] = diffs[pointer][1].substring(diffs[pointer + 1][1].length) + diffs[pointer + 1][1];
              diffs.splice(pointer + 1, 1);
              changes = true;
            }
          }
          pointer++;
        }
        if (changes) {
          diff_cleanupMerge(diffs, fix_unicode);
        }
      }
      __name(diff_cleanupMerge, "diff_cleanupMerge");
      function is_surrogate_pair_start(charCode) {
        return charCode >= 55296 && charCode <= 56319;
      }
      __name(is_surrogate_pair_start, "is_surrogate_pair_start");
      function is_surrogate_pair_end(charCode) {
        return charCode >= 56320 && charCode <= 57343;
      }
      __name(is_surrogate_pair_end, "is_surrogate_pair_end");
      function starts_with_pair_end(str) {
        return is_surrogate_pair_end(str.charCodeAt(0));
      }
      __name(starts_with_pair_end, "starts_with_pair_end");
      function ends_with_pair_start(str) {
        return is_surrogate_pair_start(str.charCodeAt(str.length - 1));
      }
      __name(ends_with_pair_start, "ends_with_pair_start");
      function remove_empty_tuples(tuples) {
        var ret = [];
        for (var i2 = 0; i2 < tuples.length; i2++) {
          if (tuples[i2][1].length > 0) {
            ret.push(tuples[i2]);
          }
        }
        return ret;
      }
      __name(remove_empty_tuples, "remove_empty_tuples");
      function make_edit_splice(before, oldMiddle, newMiddle, after) {
        if (ends_with_pair_start(before) || starts_with_pair_end(after)) {
          return null;
        }
        return remove_empty_tuples([
          [DIFF_EQUAL, before],
          [DIFF_DELETE, oldMiddle],
          [DIFF_INSERT, newMiddle],
          [DIFF_EQUAL, after]
        ]);
      }
      __name(make_edit_splice, "make_edit_splice");
      function find_cursor_edit_diff(oldText, newText, cursor_pos) {
        var oldRange = typeof cursor_pos === "number" ? { index: cursor_pos, length: 0 } : cursor_pos.oldRange;
        var newRange = typeof cursor_pos === "number" ? null : cursor_pos.newRange;
        var oldLength = oldText.length;
        var newLength = newText.length;
        if (oldRange.length === 0 && (newRange === null || newRange.length === 0)) {
          var oldCursor = oldRange.index;
          var oldBefore = oldText.slice(0, oldCursor);
          var oldAfter = oldText.slice(oldCursor);
          var maybeNewCursor = newRange ? newRange.index : null;
          editBefore: {
            var newCursor = oldCursor + newLength - oldLength;
            if (maybeNewCursor !== null && maybeNewCursor !== newCursor) {
              break editBefore;
            }
            if (newCursor < 0 || newCursor > newLength) {
              break editBefore;
            }
            var newBefore = newText.slice(0, newCursor);
            var newAfter = newText.slice(newCursor);
            if (newAfter !== oldAfter) {
              break editBefore;
            }
            var prefixLength = Math.min(oldCursor, newCursor);
            var oldPrefix = oldBefore.slice(0, prefixLength);
            var newPrefix = newBefore.slice(0, prefixLength);
            if (oldPrefix !== newPrefix) {
              break editBefore;
            }
            var oldMiddle = oldBefore.slice(prefixLength);
            var newMiddle = newBefore.slice(prefixLength);
            return make_edit_splice(oldPrefix, oldMiddle, newMiddle, oldAfter);
          }
          editAfter: {
            if (maybeNewCursor !== null && maybeNewCursor !== oldCursor) {
              break editAfter;
            }
            var cursor = oldCursor;
            var newBefore = newText.slice(0, cursor);
            var newAfter = newText.slice(cursor);
            if (newBefore !== oldBefore) {
              break editAfter;
            }
            var suffixLength = Math.min(oldLength - cursor, newLength - cursor);
            var oldSuffix = oldAfter.slice(oldAfter.length - suffixLength);
            var newSuffix = newAfter.slice(newAfter.length - suffixLength);
            if (oldSuffix !== newSuffix) {
              break editAfter;
            }
            var oldMiddle = oldAfter.slice(0, oldAfter.length - suffixLength);
            var newMiddle = newAfter.slice(0, newAfter.length - suffixLength);
            return make_edit_splice(oldBefore, oldMiddle, newMiddle, oldSuffix);
          }
        }
        if (oldRange.length > 0 && newRange && newRange.length === 0) {
          replaceRange: {
            var oldPrefix = oldText.slice(0, oldRange.index);
            var oldSuffix = oldText.slice(oldRange.index + oldRange.length);
            var prefixLength = oldPrefix.length;
            var suffixLength = oldSuffix.length;
            if (newLength < prefixLength + suffixLength) {
              break replaceRange;
            }
            var newPrefix = newText.slice(0, prefixLength);
            var newSuffix = newText.slice(newLength - suffixLength);
            if (oldPrefix !== newPrefix || oldSuffix !== newSuffix) {
              break replaceRange;
            }
            var oldMiddle = oldText.slice(prefixLength, oldLength - suffixLength);
            var newMiddle = newText.slice(prefixLength, newLength - suffixLength);
            return make_edit_splice(oldPrefix, oldMiddle, newMiddle, oldSuffix);
          }
        }
        return null;
      }
      __name(find_cursor_edit_diff, "find_cursor_edit_diff");
      function diff(text1, text2, cursor_pos, cleanup) {
        return diff_main(text1, text2, cursor_pos, cleanup, true);
      }
      __name(diff, "diff");
      diff.INSERT = DIFF_INSERT;
      diff.DELETE = DIFF_DELETE;
      diff.EQUAL = DIFF_EQUAL;
      module2.exports = diff;
    }
  });

  // node_modules/lodash.clonedeep/index.js
  var require_lodash = __commonJS({
    "node_modules/lodash.clonedeep/index.js"(exports2, module2) {
      var LARGE_ARRAY_SIZE2 = 200;
      var HASH_UNDEFINED4 = "__lodash_hash_undefined__";
      var MAX_SAFE_INTEGER3 = 9007199254740991;
      var argsTag5 = "[object Arguments]";
      var arrayTag4 = "[object Array]";
      var boolTag5 = "[object Boolean]";
      var dateTag5 = "[object Date]";
      var errorTag4 = "[object Error]";
      var funcTag4 = "[object Function]";
      var genTag3 = "[object GeneratorFunction]";
      var mapTag7 = "[object Map]";
      var numberTag5 = "[object Number]";
      var objectTag6 = "[object Object]";
      var promiseTag2 = "[object Promise]";
      var regexpTag5 = "[object RegExp]";
      var setTag7 = "[object Set]";
      var stringTag5 = "[object String]";
      var symbolTag4 = "[object Symbol]";
      var weakMapTag4 = "[object WeakMap]";
      var arrayBufferTag5 = "[object ArrayBuffer]";
      var dataViewTag6 = "[object DataView]";
      var float32Tag4 = "[object Float32Array]";
      var float64Tag4 = "[object Float64Array]";
      var int8Tag4 = "[object Int8Array]";
      var int16Tag4 = "[object Int16Array]";
      var int32Tag4 = "[object Int32Array]";
      var uint8Tag4 = "[object Uint8Array]";
      var uint8ClampedTag4 = "[object Uint8ClampedArray]";
      var uint16Tag4 = "[object Uint16Array]";
      var uint32Tag4 = "[object Uint32Array]";
      var reRegExpChar2 = /[\\^$.*+?()[\]{}|]/g;
      var reFlags2 = /\w*$/;
      var reIsHostCtor2 = /^\[object .+?Constructor\]$/;
      var reIsUint2 = /^(?:0|[1-9]\d*)$/;
      var cloneableTags2 = {};
      cloneableTags2[argsTag5] = cloneableTags2[arrayTag4] = cloneableTags2[arrayBufferTag5] = cloneableTags2[dataViewTag6] = cloneableTags2[boolTag5] = cloneableTags2[dateTag5] = cloneableTags2[float32Tag4] = cloneableTags2[float64Tag4] = cloneableTags2[int8Tag4] = cloneableTags2[int16Tag4] = cloneableTags2[int32Tag4] = cloneableTags2[mapTag7] = cloneableTags2[numberTag5] = cloneableTags2[objectTag6] = cloneableTags2[regexpTag5] = cloneableTags2[setTag7] = cloneableTags2[stringTag5] = cloneableTags2[symbolTag4] = cloneableTags2[uint8Tag4] = cloneableTags2[uint8ClampedTag4] = cloneableTags2[uint16Tag4] = cloneableTags2[uint32Tag4] = true;
      cloneableTags2[errorTag4] = cloneableTags2[funcTag4] = cloneableTags2[weakMapTag4] = false;
      var freeGlobal2 = typeof global == "object" && global && global.Object === Object && global;
      var freeSelf2 = typeof self == "object" && self && self.Object === Object && self;
      var root2 = freeGlobal2 || freeSelf2 || Function("return this")();
      var freeExports4 = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
      var freeModule4 = freeExports4 && typeof module2 == "object" && module2 && !module2.nodeType && module2;
      var moduleExports4 = freeModule4 && freeModule4.exports === freeExports4;
      function addMapEntry(map, pair) {
        map.set(pair[0], pair[1]);
        return map;
      }
      __name(addMapEntry, "addMapEntry");
      function addSetEntry(set, value) {
        set.add(value);
        return set;
      }
      __name(addSetEntry, "addSetEntry");
      function arrayEach2(array, iteratee) {
        var index = -1, length = array ? array.length : 0;
        while (++index < length) {
          if (iteratee(array[index], index, array) === false) {
            break;
          }
        }
        return array;
      }
      __name(arrayEach2, "arrayEach");
      function arrayPush2(array, values) {
        var index = -1, length = values.length, offset = array.length;
        while (++index < length) {
          array[offset + index] = values[index];
        }
        return array;
      }
      __name(arrayPush2, "arrayPush");
      function arrayReduce(array, iteratee, accumulator, initAccum) {
        var index = -1, length = array ? array.length : 0;
        if (initAccum && length) {
          accumulator = array[++index];
        }
        while (++index < length) {
          accumulator = iteratee(accumulator, array[index], index, array);
        }
        return accumulator;
      }
      __name(arrayReduce, "arrayReduce");
      function baseTimes2(n2, iteratee) {
        var index = -1, result = Array(n2);
        while (++index < n2) {
          result[index] = iteratee(index);
        }
        return result;
      }
      __name(baseTimes2, "baseTimes");
      function getValue2(object, key) {
        return object == null ? void 0 : object[key];
      }
      __name(getValue2, "getValue");
      function isHostObject(value) {
        var result = false;
        if (value != null && typeof value.toString != "function") {
          try {
            result = !!(value + "");
          } catch (e2) {
          }
        }
        return result;
      }
      __name(isHostObject, "isHostObject");
      function mapToArray2(map) {
        var index = -1, result = Array(map.size);
        map.forEach(function(value, key) {
          result[++index] = [key, value];
        });
        return result;
      }
      __name(mapToArray2, "mapToArray");
      function overArg2(func, transform) {
        return function(arg) {
          return func(transform(arg));
        };
      }
      __name(overArg2, "overArg");
      function setToArray2(set) {
        var index = -1, result = Array(set.size);
        set.forEach(function(value) {
          result[++index] = value;
        });
        return result;
      }
      __name(setToArray2, "setToArray");
      var arrayProto2 = Array.prototype;
      var funcProto4 = Function.prototype;
      var objectProto17 = Object.prototype;
      var coreJsData2 = root2["__core-js_shared__"];
      var maskSrcKey2 = function() {
        var uid = /[^.]+$/.exec(coreJsData2 && coreJsData2.keys && coreJsData2.keys.IE_PROTO || "");
        return uid ? "Symbol(src)_1." + uid : "";
      }();
      var funcToString4 = funcProto4.toString;
      var hasOwnProperty14 = objectProto17.hasOwnProperty;
      var objectToString2 = objectProto17.toString;
      var reIsNative2 = RegExp(
        "^" + funcToString4.call(hasOwnProperty14).replace(reRegExpChar2, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
      );
      var Buffer4 = moduleExports4 ? root2.Buffer : void 0;
      var Symbol3 = root2.Symbol;
      var Uint8Array3 = root2.Uint8Array;
      var getPrototype2 = overArg2(Object.getPrototypeOf, Object);
      var objectCreate2 = Object.create;
      var propertyIsEnumerable3 = objectProto17.propertyIsEnumerable;
      var splice2 = arrayProto2.splice;
      var nativeGetSymbols3 = Object.getOwnPropertySymbols;
      var nativeIsBuffer2 = Buffer4 ? Buffer4.isBuffer : void 0;
      var nativeKeys2 = overArg2(Object.keys, Object);
      var DataView2 = getNative2(root2, "DataView");
      var Map3 = getNative2(root2, "Map");
      var Promise3 = getNative2(root2, "Promise");
      var Set3 = getNative2(root2, "Set");
      var WeakMap3 = getNative2(root2, "WeakMap");
      var nativeCreate2 = getNative2(Object, "create");
      var dataViewCtorString2 = toSource2(DataView2);
      var mapCtorString2 = toSource2(Map3);
      var promiseCtorString2 = toSource2(Promise3);
      var setCtorString2 = toSource2(Set3);
      var weakMapCtorString2 = toSource2(WeakMap3);
      var symbolProto3 = Symbol3 ? Symbol3.prototype : void 0;
      var symbolValueOf3 = symbolProto3 ? symbolProto3.valueOf : void 0;
      function Hash2(entries) {
        var index = -1, length = entries ? entries.length : 0;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      __name(Hash2, "Hash");
      function hashClear2() {
        this.__data__ = nativeCreate2 ? nativeCreate2(null) : {};
      }
      __name(hashClear2, "hashClear");
      function hashDelete2(key) {
        return this.has(key) && delete this.__data__[key];
      }
      __name(hashDelete2, "hashDelete");
      function hashGet2(key) {
        var data = this.__data__;
        if (nativeCreate2) {
          var result = data[key];
          return result === HASH_UNDEFINED4 ? void 0 : result;
        }
        return hasOwnProperty14.call(data, key) ? data[key] : void 0;
      }
      __name(hashGet2, "hashGet");
      function hashHas2(key) {
        var data = this.__data__;
        return nativeCreate2 ? data[key] !== void 0 : hasOwnProperty14.call(data, key);
      }
      __name(hashHas2, "hashHas");
      function hashSet2(key, value) {
        var data = this.__data__;
        data[key] = nativeCreate2 && value === void 0 ? HASH_UNDEFINED4 : value;
        return this;
      }
      __name(hashSet2, "hashSet");
      Hash2.prototype.clear = hashClear2;
      Hash2.prototype["delete"] = hashDelete2;
      Hash2.prototype.get = hashGet2;
      Hash2.prototype.has = hashHas2;
      Hash2.prototype.set = hashSet2;
      function ListCache2(entries) {
        var index = -1, length = entries ? entries.length : 0;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      __name(ListCache2, "ListCache");
      function listCacheClear2() {
        this.__data__ = [];
      }
      __name(listCacheClear2, "listCacheClear");
      function listCacheDelete2(key) {
        var data = this.__data__, index = assocIndexOf2(data, key);
        if (index < 0) {
          return false;
        }
        var lastIndex = data.length - 1;
        if (index == lastIndex) {
          data.pop();
        } else {
          splice2.call(data, index, 1);
        }
        return true;
      }
      __name(listCacheDelete2, "listCacheDelete");
      function listCacheGet2(key) {
        var data = this.__data__, index = assocIndexOf2(data, key);
        return index < 0 ? void 0 : data[index][1];
      }
      __name(listCacheGet2, "listCacheGet");
      function listCacheHas2(key) {
        return assocIndexOf2(this.__data__, key) > -1;
      }
      __name(listCacheHas2, "listCacheHas");
      function listCacheSet2(key, value) {
        var data = this.__data__, index = assocIndexOf2(data, key);
        if (index < 0) {
          data.push([key, value]);
        } else {
          data[index][1] = value;
        }
        return this;
      }
      __name(listCacheSet2, "listCacheSet");
      ListCache2.prototype.clear = listCacheClear2;
      ListCache2.prototype["delete"] = listCacheDelete2;
      ListCache2.prototype.get = listCacheGet2;
      ListCache2.prototype.has = listCacheHas2;
      ListCache2.prototype.set = listCacheSet2;
      function MapCache2(entries) {
        var index = -1, length = entries ? entries.length : 0;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      __name(MapCache2, "MapCache");
      function mapCacheClear2() {
        this.__data__ = {
          "hash": new Hash2(),
          "map": new (Map3 || ListCache2)(),
          "string": new Hash2()
        };
      }
      __name(mapCacheClear2, "mapCacheClear");
      function mapCacheDelete2(key) {
        return getMapData2(this, key)["delete"](key);
      }
      __name(mapCacheDelete2, "mapCacheDelete");
      function mapCacheGet2(key) {
        return getMapData2(this, key).get(key);
      }
      __name(mapCacheGet2, "mapCacheGet");
      function mapCacheHas2(key) {
        return getMapData2(this, key).has(key);
      }
      __name(mapCacheHas2, "mapCacheHas");
      function mapCacheSet2(key, value) {
        getMapData2(this, key).set(key, value);
        return this;
      }
      __name(mapCacheSet2, "mapCacheSet");
      MapCache2.prototype.clear = mapCacheClear2;
      MapCache2.prototype["delete"] = mapCacheDelete2;
      MapCache2.prototype.get = mapCacheGet2;
      MapCache2.prototype.has = mapCacheHas2;
      MapCache2.prototype.set = mapCacheSet2;
      function Stack2(entries) {
        this.__data__ = new ListCache2(entries);
      }
      __name(Stack2, "Stack");
      function stackClear2() {
        this.__data__ = new ListCache2();
      }
      __name(stackClear2, "stackClear");
      function stackDelete2(key) {
        return this.__data__["delete"](key);
      }
      __name(stackDelete2, "stackDelete");
      function stackGet2(key) {
        return this.__data__.get(key);
      }
      __name(stackGet2, "stackGet");
      function stackHas2(key) {
        return this.__data__.has(key);
      }
      __name(stackHas2, "stackHas");
      function stackSet2(key, value) {
        var cache2 = this.__data__;
        if (cache2 instanceof ListCache2) {
          var pairs = cache2.__data__;
          if (!Map3 || pairs.length < LARGE_ARRAY_SIZE2 - 1) {
            pairs.push([key, value]);
            return this;
          }
          cache2 = this.__data__ = new MapCache2(pairs);
        }
        cache2.set(key, value);
        return this;
      }
      __name(stackSet2, "stackSet");
      Stack2.prototype.clear = stackClear2;
      Stack2.prototype["delete"] = stackDelete2;
      Stack2.prototype.get = stackGet2;
      Stack2.prototype.has = stackHas2;
      Stack2.prototype.set = stackSet2;
      function arrayLikeKeys2(value, inherited) {
        var result = isArray2(value) || isArguments2(value) ? baseTimes2(value.length, String) : [];
        var length = result.length, skipIndexes = !!length;
        for (var key in value) {
          if ((inherited || hasOwnProperty14.call(value, key)) && !(skipIndexes && (key == "length" || isIndex2(key, length)))) {
            result.push(key);
          }
        }
        return result;
      }
      __name(arrayLikeKeys2, "arrayLikeKeys");
      function assignValue2(object, key, value) {
        var objValue = object[key];
        if (!(hasOwnProperty14.call(object, key) && eq2(objValue, value)) || value === void 0 && !(key in object)) {
          object[key] = value;
        }
      }
      __name(assignValue2, "assignValue");
      function assocIndexOf2(array, key) {
        var length = array.length;
        while (length--) {
          if (eq2(array[length][0], key)) {
            return length;
          }
        }
        return -1;
      }
      __name(assocIndexOf2, "assocIndexOf");
      function baseAssign2(object, source) {
        return object && copyObject2(source, keys2(source), object);
      }
      __name(baseAssign2, "baseAssign");
      function baseClone2(value, isDeep, isFull, customizer, key, object, stack) {
        var result;
        if (customizer) {
          result = object ? customizer(value, key, object, stack) : customizer(value);
        }
        if (result !== void 0) {
          return result;
        }
        if (!isObject2(value)) {
          return value;
        }
        var isArr = isArray2(value);
        if (isArr) {
          result = initCloneArray2(value);
          if (!isDeep) {
            return copyArray2(value, result);
          }
        } else {
          var tag = getTag2(value), isFunc = tag == funcTag4 || tag == genTag3;
          if (isBuffer2(value)) {
            return cloneBuffer2(value, isDeep);
          }
          if (tag == objectTag6 || tag == argsTag5 || isFunc && !object) {
            if (isHostObject(value)) {
              return object ? value : {};
            }
            result = initCloneObject2(isFunc ? {} : value);
            if (!isDeep) {
              return copySymbols2(value, baseAssign2(result, value));
            }
          } else {
            if (!cloneableTags2[tag]) {
              return object ? value : {};
            }
            result = initCloneByTag2(value, tag, baseClone2, isDeep);
          }
        }
        stack || (stack = new Stack2());
        var stacked = stack.get(value);
        if (stacked) {
          return stacked;
        }
        stack.set(value, result);
        if (!isArr) {
          var props = isFull ? getAllKeys2(value) : keys2(value);
        }
        arrayEach2(props || value, function(subValue, key2) {
          if (props) {
            key2 = subValue;
            subValue = value[key2];
          }
          assignValue2(result, key2, baseClone2(subValue, isDeep, isFull, customizer, key2, value, stack));
        });
        return result;
      }
      __name(baseClone2, "baseClone");
      function baseCreate2(proto) {
        return isObject2(proto) ? objectCreate2(proto) : {};
      }
      __name(baseCreate2, "baseCreate");
      function baseGetAllKeys2(object, keysFunc, symbolsFunc) {
        var result = keysFunc(object);
        return isArray2(object) ? result : arrayPush2(result, symbolsFunc(object));
      }
      __name(baseGetAllKeys2, "baseGetAllKeys");
      function baseGetTag2(value) {
        return objectToString2.call(value);
      }
      __name(baseGetTag2, "baseGetTag");
      function baseIsNative2(value) {
        if (!isObject2(value) || isMasked2(value)) {
          return false;
        }
        var pattern = isFunction2(value) || isHostObject(value) ? reIsNative2 : reIsHostCtor2;
        return pattern.test(toSource2(value));
      }
      __name(baseIsNative2, "baseIsNative");
      function baseKeys2(object) {
        if (!isPrototype2(object)) {
          return nativeKeys2(object);
        }
        var result = [];
        for (var key in Object(object)) {
          if (hasOwnProperty14.call(object, key) && key != "constructor") {
            result.push(key);
          }
        }
        return result;
      }
      __name(baseKeys2, "baseKeys");
      function cloneBuffer2(buffer, isDeep) {
        if (isDeep) {
          return buffer.slice();
        }
        var result = new buffer.constructor(buffer.length);
        buffer.copy(result);
        return result;
      }
      __name(cloneBuffer2, "cloneBuffer");
      function cloneArrayBuffer2(arrayBuffer) {
        var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
        new Uint8Array3(result).set(new Uint8Array3(arrayBuffer));
        return result;
      }
      __name(cloneArrayBuffer2, "cloneArrayBuffer");
      function cloneDataView2(dataView, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer2(dataView.buffer) : dataView.buffer;
        return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
      }
      __name(cloneDataView2, "cloneDataView");
      function cloneMap(map, isDeep, cloneFunc) {
        var array = isDeep ? cloneFunc(mapToArray2(map), true) : mapToArray2(map);
        return arrayReduce(array, addMapEntry, new map.constructor());
      }
      __name(cloneMap, "cloneMap");
      function cloneRegExp2(regexp) {
        var result = new regexp.constructor(regexp.source, reFlags2.exec(regexp));
        result.lastIndex = regexp.lastIndex;
        return result;
      }
      __name(cloneRegExp2, "cloneRegExp");
      function cloneSet(set, isDeep, cloneFunc) {
        var array = isDeep ? cloneFunc(setToArray2(set), true) : setToArray2(set);
        return arrayReduce(array, addSetEntry, new set.constructor());
      }
      __name(cloneSet, "cloneSet");
      function cloneSymbol2(symbol) {
        return symbolValueOf3 ? Object(symbolValueOf3.call(symbol)) : {};
      }
      __name(cloneSymbol2, "cloneSymbol");
      function cloneTypedArray2(typedArray, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer2(typedArray.buffer) : typedArray.buffer;
        return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
      }
      __name(cloneTypedArray2, "cloneTypedArray");
      function copyArray2(source, array) {
        var index = -1, length = source.length;
        array || (array = Array(length));
        while (++index < length) {
          array[index] = source[index];
        }
        return array;
      }
      __name(copyArray2, "copyArray");
      function copyObject2(source, props, object, customizer) {
        object || (object = {});
        var index = -1, length = props.length;
        while (++index < length) {
          var key = props[index];
          var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
          assignValue2(object, key, newValue === void 0 ? source[key] : newValue);
        }
        return object;
      }
      __name(copyObject2, "copyObject");
      function copySymbols2(source, object) {
        return copyObject2(source, getSymbols2(source), object);
      }
      __name(copySymbols2, "copySymbols");
      function getAllKeys2(object) {
        return baseGetAllKeys2(object, keys2, getSymbols2);
      }
      __name(getAllKeys2, "getAllKeys");
      function getMapData2(map, key) {
        var data = map.__data__;
        return isKeyable2(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
      }
      __name(getMapData2, "getMapData");
      function getNative2(object, key) {
        var value = getValue2(object, key);
        return baseIsNative2(value) ? value : void 0;
      }
      __name(getNative2, "getNative");
      var getSymbols2 = nativeGetSymbols3 ? overArg2(nativeGetSymbols3, Object) : stubArray2;
      var getTag2 = baseGetTag2;
      if (DataView2 && getTag2(new DataView2(new ArrayBuffer(1))) != dataViewTag6 || Map3 && getTag2(new Map3()) != mapTag7 || Promise3 && getTag2(Promise3.resolve()) != promiseTag2 || Set3 && getTag2(new Set3()) != setTag7 || WeakMap3 && getTag2(new WeakMap3()) != weakMapTag4) {
        getTag2 = /* @__PURE__ */ __name(function(value) {
          var result = objectToString2.call(value), Ctor = result == objectTag6 ? value.constructor : void 0, ctorString = Ctor ? toSource2(Ctor) : void 0;
          if (ctorString) {
            switch (ctorString) {
              case dataViewCtorString2:
                return dataViewTag6;
              case mapCtorString2:
                return mapTag7;
              case promiseCtorString2:
                return promiseTag2;
              case setCtorString2:
                return setTag7;
              case weakMapCtorString2:
                return weakMapTag4;
            }
          }
          return result;
        }, "getTag");
      }
      function initCloneArray2(array) {
        var length = array.length, result = array.constructor(length);
        if (length && typeof array[0] == "string" && hasOwnProperty14.call(array, "index")) {
          result.index = array.index;
          result.input = array.input;
        }
        return result;
      }
      __name(initCloneArray2, "initCloneArray");
      function initCloneObject2(object) {
        return typeof object.constructor == "function" && !isPrototype2(object) ? baseCreate2(getPrototype2(object)) : {};
      }
      __name(initCloneObject2, "initCloneObject");
      function initCloneByTag2(object, tag, cloneFunc, isDeep) {
        var Ctor = object.constructor;
        switch (tag) {
          case arrayBufferTag5:
            return cloneArrayBuffer2(object);
          case boolTag5:
          case dateTag5:
            return new Ctor(+object);
          case dataViewTag6:
            return cloneDataView2(object, isDeep);
          case float32Tag4:
          case float64Tag4:
          case int8Tag4:
          case int16Tag4:
          case int32Tag4:
          case uint8Tag4:
          case uint8ClampedTag4:
          case uint16Tag4:
          case uint32Tag4:
            return cloneTypedArray2(object, isDeep);
          case mapTag7:
            return cloneMap(object, isDeep, cloneFunc);
          case numberTag5:
          case stringTag5:
            return new Ctor(object);
          case regexpTag5:
            return cloneRegExp2(object);
          case setTag7:
            return cloneSet(object, isDeep, cloneFunc);
          case symbolTag4:
            return cloneSymbol2(object);
        }
      }
      __name(initCloneByTag2, "initCloneByTag");
      function isIndex2(value, length) {
        length = length == null ? MAX_SAFE_INTEGER3 : length;
        return !!length && (typeof value == "number" || reIsUint2.test(value)) && (value > -1 && value % 1 == 0 && value < length);
      }
      __name(isIndex2, "isIndex");
      function isKeyable2(value) {
        var type = typeof value;
        return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
      }
      __name(isKeyable2, "isKeyable");
      function isMasked2(func) {
        return !!maskSrcKey2 && maskSrcKey2 in func;
      }
      __name(isMasked2, "isMasked");
      function isPrototype2(value) {
        var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto17;
        return value === proto;
      }
      __name(isPrototype2, "isPrototype");
      function toSource2(func) {
        if (func != null) {
          try {
            return funcToString4.call(func);
          } catch (e2) {
          }
          try {
            return func + "";
          } catch (e2) {
          }
        }
        return "";
      }
      __name(toSource2, "toSource");
      function cloneDeep2(value) {
        return baseClone2(value, true, true);
      }
      __name(cloneDeep2, "cloneDeep");
      function eq2(value, other) {
        return value === other || value !== value && other !== other;
      }
      __name(eq2, "eq");
      function isArguments2(value) {
        return isArrayLikeObject2(value) && hasOwnProperty14.call(value, "callee") && (!propertyIsEnumerable3.call(value, "callee") || objectToString2.call(value) == argsTag5);
      }
      __name(isArguments2, "isArguments");
      var isArray2 = Array.isArray;
      function isArrayLike2(value) {
        return value != null && isLength2(value.length) && !isFunction2(value);
      }
      __name(isArrayLike2, "isArrayLike");
      function isArrayLikeObject2(value) {
        return isObjectLike2(value) && isArrayLike2(value);
      }
      __name(isArrayLikeObject2, "isArrayLikeObject");
      var isBuffer2 = nativeIsBuffer2 || stubFalse2;
      function isFunction2(value) {
        var tag = isObject2(value) ? objectToString2.call(value) : "";
        return tag == funcTag4 || tag == genTag3;
      }
      __name(isFunction2, "isFunction");
      function isLength2(value) {
        return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER3;
      }
      __name(isLength2, "isLength");
      function isObject2(value) {
        var type = typeof value;
        return !!value && (type == "object" || type == "function");
      }
      __name(isObject2, "isObject");
      function isObjectLike2(value) {
        return !!value && typeof value == "object";
      }
      __name(isObjectLike2, "isObjectLike");
      function keys2(object) {
        return isArrayLike2(object) ? arrayLikeKeys2(object) : baseKeys2(object);
      }
      __name(keys2, "keys");
      function stubArray2() {
        return [];
      }
      __name(stubArray2, "stubArray");
      function stubFalse2() {
        return false;
      }
      __name(stubFalse2, "stubFalse");
      module2.exports = cloneDeep2;
    }
  });

  // node_modules/lodash.isequal/index.js
  var require_lodash2 = __commonJS({
    "node_modules/lodash.isequal/index.js"(exports2, module2) {
      var LARGE_ARRAY_SIZE2 = 200;
      var HASH_UNDEFINED4 = "__lodash_hash_undefined__";
      var COMPARE_PARTIAL_FLAG5 = 1;
      var COMPARE_UNORDERED_FLAG3 = 2;
      var MAX_SAFE_INTEGER3 = 9007199254740991;
      var argsTag5 = "[object Arguments]";
      var arrayTag4 = "[object Array]";
      var asyncTag2 = "[object AsyncFunction]";
      var boolTag5 = "[object Boolean]";
      var dateTag5 = "[object Date]";
      var errorTag4 = "[object Error]";
      var funcTag4 = "[object Function]";
      var genTag3 = "[object GeneratorFunction]";
      var mapTag7 = "[object Map]";
      var numberTag5 = "[object Number]";
      var nullTag2 = "[object Null]";
      var objectTag6 = "[object Object]";
      var promiseTag2 = "[object Promise]";
      var proxyTag2 = "[object Proxy]";
      var regexpTag5 = "[object RegExp]";
      var setTag7 = "[object Set]";
      var stringTag5 = "[object String]";
      var symbolTag4 = "[object Symbol]";
      var undefinedTag2 = "[object Undefined]";
      var weakMapTag4 = "[object WeakMap]";
      var arrayBufferTag5 = "[object ArrayBuffer]";
      var dataViewTag6 = "[object DataView]";
      var float32Tag4 = "[object Float32Array]";
      var float64Tag4 = "[object Float64Array]";
      var int8Tag4 = "[object Int8Array]";
      var int16Tag4 = "[object Int16Array]";
      var int32Tag4 = "[object Int32Array]";
      var uint8Tag4 = "[object Uint8Array]";
      var uint8ClampedTag4 = "[object Uint8ClampedArray]";
      var uint16Tag4 = "[object Uint16Array]";
      var uint32Tag4 = "[object Uint32Array]";
      var reRegExpChar2 = /[\\^$.*+?()[\]{}|]/g;
      var reIsHostCtor2 = /^\[object .+?Constructor\]$/;
      var reIsUint2 = /^(?:0|[1-9]\d*)$/;
      var typedArrayTags2 = {};
      typedArrayTags2[float32Tag4] = typedArrayTags2[float64Tag4] = typedArrayTags2[int8Tag4] = typedArrayTags2[int16Tag4] = typedArrayTags2[int32Tag4] = typedArrayTags2[uint8Tag4] = typedArrayTags2[uint8ClampedTag4] = typedArrayTags2[uint16Tag4] = typedArrayTags2[uint32Tag4] = true;
      typedArrayTags2[argsTag5] = typedArrayTags2[arrayTag4] = typedArrayTags2[arrayBufferTag5] = typedArrayTags2[boolTag5] = typedArrayTags2[dataViewTag6] = typedArrayTags2[dateTag5] = typedArrayTags2[errorTag4] = typedArrayTags2[funcTag4] = typedArrayTags2[mapTag7] = typedArrayTags2[numberTag5] = typedArrayTags2[objectTag6] = typedArrayTags2[regexpTag5] = typedArrayTags2[setTag7] = typedArrayTags2[stringTag5] = typedArrayTags2[weakMapTag4] = false;
      var freeGlobal2 = typeof global == "object" && global && global.Object === Object && global;
      var freeSelf2 = typeof self == "object" && self && self.Object === Object && self;
      var root2 = freeGlobal2 || freeSelf2 || Function("return this")();
      var freeExports4 = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
      var freeModule4 = freeExports4 && typeof module2 == "object" && module2 && !module2.nodeType && module2;
      var moduleExports4 = freeModule4 && freeModule4.exports === freeExports4;
      var freeProcess2 = moduleExports4 && freeGlobal2.process;
      var nodeUtil2 = function() {
        try {
          return freeProcess2 && freeProcess2.binding && freeProcess2.binding("util");
        } catch (e2) {
        }
      }();
      var nodeIsTypedArray2 = nodeUtil2 && nodeUtil2.isTypedArray;
      function arrayFilter2(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
        while (++index < length) {
          var value = array[index];
          if (predicate(value, index, array)) {
            result[resIndex++] = value;
          }
        }
        return result;
      }
      __name(arrayFilter2, "arrayFilter");
      function arrayPush2(array, values) {
        var index = -1, length = values.length, offset = array.length;
        while (++index < length) {
          array[offset + index] = values[index];
        }
        return array;
      }
      __name(arrayPush2, "arrayPush");
      function arraySome2(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (predicate(array[index], index, array)) {
            return true;
          }
        }
        return false;
      }
      __name(arraySome2, "arraySome");
      function baseTimes2(n2, iteratee) {
        var index = -1, result = Array(n2);
        while (++index < n2) {
          result[index] = iteratee(index);
        }
        return result;
      }
      __name(baseTimes2, "baseTimes");
      function baseUnary2(func) {
        return function(value) {
          return func(value);
        };
      }
      __name(baseUnary2, "baseUnary");
      function cacheHas2(cache2, key) {
        return cache2.has(key);
      }
      __name(cacheHas2, "cacheHas");
      function getValue2(object, key) {
        return object == null ? void 0 : object[key];
      }
      __name(getValue2, "getValue");
      function mapToArray2(map) {
        var index = -1, result = Array(map.size);
        map.forEach(function(value, key) {
          result[++index] = [key, value];
        });
        return result;
      }
      __name(mapToArray2, "mapToArray");
      function overArg2(func, transform) {
        return function(arg) {
          return func(transform(arg));
        };
      }
      __name(overArg2, "overArg");
      function setToArray2(set) {
        var index = -1, result = Array(set.size);
        set.forEach(function(value) {
          result[++index] = value;
        });
        return result;
      }
      __name(setToArray2, "setToArray");
      var arrayProto2 = Array.prototype;
      var funcProto4 = Function.prototype;
      var objectProto17 = Object.prototype;
      var coreJsData2 = root2["__core-js_shared__"];
      var funcToString4 = funcProto4.toString;
      var hasOwnProperty14 = objectProto17.hasOwnProperty;
      var maskSrcKey2 = function() {
        var uid = /[^.]+$/.exec(coreJsData2 && coreJsData2.keys && coreJsData2.keys.IE_PROTO || "");
        return uid ? "Symbol(src)_1." + uid : "";
      }();
      var nativeObjectToString3 = objectProto17.toString;
      var reIsNative2 = RegExp(
        "^" + funcToString4.call(hasOwnProperty14).replace(reRegExpChar2, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
      );
      var Buffer4 = moduleExports4 ? root2.Buffer : void 0;
      var Symbol3 = root2.Symbol;
      var Uint8Array3 = root2.Uint8Array;
      var propertyIsEnumerable3 = objectProto17.propertyIsEnumerable;
      var splice2 = arrayProto2.splice;
      var symToStringTag3 = Symbol3 ? Symbol3.toStringTag : void 0;
      var nativeGetSymbols3 = Object.getOwnPropertySymbols;
      var nativeIsBuffer2 = Buffer4 ? Buffer4.isBuffer : void 0;
      var nativeKeys2 = overArg2(Object.keys, Object);
      var DataView2 = getNative2(root2, "DataView");
      var Map3 = getNative2(root2, "Map");
      var Promise3 = getNative2(root2, "Promise");
      var Set3 = getNative2(root2, "Set");
      var WeakMap3 = getNative2(root2, "WeakMap");
      var nativeCreate2 = getNative2(Object, "create");
      var dataViewCtorString2 = toSource2(DataView2);
      var mapCtorString2 = toSource2(Map3);
      var promiseCtorString2 = toSource2(Promise3);
      var setCtorString2 = toSource2(Set3);
      var weakMapCtorString2 = toSource2(WeakMap3);
      var symbolProto3 = Symbol3 ? Symbol3.prototype : void 0;
      var symbolValueOf3 = symbolProto3 ? symbolProto3.valueOf : void 0;
      function Hash2(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      __name(Hash2, "Hash");
      function hashClear2() {
        this.__data__ = nativeCreate2 ? nativeCreate2(null) : {};
        this.size = 0;
      }
      __name(hashClear2, "hashClear");
      function hashDelete2(key) {
        var result = this.has(key) && delete this.__data__[key];
        this.size -= result ? 1 : 0;
        return result;
      }
      __name(hashDelete2, "hashDelete");
      function hashGet2(key) {
        var data = this.__data__;
        if (nativeCreate2) {
          var result = data[key];
          return result === HASH_UNDEFINED4 ? void 0 : result;
        }
        return hasOwnProperty14.call(data, key) ? data[key] : void 0;
      }
      __name(hashGet2, "hashGet");
      function hashHas2(key) {
        var data = this.__data__;
        return nativeCreate2 ? data[key] !== void 0 : hasOwnProperty14.call(data, key);
      }
      __name(hashHas2, "hashHas");
      function hashSet2(key, value) {
        var data = this.__data__;
        this.size += this.has(key) ? 0 : 1;
        data[key] = nativeCreate2 && value === void 0 ? HASH_UNDEFINED4 : value;
        return this;
      }
      __name(hashSet2, "hashSet");
      Hash2.prototype.clear = hashClear2;
      Hash2.prototype["delete"] = hashDelete2;
      Hash2.prototype.get = hashGet2;
      Hash2.prototype.has = hashHas2;
      Hash2.prototype.set = hashSet2;
      function ListCache2(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      __name(ListCache2, "ListCache");
      function listCacheClear2() {
        this.__data__ = [];
        this.size = 0;
      }
      __name(listCacheClear2, "listCacheClear");
      function listCacheDelete2(key) {
        var data = this.__data__, index = assocIndexOf2(data, key);
        if (index < 0) {
          return false;
        }
        var lastIndex = data.length - 1;
        if (index == lastIndex) {
          data.pop();
        } else {
          splice2.call(data, index, 1);
        }
        --this.size;
        return true;
      }
      __name(listCacheDelete2, "listCacheDelete");
      function listCacheGet2(key) {
        var data = this.__data__, index = assocIndexOf2(data, key);
        return index < 0 ? void 0 : data[index][1];
      }
      __name(listCacheGet2, "listCacheGet");
      function listCacheHas2(key) {
        return assocIndexOf2(this.__data__, key) > -1;
      }
      __name(listCacheHas2, "listCacheHas");
      function listCacheSet2(key, value) {
        var data = this.__data__, index = assocIndexOf2(data, key);
        if (index < 0) {
          ++this.size;
          data.push([key, value]);
        } else {
          data[index][1] = value;
        }
        return this;
      }
      __name(listCacheSet2, "listCacheSet");
      ListCache2.prototype.clear = listCacheClear2;
      ListCache2.prototype["delete"] = listCacheDelete2;
      ListCache2.prototype.get = listCacheGet2;
      ListCache2.prototype.has = listCacheHas2;
      ListCache2.prototype.set = listCacheSet2;
      function MapCache2(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      __name(MapCache2, "MapCache");
      function mapCacheClear2() {
        this.size = 0;
        this.__data__ = {
          "hash": new Hash2(),
          "map": new (Map3 || ListCache2)(),
          "string": new Hash2()
        };
      }
      __name(mapCacheClear2, "mapCacheClear");
      function mapCacheDelete2(key) {
        var result = getMapData2(this, key)["delete"](key);
        this.size -= result ? 1 : 0;
        return result;
      }
      __name(mapCacheDelete2, "mapCacheDelete");
      function mapCacheGet2(key) {
        return getMapData2(this, key).get(key);
      }
      __name(mapCacheGet2, "mapCacheGet");
      function mapCacheHas2(key) {
        return getMapData2(this, key).has(key);
      }
      __name(mapCacheHas2, "mapCacheHas");
      function mapCacheSet2(key, value) {
        var data = getMapData2(this, key), size = data.size;
        data.set(key, value);
        this.size += data.size == size ? 0 : 1;
        return this;
      }
      __name(mapCacheSet2, "mapCacheSet");
      MapCache2.prototype.clear = mapCacheClear2;
      MapCache2.prototype["delete"] = mapCacheDelete2;
      MapCache2.prototype.get = mapCacheGet2;
      MapCache2.prototype.has = mapCacheHas2;
      MapCache2.prototype.set = mapCacheSet2;
      function SetCache2(values) {
        var index = -1, length = values == null ? 0 : values.length;
        this.__data__ = new MapCache2();
        while (++index < length) {
          this.add(values[index]);
        }
      }
      __name(SetCache2, "SetCache");
      function setCacheAdd2(value) {
        this.__data__.set(value, HASH_UNDEFINED4);
        return this;
      }
      __name(setCacheAdd2, "setCacheAdd");
      function setCacheHas2(value) {
        return this.__data__.has(value);
      }
      __name(setCacheHas2, "setCacheHas");
      SetCache2.prototype.add = SetCache2.prototype.push = setCacheAdd2;
      SetCache2.prototype.has = setCacheHas2;
      function Stack2(entries) {
        var data = this.__data__ = new ListCache2(entries);
        this.size = data.size;
      }
      __name(Stack2, "Stack");
      function stackClear2() {
        this.__data__ = new ListCache2();
        this.size = 0;
      }
      __name(stackClear2, "stackClear");
      function stackDelete2(key) {
        var data = this.__data__, result = data["delete"](key);
        this.size = data.size;
        return result;
      }
      __name(stackDelete2, "stackDelete");
      function stackGet2(key) {
        return this.__data__.get(key);
      }
      __name(stackGet2, "stackGet");
      function stackHas2(key) {
        return this.__data__.has(key);
      }
      __name(stackHas2, "stackHas");
      function stackSet2(key, value) {
        var data = this.__data__;
        if (data instanceof ListCache2) {
          var pairs = data.__data__;
          if (!Map3 || pairs.length < LARGE_ARRAY_SIZE2 - 1) {
            pairs.push([key, value]);
            this.size = ++data.size;
            return this;
          }
          data = this.__data__ = new MapCache2(pairs);
        }
        data.set(key, value);
        this.size = data.size;
        return this;
      }
      __name(stackSet2, "stackSet");
      Stack2.prototype.clear = stackClear2;
      Stack2.prototype["delete"] = stackDelete2;
      Stack2.prototype.get = stackGet2;
      Stack2.prototype.has = stackHas2;
      Stack2.prototype.set = stackSet2;
      function arrayLikeKeys2(value, inherited) {
        var isArr = isArray2(value), isArg = !isArr && isArguments2(value), isBuff = !isArr && !isArg && isBuffer2(value), isType = !isArr && !isArg && !isBuff && isTypedArray2(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes2(value.length, String) : [], length = result.length;
        for (var key in value) {
          if ((inherited || hasOwnProperty14.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
          (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
          isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
          isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
          isIndex2(key, length)))) {
            result.push(key);
          }
        }
        return result;
      }
      __name(arrayLikeKeys2, "arrayLikeKeys");
      function assocIndexOf2(array, key) {
        var length = array.length;
        while (length--) {
          if (eq2(array[length][0], key)) {
            return length;
          }
        }
        return -1;
      }
      __name(assocIndexOf2, "assocIndexOf");
      function baseGetAllKeys2(object, keysFunc, symbolsFunc) {
        var result = keysFunc(object);
        return isArray2(object) ? result : arrayPush2(result, symbolsFunc(object));
      }
      __name(baseGetAllKeys2, "baseGetAllKeys");
      function baseGetTag2(value) {
        if (value == null) {
          return value === void 0 ? undefinedTag2 : nullTag2;
        }
        return symToStringTag3 && symToStringTag3 in Object(value) ? getRawTag2(value) : objectToString2(value);
      }
      __name(baseGetTag2, "baseGetTag");
      function baseIsArguments2(value) {
        return isObjectLike2(value) && baseGetTag2(value) == argsTag5;
      }
      __name(baseIsArguments2, "baseIsArguments");
      function baseIsEqual2(value, other, bitmask, customizer, stack) {
        if (value === other) {
          return true;
        }
        if (value == null || other == null || !isObjectLike2(value) && !isObjectLike2(other)) {
          return value !== value && other !== other;
        }
        return baseIsEqualDeep2(value, other, bitmask, customizer, baseIsEqual2, stack);
      }
      __name(baseIsEqual2, "baseIsEqual");
      function baseIsEqualDeep2(object, other, bitmask, customizer, equalFunc, stack) {
        var objIsArr = isArray2(object), othIsArr = isArray2(other), objTag = objIsArr ? arrayTag4 : getTag2(object), othTag = othIsArr ? arrayTag4 : getTag2(other);
        objTag = objTag == argsTag5 ? objectTag6 : objTag;
        othTag = othTag == argsTag5 ? objectTag6 : othTag;
        var objIsObj = objTag == objectTag6, othIsObj = othTag == objectTag6, isSameTag = objTag == othTag;
        if (isSameTag && isBuffer2(object)) {
          if (!isBuffer2(other)) {
            return false;
          }
          objIsArr = true;
          objIsObj = false;
        }
        if (isSameTag && !objIsObj) {
          stack || (stack = new Stack2());
          return objIsArr || isTypedArray2(object) ? equalArrays2(object, other, bitmask, customizer, equalFunc, stack) : equalByTag2(object, other, objTag, bitmask, customizer, equalFunc, stack);
        }
        if (!(bitmask & COMPARE_PARTIAL_FLAG5)) {
          var objIsWrapped = objIsObj && hasOwnProperty14.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty14.call(other, "__wrapped__");
          if (objIsWrapped || othIsWrapped) {
            var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
            stack || (stack = new Stack2());
            return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
          }
        }
        if (!isSameTag) {
          return false;
        }
        stack || (stack = new Stack2());
        return equalObjects2(object, other, bitmask, customizer, equalFunc, stack);
      }
      __name(baseIsEqualDeep2, "baseIsEqualDeep");
      function baseIsNative2(value) {
        if (!isObject2(value) || isMasked2(value)) {
          return false;
        }
        var pattern = isFunction2(value) ? reIsNative2 : reIsHostCtor2;
        return pattern.test(toSource2(value));
      }
      __name(baseIsNative2, "baseIsNative");
      function baseIsTypedArray2(value) {
        return isObjectLike2(value) && isLength2(value.length) && !!typedArrayTags2[baseGetTag2(value)];
      }
      __name(baseIsTypedArray2, "baseIsTypedArray");
      function baseKeys2(object) {
        if (!isPrototype2(object)) {
          return nativeKeys2(object);
        }
        var result = [];
        for (var key in Object(object)) {
          if (hasOwnProperty14.call(object, key) && key != "constructor") {
            result.push(key);
          }
        }
        return result;
      }
      __name(baseKeys2, "baseKeys");
      function equalArrays2(array, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG5, arrLength = array.length, othLength = other.length;
        if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
          return false;
        }
        var stacked = stack.get(array);
        if (stacked && stack.get(other)) {
          return stacked == other;
        }
        var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG3 ? new SetCache2() : void 0;
        stack.set(array, other);
        stack.set(other, array);
        while (++index < arrLength) {
          var arrValue = array[index], othValue = other[index];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
          }
          if (compared !== void 0) {
            if (compared) {
              continue;
            }
            result = false;
            break;
          }
          if (seen) {
            if (!arraySome2(other, function(othValue2, othIndex) {
              if (!cacheHas2(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                return seen.push(othIndex);
              }
            })) {
              result = false;
              break;
            }
          } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
            result = false;
            break;
          }
        }
        stack["delete"](array);
        stack["delete"](other);
        return result;
      }
      __name(equalArrays2, "equalArrays");
      function equalByTag2(object, other, tag, bitmask, customizer, equalFunc, stack) {
        switch (tag) {
          case dataViewTag6:
            if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
              return false;
            }
            object = object.buffer;
            other = other.buffer;
          case arrayBufferTag5:
            if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array3(object), new Uint8Array3(other))) {
              return false;
            }
            return true;
          case boolTag5:
          case dateTag5:
          case numberTag5:
            return eq2(+object, +other);
          case errorTag4:
            return object.name == other.name && object.message == other.message;
          case regexpTag5:
          case stringTag5:
            return object == other + "";
          case mapTag7:
            var convert = mapToArray2;
          case setTag7:
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG5;
            convert || (convert = setToArray2);
            if (object.size != other.size && !isPartial) {
              return false;
            }
            var stacked = stack.get(object);
            if (stacked) {
              return stacked == other;
            }
            bitmask |= COMPARE_UNORDERED_FLAG3;
            stack.set(object, other);
            var result = equalArrays2(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
            stack["delete"](object);
            return result;
          case symbolTag4:
            if (symbolValueOf3) {
              return symbolValueOf3.call(object) == symbolValueOf3.call(other);
            }
        }
        return false;
      }
      __name(equalByTag2, "equalByTag");
      function equalObjects2(object, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG5, objProps = getAllKeys2(object), objLength = objProps.length, othProps = getAllKeys2(other), othLength = othProps.length;
        if (objLength != othLength && !isPartial) {
          return false;
        }
        var index = objLength;
        while (index--) {
          var key = objProps[index];
          if (!(isPartial ? key in other : hasOwnProperty14.call(other, key))) {
            return false;
          }
        }
        var stacked = stack.get(object);
        if (stacked && stack.get(other)) {
          return stacked == other;
        }
        var result = true;
        stack.set(object, other);
        stack.set(other, object);
        var skipCtor = isPartial;
        while (++index < objLength) {
          key = objProps[index];
          var objValue = object[key], othValue = other[key];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
          }
          if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
            result = false;
            break;
          }
          skipCtor || (skipCtor = key == "constructor");
        }
        if (result && !skipCtor) {
          var objCtor = object.constructor, othCtor = other.constructor;
          if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
            result = false;
          }
        }
        stack["delete"](object);
        stack["delete"](other);
        return result;
      }
      __name(equalObjects2, "equalObjects");
      function getAllKeys2(object) {
        return baseGetAllKeys2(object, keys2, getSymbols2);
      }
      __name(getAllKeys2, "getAllKeys");
      function getMapData2(map, key) {
        var data = map.__data__;
        return isKeyable2(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
      }
      __name(getMapData2, "getMapData");
      function getNative2(object, key) {
        var value = getValue2(object, key);
        return baseIsNative2(value) ? value : void 0;
      }
      __name(getNative2, "getNative");
      function getRawTag2(value) {
        var isOwn = hasOwnProperty14.call(value, symToStringTag3), tag = value[symToStringTag3];
        try {
          value[symToStringTag3] = void 0;
          var unmasked = true;
        } catch (e2) {
        }
        var result = nativeObjectToString3.call(value);
        if (unmasked) {
          if (isOwn) {
            value[symToStringTag3] = tag;
          } else {
            delete value[symToStringTag3];
          }
        }
        return result;
      }
      __name(getRawTag2, "getRawTag");
      var getSymbols2 = !nativeGetSymbols3 ? stubArray2 : function(object) {
        if (object == null) {
          return [];
        }
        object = Object(object);
        return arrayFilter2(nativeGetSymbols3(object), function(symbol) {
          return propertyIsEnumerable3.call(object, symbol);
        });
      };
      var getTag2 = baseGetTag2;
      if (DataView2 && getTag2(new DataView2(new ArrayBuffer(1))) != dataViewTag6 || Map3 && getTag2(new Map3()) != mapTag7 || Promise3 && getTag2(Promise3.resolve()) != promiseTag2 || Set3 && getTag2(new Set3()) != setTag7 || WeakMap3 && getTag2(new WeakMap3()) != weakMapTag4) {
        getTag2 = /* @__PURE__ */ __name(function(value) {
          var result = baseGetTag2(value), Ctor = result == objectTag6 ? value.constructor : void 0, ctorString = Ctor ? toSource2(Ctor) : "";
          if (ctorString) {
            switch (ctorString) {
              case dataViewCtorString2:
                return dataViewTag6;
              case mapCtorString2:
                return mapTag7;
              case promiseCtorString2:
                return promiseTag2;
              case setCtorString2:
                return setTag7;
              case weakMapCtorString2:
                return weakMapTag4;
            }
          }
          return result;
        }, "getTag");
      }
      function isIndex2(value, length) {
        length = length == null ? MAX_SAFE_INTEGER3 : length;
        return !!length && (typeof value == "number" || reIsUint2.test(value)) && (value > -1 && value % 1 == 0 && value < length);
      }
      __name(isIndex2, "isIndex");
      function isKeyable2(value) {
        var type = typeof value;
        return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
      }
      __name(isKeyable2, "isKeyable");
      function isMasked2(func) {
        return !!maskSrcKey2 && maskSrcKey2 in func;
      }
      __name(isMasked2, "isMasked");
      function isPrototype2(value) {
        var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto17;
        return value === proto;
      }
      __name(isPrototype2, "isPrototype");
      function objectToString2(value) {
        return nativeObjectToString3.call(value);
      }
      __name(objectToString2, "objectToString");
      function toSource2(func) {
        if (func != null) {
          try {
            return funcToString4.call(func);
          } catch (e2) {
          }
          try {
            return func + "";
          } catch (e2) {
          }
        }
        return "";
      }
      __name(toSource2, "toSource");
      function eq2(value, other) {
        return value === other || value !== value && other !== other;
      }
      __name(eq2, "eq");
      var isArguments2 = baseIsArguments2(/* @__PURE__ */ function() {
        return arguments;
      }()) ? baseIsArguments2 : function(value) {
        return isObjectLike2(value) && hasOwnProperty14.call(value, "callee") && !propertyIsEnumerable3.call(value, "callee");
      };
      var isArray2 = Array.isArray;
      function isArrayLike2(value) {
        return value != null && isLength2(value.length) && !isFunction2(value);
      }
      __name(isArrayLike2, "isArrayLike");
      var isBuffer2 = nativeIsBuffer2 || stubFalse2;
      function isEqual3(value, other) {
        return baseIsEqual2(value, other);
      }
      __name(isEqual3, "isEqual");
      function isFunction2(value) {
        if (!isObject2(value)) {
          return false;
        }
        var tag = baseGetTag2(value);
        return tag == funcTag4 || tag == genTag3 || tag == asyncTag2 || tag == proxyTag2;
      }
      __name(isFunction2, "isFunction");
      function isLength2(value) {
        return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER3;
      }
      __name(isLength2, "isLength");
      function isObject2(value) {
        var type = typeof value;
        return value != null && (type == "object" || type == "function");
      }
      __name(isObject2, "isObject");
      function isObjectLike2(value) {
        return value != null && typeof value == "object";
      }
      __name(isObjectLike2, "isObjectLike");
      var isTypedArray2 = nodeIsTypedArray2 ? baseUnary2(nodeIsTypedArray2) : baseIsTypedArray2;
      function keys2(object) {
        return isArrayLike2(object) ? arrayLikeKeys2(object) : baseKeys2(object);
      }
      __name(keys2, "keys");
      function stubArray2() {
        return [];
      }
      __name(stubArray2, "stubArray");
      function stubFalse2() {
        return false;
      }
      __name(stubFalse2, "stubFalse");
      module2.exports = isEqual3;
    }
  });

  // node_modules/quill-delta/dist/AttributeMap.js
  var require_AttributeMap = __commonJS({
    "node_modules/quill-delta/dist/AttributeMap.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      var cloneDeep2 = require_lodash();
      var isEqual3 = require_lodash2();
      var AttributeMap5;
      (function(AttributeMap6) {
        function compose(a2 = {}, b2 = {}, keepNull = false) {
          if (typeof a2 !== "object") {
            a2 = {};
          }
          if (typeof b2 !== "object") {
            b2 = {};
          }
          let attributes = cloneDeep2(b2);
          if (!keepNull) {
            attributes = Object.keys(attributes).reduce((copy, key) => {
              if (attributes[key] != null) {
                copy[key] = attributes[key];
              }
              return copy;
            }, {});
          }
          for (const key in a2) {
            if (a2[key] !== void 0 && b2[key] === void 0) {
              attributes[key] = a2[key];
            }
          }
          return Object.keys(attributes).length > 0 ? attributes : void 0;
        }
        __name(compose, "compose");
        AttributeMap6.compose = compose;
        function diff(a2 = {}, b2 = {}) {
          if (typeof a2 !== "object") {
            a2 = {};
          }
          if (typeof b2 !== "object") {
            b2 = {};
          }
          const attributes = Object.keys(a2).concat(Object.keys(b2)).reduce((attrs, key) => {
            if (!isEqual3(a2[key], b2[key])) {
              attrs[key] = b2[key] === void 0 ? null : b2[key];
            }
            return attrs;
          }, {});
          return Object.keys(attributes).length > 0 ? attributes : void 0;
        }
        __name(diff, "diff");
        AttributeMap6.diff = diff;
        function invert(attr = {}, base = {}) {
          attr = attr || {};
          const baseInverted = Object.keys(base).reduce((memo, key) => {
            if (base[key] !== attr[key] && attr[key] !== void 0) {
              memo[key] = base[key];
            }
            return memo;
          }, {});
          return Object.keys(attr).reduce((memo, key) => {
            if (attr[key] !== base[key] && base[key] === void 0) {
              memo[key] = null;
            }
            return memo;
          }, baseInverted);
        }
        __name(invert, "invert");
        AttributeMap6.invert = invert;
        function transform(a2, b2, priority = false) {
          if (typeof a2 !== "object") {
            return b2;
          }
          if (typeof b2 !== "object") {
            return void 0;
          }
          if (!priority) {
            return b2;
          }
          const attributes = Object.keys(b2).reduce((attrs, key) => {
            if (a2[key] === void 0) {
              attrs[key] = b2[key];
            }
            return attrs;
          }, {});
          return Object.keys(attributes).length > 0 ? attributes : void 0;
        }
        __name(transform, "transform");
        AttributeMap6.transform = transform;
      })(AttributeMap5 || (AttributeMap5 = {}));
      exports2.default = AttributeMap5;
    }
  });

  // node_modules/quill-delta/dist/Op.js
  var require_Op = __commonJS({
    "node_modules/quill-delta/dist/Op.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      var Op4;
      (function(Op5) {
        function length(op) {
          if (typeof op.delete === "number") {
            return op.delete;
          } else if (typeof op.retain === "number") {
            return op.retain;
          } else if (typeof op.retain === "object" && op.retain !== null) {
            return 1;
          } else {
            return typeof op.insert === "string" ? op.insert.length : 1;
          }
        }
        __name(length, "length");
        Op5.length = length;
      })(Op4 || (Op4 = {}));
      exports2.default = Op4;
    }
  });

  // node_modules/quill-delta/dist/OpIterator.js
  var require_OpIterator = __commonJS({
    "node_modules/quill-delta/dist/OpIterator.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      var Op_1 = require_Op();
      var Iterator = class {
        static {
          __name(this, "Iterator");
        }
        constructor(ops) {
          this.ops = ops;
          this.index = 0;
          this.offset = 0;
        }
        hasNext() {
          return this.peekLength() < Infinity;
        }
        next(length) {
          if (!length) {
            length = Infinity;
          }
          const nextOp = this.ops[this.index];
          if (nextOp) {
            const offset = this.offset;
            const opLength = Op_1.default.length(nextOp);
            if (length >= opLength - offset) {
              length = opLength - offset;
              this.index += 1;
              this.offset = 0;
            } else {
              this.offset += length;
            }
            if (typeof nextOp.delete === "number") {
              return { delete: length };
            } else {
              const retOp = {};
              if (nextOp.attributes) {
                retOp.attributes = nextOp.attributes;
              }
              if (typeof nextOp.retain === "number") {
                retOp.retain = length;
              } else if (typeof nextOp.retain === "object" && nextOp.retain !== null) {
                retOp.retain = nextOp.retain;
              } else if (typeof nextOp.insert === "string") {
                retOp.insert = nextOp.insert.substr(offset, length);
              } else {
                retOp.insert = nextOp.insert;
              }
              return retOp;
            }
          } else {
            return { retain: Infinity };
          }
        }
        peek() {
          return this.ops[this.index];
        }
        peekLength() {
          if (this.ops[this.index]) {
            return Op_1.default.length(this.ops[this.index]) - this.offset;
          } else {
            return Infinity;
          }
        }
        peekType() {
          const op = this.ops[this.index];
          if (op) {
            if (typeof op.delete === "number") {
              return "delete";
            } else if (typeof op.retain === "number" || typeof op.retain === "object" && op.retain !== null) {
              return "retain";
            } else {
              return "insert";
            }
          }
          return "retain";
        }
        rest() {
          if (!this.hasNext()) {
            return [];
          } else if (this.offset === 0) {
            return this.ops.slice(this.index);
          } else {
            const offset = this.offset;
            const index = this.index;
            const next = this.next();
            const rest = this.ops.slice(this.index);
            this.offset = offset;
            this.index = index;
            return [next].concat(rest);
          }
        }
      };
      exports2.default = Iterator;
    }
  });

  // node_modules/quill-delta/dist/Delta.js
  var require_Delta = __commonJS({
    "node_modules/quill-delta/dist/Delta.js"(exports2, module2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.AttributeMap = exports2.OpIterator = exports2.Op = void 0;
      var diff = require_diff();
      var cloneDeep2 = require_lodash();
      var isEqual3 = require_lodash2();
      var AttributeMap_1 = require_AttributeMap();
      exports2.AttributeMap = AttributeMap_1.default;
      var Op_1 = require_Op();
      exports2.Op = Op_1.default;
      var OpIterator_1 = require_OpIterator();
      exports2.OpIterator = OpIterator_1.default;
      var NULL_CHARACTER = String.fromCharCode(0);
      var getEmbedTypeAndData = /* @__PURE__ */ __name((a2, b2) => {
        if (typeof a2 !== "object" || a2 === null) {
          throw new Error(`cannot retain a ${typeof a2}`);
        }
        if (typeof b2 !== "object" || b2 === null) {
          throw new Error(`cannot retain a ${typeof b2}`);
        }
        const embedType = Object.keys(a2)[0];
        if (!embedType || embedType !== Object.keys(b2)[0]) {
          throw new Error(`embed types not matched: ${embedType} != ${Object.keys(b2)[0]}`);
        }
        return [embedType, a2[embedType], b2[embedType]];
      }, "getEmbedTypeAndData");
      var Delta13 = class _Delta {
        static {
          __name(this, "Delta");
        }
        constructor(ops) {
          if (Array.isArray(ops)) {
            this.ops = ops;
          } else if (ops != null && Array.isArray(ops.ops)) {
            this.ops = ops.ops;
          } else {
            this.ops = [];
          }
        }
        static registerEmbed(embedType, handler) {
          this.handlers[embedType] = handler;
        }
        static unregisterEmbed(embedType) {
          delete this.handlers[embedType];
        }
        static getHandler(embedType) {
          const handler = this.handlers[embedType];
          if (!handler) {
            throw new Error(`no handlers for embed type "${embedType}"`);
          }
          return handler;
        }
        insert(arg, attributes) {
          const newOp = {};
          if (typeof arg === "string" && arg.length === 0) {
            return this;
          }
          newOp.insert = arg;
          if (attributes != null && typeof attributes === "object" && Object.keys(attributes).length > 0) {
            newOp.attributes = attributes;
          }
          return this.push(newOp);
        }
        delete(length) {
          if (length <= 0) {
            return this;
          }
          return this.push({ delete: length });
        }
        retain(length, attributes) {
          if (typeof length === "number" && length <= 0) {
            return this;
          }
          const newOp = { retain: length };
          if (attributes != null && typeof attributes === "object" && Object.keys(attributes).length > 0) {
            newOp.attributes = attributes;
          }
          return this.push(newOp);
        }
        push(newOp) {
          let index = this.ops.length;
          let lastOp = this.ops[index - 1];
          newOp = cloneDeep2(newOp);
          if (typeof lastOp === "object") {
            if (typeof newOp.delete === "number" && typeof lastOp.delete === "number") {
              this.ops[index - 1] = { delete: lastOp.delete + newOp.delete };
              return this;
            }
            if (typeof lastOp.delete === "number" && newOp.insert != null) {
              index -= 1;
              lastOp = this.ops[index - 1];
              if (typeof lastOp !== "object") {
                this.ops.unshift(newOp);
                return this;
              }
            }
            if (isEqual3(newOp.attributes, lastOp.attributes)) {
              if (typeof newOp.insert === "string" && typeof lastOp.insert === "string") {
                this.ops[index - 1] = { insert: lastOp.insert + newOp.insert };
                if (typeof newOp.attributes === "object") {
                  this.ops[index - 1].attributes = newOp.attributes;
                }
                return this;
              } else if (typeof newOp.retain === "number" && typeof lastOp.retain === "number") {
                this.ops[index - 1] = { retain: lastOp.retain + newOp.retain };
                if (typeof newOp.attributes === "object") {
                  this.ops[index - 1].attributes = newOp.attributes;
                }
                return this;
              }
            }
          }
          if (index === this.ops.length) {
            this.ops.push(newOp);
          } else {
            this.ops.splice(index, 0, newOp);
          }
          return this;
        }
        chop() {
          const lastOp = this.ops[this.ops.length - 1];
          if (lastOp && typeof lastOp.retain === "number" && !lastOp.attributes) {
            this.ops.pop();
          }
          return this;
        }
        filter(predicate) {
          return this.ops.filter(predicate);
        }
        forEach(predicate) {
          this.ops.forEach(predicate);
        }
        map(predicate) {
          return this.ops.map(predicate);
        }
        partition(predicate) {
          const passed = [];
          const failed = [];
          this.forEach((op) => {
            const target = predicate(op) ? passed : failed;
            target.push(op);
          });
          return [passed, failed];
        }
        reduce(predicate, initialValue) {
          return this.ops.reduce(predicate, initialValue);
        }
        changeLength() {
          return this.reduce((length, elem) => {
            if (elem.insert) {
              return length + Op_1.default.length(elem);
            } else if (elem.delete) {
              return length - elem.delete;
            }
            return length;
          }, 0);
        }
        length() {
          return this.reduce((length, elem) => {
            return length + Op_1.default.length(elem);
          }, 0);
        }
        slice(start2 = 0, end = Infinity) {
          const ops = [];
          const iter = new OpIterator_1.default(this.ops);
          let index = 0;
          while (index < end && iter.hasNext()) {
            let nextOp;
            if (index < start2) {
              nextOp = iter.next(start2 - index);
            } else {
              nextOp = iter.next(end - index);
              ops.push(nextOp);
            }
            index += Op_1.default.length(nextOp);
          }
          return new _Delta(ops);
        }
        compose(other) {
          const thisIter = new OpIterator_1.default(this.ops);
          const otherIter = new OpIterator_1.default(other.ops);
          const ops = [];
          const firstOther = otherIter.peek();
          if (firstOther != null && typeof firstOther.retain === "number" && firstOther.attributes == null) {
            let firstLeft = firstOther.retain;
            while (thisIter.peekType() === "insert" && thisIter.peekLength() <= firstLeft) {
              firstLeft -= thisIter.peekLength();
              ops.push(thisIter.next());
            }
            if (firstOther.retain - firstLeft > 0) {
              otherIter.next(firstOther.retain - firstLeft);
            }
          }
          const delta = new _Delta(ops);
          while (thisIter.hasNext() || otherIter.hasNext()) {
            if (otherIter.peekType() === "insert") {
              delta.push(otherIter.next());
            } else if (thisIter.peekType() === "delete") {
              delta.push(thisIter.next());
            } else {
              const length = Math.min(thisIter.peekLength(), otherIter.peekLength());
              const thisOp = thisIter.next(length);
              const otherOp = otherIter.next(length);
              if (otherOp.retain) {
                const newOp = {};
                if (typeof thisOp.retain === "number") {
                  newOp.retain = typeof otherOp.retain === "number" ? length : otherOp.retain;
                } else {
                  if (typeof otherOp.retain === "number") {
                    if (thisOp.retain == null) {
                      newOp.insert = thisOp.insert;
                    } else {
                      newOp.retain = thisOp.retain;
                    }
                  } else {
                    const action = thisOp.retain == null ? "insert" : "retain";
                    const [embedType, thisData, otherData] = getEmbedTypeAndData(thisOp[action], otherOp.retain);
                    const handler = _Delta.getHandler(embedType);
                    newOp[action] = {
                      [embedType]: handler.compose(thisData, otherData, action === "retain")
                    };
                  }
                }
                const attributes = AttributeMap_1.default.compose(thisOp.attributes, otherOp.attributes, typeof thisOp.retain === "number");
                if (attributes) {
                  newOp.attributes = attributes;
                }
                delta.push(newOp);
                if (!otherIter.hasNext() && isEqual3(delta.ops[delta.ops.length - 1], newOp)) {
                  const rest = new _Delta(thisIter.rest());
                  return delta.concat(rest).chop();
                }
              } else if (typeof otherOp.delete === "number" && (typeof thisOp.retain === "number" || typeof thisOp.retain === "object" && thisOp.retain !== null)) {
                delta.push(otherOp);
              }
            }
          }
          return delta.chop();
        }
        concat(other) {
          const delta = new _Delta(this.ops.slice());
          if (other.ops.length > 0) {
            delta.push(other.ops[0]);
            delta.ops = delta.ops.concat(other.ops.slice(1));
          }
          return delta;
        }
        diff(other, cursor) {
          if (this.ops === other.ops) {
            return new _Delta();
          }
          const strings = [this, other].map((delta) => {
            return delta.map((op) => {
              if (op.insert != null) {
                return typeof op.insert === "string" ? op.insert : NULL_CHARACTER;
              }
              const prep = delta === other ? "on" : "with";
              throw new Error("diff() called " + prep + " non-document");
            }).join("");
          });
          const retDelta = new _Delta();
          const diffResult = diff(strings[0], strings[1], cursor, true);
          const thisIter = new OpIterator_1.default(this.ops);
          const otherIter = new OpIterator_1.default(other.ops);
          diffResult.forEach((component) => {
            let length = component[1].length;
            while (length > 0) {
              let opLength = 0;
              switch (component[0]) {
                case diff.INSERT:
                  opLength = Math.min(otherIter.peekLength(), length);
                  retDelta.push(otherIter.next(opLength));
                  break;
                case diff.DELETE:
                  opLength = Math.min(length, thisIter.peekLength());
                  thisIter.next(opLength);
                  retDelta.delete(opLength);
                  break;
                case diff.EQUAL:
                  opLength = Math.min(thisIter.peekLength(), otherIter.peekLength(), length);
                  const thisOp = thisIter.next(opLength);
                  const otherOp = otherIter.next(opLength);
                  if (isEqual3(thisOp.insert, otherOp.insert)) {
                    retDelta.retain(opLength, AttributeMap_1.default.diff(thisOp.attributes, otherOp.attributes));
                  } else {
                    retDelta.push(otherOp).delete(opLength);
                  }
                  break;
              }
              length -= opLength;
            }
          });
          return retDelta.chop();
        }
        eachLine(predicate, newline = "\n") {
          const iter = new OpIterator_1.default(this.ops);
          let line = new _Delta();
          let i2 = 0;
          while (iter.hasNext()) {
            if (iter.peekType() !== "insert") {
              return;
            }
            const thisOp = iter.peek();
            const start2 = Op_1.default.length(thisOp) - iter.peekLength();
            const index = typeof thisOp.insert === "string" ? thisOp.insert.indexOf(newline, start2) - start2 : -1;
            if (index < 0) {
              line.push(iter.next());
            } else if (index > 0) {
              line.push(iter.next(index));
            } else {
              if (predicate(line, iter.next(1).attributes || {}, i2) === false) {
                return;
              }
              i2 += 1;
              line = new _Delta();
            }
          }
          if (line.length() > 0) {
            predicate(line, {}, i2);
          }
        }
        invert(base) {
          const inverted = new _Delta();
          this.reduce((baseIndex, op) => {
            if (op.insert) {
              inverted.delete(Op_1.default.length(op));
            } else if (typeof op.retain === "number" && op.attributes == null) {
              inverted.retain(op.retain);
              return baseIndex + op.retain;
            } else if (op.delete || typeof op.retain === "number") {
              const length = op.delete || op.retain;
              const slice = base.slice(baseIndex, baseIndex + length);
              slice.forEach((baseOp) => {
                if (op.delete) {
                  inverted.push(baseOp);
                } else if (op.retain && op.attributes) {
                  inverted.retain(Op_1.default.length(baseOp), AttributeMap_1.default.invert(op.attributes, baseOp.attributes));
                }
              });
              return baseIndex + length;
            } else if (typeof op.retain === "object" && op.retain !== null) {
              const slice = base.slice(baseIndex, baseIndex + 1);
              const baseOp = new OpIterator_1.default(slice.ops).next();
              const [embedType, opData, baseOpData] = getEmbedTypeAndData(op.retain, baseOp.insert);
              const handler = _Delta.getHandler(embedType);
              inverted.retain({ [embedType]: handler.invert(opData, baseOpData) }, AttributeMap_1.default.invert(op.attributes, baseOp.attributes));
              return baseIndex + 1;
            }
            return baseIndex;
          }, 0);
          return inverted.chop();
        }
        transform(arg, priority = false) {
          priority = !!priority;
          if (typeof arg === "number") {
            return this.transformPosition(arg, priority);
          }
          const other = arg;
          const thisIter = new OpIterator_1.default(this.ops);
          const otherIter = new OpIterator_1.default(other.ops);
          const delta = new _Delta();
          while (thisIter.hasNext() || otherIter.hasNext()) {
            if (thisIter.peekType() === "insert" && (priority || otherIter.peekType() !== "insert")) {
              delta.retain(Op_1.default.length(thisIter.next()));
            } else if (otherIter.peekType() === "insert") {
              delta.push(otherIter.next());
            } else {
              const length = Math.min(thisIter.peekLength(), otherIter.peekLength());
              const thisOp = thisIter.next(length);
              const otherOp = otherIter.next(length);
              if (thisOp.delete) {
                continue;
              } else if (otherOp.delete) {
                delta.push(otherOp);
              } else {
                const thisData = thisOp.retain;
                const otherData = otherOp.retain;
                let transformedData = typeof otherData === "object" && otherData !== null ? otherData : length;
                if (typeof thisData === "object" && thisData !== null && typeof otherData === "object" && otherData !== null) {
                  const embedType = Object.keys(thisData)[0];
                  if (embedType === Object.keys(otherData)[0]) {
                    const handler = _Delta.getHandler(embedType);
                    if (handler) {
                      transformedData = {
                        [embedType]: handler.transform(thisData[embedType], otherData[embedType], priority)
                      };
                    }
                  }
                }
                delta.retain(transformedData, AttributeMap_1.default.transform(thisOp.attributes, otherOp.attributes, priority));
              }
            }
          }
          return delta.chop();
        }
        transformPosition(index, priority = false) {
          priority = !!priority;
          const thisIter = new OpIterator_1.default(this.ops);
          let offset = 0;
          while (thisIter.hasNext() && offset <= index) {
            const length = thisIter.peekLength();
            const nextType = thisIter.peekType();
            thisIter.next();
            if (nextType === "delete") {
              index -= Math.min(length, index - offset);
              continue;
            } else if (nextType === "insert" && (offset < index || !priority)) {
              index += length;
            }
            offset += length;
          }
          return index;
        }
      };
      Delta13.Op = Op_1.default;
      Delta13.OpIterator = OpIterator_1.default;
      Delta13.AttributeMap = AttributeMap_1.default;
      Delta13.handlers = {};
      exports2.default = Delta13;
      if (typeof module2 === "object") {
        module2.exports = Delta13;
        module2.exports.default = Delta13;
      }
    }
  });

  // node_modules/eventemitter3/index.js
  var require_eventemitter3 = __commonJS({
    "node_modules/eventemitter3/index.js"(exports2, module2) {
      "use strict";
      var has = Object.prototype.hasOwnProperty;
      var prefix = "~";
      function Events() {
      }
      __name(Events, "Events");
      if (Object.create) {
        Events.prototype = /* @__PURE__ */ Object.create(null);
        if (!new Events().__proto__)
          prefix = false;
      }
      function EE(fn, context, once) {
        this.fn = fn;
        this.context = context;
        this.once = once || false;
      }
      __name(EE, "EE");
      function addListener(emitter, event, fn, context, once) {
        if (typeof fn !== "function") {
          throw new TypeError("The listener must be a function");
        }
        var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
        if (!emitter._events[evt])
          emitter._events[evt] = listener, emitter._eventsCount++;
        else if (!emitter._events[evt].fn)
          emitter._events[evt].push(listener);
        else
          emitter._events[evt] = [emitter._events[evt], listener];
        return emitter;
      }
      __name(addListener, "addListener");
      function clearEvent(emitter, evt) {
        if (--emitter._eventsCount === 0)
          emitter._events = new Events();
        else
          delete emitter._events[evt];
      }
      __name(clearEvent, "clearEvent");
      function EventEmitter2() {
        this._events = new Events();
        this._eventsCount = 0;
      }
      __name(EventEmitter2, "EventEmitter");
      EventEmitter2.prototype.eventNames = /* @__PURE__ */ __name(function eventNames() {
        var names = [], events, name;
        if (this._eventsCount === 0)
          return names;
        for (name in events = this._events) {
          if (has.call(events, name))
            names.push(prefix ? name.slice(1) : name);
        }
        if (Object.getOwnPropertySymbols) {
          return names.concat(Object.getOwnPropertySymbols(events));
        }
        return names;
      }, "eventNames");
      EventEmitter2.prototype.listeners = /* @__PURE__ */ __name(function listeners(event) {
        var evt = prefix ? prefix + event : event, handlers = this._events[evt];
        if (!handlers)
          return [];
        if (handlers.fn)
          return [handlers.fn];
        for (var i2 = 0, l2 = handlers.length, ee = new Array(l2); i2 < l2; i2++) {
          ee[i2] = handlers[i2].fn;
        }
        return ee;
      }, "listeners");
      EventEmitter2.prototype.listenerCount = /* @__PURE__ */ __name(function listenerCount(event) {
        var evt = prefix ? prefix + event : event, listeners = this._events[evt];
        if (!listeners)
          return 0;
        if (listeners.fn)
          return 1;
        return listeners.length;
      }, "listenerCount");
      EventEmitter2.prototype.emit = /* @__PURE__ */ __name(function emit(event, a1, a2, a3, a4, a5) {
        var evt = prefix ? prefix + event : event;
        if (!this._events[evt])
          return false;
        var listeners = this._events[evt], len = arguments.length, args, i2;
        if (listeners.fn) {
          if (listeners.once)
            this.removeListener(event, listeners.fn, void 0, true);
          switch (len) {
            case 1:
              return listeners.fn.call(listeners.context), true;
            case 2:
              return listeners.fn.call(listeners.context, a1), true;
            case 3:
              return listeners.fn.call(listeners.context, a1, a2), true;
            case 4:
              return listeners.fn.call(listeners.context, a1, a2, a3), true;
            case 5:
              return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
            case 6:
              return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
          }
          for (i2 = 1, args = new Array(len - 1); i2 < len; i2++) {
            args[i2 - 1] = arguments[i2];
          }
          listeners.fn.apply(listeners.context, args);
        } else {
          var length = listeners.length, j2;
          for (i2 = 0; i2 < length; i2++) {
            if (listeners[i2].once)
              this.removeListener(event, listeners[i2].fn, void 0, true);
            switch (len) {
              case 1:
                listeners[i2].fn.call(listeners[i2].context);
                break;
              case 2:
                listeners[i2].fn.call(listeners[i2].context, a1);
                break;
              case 3:
                listeners[i2].fn.call(listeners[i2].context, a1, a2);
                break;
              case 4:
                listeners[i2].fn.call(listeners[i2].context, a1, a2, a3);
                break;
              default:
                if (!args)
                  for (j2 = 1, args = new Array(len - 1); j2 < len; j2++) {
                    args[j2 - 1] = arguments[j2];
                  }
                listeners[i2].fn.apply(listeners[i2].context, args);
            }
          }
        }
        return true;
      }, "emit");
      EventEmitter2.prototype.on = /* @__PURE__ */ __name(function on(event, fn, context) {
        return addListener(this, event, fn, context, false);
      }, "on");
      EventEmitter2.prototype.once = /* @__PURE__ */ __name(function once(event, fn, context) {
        return addListener(this, event, fn, context, true);
      }, "once");
      EventEmitter2.prototype.removeListener = /* @__PURE__ */ __name(function removeListener(event, fn, context, once) {
        var evt = prefix ? prefix + event : event;
        if (!this._events[evt])
          return this;
        if (!fn) {
          clearEvent(this, evt);
          return this;
        }
        var listeners = this._events[evt];
        if (listeners.fn) {
          if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
            clearEvent(this, evt);
          }
        } else {
          for (var i2 = 0, events = [], length = listeners.length; i2 < length; i2++) {
            if (listeners[i2].fn !== fn || once && !listeners[i2].once || context && listeners[i2].context !== context) {
              events.push(listeners[i2]);
            }
          }
          if (events.length)
            this._events[evt] = events.length === 1 ? events[0] : events;
          else
            clearEvent(this, evt);
        }
        return this;
      }, "removeListener");
      EventEmitter2.prototype.removeAllListeners = /* @__PURE__ */ __name(function removeAllListeners(event) {
        var evt;
        if (event) {
          evt = prefix ? prefix + event : event;
          if (this._events[evt])
            clearEvent(this, evt);
        } else {
          this._events = new Events();
          this._eventsCount = 0;
        }
        return this;
      }, "removeAllListeners");
      EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
      EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
      EventEmitter2.prefixed = prefix;
      EventEmitter2.EventEmitter = EventEmitter2;
      if ("undefined" !== typeof module2) {
        module2.exports = EventEmitter2;
      }
    }
  });

  // node_modules/quill-html-edit-button/dist/quill.htmlEditButton.min.js
  var require_quill_htmlEditButton_min = __commonJS({
    "node_modules/quill-html-edit-button/dist/quill.htmlEditButton.min.js"(exports2, module2) {
      !function(t2, e2) {
        if ("object" == typeof exports2 && "object" == typeof module2)
          module2.exports = e2();
        else if ("function" == typeof define && define.amd)
          define([], e2);
        else {
          var n2 = e2();
          for (var r2 in n2)
            ("object" == typeof exports2 ? exports2 : t2)[r2] = n2[r2];
        }
      }(self, () => (() => {
        var t2 = { 64: (t3, e3, n3) => {
          (t3.exports = n3(765)(false)).push([t3.id, ".ql-html-overlayContainer {\n  background: #0000007d;\n  position: fixed;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  z-index: 9999;\n}\n\n.ql-html-popupContainer {\n  background: #ddd;\n  position: absolute;\n  top: 5%;\n  left: 5%;\n  right: 5%;\n  bottom: 5%;\n  border-radius: 10px;\n}\n\n.ql-html-textContainer {\n  position: relative;\n  height: calc(100% - 40px);\n  padding: 20px;\n}\n\n.ql-html-textArea {\n  background: #fff;\n  position: absolute;\n  left: 15px;\n  width: calc(100% - 30px);\n  height: calc(100% - 60px) !important;\n}\n\n.ql-html-textArea .ql-syntax {\n  word-break: break-all;\n  white-space: pre-wrap;\n}\n\n.ql-html-buttonCancel {\n  margin-right: 20px;\n}\n\n.ql-html-popupTitle {\n  margin: 0;\n  display: block;\n  font-style: italic;\n}\n\n.ql-html-buttonGroup {\n  position: absolute;\n  bottom: 20px;\n  transform: scale(1.5);\n  left: calc(50% - 60px);\n}\n", ""]);
        }, 765: (t3) => {
          t3.exports = function(t4) {
            var e3 = [];
            return e3.toString = function() {
              return this.map(function(e4) {
                var n3 = function(t5, e5) {
                  var n4 = t5[1] || "", r2 = t5[3];
                  if (!r2)
                    return n4;
                  if (e5 && "function" == typeof btoa) {
                    var s2 = (o2 = r2, "/*# sourceMappingURL=data:application/json;charset=utf-8;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(o2)))) + " */"), i2 = r2.sources.map(function(t6) {
                      return "/*# sourceURL=" + r2.sourceRoot + t6 + " */";
                    });
                    return [n4].concat(i2).concat([s2]).join("\n");
                  }
                  var o2;
                  return [n4].join("\n");
                }(e4, t4);
                return e4[2] ? "@media " + e4[2] + "{" + n3 + "}" : n3;
              }).join("");
            }, e3.i = function(t5, n3) {
              "string" == typeof t5 && (t5 = [[null, t5, ""]]);
              for (var r2 = {}, s2 = 0; s2 < this.length; s2++) {
                var i2 = this[s2][0];
                "number" == typeof i2 && (r2[i2] = true);
              }
              for (s2 = 0; s2 < t5.length; s2++) {
                var o2 = t5[s2];
                "number" == typeof o2[0] && r2[o2[0]] || (n3 && !o2[2] ? o2[2] = n3 : n3 && (o2[2] = "(" + o2[2] + ") and (" + n3 + ")"), e3.push(o2));
              }
            }, e3;
          };
        }, 228: (t3) => {
          "use strict";
          var e3 = Object.prototype.hasOwnProperty, n3 = "~";
          function r2() {
          }
          __name(r2, "r");
          function s2(t4, e4, n4) {
            this.fn = t4, this.context = e4, this.once = n4 || false;
          }
          __name(s2, "s");
          function i2(t4, e4, r3, i3, o3) {
            if ("function" != typeof r3)
              throw new TypeError("The listener must be a function");
            var l3 = new s2(r3, i3 || t4, o3), a2 = n3 ? n3 + e4 : e4;
            return t4._events[a2] ? t4._events[a2].fn ? t4._events[a2] = [t4._events[a2], l3] : t4._events[a2].push(l3) : (t4._events[a2] = l3, t4._eventsCount++), t4;
          }
          __name(i2, "i");
          function o2(t4, e4) {
            0 == --t4._eventsCount ? t4._events = new r2() : delete t4._events[e4];
          }
          __name(o2, "o");
          function l2() {
            this._events = new r2(), this._eventsCount = 0;
          }
          __name(l2, "l");
          Object.create && (r2.prototype = /* @__PURE__ */ Object.create(null), new r2().__proto__ || (n3 = false)), l2.prototype.eventNames = function() {
            var t4, r3, s3 = [];
            if (0 === this._eventsCount)
              return s3;
            for (r3 in t4 = this._events)
              e3.call(t4, r3) && s3.push(n3 ? r3.slice(1) : r3);
            return Object.getOwnPropertySymbols ? s3.concat(Object.getOwnPropertySymbols(t4)) : s3;
          }, l2.prototype.listeners = function(t4) {
            var e4 = n3 ? n3 + t4 : t4, r3 = this._events[e4];
            if (!r3)
              return [];
            if (r3.fn)
              return [r3.fn];
            for (var s3 = 0, i3 = r3.length, o3 = new Array(i3); s3 < i3; s3++)
              o3[s3] = r3[s3].fn;
            return o3;
          }, l2.prototype.listenerCount = function(t4) {
            var e4 = n3 ? n3 + t4 : t4, r3 = this._events[e4];
            return r3 ? r3.fn ? 1 : r3.length : 0;
          }, l2.prototype.emit = function(t4, e4, r3, s3, i3, o3) {
            var l3 = n3 ? n3 + t4 : t4;
            if (!this._events[l3])
              return false;
            var a2, c2, u2 = this._events[l3], h2 = arguments.length;
            if (u2.fn) {
              switch (u2.once && this.removeListener(t4, u2.fn, void 0, true), h2) {
                case 1:
                  return u2.fn.call(u2.context), true;
                case 2:
                  return u2.fn.call(u2.context, e4), true;
                case 3:
                  return u2.fn.call(u2.context, e4, r3), true;
                case 4:
                  return u2.fn.call(u2.context, e4, r3, s3), true;
                case 5:
                  return u2.fn.call(u2.context, e4, r3, s3, i3), true;
                case 6:
                  return u2.fn.call(u2.context, e4, r3, s3, i3, o3), true;
              }
              for (c2 = 1, a2 = new Array(h2 - 1); c2 < h2; c2++)
                a2[c2 - 1] = arguments[c2];
              u2.fn.apply(u2.context, a2);
            } else {
              var d2, f2 = u2.length;
              for (c2 = 0; c2 < f2; c2++)
                switch (u2[c2].once && this.removeListener(t4, u2[c2].fn, void 0, true), h2) {
                  case 1:
                    u2[c2].fn.call(u2[c2].context);
                    break;
                  case 2:
                    u2[c2].fn.call(u2[c2].context, e4);
                    break;
                  case 3:
                    u2[c2].fn.call(u2[c2].context, e4, r3);
                    break;
                  case 4:
                    u2[c2].fn.call(u2[c2].context, e4, r3, s3);
                    break;
                  default:
                    if (!a2)
                      for (d2 = 1, a2 = new Array(h2 - 1); d2 < h2; d2++)
                        a2[d2 - 1] = arguments[d2];
                    u2[c2].fn.apply(u2[c2].context, a2);
                }
            }
            return true;
          }, l2.prototype.on = function(t4, e4, n4) {
            return i2(this, t4, e4, n4, false);
          }, l2.prototype.once = function(t4, e4, n4) {
            return i2(this, t4, e4, n4, true);
          }, l2.prototype.removeListener = function(t4, e4, r3, s3) {
            var i3 = n3 ? n3 + t4 : t4;
            if (!this._events[i3])
              return this;
            if (!e4)
              return o2(this, i3), this;
            var l3 = this._events[i3];
            if (l3.fn)
              l3.fn !== e4 || s3 && !l3.once || r3 && l3.context !== r3 || o2(this, i3);
            else {
              for (var a2 = 0, c2 = [], u2 = l3.length; a2 < u2; a2++)
                (l3[a2].fn !== e4 || s3 && !l3[a2].once || r3 && l3[a2].context !== r3) && c2.push(l3[a2]);
              c2.length ? this._events[i3] = 1 === c2.length ? c2[0] : c2 : o2(this, i3);
            }
            return this;
          }, l2.prototype.removeAllListeners = function(t4) {
            var e4;
            return t4 ? (e4 = n3 ? n3 + t4 : t4, this._events[e4] && o2(this, e4)) : (this._events = new r2(), this._eventsCount = 0), this;
          }, l2.prototype.off = l2.prototype.removeListener, l2.prototype.addListener = l2.prototype.on, l2.prefixed = n3, l2.EventEmitter = l2, t3.exports = l2;
        }, 606: (t3) => {
          var e3 = -1, n3 = 1, r2 = 0;
          function s2(t4, g3, m3, b3, y3) {
            if (t4 === g3)
              return t4 ? [[r2, t4]] : [];
            if (null != m3) {
              var x3 = function(t5, e4, n4) {
                var r3 = "number" == typeof n4 ? { index: n4, length: 0 } : n4.oldRange, s3 = "number" == typeof n4 ? null : n4.newRange, i3 = t5.length, o3 = e4.length;
                if (0 === r3.length && (null === s3 || 0 === s3.length)) {
                  var l3 = r3.index, a3 = t5.slice(0, l3), c3 = t5.slice(l3), u3 = s3 ? s3.index : null, h3 = l3 + o3 - i3;
                  if ((null === u3 || u3 === h3) && !(h3 < 0 || h3 > o3)) {
                    var d3 = e4.slice(0, h3);
                    if ((g4 = e4.slice(h3)) === c3) {
                      var f3 = Math.min(l3, h3);
                      if ((b4 = a3.slice(0, f3)) === (x4 = d3.slice(0, f3)))
                        return v2(b4, a3.slice(f3), d3.slice(f3), c3);
                    }
                  }
                  if (null === u3 || u3 === l3) {
                    var p3 = l3, g4 = (d3 = e4.slice(0, p3), e4.slice(p3));
                    if (d3 === a3) {
                      var m4 = Math.min(i3 - p3, o3 - p3);
                      if ((y4 = c3.slice(c3.length - m4)) === (N3 = g4.slice(g4.length - m4)))
                        return v2(a3, c3.slice(0, c3.length - m4), g4.slice(0, g4.length - m4), y4);
                    }
                  }
                }
                if (r3.length > 0 && s3 && 0 === s3.length) {
                  var b4 = t5.slice(0, r3.index), y4 = t5.slice(r3.index + r3.length);
                  if (!(o3 < (f3 = b4.length) + (m4 = y4.length))) {
                    var x4 = e4.slice(0, f3), N3 = e4.slice(o3 - m4);
                    if (b4 === x4 && y4 === N3)
                      return v2(b4, t5.slice(f3, i3 - m4), e4.slice(f3, o3 - m4), y4);
                  }
                }
                return null;
              }(t4, g3, m3);
              if (x3)
                return x3;
            }
            var N2 = o2(t4, g3), w2 = t4.substring(0, N2);
            N2 = a2(t4 = t4.substring(N2), g3 = g3.substring(N2));
            var E2 = t4.substring(t4.length - N2), A2 = function(t5, l3) {
              var c3;
              if (!t5)
                return [[n3, l3]];
              if (!l3)
                return [[e3, t5]];
              var u3 = t5.length > l3.length ? t5 : l3, h3 = t5.length > l3.length ? l3 : t5, d3 = u3.indexOf(h3);
              if (-1 !== d3)
                return c3 = [[n3, u3.substring(0, d3)], [r2, h3], [n3, u3.substring(d3 + h3.length)]], t5.length > l3.length && (c3[0][0] = c3[2][0] = e3), c3;
              if (1 === h3.length)
                return [[e3, t5], [n3, l3]];
              var f3 = function(t6, e4) {
                var n4 = t6.length > e4.length ? t6 : e4, r3 = t6.length > e4.length ? e4 : t6;
                if (n4.length < 4 || 2 * r3.length < n4.length)
                  return null;
                function s3(t7, e5, n5) {
                  for (var r4, s4, i4, l5, c5 = t7.substring(n5, n5 + Math.floor(t7.length / 4)), u5 = -1, h5 = ""; -1 !== (u5 = e5.indexOf(c5, u5 + 1)); ) {
                    var d5 = o2(t7.substring(n5), e5.substring(u5)), f5 = a2(t7.substring(0, n5), e5.substring(0, u5));
                    h5.length < f5 + d5 && (h5 = e5.substring(u5 - f5, u5) + e5.substring(u5, u5 + d5), r4 = t7.substring(0, n5 - f5), s4 = t7.substring(n5 + d5), i4 = e5.substring(0, u5 - f5), l5 = e5.substring(u5 + d5));
                  }
                  return 2 * h5.length >= t7.length ? [r4, s4, i4, l5, h5] : null;
                }
                __name(s3, "s");
                var i3, l4, c4, u4, h4, d4 = s3(n4, r3, Math.ceil(n4.length / 4)), f4 = s3(n4, r3, Math.ceil(n4.length / 2));
                if (!d4 && !f4)
                  return null;
                i3 = f4 ? d4 && d4[4].length > f4[4].length ? d4 : f4 : d4;
                t6.length > e4.length ? (l4 = i3[0], c4 = i3[1], u4 = i3[2], h4 = i3[3]) : (u4 = i3[0], h4 = i3[1], l4 = i3[2], c4 = i3[3]);
                var p4 = i3[4];
                return [l4, c4, u4, h4, p4];
              }(t5, l3);
              if (f3) {
                var p3 = f3[0], g4 = f3[1], m4 = f3[2], b4 = f3[3], y4 = f3[4], v3 = s2(p3, m4), x4 = s2(g4, b4);
                return v3.concat([[r2, y4]], x4);
              }
              return function(t6, r3) {
                for (var s3 = t6.length, o3 = r3.length, l4 = Math.ceil((s3 + o3) / 2), a3 = l4, c4 = 2 * l4, u4 = new Array(c4), h4 = new Array(c4), d4 = 0; d4 < c4; d4++)
                  u4[d4] = -1, h4[d4] = -1;
                u4[a3 + 1] = 0, h4[a3 + 1] = 0;
                for (var f4 = s3 - o3, p4 = f4 % 2 != 0, g5 = 0, m5 = 0, b5 = 0, y5 = 0, v4 = 0; v4 < l4; v4++) {
                  for (var x5 = -v4 + g5; x5 <= v4 - m5; x5 += 2) {
                    for (var N3 = a3 + x5, w3 = (_2 = x5 === -v4 || x5 !== v4 && u4[N3 - 1] < u4[N3 + 1] ? u4[N3 + 1] : u4[N3 - 1] + 1) - x5; _2 < s3 && w3 < o3 && t6.charAt(_2) === r3.charAt(w3); )
                      _2++, w3++;
                    if (u4[N3] = _2, _2 > s3)
                      m5 += 2;
                    else if (w3 > o3)
                      g5 += 2;
                    else if (p4) {
                      if ((q2 = a3 + f4 - x5) >= 0 && q2 < c4 && -1 !== h4[q2]) {
                        if (_2 >= (A3 = s3 - h4[q2]))
                          return i2(t6, r3, _2, w3);
                      }
                    }
                  }
                  for (var E3 = -v4 + b5; E3 <= v4 - y5; E3 += 2) {
                    for (var A3, q2 = a3 + E3, k2 = (A3 = E3 === -v4 || E3 !== v4 && h4[q2 - 1] < h4[q2 + 1] ? h4[q2 + 1] : h4[q2 - 1] + 1) - E3; A3 < s3 && k2 < o3 && t6.charAt(s3 - A3 - 1) === r3.charAt(o3 - k2 - 1); )
                      A3++, k2++;
                    if (h4[q2] = A3, A3 > s3)
                      y5 += 2;
                    else if (k2 > o3)
                      b5 += 2;
                    else if (!p4) {
                      if ((N3 = a3 + f4 - E3) >= 0 && N3 < c4 && -1 !== u4[N3]) {
                        var _2;
                        w3 = a3 + (_2 = u4[N3]) - N3;
                        if (_2 >= (A3 = s3 - A3))
                          return i2(t6, r3, _2, w3);
                      }
                    }
                  }
                }
                return [[e3, t6], [n3, r3]];
              }(t5, l3);
            }(t4 = t4.substring(0, t4.length - N2), g3 = g3.substring(0, g3.length - N2));
            return w2 && A2.unshift([r2, w2]), E2 && A2.push([r2, E2]), p2(A2, y3), b3 && function(t5) {
              var s3 = false, i3 = [], o3 = 0, g4 = null, m4 = 0, b4 = 0, y4 = 0, v3 = 0, x4 = 0;
              for (; m4 < t5.length; )
                t5[m4][0] == r2 ? (i3[o3++] = m4, b4 = v3, y4 = x4, v3 = 0, x4 = 0, g4 = t5[m4][1]) : (t5[m4][0] == n3 ? v3 += t5[m4][1].length : x4 += t5[m4][1].length, g4 && g4.length <= Math.max(b4, y4) && g4.length <= Math.max(v3, x4) && (t5.splice(i3[o3 - 1], 0, [e3, g4]), t5[i3[o3 - 1] + 1][0] = n3, o3--, m4 = --o3 > 0 ? i3[o3 - 1] : -1, b4 = 0, y4 = 0, v3 = 0, x4 = 0, g4 = null, s3 = true)), m4++;
              s3 && p2(t5);
              (function(t6) {
                function e4(t7, e5) {
                  if (!t7 || !e5)
                    return 6;
                  var n5 = t7.charAt(t7.length - 1), r3 = e5.charAt(0), s5 = n5.match(c2), i5 = r3.match(c2), o5 = s5 && n5.match(u2), l4 = i5 && r3.match(u2), a3 = o5 && n5.match(h2), p4 = l4 && r3.match(h2), g6 = a3 && t7.match(d2), m6 = p4 && e5.match(f2);
                  return g6 || m6 ? 5 : a3 || p4 ? 4 : s5 && !o5 && l4 ? 3 : o5 || l4 ? 2 : s5 || i5 ? 1 : 0;
                }
                __name(e4, "e");
                var n4 = 1;
                for (; n4 < t6.length - 1; ) {
                  if (t6[n4 - 1][0] == r2 && t6[n4 + 1][0] == r2) {
                    var s4 = t6[n4 - 1][1], i4 = t6[n4][1], o4 = t6[n4 + 1][1], l3 = a2(s4, i4);
                    if (l3) {
                      var p3 = i4.substring(i4.length - l3);
                      s4 = s4.substring(0, s4.length - l3), i4 = p3 + i4.substring(0, i4.length - l3), o4 = p3 + o4;
                    }
                    for (var g5 = s4, m5 = i4, b5 = o4, y5 = e4(s4, i4) + e4(i4, o4); i4.charAt(0) === o4.charAt(0); ) {
                      s4 += i4.charAt(0), i4 = i4.substring(1) + o4.charAt(0), o4 = o4.substring(1);
                      var v4 = e4(s4, i4) + e4(i4, o4);
                      v4 >= y5 && (y5 = v4, g5 = s4, m5 = i4, b5 = o4);
                    }
                    t6[n4 - 1][1] != g5 && (g5 ? t6[n4 - 1][1] = g5 : (t6.splice(n4 - 1, 1), n4--), t6[n4][1] = m5, b5 ? t6[n4 + 1][1] = b5 : (t6.splice(n4 + 1, 1), n4--));
                  }
                  n4++;
                }
              })(t5), m4 = 1;
              for (; m4 < t5.length; ) {
                if (t5[m4 - 1][0] == e3 && t5[m4][0] == n3) {
                  var N3 = t5[m4 - 1][1], w3 = t5[m4][1], E3 = l2(N3, w3), A3 = l2(w3, N3);
                  E3 >= A3 ? (E3 >= N3.length / 2 || E3 >= w3.length / 2) && (t5.splice(m4, 0, [r2, w3.substring(0, E3)]), t5[m4 - 1][1] = N3.substring(0, N3.length - E3), t5[m4 + 1][1] = w3.substring(E3), m4++) : (A3 >= N3.length / 2 || A3 >= w3.length / 2) && (t5.splice(m4, 0, [r2, N3.substring(0, A3)]), t5[m4 - 1][0] = n3, t5[m4 - 1][1] = w3.substring(0, w3.length - A3), t5[m4 + 1][0] = e3, t5[m4 + 1][1] = N3.substring(A3), m4++), m4++;
                }
                m4++;
              }
            }(A2), A2;
          }
          __name(s2, "s");
          function i2(t4, e4, n4, r3) {
            var i3 = t4.substring(0, n4), o3 = e4.substring(0, r3), l3 = t4.substring(n4), a3 = e4.substring(r3), c3 = s2(i3, o3), u3 = s2(l3, a3);
            return c3.concat(u3);
          }
          __name(i2, "i");
          function o2(t4, e4) {
            if (!t4 || !e4 || t4.charAt(0) !== e4.charAt(0))
              return 0;
            for (var n4 = 0, r3 = Math.min(t4.length, e4.length), s3 = r3, i3 = 0; n4 < s3; )
              t4.substring(i3, s3) == e4.substring(i3, s3) ? i3 = n4 = s3 : r3 = s3, s3 = Math.floor((r3 - n4) / 2 + n4);
            return g2(t4.charCodeAt(s3 - 1)) && s3--, s3;
          }
          __name(o2, "o");
          function l2(t4, e4) {
            var n4 = t4.length, r3 = e4.length;
            if (0 == n4 || 0 == r3)
              return 0;
            n4 > r3 ? t4 = t4.substring(n4 - r3) : n4 < r3 && (e4 = e4.substring(0, n4));
            var s3 = Math.min(n4, r3);
            if (t4 == e4)
              return s3;
            for (var i3 = 0, o3 = 1; ; ) {
              var l3 = t4.substring(s3 - o3), a3 = e4.indexOf(l3);
              if (-1 == a3)
                return i3;
              o3 += a3, 0 != a3 && t4.substring(s3 - o3) != e4.substring(0, o3) || (i3 = o3, o3++);
            }
          }
          __name(l2, "l");
          function a2(t4, e4) {
            if (!t4 || !e4 || t4.slice(-1) !== e4.slice(-1))
              return 0;
            for (var n4 = 0, r3 = Math.min(t4.length, e4.length), s3 = r3, i3 = 0; n4 < s3; )
              t4.substring(t4.length - s3, t4.length - i3) == e4.substring(e4.length - s3, e4.length - i3) ? i3 = n4 = s3 : r3 = s3, s3 = Math.floor((r3 - n4) / 2 + n4);
            return m2(t4.charCodeAt(t4.length - s3)) && s3--, s3;
          }
          __name(a2, "a");
          var c2 = /[^a-zA-Z0-9]/, u2 = /\s/, h2 = /[\r\n]/, d2 = /\n\r?\n$/, f2 = /^\r?\n\r?\n/;
          function p2(t4, s3) {
            t4.push([r2, ""]);
            for (var i3, l3 = 0, c3 = 0, u3 = 0, h3 = "", d3 = ""; l3 < t4.length; )
              if (l3 < t4.length - 1 && !t4[l3][1])
                t4.splice(l3, 1);
              else
                switch (t4[l3][0]) {
                  case n3:
                    u3++, d3 += t4[l3][1], l3++;
                    break;
                  case e3:
                    c3++, h3 += t4[l3][1], l3++;
                    break;
                  case r2:
                    var f3 = l3 - u3 - c3 - 1;
                    if (s3) {
                      if (f3 >= 0 && y2(t4[f3][1])) {
                        var g3 = t4[f3][1].slice(-1);
                        if (t4[f3][1] = t4[f3][1].slice(0, -1), h3 = g3 + h3, d3 = g3 + d3, !t4[f3][1]) {
                          t4.splice(f3, 1), l3--;
                          var m3 = f3 - 1;
                          t4[m3] && t4[m3][0] === n3 && (u3++, d3 = t4[m3][1] + d3, m3--), t4[m3] && t4[m3][0] === e3 && (c3++, h3 = t4[m3][1] + h3, m3--), f3 = m3;
                        }
                      }
                      if (b2(t4[l3][1])) {
                        g3 = t4[l3][1].charAt(0);
                        t4[l3][1] = t4[l3][1].slice(1), h3 += g3, d3 += g3;
                      }
                    }
                    if (l3 < t4.length - 1 && !t4[l3][1]) {
                      t4.splice(l3, 1);
                      break;
                    }
                    if (h3.length > 0 || d3.length > 0) {
                      h3.length > 0 && d3.length > 0 && (0 !== (i3 = o2(d3, h3)) && (f3 >= 0 ? t4[f3][1] += d3.substring(0, i3) : (t4.splice(0, 0, [r2, d3.substring(0, i3)]), l3++), d3 = d3.substring(i3), h3 = h3.substring(i3)), 0 !== (i3 = a2(d3, h3)) && (t4[l3][1] = d3.substring(d3.length - i3) + t4[l3][1], d3 = d3.substring(0, d3.length - i3), h3 = h3.substring(0, h3.length - i3)));
                      var v3 = u3 + c3;
                      0 === h3.length && 0 === d3.length ? (t4.splice(l3 - v3, v3), l3 -= v3) : 0 === h3.length ? (t4.splice(l3 - v3, v3, [n3, d3]), l3 = l3 - v3 + 1) : 0 === d3.length ? (t4.splice(l3 - v3, v3, [e3, h3]), l3 = l3 - v3 + 1) : (t4.splice(l3 - v3, v3, [e3, h3], [n3, d3]), l3 = l3 - v3 + 2);
                    }
                    0 !== l3 && t4[l3 - 1][0] === r2 ? (t4[l3 - 1][1] += t4[l3][1], t4.splice(l3, 1)) : l3++, u3 = 0, c3 = 0, h3 = "", d3 = "";
                }
            "" === t4[t4.length - 1][1] && t4.pop();
            var x3 = false;
            for (l3 = 1; l3 < t4.length - 1; )
              t4[l3 - 1][0] === r2 && t4[l3 + 1][0] === r2 && (t4[l3][1].substring(t4[l3][1].length - t4[l3 - 1][1].length) === t4[l3 - 1][1] ? (t4[l3][1] = t4[l3 - 1][1] + t4[l3][1].substring(0, t4[l3][1].length - t4[l3 - 1][1].length), t4[l3 + 1][1] = t4[l3 - 1][1] + t4[l3 + 1][1], t4.splice(l3 - 1, 1), x3 = true) : t4[l3][1].substring(0, t4[l3 + 1][1].length) == t4[l3 + 1][1] && (t4[l3 - 1][1] += t4[l3 + 1][1], t4[l3][1] = t4[l3][1].substring(t4[l3 + 1][1].length) + t4[l3 + 1][1], t4.splice(l3 + 1, 1), x3 = true)), l3++;
            x3 && p2(t4, s3);
          }
          __name(p2, "p");
          function g2(t4) {
            return t4 >= 55296 && t4 <= 56319;
          }
          __name(g2, "g");
          function m2(t4) {
            return t4 >= 56320 && t4 <= 57343;
          }
          __name(m2, "m");
          function b2(t4) {
            return m2(t4.charCodeAt(0));
          }
          __name(b2, "b");
          function y2(t4) {
            return g2(t4.charCodeAt(t4.length - 1));
          }
          __name(y2, "y");
          function v2(t4, s3, i3, o3) {
            return y2(t4) || b2(o3) ? null : function(t5) {
              for (var e4 = [], n4 = 0; n4 < t5.length; n4++)
                t5[n4][1].length > 0 && e4.push(t5[n4]);
              return e4;
            }([[r2, t4], [e3, s3], [n3, i3], [r2, o3]]);
          }
          __name(v2, "v");
          function x2(t4, e4, n4, r3) {
            return s2(t4, e4, n4, r3, true);
          }
          __name(x2, "x");
          x2.INSERT = n3, x2.DELETE = e3, x2.EQUAL = r2, t3.exports = x2;
        }, 193: (t3, e3, n3) => {
          t3 = n3.nmd(t3);
          var r2 = "__lodash_hash_undefined__", s2 = 9007199254740991, i2 = "[object Arguments]", o2 = "[object Boolean]", l2 = "[object Date]", a2 = "[object Function]", c2 = "[object GeneratorFunction]", u2 = "[object Map]", h2 = "[object Number]", d2 = "[object Object]", f2 = "[object Promise]", p2 = "[object RegExp]", g2 = "[object Set]", m2 = "[object String]", b2 = "[object Symbol]", y2 = "[object WeakMap]", v2 = "[object ArrayBuffer]", x2 = "[object DataView]", N2 = "[object Float32Array]", w2 = "[object Float64Array]", E2 = "[object Int8Array]", A2 = "[object Int16Array]", q2 = "[object Int32Array]", k2 = "[object Uint8Array]", _2 = "[object Uint8ClampedArray]", L2 = "[object Uint16Array]", O2 = "[object Uint32Array]", T2 = /\w*$/, S2 = /^\[object .+?Constructor\]$/, C2 = /^(?:0|[1-9]\d*)$/, j2 = {};
          j2[i2] = j2["[object Array]"] = j2[v2] = j2[x2] = j2[o2] = j2[l2] = j2[N2] = j2[w2] = j2[E2] = j2[A2] = j2[q2] = j2[u2] = j2[h2] = j2[d2] = j2[p2] = j2[g2] = j2[m2] = j2[b2] = j2[k2] = j2[_2] = j2[L2] = j2[O2] = true, j2["[object Error]"] = j2[a2] = j2[y2] = false;
          var R2 = "object" == typeof n3.g && n3.g && n3.g.Object === Object && n3.g, I2 = "object" == typeof self && self && self.Object === Object && self, M2 = R2 || I2 || Function("return this")(), B2 = e3 && !e3.nodeType && e3, U2 = B2 && t3 && !t3.nodeType && t3, D2 = U2 && U2.exports === B2;
          function P2(t4, e4) {
            return t4.set(e4[0], e4[1]), t4;
          }
          __name(P2, "P");
          function z2(t4, e4) {
            return t4.add(e4), t4;
          }
          __name(z2, "z");
          function H2(t4, e4, n4, r3) {
            var s3 = -1, i3 = t4 ? t4.length : 0;
            for (r3 && i3 && (n4 = t4[++s3]); ++s3 < i3; )
              n4 = e4(n4, t4[s3], s3, t4);
            return n4;
          }
          __name(H2, "H");
          function F2(t4) {
            var e4 = false;
            if (null != t4 && "function" != typeof t4.toString)
              try {
                e4 = !!(t4 + "");
              } catch (t5) {
              }
            return e4;
          }
          __name(F2, "F");
          function $2(t4) {
            var e4 = -1, n4 = Array(t4.size);
            return t4.forEach(function(t5, r3) {
              n4[++e4] = [r3, t5];
            }), n4;
          }
          __name($2, "$");
          function V2(t4, e4) {
            return function(n4) {
              return t4(e4(n4));
            };
          }
          __name(V2, "V");
          function K2(t4) {
            var e4 = -1, n4 = Array(t4.size);
            return t4.forEach(function(t5) {
              n4[++e4] = t5;
            }), n4;
          }
          __name(K2, "K");
          var W2, Z = Array.prototype, G2 = Function.prototype, X2 = Object.prototype, Q2 = M2["__core-js_shared__"], Y2 = (W2 = /[^.]+$/.exec(Q2 && Q2.keys && Q2.keys.IE_PROTO || "")) ? "Symbol(src)_1." + W2 : "", J2 = G2.toString, tt = X2.hasOwnProperty, et = X2.toString, nt = RegExp("^" + J2.call(tt).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"), rt = D2 ? M2.Buffer : void 0, st = M2.Symbol, it = M2.Uint8Array, ot = V2(Object.getPrototypeOf, Object), lt = Object.create, at = X2.propertyIsEnumerable, ct = Z.splice, ut = Object.getOwnPropertySymbols, ht = rt ? rt.isBuffer : void 0, dt = V2(Object.keys, Object), ft = Ut(M2, "DataView"), pt = Ut(M2, "Map"), gt = Ut(M2, "Promise"), mt = Ut(M2, "Set"), bt = Ut(M2, "WeakMap"), yt = Ut(Object, "create"), vt = Ft(ft), xt = Ft(pt), Nt = Ft(gt), wt = Ft(mt), Et = Ft(bt), At = st ? st.prototype : void 0, qt = At ? At.valueOf : void 0;
          function kt(t4) {
            var e4 = -1, n4 = t4 ? t4.length : 0;
            for (this.clear(); ++e4 < n4; ) {
              var r3 = t4[e4];
              this.set(r3[0], r3[1]);
            }
          }
          __name(kt, "kt");
          function _t(t4) {
            var e4 = -1, n4 = t4 ? t4.length : 0;
            for (this.clear(); ++e4 < n4; ) {
              var r3 = t4[e4];
              this.set(r3[0], r3[1]);
            }
          }
          __name(_t, "_t");
          function Lt(t4) {
            var e4 = -1, n4 = t4 ? t4.length : 0;
            for (this.clear(); ++e4 < n4; ) {
              var r3 = t4[e4];
              this.set(r3[0], r3[1]);
            }
          }
          __name(Lt, "Lt");
          function Ot(t4) {
            this.__data__ = new _t(t4);
          }
          __name(Ot, "Ot");
          function Tt(t4, e4) {
            var n4 = Vt(t4) || function(t5) {
              return function(t6) {
                return /* @__PURE__ */ function(t7) {
                  return !!t7 && "object" == typeof t7;
                }(t6) && Kt(t6);
              }(t5) && tt.call(t5, "callee") && (!at.call(t5, "callee") || et.call(t5) == i2);
            }(t4) ? function(t5, e5) {
              for (var n5 = -1, r4 = Array(t5); ++n5 < t5; )
                r4[n5] = e5(n5);
              return r4;
            }(t4.length, String) : [], r3 = n4.length, s3 = !!r3;
            for (var o3 in t4)
              !e4 && !tt.call(t4, o3) || s3 && ("length" == o3 || zt(o3, r3)) || n4.push(o3);
            return n4;
          }
          __name(Tt, "Tt");
          function St(t4, e4, n4) {
            var r3 = t4[e4];
            tt.call(t4, e4) && $t(r3, n4) && (void 0 !== n4 || e4 in t4) || (t4[e4] = n4);
          }
          __name(St, "St");
          function Ct(t4, e4) {
            for (var n4 = t4.length; n4--; )
              if ($t(t4[n4][0], e4))
                return n4;
            return -1;
          }
          __name(Ct, "Ct");
          function jt(t4, e4, n4, r3, s3, f3, y3) {
            var S3;
            if (r3 && (S3 = f3 ? r3(t4, s3, f3, y3) : r3(t4)), void 0 !== S3)
              return S3;
            if (!Gt(t4))
              return t4;
            var C3 = Vt(t4);
            if (C3) {
              if (S3 = function(t5) {
                var e5 = t5.length, n5 = t5.constructor(e5);
                e5 && "string" == typeof t5[0] && tt.call(t5, "index") && (n5.index = t5.index, n5.input = t5.input);
                return n5;
              }(t4), !e4)
                return function(t5, e5) {
                  var n5 = -1, r4 = t5.length;
                  e5 || (e5 = Array(r4));
                  for (; ++n5 < r4; )
                    e5[n5] = t5[n5];
                  return e5;
                }(t4, S3);
            } else {
              var R3 = Pt(t4), I3 = R3 == a2 || R3 == c2;
              if (Wt(t4))
                return function(t5, e5) {
                  if (e5)
                    return t5.slice();
                  var n5 = new t5.constructor(t5.length);
                  return t5.copy(n5), n5;
                }(t4, e4);
              if (R3 == d2 || R3 == i2 || I3 && !f3) {
                if (F2(t4))
                  return f3 ? t4 : {};
                if (S3 = function(t5) {
                  return "function" != typeof t5.constructor || Ht(t5) ? {} : (e5 = ot(t5), Gt(e5) ? lt(e5) : {});
                  var e5;
                }(I3 ? {} : t4), !e4)
                  return function(t5, e5) {
                    return Mt(t5, Dt(t5), e5);
                  }(t4, function(t5, e5) {
                    return t5 && Mt(e5, Xt(e5), t5);
                  }(S3, t4));
              } else {
                if (!j2[R3])
                  return f3 ? t4 : {};
                S3 = function(t5, e5, n5, r4) {
                  var s4 = t5.constructor;
                  switch (e5) {
                    case v2:
                      return It(t5);
                    case o2:
                    case l2:
                      return new s4(+t5);
                    case x2:
                      return function(t6, e6) {
                        var n6 = e6 ? It(t6.buffer) : t6.buffer;
                        return new t6.constructor(n6, t6.byteOffset, t6.byteLength);
                      }(t5, r4);
                    case N2:
                    case w2:
                    case E2:
                    case A2:
                    case q2:
                    case k2:
                    case _2:
                    case L2:
                    case O2:
                      return function(t6, e6) {
                        var n6 = e6 ? It(t6.buffer) : t6.buffer;
                        return new t6.constructor(n6, t6.byteOffset, t6.length);
                      }(t5, r4);
                    case u2:
                      return function(t6, e6, n6) {
                        var r5 = e6 ? n6($2(t6), true) : $2(t6);
                        return H2(r5, P2, new t6.constructor());
                      }(t5, r4, n5);
                    case h2:
                    case m2:
                      return new s4(t5);
                    case p2:
                      return function(t6) {
                        var e6 = new t6.constructor(t6.source, T2.exec(t6));
                        return e6.lastIndex = t6.lastIndex, e6;
                      }(t5);
                    case g2:
                      return function(t6, e6, n6) {
                        var r5 = e6 ? n6(K2(t6), true) : K2(t6);
                        return H2(r5, z2, new t6.constructor());
                      }(t5, r4, n5);
                    case b2:
                      return i3 = t5, qt ? Object(qt.call(i3)) : {};
                  }
                  var i3;
                }(t4, R3, jt, e4);
              }
            }
            y3 || (y3 = new Ot());
            var M3 = y3.get(t4);
            if (M3)
              return M3;
            if (y3.set(t4, S3), !C3)
              var B3 = n4 ? function(t5) {
                return function(t6, e5, n5) {
                  var r4 = e5(t6);
                  return Vt(t6) ? r4 : function(t7, e6) {
                    for (var n6 = -1, r5 = e6.length, s4 = t7.length; ++n6 < r5; )
                      t7[s4 + n6] = e6[n6];
                    return t7;
                  }(r4, n5(t6));
                }(t5, Xt, Dt);
              }(t4) : Xt(t4);
            return function(t5, e5) {
              for (var n5 = -1, r4 = t5 ? t5.length : 0; ++n5 < r4 && false !== e5(t5[n5], n5, t5); )
                ;
            }(B3 || t4, function(s4, i3) {
              B3 && (s4 = t4[i3 = s4]), St(S3, i3, jt(s4, e4, n4, r3, i3, t4, y3));
            }), S3;
          }
          __name(jt, "jt");
          function Rt(t4) {
            return !(!Gt(t4) || (e4 = t4, Y2 && Y2 in e4)) && (Zt(t4) || F2(t4) ? nt : S2).test(Ft(t4));
            var e4;
          }
          __name(Rt, "Rt");
          function It(t4) {
            var e4 = new t4.constructor(t4.byteLength);
            return new it(e4).set(new it(t4)), e4;
          }
          __name(It, "It");
          function Mt(t4, e4, n4, r3) {
            n4 || (n4 = {});
            for (var s3 = -1, i3 = e4.length; ++s3 < i3; ) {
              var o3 = e4[s3], l3 = r3 ? r3(n4[o3], t4[o3], o3, n4, t4) : void 0;
              St(n4, o3, void 0 === l3 ? t4[o3] : l3);
            }
            return n4;
          }
          __name(Mt, "Mt");
          function Bt(t4, e4) {
            var n4, r3, s3 = t4.__data__;
            return ("string" == (r3 = typeof (n4 = e4)) || "number" == r3 || "symbol" == r3 || "boolean" == r3 ? "__proto__" !== n4 : null === n4) ? s3["string" == typeof e4 ? "string" : "hash"] : s3.map;
          }
          __name(Bt, "Bt");
          function Ut(t4, e4) {
            var n4 = function(t5, e5) {
              return null == t5 ? void 0 : t5[e5];
            }(t4, e4);
            return Rt(n4) ? n4 : void 0;
          }
          __name(Ut, "Ut");
          kt.prototype.clear = function() {
            this.__data__ = yt ? yt(null) : {};
          }, kt.prototype.delete = function(t4) {
            return this.has(t4) && delete this.__data__[t4];
          }, kt.prototype.get = function(t4) {
            var e4 = this.__data__;
            if (yt) {
              var n4 = e4[t4];
              return n4 === r2 ? void 0 : n4;
            }
            return tt.call(e4, t4) ? e4[t4] : void 0;
          }, kt.prototype.has = function(t4) {
            var e4 = this.__data__;
            return yt ? void 0 !== e4[t4] : tt.call(e4, t4);
          }, kt.prototype.set = function(t4, e4) {
            return this.__data__[t4] = yt && void 0 === e4 ? r2 : e4, this;
          }, _t.prototype.clear = function() {
            this.__data__ = [];
          }, _t.prototype.delete = function(t4) {
            var e4 = this.__data__, n4 = Ct(e4, t4);
            return !(n4 < 0) && (n4 == e4.length - 1 ? e4.pop() : ct.call(e4, n4, 1), true);
          }, _t.prototype.get = function(t4) {
            var e4 = this.__data__, n4 = Ct(e4, t4);
            return n4 < 0 ? void 0 : e4[n4][1];
          }, _t.prototype.has = function(t4) {
            return Ct(this.__data__, t4) > -1;
          }, _t.prototype.set = function(t4, e4) {
            var n4 = this.__data__, r3 = Ct(n4, t4);
            return r3 < 0 ? n4.push([t4, e4]) : n4[r3][1] = e4, this;
          }, Lt.prototype.clear = function() {
            this.__data__ = { hash: new kt(), map: new (pt || _t)(), string: new kt() };
          }, Lt.prototype.delete = function(t4) {
            return Bt(this, t4).delete(t4);
          }, Lt.prototype.get = function(t4) {
            return Bt(this, t4).get(t4);
          }, Lt.prototype.has = function(t4) {
            return Bt(this, t4).has(t4);
          }, Lt.prototype.set = function(t4, e4) {
            return Bt(this, t4).set(t4, e4), this;
          }, Ot.prototype.clear = function() {
            this.__data__ = new _t();
          }, Ot.prototype.delete = function(t4) {
            return this.__data__.delete(t4);
          }, Ot.prototype.get = function(t4) {
            return this.__data__.get(t4);
          }, Ot.prototype.has = function(t4) {
            return this.__data__.has(t4);
          }, Ot.prototype.set = function(t4, e4) {
            var n4 = this.__data__;
            if (n4 instanceof _t) {
              var r3 = n4.__data__;
              if (!pt || r3.length < 199)
                return r3.push([t4, e4]), this;
              n4 = this.__data__ = new Lt(r3);
            }
            return n4.set(t4, e4), this;
          };
          var Dt = ut ? V2(ut, Object) : function() {
            return [];
          }, Pt = /* @__PURE__ */ __name(function(t4) {
            return et.call(t4);
          }, "Pt");
          function zt(t4, e4) {
            return !!(e4 = null == e4 ? s2 : e4) && ("number" == typeof t4 || C2.test(t4)) && t4 > -1 && t4 % 1 == 0 && t4 < e4;
          }
          __name(zt, "zt");
          function Ht(t4) {
            var e4 = t4 && t4.constructor;
            return t4 === ("function" == typeof e4 && e4.prototype || X2);
          }
          __name(Ht, "Ht");
          function Ft(t4) {
            if (null != t4) {
              try {
                return J2.call(t4);
              } catch (t5) {
              }
              try {
                return t4 + "";
              } catch (t5) {
              }
            }
            return "";
          }
          __name(Ft, "Ft");
          function $t(t4, e4) {
            return t4 === e4 || t4 != t4 && e4 != e4;
          }
          __name($t, "$t");
          (ft && Pt(new ft(new ArrayBuffer(1))) != x2 || pt && Pt(new pt()) != u2 || gt && Pt(gt.resolve()) != f2 || mt && Pt(new mt()) != g2 || bt && Pt(new bt()) != y2) && (Pt = /* @__PURE__ */ __name(function(t4) {
            var e4 = et.call(t4), n4 = e4 == d2 ? t4.constructor : void 0, r3 = n4 ? Ft(n4) : void 0;
            if (r3)
              switch (r3) {
                case vt:
                  return x2;
                case xt:
                  return u2;
                case Nt:
                  return f2;
                case wt:
                  return g2;
                case Et:
                  return y2;
              }
            return e4;
          }, "Pt"));
          var Vt = Array.isArray;
          function Kt(t4) {
            return null != t4 && function(t5) {
              return "number" == typeof t5 && t5 > -1 && t5 % 1 == 0 && t5 <= s2;
            }(t4.length) && !Zt(t4);
          }
          __name(Kt, "Kt");
          var Wt = ht || function() {
            return false;
          };
          function Zt(t4) {
            var e4 = Gt(t4) ? et.call(t4) : "";
            return e4 == a2 || e4 == c2;
          }
          __name(Zt, "Zt");
          function Gt(t4) {
            var e4 = typeof t4;
            return !!t4 && ("object" == e4 || "function" == e4);
          }
          __name(Gt, "Gt");
          function Xt(t4) {
            return Kt(t4) ? Tt(t4) : function(t5) {
              if (!Ht(t5))
                return dt(t5);
              var e4 = [];
              for (var n4 in Object(t5))
                tt.call(t5, n4) && "constructor" != n4 && e4.push(n4);
              return e4;
            }(t4);
          }
          __name(Xt, "Xt");
          t3.exports = function(t4) {
            return jt(t4, true, true);
          };
        }, 142: (t3, e3, n3) => {
          t3 = n3.nmd(t3);
          var r2 = "__lodash_hash_undefined__", s2 = 1, i2 = 2, o2 = 9007199254740991, l2 = "[object Arguments]", a2 = "[object Array]", c2 = "[object AsyncFunction]", u2 = "[object Boolean]", h2 = "[object Date]", d2 = "[object Error]", f2 = "[object Function]", p2 = "[object GeneratorFunction]", g2 = "[object Map]", m2 = "[object Number]", b2 = "[object Null]", y2 = "[object Object]", v2 = "[object Promise]", x2 = "[object Proxy]", N2 = "[object RegExp]", w2 = "[object Set]", E2 = "[object String]", A2 = "[object Symbol]", q2 = "[object Undefined]", k2 = "[object WeakMap]", _2 = "[object ArrayBuffer]", L2 = "[object DataView]", O2 = /^\[object .+?Constructor\]$/, T2 = /^(?:0|[1-9]\d*)$/, S2 = {};
          S2["[object Float32Array]"] = S2["[object Float64Array]"] = S2["[object Int8Array]"] = S2["[object Int16Array]"] = S2["[object Int32Array]"] = S2["[object Uint8Array]"] = S2["[object Uint8ClampedArray]"] = S2["[object Uint16Array]"] = S2["[object Uint32Array]"] = true, S2[l2] = S2[a2] = S2[_2] = S2[u2] = S2[L2] = S2[h2] = S2[d2] = S2[f2] = S2[g2] = S2[m2] = S2[y2] = S2[N2] = S2[w2] = S2[E2] = S2[k2] = false;
          var C2 = "object" == typeof n3.g && n3.g && n3.g.Object === Object && n3.g, j2 = "object" == typeof self && self && self.Object === Object && self, R2 = C2 || j2 || Function("return this")(), I2 = e3 && !e3.nodeType && e3, M2 = I2 && t3 && !t3.nodeType && t3, B2 = M2 && M2.exports === I2, U2 = B2 && C2.process, D2 = function() {
            try {
              return U2 && U2.binding && U2.binding("util");
            } catch (t4) {
            }
          }(), P2 = D2 && D2.isTypedArray;
          function z2(t4, e4) {
            for (var n4 = -1, r3 = null == t4 ? 0 : t4.length; ++n4 < r3; )
              if (e4(t4[n4], n4, t4))
                return true;
            return false;
          }
          __name(z2, "z");
          function H2(t4) {
            var e4 = -1, n4 = Array(t4.size);
            return t4.forEach(function(t5, r3) {
              n4[++e4] = [r3, t5];
            }), n4;
          }
          __name(H2, "H");
          function F2(t4) {
            var e4 = -1, n4 = Array(t4.size);
            return t4.forEach(function(t5) {
              n4[++e4] = t5;
            }), n4;
          }
          __name(F2, "F");
          var $2, V2, K2, W2 = Array.prototype, Z = Function.prototype, G2 = Object.prototype, X2 = R2["__core-js_shared__"], Q2 = Z.toString, Y2 = G2.hasOwnProperty, J2 = ($2 = /[^.]+$/.exec(X2 && X2.keys && X2.keys.IE_PROTO || "")) ? "Symbol(src)_1." + $2 : "", tt = G2.toString, et = RegExp("^" + Q2.call(Y2).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"), nt = B2 ? R2.Buffer : void 0, rt = R2.Symbol, st = R2.Uint8Array, it = G2.propertyIsEnumerable, ot = W2.splice, lt = rt ? rt.toStringTag : void 0, at = Object.getOwnPropertySymbols, ct = nt ? nt.isBuffer : void 0, ut = (V2 = Object.keys, K2 = Object, function(t4) {
            return V2(K2(t4));
          }), ht = Dt(R2, "DataView"), dt = Dt(R2, "Map"), ft = Dt(R2, "Promise"), pt = Dt(R2, "Set"), gt = Dt(R2, "WeakMap"), mt = Dt(Object, "create"), bt = Ft(ht), yt = Ft(dt), vt = Ft(ft), xt = Ft(pt), Nt = Ft(gt), wt = rt ? rt.prototype : void 0, Et = wt ? wt.valueOf : void 0;
          function At(t4) {
            var e4 = -1, n4 = null == t4 ? 0 : t4.length;
            for (this.clear(); ++e4 < n4; ) {
              var r3 = t4[e4];
              this.set(r3[0], r3[1]);
            }
          }
          __name(At, "At");
          function qt(t4) {
            var e4 = -1, n4 = null == t4 ? 0 : t4.length;
            for (this.clear(); ++e4 < n4; ) {
              var r3 = t4[e4];
              this.set(r3[0], r3[1]);
            }
          }
          __name(qt, "qt");
          function kt(t4) {
            var e4 = -1, n4 = null == t4 ? 0 : t4.length;
            for (this.clear(); ++e4 < n4; ) {
              var r3 = t4[e4];
              this.set(r3[0], r3[1]);
            }
          }
          __name(kt, "kt");
          function _t(t4) {
            var e4 = -1, n4 = null == t4 ? 0 : t4.length;
            for (this.__data__ = new kt(); ++e4 < n4; )
              this.add(t4[e4]);
          }
          __name(_t, "_t");
          function Lt(t4) {
            var e4 = this.__data__ = new qt(t4);
            this.size = e4.size;
          }
          __name(Lt, "Lt");
          function Ot(t4, e4) {
            var n4 = Kt(t4), r3 = !n4 && Vt(t4), s3 = !n4 && !r3 && Wt(t4), i3 = !n4 && !r3 && !s3 && Yt(t4), o3 = n4 || r3 || s3 || i3, l3 = o3 ? function(t5, e5) {
              for (var n5 = -1, r4 = Array(t5); ++n5 < t5; )
                r4[n5] = e5(n5);
              return r4;
            }(t4.length, String) : [], a3 = l3.length;
            for (var c3 in t4)
              !e4 && !Y2.call(t4, c3) || o3 && ("length" == c3 || s3 && ("offset" == c3 || "parent" == c3) || i3 && ("buffer" == c3 || "byteLength" == c3 || "byteOffset" == c3) || Ht(c3, a3)) || l3.push(c3);
            return l3;
          }
          __name(Ot, "Ot");
          function Tt(t4, e4) {
            for (var n4 = t4.length; n4--; )
              if ($t(t4[n4][0], e4))
                return n4;
            return -1;
          }
          __name(Tt, "Tt");
          function St(t4) {
            return null == t4 ? void 0 === t4 ? q2 : b2 : lt && lt in Object(t4) ? function(t5) {
              var e4 = Y2.call(t5, lt), n4 = t5[lt];
              try {
                t5[lt] = void 0;
                var r3 = true;
              } catch (t6) {
              }
              var s3 = tt.call(t5);
              r3 && (e4 ? t5[lt] = n4 : delete t5[lt]);
              return s3;
            }(t4) : function(t5) {
              return tt.call(t5);
            }(t4);
          }
          __name(St, "St");
          function Ct(t4) {
            return Qt(t4) && St(t4) == l2;
          }
          __name(Ct, "Ct");
          function jt(t4, e4, n4, r3, o3) {
            return t4 === e4 || (null == t4 || null == e4 || !Qt(t4) && !Qt(e4) ? t4 != t4 && e4 != e4 : function(t5, e5, n5, r4, o4, c3) {
              var f3 = Kt(t5), p3 = Kt(e5), b3 = f3 ? a2 : zt(t5), v3 = p3 ? a2 : zt(e5), x3 = (b3 = b3 == l2 ? y2 : b3) == y2, q3 = (v3 = v3 == l2 ? y2 : v3) == y2, k3 = b3 == v3;
              if (k3 && Wt(t5)) {
                if (!Wt(e5))
                  return false;
                f3 = true, x3 = false;
              }
              if (k3 && !x3)
                return c3 || (c3 = new Lt()), f3 || Yt(t5) ? Mt(t5, e5, n5, r4, o4, c3) : function(t6, e6, n6, r5, o5, l3, a3) {
                  switch (n6) {
                    case L2:
                      if (t6.byteLength != e6.byteLength || t6.byteOffset != e6.byteOffset)
                        return false;
                      t6 = t6.buffer, e6 = e6.buffer;
                    case _2:
                      return !(t6.byteLength != e6.byteLength || !l3(new st(t6), new st(e6)));
                    case u2:
                    case h2:
                    case m2:
                      return $t(+t6, +e6);
                    case d2:
                      return t6.name == e6.name && t6.message == e6.message;
                    case N2:
                    case E2:
                      return t6 == e6 + "";
                    case g2:
                      var c4 = H2;
                    case w2:
                      var f4 = r5 & s2;
                      if (c4 || (c4 = F2), t6.size != e6.size && !f4)
                        return false;
                      var p4 = a3.get(t6);
                      if (p4)
                        return p4 == e6;
                      r5 |= i2, a3.set(t6, e6);
                      var b4 = Mt(c4(t6), c4(e6), r5, o5, l3, a3);
                      return a3.delete(t6), b4;
                    case A2:
                      if (Et)
                        return Et.call(t6) == Et.call(e6);
                  }
                  return false;
                }(t5, e5, b3, n5, r4, o4, c3);
              if (!(n5 & s2)) {
                var O3 = x3 && Y2.call(t5, "__wrapped__"), T3 = q3 && Y2.call(e5, "__wrapped__");
                if (O3 || T3) {
                  var S3 = O3 ? t5.value() : t5, C3 = T3 ? e5.value() : e5;
                  return c3 || (c3 = new Lt()), o4(S3, C3, n5, r4, c3);
                }
              }
              if (!k3)
                return false;
              return c3 || (c3 = new Lt()), function(t6, e6, n6, r5, i3, o5) {
                var l3 = n6 & s2, a3 = Bt(t6), c4 = a3.length, u3 = Bt(e6), h3 = u3.length;
                if (c4 != h3 && !l3)
                  return false;
                var d3 = c4;
                for (; d3--; ) {
                  var f4 = a3[d3];
                  if (!(l3 ? f4 in e6 : Y2.call(e6, f4)))
                    return false;
                }
                var p4 = o5.get(t6);
                if (p4 && o5.get(e6))
                  return p4 == e6;
                var g3 = true;
                o5.set(t6, e6), o5.set(e6, t6);
                var m3 = l3;
                for (; ++d3 < c4; ) {
                  var b4 = t6[f4 = a3[d3]], y3 = e6[f4];
                  if (r5)
                    var v4 = l3 ? r5(y3, b4, f4, e6, t6, o5) : r5(b4, y3, f4, t6, e6, o5);
                  if (!(void 0 === v4 ? b4 === y3 || i3(b4, y3, n6, r5, o5) : v4)) {
                    g3 = false;
                    break;
                  }
                  m3 || (m3 = "constructor" == f4);
                }
                if (g3 && !m3) {
                  var x4 = t6.constructor, N3 = e6.constructor;
                  x4 == N3 || !("constructor" in t6) || !("constructor" in e6) || "function" == typeof x4 && x4 instanceof x4 && "function" == typeof N3 && N3 instanceof N3 || (g3 = false);
                }
                return o5.delete(t6), o5.delete(e6), g3;
              }(t5, e5, n5, r4, o4, c3);
            }(t4, e4, n4, r3, jt, o3));
          }
          __name(jt, "jt");
          function Rt(t4) {
            return !(!Xt(t4) || function(t5) {
              return !!J2 && J2 in t5;
            }(t4)) && (Zt(t4) ? et : O2).test(Ft(t4));
          }
          __name(Rt, "Rt");
          function It(t4) {
            if (n4 = (e4 = t4) && e4.constructor, r3 = "function" == typeof n4 && n4.prototype || G2, e4 !== r3)
              return ut(t4);
            var e4, n4, r3, s3 = [];
            for (var i3 in Object(t4))
              Y2.call(t4, i3) && "constructor" != i3 && s3.push(i3);
            return s3;
          }
          __name(It, "It");
          function Mt(t4, e4, n4, r3, o3, l3) {
            var a3 = n4 & s2, c3 = t4.length, u3 = e4.length;
            if (c3 != u3 && !(a3 && u3 > c3))
              return false;
            var h3 = l3.get(t4);
            if (h3 && l3.get(e4))
              return h3 == e4;
            var d3 = -1, f3 = true, p3 = n4 & i2 ? new _t() : void 0;
            for (l3.set(t4, e4), l3.set(e4, t4); ++d3 < c3; ) {
              var g3 = t4[d3], m3 = e4[d3];
              if (r3)
                var b3 = a3 ? r3(m3, g3, d3, e4, t4, l3) : r3(g3, m3, d3, t4, e4, l3);
              if (void 0 !== b3) {
                if (b3)
                  continue;
                f3 = false;
                break;
              }
              if (p3) {
                if (!z2(e4, function(t5, e5) {
                  if (s3 = e5, !p3.has(s3) && (g3 === t5 || o3(g3, t5, n4, r3, l3)))
                    return p3.push(e5);
                  var s3;
                })) {
                  f3 = false;
                  break;
                }
              } else if (g3 !== m3 && !o3(g3, m3, n4, r3, l3)) {
                f3 = false;
                break;
              }
            }
            return l3.delete(t4), l3.delete(e4), f3;
          }
          __name(Mt, "Mt");
          function Bt(t4) {
            return function(t5, e4, n4) {
              var r3 = e4(t5);
              return Kt(t5) ? r3 : function(t6, e5) {
                for (var n5 = -1, r4 = e5.length, s3 = t6.length; ++n5 < r4; )
                  t6[s3 + n5] = e5[n5];
                return t6;
              }(r3, n4(t5));
            }(t4, Jt, Pt);
          }
          __name(Bt, "Bt");
          function Ut(t4, e4) {
            var n4, r3, s3 = t4.__data__;
            return ("string" == (r3 = typeof (n4 = e4)) || "number" == r3 || "symbol" == r3 || "boolean" == r3 ? "__proto__" !== n4 : null === n4) ? s3["string" == typeof e4 ? "string" : "hash"] : s3.map;
          }
          __name(Ut, "Ut");
          function Dt(t4, e4) {
            var n4 = function(t5, e5) {
              return null == t5 ? void 0 : t5[e5];
            }(t4, e4);
            return Rt(n4) ? n4 : void 0;
          }
          __name(Dt, "Dt");
          At.prototype.clear = function() {
            this.__data__ = mt ? mt(null) : {}, this.size = 0;
          }, At.prototype.delete = function(t4) {
            var e4 = this.has(t4) && delete this.__data__[t4];
            return this.size -= e4 ? 1 : 0, e4;
          }, At.prototype.get = function(t4) {
            var e4 = this.__data__;
            if (mt) {
              var n4 = e4[t4];
              return n4 === r2 ? void 0 : n4;
            }
            return Y2.call(e4, t4) ? e4[t4] : void 0;
          }, At.prototype.has = function(t4) {
            var e4 = this.__data__;
            return mt ? void 0 !== e4[t4] : Y2.call(e4, t4);
          }, At.prototype.set = function(t4, e4) {
            var n4 = this.__data__;
            return this.size += this.has(t4) ? 0 : 1, n4[t4] = mt && void 0 === e4 ? r2 : e4, this;
          }, qt.prototype.clear = function() {
            this.__data__ = [], this.size = 0;
          }, qt.prototype.delete = function(t4) {
            var e4 = this.__data__, n4 = Tt(e4, t4);
            return !(n4 < 0) && (n4 == e4.length - 1 ? e4.pop() : ot.call(e4, n4, 1), --this.size, true);
          }, qt.prototype.get = function(t4) {
            var e4 = this.__data__, n4 = Tt(e4, t4);
            return n4 < 0 ? void 0 : e4[n4][1];
          }, qt.prototype.has = function(t4) {
            return Tt(this.__data__, t4) > -1;
          }, qt.prototype.set = function(t4, e4) {
            var n4 = this.__data__, r3 = Tt(n4, t4);
            return r3 < 0 ? (++this.size, n4.push([t4, e4])) : n4[r3][1] = e4, this;
          }, kt.prototype.clear = function() {
            this.size = 0, this.__data__ = { hash: new At(), map: new (dt || qt)(), string: new At() };
          }, kt.prototype.delete = function(t4) {
            var e4 = Ut(this, t4).delete(t4);
            return this.size -= e4 ? 1 : 0, e4;
          }, kt.prototype.get = function(t4) {
            return Ut(this, t4).get(t4);
          }, kt.prototype.has = function(t4) {
            return Ut(this, t4).has(t4);
          }, kt.prototype.set = function(t4, e4) {
            var n4 = Ut(this, t4), r3 = n4.size;
            return n4.set(t4, e4), this.size += n4.size == r3 ? 0 : 1, this;
          }, _t.prototype.add = _t.prototype.push = function(t4) {
            return this.__data__.set(t4, r2), this;
          }, _t.prototype.has = function(t4) {
            return this.__data__.has(t4);
          }, Lt.prototype.clear = function() {
            this.__data__ = new qt(), this.size = 0;
          }, Lt.prototype.delete = function(t4) {
            var e4 = this.__data__, n4 = e4.delete(t4);
            return this.size = e4.size, n4;
          }, Lt.prototype.get = function(t4) {
            return this.__data__.get(t4);
          }, Lt.prototype.has = function(t4) {
            return this.__data__.has(t4);
          }, Lt.prototype.set = function(t4, e4) {
            var n4 = this.__data__;
            if (n4 instanceof qt) {
              var r3 = n4.__data__;
              if (!dt || r3.length < 199)
                return r3.push([t4, e4]), this.size = ++n4.size, this;
              n4 = this.__data__ = new kt(r3);
            }
            return n4.set(t4, e4), this.size = n4.size, this;
          };
          var Pt = at ? function(t4) {
            return null == t4 ? [] : (t4 = Object(t4), function(t5, e4) {
              for (var n4 = -1, r3 = null == t5 ? 0 : t5.length, s3 = 0, i3 = []; ++n4 < r3; ) {
                var o3 = t5[n4];
                e4(o3, n4, t5) && (i3[s3++] = o3);
              }
              return i3;
            }(at(t4), function(e4) {
              return it.call(t4, e4);
            }));
          } : function() {
            return [];
          }, zt = St;
          function Ht(t4, e4) {
            return !!(e4 = null == e4 ? o2 : e4) && ("number" == typeof t4 || T2.test(t4)) && t4 > -1 && t4 % 1 == 0 && t4 < e4;
          }
          __name(Ht, "Ht");
          function Ft(t4) {
            if (null != t4) {
              try {
                return Q2.call(t4);
              } catch (t5) {
              }
              try {
                return t4 + "";
              } catch (t5) {
              }
            }
            return "";
          }
          __name(Ft, "Ft");
          function $t(t4, e4) {
            return t4 === e4 || t4 != t4 && e4 != e4;
          }
          __name($t, "$t");
          (ht && zt(new ht(new ArrayBuffer(1))) != L2 || dt && zt(new dt()) != g2 || ft && zt(ft.resolve()) != v2 || pt && zt(new pt()) != w2 || gt && zt(new gt()) != k2) && (zt = /* @__PURE__ */ __name(function(t4) {
            var e4 = St(t4), n4 = e4 == y2 ? t4.constructor : void 0, r3 = n4 ? Ft(n4) : "";
            if (r3)
              switch (r3) {
                case bt:
                  return L2;
                case yt:
                  return g2;
                case vt:
                  return v2;
                case xt:
                  return w2;
                case Nt:
                  return k2;
              }
            return e4;
          }, "zt"));
          var Vt = Ct(/* @__PURE__ */ function() {
            return arguments;
          }()) ? Ct : function(t4) {
            return Qt(t4) && Y2.call(t4, "callee") && !it.call(t4, "callee");
          }, Kt = Array.isArray;
          var Wt = ct || function() {
            return false;
          };
          function Zt(t4) {
            if (!Xt(t4))
              return false;
            var e4 = St(t4);
            return e4 == f2 || e4 == p2 || e4 == c2 || e4 == x2;
          }
          __name(Zt, "Zt");
          function Gt(t4) {
            return "number" == typeof t4 && t4 > -1 && t4 % 1 == 0 && t4 <= o2;
          }
          __name(Gt, "Gt");
          function Xt(t4) {
            var e4 = typeof t4;
            return null != t4 && ("object" == e4 || "function" == e4);
          }
          __name(Xt, "Xt");
          function Qt(t4) {
            return null != t4 && "object" == typeof t4;
          }
          __name(Qt, "Qt");
          var Yt = P2 ? /* @__PURE__ */ function(t4) {
            return function(e4) {
              return t4(e4);
            };
          }(P2) : function(t4) {
            return Qt(t4) && Gt(t4.length) && !!S2[St(t4)];
          };
          function Jt(t4) {
            return null != (e4 = t4) && Gt(e4.length) && !Zt(e4) ? Ot(t4) : It(t4);
            var e4;
          }
          __name(Jt, "Jt");
          t3.exports = function(t4, e4) {
            return jt(t4, e4);
          };
        }, 106: (t3, e3, n3) => {
          "use strict";
          Object.defineProperty(e3, "__esModule", { value: true });
          const r2 = n3(193), s2 = n3(142);
          var i2;
          !function(t4) {
            t4.compose = function(t5 = {}, e4 = {}, n4 = false) {
              "object" != typeof t5 && (t5 = {}), "object" != typeof e4 && (e4 = {});
              let s3 = r2(e4);
              n4 || (s3 = Object.keys(s3).reduce((t6, e5) => (null != s3[e5] && (t6[e5] = s3[e5]), t6), {}));
              for (const n5 in t5)
                void 0 !== t5[n5] && void 0 === e4[n5] && (s3[n5] = t5[n5]);
              return Object.keys(s3).length > 0 ? s3 : void 0;
            }, t4.diff = function(t5 = {}, e4 = {}) {
              "object" != typeof t5 && (t5 = {}), "object" != typeof e4 && (e4 = {});
              const n4 = Object.keys(t5).concat(Object.keys(e4)).reduce((n5, r3) => (s2(t5[r3], e4[r3]) || (n5[r3] = void 0 === e4[r3] ? null : e4[r3]), n5), {});
              return Object.keys(n4).length > 0 ? n4 : void 0;
            }, t4.invert = function(t5 = {}, e4 = {}) {
              t5 = t5 || {};
              const n4 = Object.keys(e4).reduce((n5, r3) => (e4[r3] !== t5[r3] && void 0 !== t5[r3] && (n5[r3] = e4[r3]), n5), {});
              return Object.keys(t5).reduce((n5, r3) => (t5[r3] !== e4[r3] && void 0 === e4[r3] && (n5[r3] = null), n5), n4);
            }, t4.transform = function(t5, e4, n4 = false) {
              if ("object" != typeof t5)
                return e4;
              if ("object" != typeof e4)
                return;
              if (!n4)
                return e4;
              const r3 = Object.keys(e4).reduce((n5, r4) => (void 0 === t5[r4] && (n5[r4] = e4[r4]), n5), {});
              return Object.keys(r3).length > 0 ? r3 : void 0;
            };
          }(i2 || (i2 = {})), e3.default = i2;
        }, 660: (t3, e3, n3) => {
          "use strict";
          Object.defineProperty(e3, "__esModule", { value: true }), e3.AttributeMap = e3.OpIterator = e3.Op = void 0;
          const r2 = n3(606), s2 = n3(193), i2 = n3(142), o2 = n3(106);
          e3.AttributeMap = o2.default;
          const l2 = n3(759);
          e3.Op = l2.default;
          const a2 = n3(317);
          e3.OpIterator = a2.default;
          const c2 = String.fromCharCode(0), u2 = /* @__PURE__ */ __name((t4, e4) => {
            if ("object" != typeof t4 || null === t4)
              throw new Error("cannot retain a " + typeof t4);
            if ("object" != typeof e4 || null === e4)
              throw new Error("cannot retain a " + typeof e4);
            const n4 = Object.keys(t4)[0];
            if (!n4 || n4 !== Object.keys(e4)[0])
              throw new Error(`embed types not matched: ${n4} != ${Object.keys(e4)[0]}`);
            return [n4, t4[n4], e4[n4]];
          }, "u");
          class h2 {
            static {
              __name(this, "h");
            }
            constructor(t4) {
              Array.isArray(t4) ? this.ops = t4 : null != t4 && Array.isArray(t4.ops) ? this.ops = t4.ops : this.ops = [];
            }
            static registerEmbed(t4, e4) {
              this.handlers[t4] = e4;
            }
            static unregisterEmbed(t4) {
              delete this.handlers[t4];
            }
            static getHandler(t4) {
              const e4 = this.handlers[t4];
              if (!e4)
                throw new Error(`no handlers for embed type "${t4}"`);
              return e4;
            }
            insert(t4, e4) {
              const n4 = {};
              return "string" == typeof t4 && 0 === t4.length ? this : (n4.insert = t4, null != e4 && "object" == typeof e4 && Object.keys(e4).length > 0 && (n4.attributes = e4), this.push(n4));
            }
            delete(t4) {
              return t4 <= 0 ? this : this.push({ delete: t4 });
            }
            retain(t4, e4) {
              if ("number" == typeof t4 && t4 <= 0)
                return this;
              const n4 = { retain: t4 };
              return null != e4 && "object" == typeof e4 && Object.keys(e4).length > 0 && (n4.attributes = e4), this.push(n4);
            }
            push(t4) {
              let e4 = this.ops.length, n4 = this.ops[e4 - 1];
              if (t4 = s2(t4), "object" == typeof n4) {
                if ("number" == typeof t4.delete && "number" == typeof n4.delete)
                  return this.ops[e4 - 1] = { delete: n4.delete + t4.delete }, this;
                if ("number" == typeof n4.delete && null != t4.insert && (e4 -= 1, n4 = this.ops[e4 - 1], "object" != typeof n4))
                  return this.ops.unshift(t4), this;
                if (i2(t4.attributes, n4.attributes)) {
                  if ("string" == typeof t4.insert && "string" == typeof n4.insert)
                    return this.ops[e4 - 1] = { insert: n4.insert + t4.insert }, "object" == typeof t4.attributes && (this.ops[e4 - 1].attributes = t4.attributes), this;
                  if ("number" == typeof t4.retain && "number" == typeof n4.retain)
                    return this.ops[e4 - 1] = { retain: n4.retain + t4.retain }, "object" == typeof t4.attributes && (this.ops[e4 - 1].attributes = t4.attributes), this;
                }
              }
              return e4 === this.ops.length ? this.ops.push(t4) : this.ops.splice(e4, 0, t4), this;
            }
            chop() {
              const t4 = this.ops[this.ops.length - 1];
              return t4 && "number" == typeof t4.retain && !t4.attributes && this.ops.pop(), this;
            }
            filter(t4) {
              return this.ops.filter(t4);
            }
            forEach(t4) {
              this.ops.forEach(t4);
            }
            map(t4) {
              return this.ops.map(t4);
            }
            partition(t4) {
              const e4 = [], n4 = [];
              return this.forEach((r3) => {
                (t4(r3) ? e4 : n4).push(r3);
              }), [e4, n4];
            }
            reduce(t4, e4) {
              return this.ops.reduce(t4, e4);
            }
            changeLength() {
              return this.reduce((t4, e4) => e4.insert ? t4 + l2.default.length(e4) : e4.delete ? t4 - e4.delete : t4, 0);
            }
            length() {
              return this.reduce((t4, e4) => t4 + l2.default.length(e4), 0);
            }
            slice(t4 = 0, e4 = 1 / 0) {
              const n4 = [], r3 = new a2.default(this.ops);
              let s3 = 0;
              for (; s3 < e4 && r3.hasNext(); ) {
                let i3;
                s3 < t4 ? i3 = r3.next(t4 - s3) : (i3 = r3.next(e4 - s3), n4.push(i3)), s3 += l2.default.length(i3);
              }
              return new h2(n4);
            }
            compose(t4) {
              const e4 = new a2.default(this.ops), n4 = new a2.default(t4.ops), r3 = [], s3 = n4.peek();
              if (null != s3 && "number" == typeof s3.retain && null == s3.attributes) {
                let t5 = s3.retain;
                for (; "insert" === e4.peekType() && e4.peekLength() <= t5; )
                  t5 -= e4.peekLength(), r3.push(e4.next());
                s3.retain - t5 > 0 && n4.next(s3.retain - t5);
              }
              const l3 = new h2(r3);
              for (; e4.hasNext() || n4.hasNext(); )
                if ("insert" === n4.peekType())
                  l3.push(n4.next());
                else if ("delete" === e4.peekType())
                  l3.push(e4.next());
                else {
                  const t5 = Math.min(e4.peekLength(), n4.peekLength()), r4 = e4.next(t5), s4 = n4.next(t5);
                  if (s4.retain) {
                    const a3 = {};
                    if ("number" == typeof r4.retain)
                      a3.retain = "number" == typeof s4.retain ? t5 : s4.retain;
                    else if ("number" == typeof s4.retain)
                      null == r4.retain ? a3.insert = r4.insert : a3.retain = r4.retain;
                    else {
                      const t6 = null == r4.retain ? "insert" : "retain", [e5, n5, i3] = u2(r4[t6], s4.retain), o3 = h2.getHandler(e5);
                      a3[t6] = { [e5]: o3.compose(n5, i3, "retain" === t6) };
                    }
                    const c3 = o2.default.compose(r4.attributes, s4.attributes, "number" == typeof r4.retain);
                    if (c3 && (a3.attributes = c3), l3.push(a3), !n4.hasNext() && i2(l3.ops[l3.ops.length - 1], a3)) {
                      const t6 = new h2(e4.rest());
                      return l3.concat(t6).chop();
                    }
                  } else
                    "number" == typeof s4.delete && ("number" == typeof r4.retain || "object" == typeof r4.retain && null !== r4.retain) && l3.push(s4);
                }
              return l3.chop();
            }
            concat(t4) {
              const e4 = new h2(this.ops.slice());
              return t4.ops.length > 0 && (e4.push(t4.ops[0]), e4.ops = e4.ops.concat(t4.ops.slice(1))), e4;
            }
            diff(t4, e4) {
              if (this.ops === t4.ops)
                return new h2();
              const n4 = [this, t4].map((e5) => e5.map((n5) => {
                if (null != n5.insert)
                  return "string" == typeof n5.insert ? n5.insert : c2;
                throw new Error("diff() called " + (e5 === t4 ? "on" : "with") + " non-document");
              }).join("")), s3 = new h2(), l3 = r2(n4[0], n4[1], e4, true), u3 = new a2.default(this.ops), d2 = new a2.default(t4.ops);
              return l3.forEach((t5) => {
                let e5 = t5[1].length;
                for (; e5 > 0; ) {
                  let n5 = 0;
                  switch (t5[0]) {
                    case r2.INSERT:
                      n5 = Math.min(d2.peekLength(), e5), s3.push(d2.next(n5));
                      break;
                    case r2.DELETE:
                      n5 = Math.min(e5, u3.peekLength()), u3.next(n5), s3.delete(n5);
                      break;
                    case r2.EQUAL:
                      n5 = Math.min(u3.peekLength(), d2.peekLength(), e5);
                      const t6 = u3.next(n5), l4 = d2.next(n5);
                      i2(t6.insert, l4.insert) ? s3.retain(n5, o2.default.diff(t6.attributes, l4.attributes)) : s3.push(l4).delete(n5);
                  }
                  e5 -= n5;
                }
              }), s3.chop();
            }
            eachLine(t4, e4 = "\n") {
              const n4 = new a2.default(this.ops);
              let r3 = new h2(), s3 = 0;
              for (; n4.hasNext(); ) {
                if ("insert" !== n4.peekType())
                  return;
                const i3 = n4.peek(), o3 = l2.default.length(i3) - n4.peekLength(), a3 = "string" == typeof i3.insert ? i3.insert.indexOf(e4, o3) - o3 : -1;
                if (a3 < 0)
                  r3.push(n4.next());
                else if (a3 > 0)
                  r3.push(n4.next(a3));
                else {
                  if (false === t4(r3, n4.next(1).attributes || {}, s3))
                    return;
                  s3 += 1, r3 = new h2();
                }
              }
              r3.length() > 0 && t4(r3, {}, s3);
            }
            invert(t4) {
              const e4 = new h2();
              return this.reduce((n4, r3) => {
                if (r3.insert)
                  e4.delete(l2.default.length(r3));
                else {
                  if ("number" == typeof r3.retain && null == r3.attributes)
                    return e4.retain(r3.retain), n4 + r3.retain;
                  if (r3.delete || "number" == typeof r3.retain) {
                    const s3 = r3.delete || r3.retain;
                    return t4.slice(n4, n4 + s3).forEach((t5) => {
                      r3.delete ? e4.push(t5) : r3.retain && r3.attributes && e4.retain(l2.default.length(t5), o2.default.invert(r3.attributes, t5.attributes));
                    }), n4 + s3;
                  }
                  if ("object" == typeof r3.retain && null !== r3.retain) {
                    const s3 = t4.slice(n4, n4 + 1), i3 = new a2.default(s3.ops).next(), [l3, c3, d2] = u2(r3.retain, i3.insert), f2 = h2.getHandler(l3);
                    return e4.retain({ [l3]: f2.invert(c3, d2) }, o2.default.invert(r3.attributes, i3.attributes)), n4 + 1;
                  }
                }
                return n4;
              }, 0), e4.chop();
            }
            transform(t4, e4 = false) {
              if (e4 = !!e4, "number" == typeof t4)
                return this.transformPosition(t4, e4);
              const n4 = t4, r3 = new a2.default(this.ops), s3 = new a2.default(n4.ops), i3 = new h2();
              for (; r3.hasNext() || s3.hasNext(); )
                if ("insert" !== r3.peekType() || !e4 && "insert" === s3.peekType())
                  if ("insert" === s3.peekType())
                    i3.push(s3.next());
                  else {
                    const t5 = Math.min(r3.peekLength(), s3.peekLength()), n5 = r3.next(t5), l3 = s3.next(t5);
                    if (n5.delete)
                      continue;
                    if (l3.delete)
                      i3.push(l3);
                    else {
                      const r4 = n5.retain, s4 = l3.retain;
                      let a3 = "object" == typeof s4 && null !== s4 ? s4 : t5;
                      if ("object" == typeof r4 && null !== r4 && "object" == typeof s4 && null !== s4) {
                        const t6 = Object.keys(r4)[0];
                        if (t6 === Object.keys(s4)[0]) {
                          const n6 = h2.getHandler(t6);
                          n6 && (a3 = { [t6]: n6.transform(r4[t6], s4[t6], e4) });
                        }
                      }
                      i3.retain(a3, o2.default.transform(n5.attributes, l3.attributes, e4));
                    }
                  }
                else
                  i3.retain(l2.default.length(r3.next()));
              return i3.chop();
            }
            transformPosition(t4, e4 = false) {
              e4 = !!e4;
              const n4 = new a2.default(this.ops);
              let r3 = 0;
              for (; n4.hasNext() && r3 <= t4; ) {
                const s3 = n4.peekLength(), i3 = n4.peekType();
                n4.next(), "delete" !== i3 ? ("insert" === i3 && (r3 < t4 || !e4) && (t4 += s3), r3 += s3) : t4 -= Math.min(s3, t4 - r3);
              }
              return t4;
            }
          }
          h2.Op = l2.default, h2.OpIterator = a2.default, h2.AttributeMap = o2.default, h2.handlers = {}, e3.default = h2, t3.exports = h2, t3.exports.default = h2;
        }, 759: (t3, e3) => {
          "use strict";
          var n3;
          Object.defineProperty(e3, "__esModule", { value: true }), function(t4) {
            t4.length = function(t5) {
              return "number" == typeof t5.delete ? t5.delete : "number" == typeof t5.retain ? t5.retain : "object" == typeof t5.retain && null !== t5.retain ? 1 : "string" == typeof t5.insert ? t5.insert.length : 1;
            };
          }(n3 || (n3 = {})), e3.default = n3;
        }, 317: (t3, e3, n3) => {
          "use strict";
          Object.defineProperty(e3, "__esModule", { value: true });
          const r2 = n3(759);
          e3.default = class {
            constructor(t4) {
              this.ops = t4, this.index = 0, this.offset = 0;
            }
            hasNext() {
              return this.peekLength() < 1 / 0;
            }
            next(t4) {
              t4 || (t4 = 1 / 0);
              const e4 = this.ops[this.index];
              if (e4) {
                const n4 = this.offset, s2 = r2.default.length(e4);
                if (t4 >= s2 - n4 ? (t4 = s2 - n4, this.index += 1, this.offset = 0) : this.offset += t4, "number" == typeof e4.delete)
                  return { delete: t4 };
                {
                  const r3 = {};
                  return e4.attributes && (r3.attributes = e4.attributes), "number" == typeof e4.retain ? r3.retain = t4 : "object" == typeof e4.retain && null !== e4.retain ? r3.retain = e4.retain : "string" == typeof e4.insert ? r3.insert = e4.insert.substr(n4, t4) : r3.insert = e4.insert, r3;
                }
              }
              return { retain: 1 / 0 };
            }
            peek() {
              return this.ops[this.index];
            }
            peekLength() {
              return this.ops[this.index] ? r2.default.length(this.ops[this.index]) - this.offset : 1 / 0;
            }
            peekType() {
              const t4 = this.ops[this.index];
              return t4 ? "number" == typeof t4.delete ? "delete" : "number" == typeof t4.retain || "object" == typeof t4.retain && null !== t4.retain ? "retain" : "insert" : "retain";
            }
            rest() {
              if (this.hasNext()) {
                if (0 === this.offset)
                  return this.ops.slice(this.index);
                {
                  const t4 = this.offset, e4 = this.index, n4 = this.next(), r3 = this.ops.slice(this.index);
                  return this.offset = t4, this.index = e4, [n4].concat(r3);
                }
              }
              return [];
            }
          };
        }, 968: (t3, e3, n3) => {
          var r2 = n3(64);
          "string" == typeof r2 && (r2 = [[t3.id, r2, ""]]);
          var s2 = { hmr: true, transform: void 0 };
          n3(27)(r2, s2);
          r2.locals && (t3.exports = r2.locals);
        }, 27: (t3, e3, n3) => {
          var r2, s2, i2 = {}, o2 = (r2 = /* @__PURE__ */ __name(function() {
            return window && document && document.all && !window.atob;
          }, "r"), function() {
            return void 0 === s2 && (s2 = r2.apply(this, arguments)), s2;
          }), l2 = /* @__PURE__ */ function(t4) {
            var e4 = {};
            return function(n4) {
              if (void 0 === e4[n4]) {
                var r3 = t4.call(this, n4);
                if (r3 instanceof window.HTMLIFrameElement)
                  try {
                    r3 = r3.contentDocument.head;
                  } catch (t5) {
                    r3 = null;
                  }
                e4[n4] = r3;
              }
              return e4[n4];
            };
          }(function(t4) {
            return document.querySelector(t4);
          }), a2 = null, c2 = 0, u2 = [], h2 = n3(874);
          function d2(t4, e4) {
            for (var n4 = 0; n4 < t4.length; n4++) {
              var r3 = t4[n4], s3 = i2[r3.id];
              if (s3) {
                s3.refs++;
                for (var o3 = 0; o3 < s3.parts.length; o3++)
                  s3.parts[o3](r3.parts[o3]);
                for (; o3 < r3.parts.length; o3++)
                  s3.parts.push(y2(r3.parts[o3], e4));
              } else {
                var l3 = [];
                for (o3 = 0; o3 < r3.parts.length; o3++)
                  l3.push(y2(r3.parts[o3], e4));
                i2[r3.id] = { id: r3.id, refs: 1, parts: l3 };
              }
            }
          }
          __name(d2, "d");
          function f2(t4, e4) {
            for (var n4 = [], r3 = {}, s3 = 0; s3 < t4.length; s3++) {
              var i3 = t4[s3], o3 = e4.base ? i3[0] + e4.base : i3[0], l3 = { css: i3[1], media: i3[2], sourceMap: i3[3] };
              r3[o3] ? r3[o3].parts.push(l3) : n4.push(r3[o3] = { id: o3, parts: [l3] });
            }
            return n4;
          }
          __name(f2, "f");
          function p2(t4, e4) {
            var n4 = l2(t4.insertInto);
            if (!n4)
              throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");
            var r3 = u2[u2.length - 1];
            if ("top" === t4.insertAt)
              r3 ? r3.nextSibling ? n4.insertBefore(e4, r3.nextSibling) : n4.appendChild(e4) : n4.insertBefore(e4, n4.firstChild), u2.push(e4);
            else if ("bottom" === t4.insertAt)
              n4.appendChild(e4);
            else {
              if ("object" != typeof t4.insertAt || !t4.insertAt.before)
                throw new Error("[Style Loader]\n\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\n Must be 'top', 'bottom', or Object.\n (https://github.com/webpack-contrib/style-loader#insertat)\n");
              var s3 = l2(t4.insertInto + " " + t4.insertAt.before);
              n4.insertBefore(e4, s3);
            }
          }
          __name(p2, "p");
          function g2(t4) {
            if (null === t4.parentNode)
              return false;
            t4.parentNode.removeChild(t4);
            var e4 = u2.indexOf(t4);
            e4 >= 0 && u2.splice(e4, 1);
          }
          __name(g2, "g");
          function m2(t4) {
            var e4 = document.createElement("style");
            return t4.attrs.type = "text/css", b2(e4, t4.attrs), p2(t4, e4), e4;
          }
          __name(m2, "m");
          function b2(t4, e4) {
            Object.keys(e4).forEach(function(n4) {
              t4.setAttribute(n4, e4[n4]);
            });
          }
          __name(b2, "b");
          function y2(t4, e4) {
            var n4, r3, s3, i3;
            if (e4.transform && t4.css) {
              if (!(i3 = e4.transform(t4.css)))
                return function() {
                };
              t4.css = i3;
            }
            if (e4.singleton) {
              var o3 = c2++;
              n4 = a2 || (a2 = m2(e4)), r3 = N2.bind(null, n4, o3, false), s3 = N2.bind(null, n4, o3, true);
            } else
              t4.sourceMap && "function" == typeof URL && "function" == typeof URL.createObjectURL && "function" == typeof URL.revokeObjectURL && "function" == typeof Blob && "function" == typeof btoa ? (n4 = function(t5) {
                var e5 = document.createElement("link");
                return t5.attrs.type = "text/css", t5.attrs.rel = "stylesheet", b2(e5, t5.attrs), p2(t5, e5), e5;
              }(e4), r3 = E2.bind(null, n4, e4), s3 = /* @__PURE__ */ __name(function() {
                g2(n4), n4.href && URL.revokeObjectURL(n4.href);
              }, "s")) : (n4 = m2(e4), r3 = w2.bind(null, n4), s3 = /* @__PURE__ */ __name(function() {
                g2(n4);
              }, "s"));
            return r3(t4), function(e5) {
              if (e5) {
                if (e5.css === t4.css && e5.media === t4.media && e5.sourceMap === t4.sourceMap)
                  return;
                r3(t4 = e5);
              } else
                s3();
            };
          }
          __name(y2, "y");
          t3.exports = function(t4, e4) {
            if ("undefined" != typeof DEBUG && DEBUG && "object" != typeof document)
              throw new Error("The style-loader cannot be used in a non-browser environment");
            (e4 = e4 || {}).attrs = "object" == typeof e4.attrs ? e4.attrs : {}, e4.singleton || "boolean" == typeof e4.singleton || (e4.singleton = o2()), e4.insertInto || (e4.insertInto = "head"), e4.insertAt || (e4.insertAt = "bottom");
            var n4 = f2(t4, e4);
            return d2(n4, e4), function(t5) {
              for (var r3 = [], s3 = 0; s3 < n4.length; s3++) {
                var o3 = n4[s3];
                (l3 = i2[o3.id]).refs--, r3.push(l3);
              }
              t5 && d2(f2(t5, e4), e4);
              for (s3 = 0; s3 < r3.length; s3++) {
                var l3;
                if (0 === (l3 = r3[s3]).refs) {
                  for (var a3 = 0; a3 < l3.parts.length; a3++)
                    l3.parts[a3]();
                  delete i2[l3.id];
                }
              }
            };
          };
          var v2, x2 = (v2 = [], function(t4, e4) {
            return v2[t4] = e4, v2.filter(Boolean).join("\n");
          });
          function N2(t4, e4, n4, r3) {
            var s3 = n4 ? "" : r3.css;
            if (t4.styleSheet)
              t4.styleSheet.cssText = x2(e4, s3);
            else {
              var i3 = document.createTextNode(s3), o3 = t4.childNodes;
              o3[e4] && t4.removeChild(o3[e4]), o3.length ? t4.insertBefore(i3, o3[e4]) : t4.appendChild(i3);
            }
          }
          __name(N2, "N");
          function w2(t4, e4) {
            var n4 = e4.css, r3 = e4.media;
            if (r3 && t4.setAttribute("media", r3), t4.styleSheet)
              t4.styleSheet.cssText = n4;
            else {
              for (; t4.firstChild; )
                t4.removeChild(t4.firstChild);
              t4.appendChild(document.createTextNode(n4));
            }
          }
          __name(w2, "w");
          function E2(t4, e4, n4) {
            var r3 = n4.css, s3 = n4.sourceMap, i3 = void 0 === e4.convertToAbsoluteUrls && s3;
            (e4.convertToAbsoluteUrls || i3) && (r3 = h2(r3)), s3 && (r3 += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(s3)))) + " */");
            var o3 = new Blob([r3], { type: "text/css" }), l3 = t4.href;
            t4.href = URL.createObjectURL(o3), l3 && URL.revokeObjectURL(l3);
          }
          __name(E2, "E");
        }, 874: (t3) => {
          t3.exports = function(t4) {
            var e3 = "undefined" != typeof window && window.location;
            if (!e3)
              throw new Error("fixUrls requires window.location");
            if (!t4 || "string" != typeof t4)
              return t4;
            var n3 = e3.protocol + "//" + e3.host, r2 = n3 + e3.pathname.replace(/\/[^\/]*$/, "/");
            return t4.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi, function(t5, e4) {
              var s2, i2 = e4.trim().replace(/^"(.*)"$/, function(t6, e5) {
                return e5;
              }).replace(/^'(.*)'$/, function(t6, e5) {
                return e5;
              });
              return /^(#|data:|http:\/\/|https:\/\/|file:\/\/\/)/i.test(i2) ? t5 : (s2 = 0 === i2.indexOf("//") ? i2 : 0 === i2.indexOf("/") ? n3 + i2 : r2 + i2.replace(/^\.\//, ""), "url(" + JSON.stringify(s2) + ")");
            });
          };
        }, 676: (t3, e3) => {
          "use strict";
          Object.defineProperty(e3, "__esModule", { value: true }), e3.FormatHTMLStringIndentation = function(t4, e4) {
            for (var n3 = " ".repeat(2), r2 = 0, s2 = "\n", i2 = null, o2 = null, l2 = null, a2 = "", c2 = 0; c2 <= t4.length; c2++) {
              i2 = o2, o2 = t4.substr(c2, 1), l2 = t4.substr(c2 + 1, 1);
              var u2 = "<br>" === t4.substr(c2, 4), h2 = "<" === o2 && "/" !== l2 && !u2, d2 = "<" === o2 && "/" === l2 && !u2, f2 = ">" === i2 && "<" !== o2 && r2 > 0, p2 = !u2 && !h2 && !d2 && f2 && "" === t4.substr(c2, t4.substr(c2).indexOf("<")).trim();
              u2 && (a2 += s2, r2--, c2 += 4), h2 ? (a2 += s2 + n3.repeat(r2), r2++) : d2 ? (--r2 < 0 && (r2 = 0), a2 += s2 + n3.repeat(r2)) : (" " === o2 && " " === l2 || o2 === s2 && "" === t4.substr(c2, t4.substr(c2).indexOf("<")).trim()) && (o2 = ""), f2 && !p2 && (a2 += s2 + n3.repeat(r2)), a2 += o2;
            }
            return e4.log("formatHTML", { before: t4, after: a2 }), a2;
          };
        }, 795: (t3, e3) => {
          "use strict";
          function n3(t4) {
            return t4.replace(/\s+/g, " ").trim();
          }
          __name(n3, "n");
          function r2(t4) {
            return t4.replace(/<br([\s]*[\/]?>)/g, "<p> </p>");
          }
          __name(r2, "r");
          function s2(t4) {
            return t4.replace(/<p><\/p>/g, "<p> </p>");
          }
          __name(s2, "s");
          function i2(t4) {
            return t4.replace(/(<(?!\/)[\w=\."'\s]*>) /g, "$1");
          }
          __name(i2, "i");
          function o2(t4) {
            return t4.replace(/ (<\/[\w]+>)/g, "$1");
          }
          __name(o2, "o");
          function l2(t4, e4) {
            return t4.reduce(function(t5, e5) {
              return e5(t5);
            }, e4);
          }
          __name(l2, "l");
          Object.defineProperty(e3, "__esModule", { value: true }), e3.OutputHTMLParser = function(t4) {
            return l2([n3, i2, o2, r2, s2], t4);
          }, e3.ConvertMultipleSpacesToSingle = n3, e3.PreserveNewlinesBr = r2, e3.PreserveNewlinesPTags = s2, e3.FixTagSpaceOpenTag = i2, e3.FixTagSpaceCloseTag = o2, e3.Compose = l2;
        }, 614: (t3, e3) => {
          "use strict";
          Object.defineProperty(e3, "__esModule", { value: true }), e3.QuillHtmlLogger = void 0;
          var n3 = function() {
            function t4() {
              this.debug = false;
            }
            __name(t4, "t");
            return t4.prototype.setDebug = function(t5) {
              this.debug = t5;
            }, t4.prototype.prefixString = function() {
              return "</> quill-html-edit-button: ";
            }, Object.defineProperty(t4.prototype, "log", { get: function() {
              return this.debug ? console.log.bind(console, this.prefixString()) : function() {
                for (var t5 = [], e4 = 0; e4 < arguments.length; e4++)
                  t5[e4] = arguments[e4];
              };
            }, enumerable: false, configurable: true }), t4;
          }();
          e3.QuillHtmlLogger = n3;
        }, 190: function(t3, e3, n3) {
          "use strict";
          var r2 = this && this.__assign || function() {
            return r2 = Object.assign || function(t4) {
              for (var e4, n4 = 1, r3 = arguments.length; n4 < r3; n4++)
                for (var s3 in e4 = arguments[n4])
                  Object.prototype.hasOwnProperty.call(e4, s3) && (t4[s3] = e4[s3]);
              return t4;
            }, r2.apply(this, arguments);
          }, s2 = this && this.__importDefault || function(t4) {
            return t4 && t4.__esModule ? t4 : { default: t4 };
          };
          Object.defineProperty(e3, "__esModule", { value: true }), e3.htmlEditButton = void 0;
          var i2 = n3(614);
          n3(968);
          var o2 = s2(n3(429)), l2 = n3(795), a2 = n3(676);
          function c2(t4) {
            return document.createElement(t4);
          }
          __name(c2, "c");
          function u2(t4, e4, n4) {
            return t4.setAttribute(e4, n4);
          }
          __name(u2, "u");
          var h2 = new i2.QuillHtmlLogger(), d2 = /* @__PURE__ */ __name(function(t4, e4) {
            var n4 = e4 || {}, s3 = !(!n4 || !n4.debug);
            h2.setDebug(s3), h2.log("logging enabled");
            var i3 = t4.getModule("toolbar");
            if (!i3)
              throw new Error('quill.htmlEditButton requires the "toolbar" module to be included too');
            var d3 = i3.container, f2 = c2("span");
            u2(f2, "class", "ql-formats");
            var p2 = c2("button");
            p2.innerHTML = n4.buttonHTML || "&lt;&gt;", p2.title = n4.buttonTitle || "Show HTML source", p2.type = "button";
            var g2 = /* @__PURE__ */ __name(function(e5) {
              t4.clipboard.dangerouslyPasteHTML(e5);
            }, "g");
            p2.onclick = function(e5) {
              e5.preventDefault(), function(t5, e6, n5) {
                var s4 = t5.container.querySelector(".ql-editor").innerHTML, i4 = c2("div"), d4 = c2("div"), f3 = e6.msg || `Edit HTML here, when you click "OK" the quill editor's contents will be replaced`, p3 = e6.cancelText || "Cancel", g3 = e6.okText || "Ok", m2 = false !== e6.closeOnClickOverlay;
                u2(d4, "class", "ql-html-overlayContainer"), u2(i4, "class", "ql-html-popupContainer");
                var b2 = c2("span");
                u2(b2, "class", "ql-html-popupTitle"), b2.innerText = f3;
                var y2 = c2("div");
                y2.appendChild(b2), u2(y2, "class", "ql-html-textContainer");
                var v2 = c2("pre");
                u2(v2, "data-language", "xml"), v2.innerText = (0, a2.FormatHTMLStringIndentation)(s4, h2);
                var x2 = c2("div");
                u2(x2, "class", "ql-html-textArea");
                var N2 = c2("button");
                N2.innerHTML = p3, u2(N2, "class", "ql-html-buttonCancel");
                var w2 = c2("button");
                w2.innerHTML = g3, u2(w2, "class", "ql-html-buttonOk");
                var E2 = c2("div");
                u2(E2, "class", "ql-html-buttonGroup");
                var A2 = document.querySelector(e6.prependSelector);
                E2.appendChild(N2), E2.appendChild(w2), x2.appendChild(v2), y2.appendChild(x2), y2.appendChild(E2), i4.appendChild(y2), d4.appendChild(i4), A2 ? A2.prepend(d4) : document.body.appendChild(d4);
                var q2 = e6 && e6.editorModules, k2 = q2 && Object.keys(q2).length ? q2 : {}, _2 = new o2.default(x2, { modules: r2({ syntax: e6.syntax }, k2) });
                N2.onclick = function() {
                  A2 ? A2.removeChild(d4) : document.body.removeChild(d4);
                }, m2 && (d4.onclick = N2.onclick), i4.onclick = function(t6) {
                  t6.preventDefault(), t6.stopPropagation();
                }, w2.onclick = function() {
                  var t6 = _2.container.querySelector(".ql-editor").innerText, e7 = (0, l2.OutputHTMLParser)(t6);
                  h2.log("OutputHTMLParser", { htmlInputFromPopup: t6, htmlOutputFormatted: e7 }), n5(e7), A2 ? A2.removeChild(d4) : document.body.removeChild(d4);
                };
              }(t4, n4, g2);
            }, f2.appendChild(p2), null == d3 || d3.appendChild(f2);
          }, "d");
          e3.htmlEditButton = d2, window.htmlEditButton = d2, e3.default = d2;
        }, 429: (t3, e3, n3) => {
          "use strict";
          n3.r(e3), n3.d(e3, { Module: () => xs, Parchment: () => r2, Range: () => cs, default: () => tl });
          var r2 = {};
          n3.r(r2), n3.d(r2, { Attributor: () => ze, AttributorStore: () => Ge, BlockBlot: () => an, ClassAttributor: () => Ke, ContainerBlot: () => un, EmbedBlot: () => hn, InlineBlot: () => on, LeafBlot: () => Je, ParentBlot: () => rn, Registry: () => $e, Scope: () => Pe, ScrollBlot: () => pn, StyleAttributor: () => Ze, TextBlot: () => mn });
          const s2 = /* @__PURE__ */ __name(function() {
            this.__data__ = [], this.size = 0;
          }, "s");
          const i2 = /* @__PURE__ */ __name(function(t4, e4) {
            return t4 === e4 || t4 != t4 && e4 != e4;
          }, "i");
          const o2 = /* @__PURE__ */ __name(function(t4, e4) {
            for (var n4 = t4.length; n4--; )
              if (i2(t4[n4][0], e4))
                return n4;
            return -1;
          }, "o");
          var l2 = Array.prototype.splice;
          const a2 = /* @__PURE__ */ __name(function(t4) {
            var e4 = this.__data__, n4 = o2(e4, t4);
            return !(n4 < 0) && (n4 == e4.length - 1 ? e4.pop() : l2.call(e4, n4, 1), --this.size, true);
          }, "a");
          const c2 = /* @__PURE__ */ __name(function(t4) {
            var e4 = this.__data__, n4 = o2(e4, t4);
            return n4 < 0 ? void 0 : e4[n4][1];
          }, "c");
          const u2 = /* @__PURE__ */ __name(function(t4) {
            return o2(this.__data__, t4) > -1;
          }, "u");
          const h2 = /* @__PURE__ */ __name(function(t4, e4) {
            var n4 = this.__data__, r3 = o2(n4, t4);
            return r3 < 0 ? (++this.size, n4.push([t4, e4])) : n4[r3][1] = e4, this;
          }, "h");
          function d2(t4) {
            var e4 = -1, n4 = null == t4 ? 0 : t4.length;
            for (this.clear(); ++e4 < n4; ) {
              var r3 = t4[e4];
              this.set(r3[0], r3[1]);
            }
          }
          __name(d2, "d");
          d2.prototype.clear = s2, d2.prototype.delete = a2, d2.prototype.get = c2, d2.prototype.has = u2, d2.prototype.set = h2;
          const f2 = d2;
          const p2 = /* @__PURE__ */ __name(function() {
            this.__data__ = new f2(), this.size = 0;
          }, "p");
          const g2 = /* @__PURE__ */ __name(function(t4) {
            var e4 = this.__data__, n4 = e4.delete(t4);
            return this.size = e4.size, n4;
          }, "g");
          const m2 = /* @__PURE__ */ __name(function(t4) {
            return this.__data__.get(t4);
          }, "m");
          const b2 = /* @__PURE__ */ __name(function(t4) {
            return this.__data__.has(t4);
          }, "b");
          const y2 = "object" == typeof global && global && global.Object === Object && global;
          var v2 = "object" == typeof self && self && self.Object === Object && self;
          const x2 = y2 || v2 || Function("return this")();
          const N2 = x2.Symbol;
          var w2 = Object.prototype, E2 = w2.hasOwnProperty, A2 = w2.toString, q2 = N2 ? N2.toStringTag : void 0;
          const k2 = /* @__PURE__ */ __name(function(t4) {
            var e4 = E2.call(t4, q2), n4 = t4[q2];
            try {
              t4[q2] = void 0;
              var r3 = true;
            } catch (t5) {
            }
            var s3 = A2.call(t4);
            return r3 && (e4 ? t4[q2] = n4 : delete t4[q2]), s3;
          }, "k");
          var _2 = Object.prototype.toString;
          const L2 = /* @__PURE__ */ __name(function(t4) {
            return _2.call(t4);
          }, "L");
          var O2 = N2 ? N2.toStringTag : void 0;
          const T2 = /* @__PURE__ */ __name(function(t4) {
            return null == t4 ? void 0 === t4 ? "[object Undefined]" : "[object Null]" : O2 && O2 in Object(t4) ? k2(t4) : L2(t4);
          }, "T");
          const S2 = /* @__PURE__ */ __name(function(t4) {
            var e4 = typeof t4;
            return null != t4 && ("object" == e4 || "function" == e4);
          }, "S");
          const C2 = /* @__PURE__ */ __name(function(t4) {
            if (!S2(t4))
              return false;
            var e4 = T2(t4);
            return "[object Function]" == e4 || "[object GeneratorFunction]" == e4 || "[object AsyncFunction]" == e4 || "[object Proxy]" == e4;
          }, "C");
          const j2 = x2["__core-js_shared__"];
          var R2, I2 = (R2 = /[^.]+$/.exec(j2 && j2.keys && j2.keys.IE_PROTO || "")) ? "Symbol(src)_1." + R2 : "";
          const M2 = /* @__PURE__ */ __name(function(t4) {
            return !!I2 && I2 in t4;
          }, "M");
          var B2 = Function.prototype.toString;
          const U2 = /* @__PURE__ */ __name(function(t4) {
            if (null != t4) {
              try {
                return B2.call(t4);
              } catch (t5) {
              }
              try {
                return t4 + "";
              } catch (t5) {
              }
            }
            return "";
          }, "U");
          var D2 = /^\[object .+?Constructor\]$/, P2 = Function.prototype, z2 = Object.prototype, H2 = P2.toString, F2 = z2.hasOwnProperty, $2 = RegExp("^" + H2.call(F2).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
          const V2 = /* @__PURE__ */ __name(function(t4) {
            return !(!S2(t4) || M2(t4)) && (C2(t4) ? $2 : D2).test(U2(t4));
          }, "V");
          const K2 = /* @__PURE__ */ __name(function(t4, e4) {
            return null == t4 ? void 0 : t4[e4];
          }, "K");
          const W2 = /* @__PURE__ */ __name(function(t4, e4) {
            var n4 = K2(t4, e4);
            return V2(n4) ? n4 : void 0;
          }, "W");
          const Z = W2(x2, "Map");
          const G2 = W2(Object, "create");
          const X2 = /* @__PURE__ */ __name(function() {
            this.__data__ = G2 ? G2(null) : {}, this.size = 0;
          }, "X");
          const Q2 = /* @__PURE__ */ __name(function(t4) {
            var e4 = this.has(t4) && delete this.__data__[t4];
            return this.size -= e4 ? 1 : 0, e4;
          }, "Q");
          var Y2 = Object.prototype.hasOwnProperty;
          const J2 = /* @__PURE__ */ __name(function(t4) {
            var e4 = this.__data__;
            if (G2) {
              var n4 = e4[t4];
              return "__lodash_hash_undefined__" === n4 ? void 0 : n4;
            }
            return Y2.call(e4, t4) ? e4[t4] : void 0;
          }, "J");
          var tt = Object.prototype.hasOwnProperty;
          const et = /* @__PURE__ */ __name(function(t4) {
            var e4 = this.__data__;
            return G2 ? void 0 !== e4[t4] : tt.call(e4, t4);
          }, "et");
          const nt = /* @__PURE__ */ __name(function(t4, e4) {
            var n4 = this.__data__;
            return this.size += this.has(t4) ? 0 : 1, n4[t4] = G2 && void 0 === e4 ? "__lodash_hash_undefined__" : e4, this;
          }, "nt");
          function rt(t4) {
            var e4 = -1, n4 = null == t4 ? 0 : t4.length;
            for (this.clear(); ++e4 < n4; ) {
              var r3 = t4[e4];
              this.set(r3[0], r3[1]);
            }
          }
          __name(rt, "rt");
          rt.prototype.clear = X2, rt.prototype.delete = Q2, rt.prototype.get = J2, rt.prototype.has = et, rt.prototype.set = nt;
          const st = rt;
          const it = /* @__PURE__ */ __name(function() {
            this.size = 0, this.__data__ = { hash: new st(), map: new (Z || f2)(), string: new st() };
          }, "it");
          const ot = /* @__PURE__ */ __name(function(t4) {
            var e4 = typeof t4;
            return "string" == e4 || "number" == e4 || "symbol" == e4 || "boolean" == e4 ? "__proto__" !== t4 : null === t4;
          }, "ot");
          const lt = /* @__PURE__ */ __name(function(t4, e4) {
            var n4 = t4.__data__;
            return ot(e4) ? n4["string" == typeof e4 ? "string" : "hash"] : n4.map;
          }, "lt");
          const at = /* @__PURE__ */ __name(function(t4) {
            var e4 = lt(this, t4).delete(t4);
            return this.size -= e4 ? 1 : 0, e4;
          }, "at");
          const ct = /* @__PURE__ */ __name(function(t4) {
            return lt(this, t4).get(t4);
          }, "ct");
          const ut = /* @__PURE__ */ __name(function(t4) {
            return lt(this, t4).has(t4);
          }, "ut");
          const ht = /* @__PURE__ */ __name(function(t4, e4) {
            var n4 = lt(this, t4), r3 = n4.size;
            return n4.set(t4, e4), this.size += n4.size == r3 ? 0 : 1, this;
          }, "ht");
          function dt(t4) {
            var e4 = -1, n4 = null == t4 ? 0 : t4.length;
            for (this.clear(); ++e4 < n4; ) {
              var r3 = t4[e4];
              this.set(r3[0], r3[1]);
            }
          }
          __name(dt, "dt");
          dt.prototype.clear = it, dt.prototype.delete = at, dt.prototype.get = ct, dt.prototype.has = ut, dt.prototype.set = ht;
          const ft = dt;
          const pt = /* @__PURE__ */ __name(function(t4, e4) {
            var n4 = this.__data__;
            if (n4 instanceof f2) {
              var r3 = n4.__data__;
              if (!Z || r3.length < 199)
                return r3.push([t4, e4]), this.size = ++n4.size, this;
              n4 = this.__data__ = new ft(r3);
            }
            return n4.set(t4, e4), this.size = n4.size, this;
          }, "pt");
          function gt(t4) {
            var e4 = this.__data__ = new f2(t4);
            this.size = e4.size;
          }
          __name(gt, "gt");
          gt.prototype.clear = p2, gt.prototype.delete = g2, gt.prototype.get = m2, gt.prototype.has = b2, gt.prototype.set = pt;
          const mt = gt;
          const bt = function() {
            try {
              var t4 = W2(Object, "defineProperty");
              return t4({}, "", {}), t4;
            } catch (t5) {
            }
          }();
          const yt = /* @__PURE__ */ __name(function(t4, e4, n4) {
            "__proto__" == e4 && bt ? bt(t4, e4, { configurable: true, enumerable: true, value: n4, writable: true }) : t4[e4] = n4;
          }, "yt");
          const vt = /* @__PURE__ */ __name(function(t4, e4, n4) {
            (void 0 !== n4 && !i2(t4[e4], n4) || void 0 === n4 && !(e4 in t4)) && yt(t4, e4, n4);
          }, "vt");
          const xt = /* @__PURE__ */ function(t4) {
            return function(e4, n4, r3) {
              for (var s3 = -1, i3 = Object(e4), o3 = r3(e4), l3 = o3.length; l3--; ) {
                var a3 = o3[t4 ? l3 : ++s3];
                if (false === n4(i3[a3], a3, i3))
                  break;
              }
              return e4;
            };
          }();
          var Nt = "object" == typeof exports2 && exports2 && !exports2.nodeType && exports2, wt = Nt && "object" == typeof module2 && module2 && !module2.nodeType && module2, Et = wt && wt.exports === Nt ? x2.Buffer : void 0, At = Et ? Et.allocUnsafe : void 0;
          const qt = /* @__PURE__ */ __name(function(t4, e4) {
            if (e4)
              return t4.slice();
            var n4 = t4.length, r3 = At ? At(n4) : new t4.constructor(n4);
            return t4.copy(r3), r3;
          }, "qt");
          const kt = x2.Uint8Array;
          const _t = /* @__PURE__ */ __name(function(t4) {
            var e4 = new t4.constructor(t4.byteLength);
            return new kt(e4).set(new kt(t4)), e4;
          }, "_t");
          const Lt = /* @__PURE__ */ __name(function(t4, e4) {
            var n4 = e4 ? _t(t4.buffer) : t4.buffer;
            return new t4.constructor(n4, t4.byteOffset, t4.length);
          }, "Lt");
          const Ot = /* @__PURE__ */ __name(function(t4, e4) {
            var n4 = -1, r3 = t4.length;
            for (e4 || (e4 = Array(r3)); ++n4 < r3; )
              e4[n4] = t4[n4];
            return e4;
          }, "Ot");
          var Tt = Object.create;
          const St = /* @__PURE__ */ function() {
            function t4() {
            }
            __name(t4, "t");
            return function(e4) {
              if (!S2(e4))
                return {};
              if (Tt)
                return Tt(e4);
              t4.prototype = e4;
              var n4 = new t4();
              return t4.prototype = void 0, n4;
            };
          }();
          const Ct = /* @__PURE__ */ __name(function(t4, e4) {
            return function(n4) {
              return t4(e4(n4));
            };
          }, "Ct");
          const jt = Ct(Object.getPrototypeOf, Object);
          var Rt = Object.prototype;
          const It = /* @__PURE__ */ __name(function(t4) {
            var e4 = t4 && t4.constructor;
            return t4 === ("function" == typeof e4 && e4.prototype || Rt);
          }, "It");
          const Mt = /* @__PURE__ */ __name(function(t4) {
            return "function" != typeof t4.constructor || It(t4) ? {} : St(jt(t4));
          }, "Mt");
          const Bt = /* @__PURE__ */ __name(function(t4) {
            return null != t4 && "object" == typeof t4;
          }, "Bt");
          const Ut = /* @__PURE__ */ __name(function(t4) {
            return Bt(t4) && "[object Arguments]" == T2(t4);
          }, "Ut");
          var Dt = Object.prototype, Pt = Dt.hasOwnProperty, zt = Dt.propertyIsEnumerable;
          const Ht = Ut(/* @__PURE__ */ function() {
            return arguments;
          }()) ? Ut : function(t4) {
            return Bt(t4) && Pt.call(t4, "callee") && !zt.call(t4, "callee");
          };
          const Ft = Array.isArray;
          const $t = /* @__PURE__ */ __name(function(t4) {
            return "number" == typeof t4 && t4 > -1 && t4 % 1 == 0 && t4 <= 9007199254740991;
          }, "$t");
          const Vt = /* @__PURE__ */ __name(function(t4) {
            return null != t4 && $t(t4.length) && !C2(t4);
          }, "Vt");
          const Kt = /* @__PURE__ */ __name(function(t4) {
            return Bt(t4) && Vt(t4);
          }, "Kt");
          const Wt = /* @__PURE__ */ __name(function() {
            return false;
          }, "Wt");
          var Zt = "object" == typeof exports2 && exports2 && !exports2.nodeType && exports2, Gt = Zt && "object" == typeof module2 && module2 && !module2.nodeType && module2, Xt = Gt && Gt.exports === Zt ? x2.Buffer : void 0;
          const Qt = (Xt ? Xt.isBuffer : void 0) || Wt;
          var Yt = Function.prototype, Jt = Object.prototype, te = Yt.toString, ee = Jt.hasOwnProperty, ne = te.call(Object);
          const re = /* @__PURE__ */ __name(function(t4) {
            if (!Bt(t4) || "[object Object]" != T2(t4))
              return false;
            var e4 = jt(t4);
            if (null === e4)
              return true;
            var n4 = ee.call(e4, "constructor") && e4.constructor;
            return "function" == typeof n4 && n4 instanceof n4 && te.call(n4) == ne;
          }, "re");
          var se = {};
          se["[object Float32Array]"] = se["[object Float64Array]"] = se["[object Int8Array]"] = se["[object Int16Array]"] = se["[object Int32Array]"] = se["[object Uint8Array]"] = se["[object Uint8ClampedArray]"] = se["[object Uint16Array]"] = se["[object Uint32Array]"] = true, se["[object Arguments]"] = se["[object Array]"] = se["[object ArrayBuffer]"] = se["[object Boolean]"] = se["[object DataView]"] = se["[object Date]"] = se["[object Error]"] = se["[object Function]"] = se["[object Map]"] = se["[object Number]"] = se["[object Object]"] = se["[object RegExp]"] = se["[object Set]"] = se["[object String]"] = se["[object WeakMap]"] = false;
          const ie = /* @__PURE__ */ __name(function(t4) {
            return Bt(t4) && $t(t4.length) && !!se[T2(t4)];
          }, "ie");
          const oe = /* @__PURE__ */ __name(function(t4) {
            return function(e4) {
              return t4(e4);
            };
          }, "oe");
          var le = "object" == typeof exports2 && exports2 && !exports2.nodeType && exports2, ae = le && "object" == typeof module2 && module2 && !module2.nodeType && module2, ce = ae && ae.exports === le && y2.process;
          const ue = function() {
            try {
              var t4 = ae && ae.require && ae.require("util").types;
              return t4 || ce && ce.binding && ce.binding("util");
            } catch (t5) {
            }
          }();
          var he = ue && ue.isTypedArray;
          const de = he ? oe(he) : ie;
          const fe = /* @__PURE__ */ __name(function(t4, e4) {
            if (("constructor" !== e4 || "function" != typeof t4[e4]) && "__proto__" != e4)
              return t4[e4];
          }, "fe");
          var pe = Object.prototype.hasOwnProperty;
          const ge = /* @__PURE__ */ __name(function(t4, e4, n4) {
            var r3 = t4[e4];
            pe.call(t4, e4) && i2(r3, n4) && (void 0 !== n4 || e4 in t4) || yt(t4, e4, n4);
          }, "ge");
          const me = /* @__PURE__ */ __name(function(t4, e4, n4, r3) {
            var s3 = !n4;
            n4 || (n4 = {});
            for (var i3 = -1, o3 = e4.length; ++i3 < o3; ) {
              var l3 = e4[i3], a3 = r3 ? r3(n4[l3], t4[l3], l3, n4, t4) : void 0;
              void 0 === a3 && (a3 = t4[l3]), s3 ? yt(n4, l3, a3) : ge(n4, l3, a3);
            }
            return n4;
          }, "me");
          const be = /* @__PURE__ */ __name(function(t4, e4) {
            for (var n4 = -1, r3 = Array(t4); ++n4 < t4; )
              r3[n4] = e4(n4);
            return r3;
          }, "be");
          var ye = /^(?:0|[1-9]\d*)$/;
          const ve = /* @__PURE__ */ __name(function(t4, e4) {
            var n4 = typeof t4;
            return !!(e4 = null == e4 ? 9007199254740991 : e4) && ("number" == n4 || "symbol" != n4 && ye.test(t4)) && t4 > -1 && t4 % 1 == 0 && t4 < e4;
          }, "ve");
          var xe = Object.prototype.hasOwnProperty;
          const Ne = /* @__PURE__ */ __name(function(t4, e4) {
            var n4 = Ft(t4), r3 = !n4 && Ht(t4), s3 = !n4 && !r3 && Qt(t4), i3 = !n4 && !r3 && !s3 && de(t4), o3 = n4 || r3 || s3 || i3, l3 = o3 ? be(t4.length, String) : [], a3 = l3.length;
            for (var c3 in t4)
              !e4 && !xe.call(t4, c3) || o3 && ("length" == c3 || s3 && ("offset" == c3 || "parent" == c3) || i3 && ("buffer" == c3 || "byteLength" == c3 || "byteOffset" == c3) || ve(c3, a3)) || l3.push(c3);
            return l3;
          }, "Ne");
          const we = /* @__PURE__ */ __name(function(t4) {
            var e4 = [];
            if (null != t4)
              for (var n4 in Object(t4))
                e4.push(n4);
            return e4;
          }, "we");
          var Ee = Object.prototype.hasOwnProperty;
          const Ae = /* @__PURE__ */ __name(function(t4) {
            if (!S2(t4))
              return we(t4);
            var e4 = It(t4), n4 = [];
            for (var r3 in t4)
              ("constructor" != r3 || !e4 && Ee.call(t4, r3)) && n4.push(r3);
            return n4;
          }, "Ae");
          const qe = /* @__PURE__ */ __name(function(t4) {
            return Vt(t4) ? Ne(t4, true) : Ae(t4);
          }, "qe");
          const ke = /* @__PURE__ */ __name(function(t4) {
            return me(t4, qe(t4));
          }, "ke");
          const _e = /* @__PURE__ */ __name(function(t4, e4, n4, r3, s3, i3, o3) {
            var l3 = fe(t4, n4), a3 = fe(e4, n4), c3 = o3.get(a3);
            if (c3)
              vt(t4, n4, c3);
            else {
              var u3 = i3 ? i3(l3, a3, n4 + "", t4, e4, o3) : void 0, h3 = void 0 === u3;
              if (h3) {
                var d3 = Ft(a3), f3 = !d3 && Qt(a3), p3 = !d3 && !f3 && de(a3);
                u3 = a3, d3 || f3 || p3 ? Ft(l3) ? u3 = l3 : Kt(l3) ? u3 = Ot(l3) : f3 ? (h3 = false, u3 = qt(a3, true)) : p3 ? (h3 = false, u3 = Lt(a3, true)) : u3 = [] : re(a3) || Ht(a3) ? (u3 = l3, Ht(l3) ? u3 = ke(l3) : S2(l3) && !C2(l3) || (u3 = Mt(a3))) : h3 = false;
              }
              h3 && (o3.set(a3, u3), s3(u3, a3, r3, i3, o3), o3.delete(a3)), vt(t4, n4, u3);
            }
          }, "_e");
          const Le = /* @__PURE__ */ __name(function t4(e4, n4, r3, s3, i3) {
            e4 !== n4 && xt(n4, function(o3, l3) {
              if (i3 || (i3 = new mt()), S2(o3))
                _e(e4, n4, l3, r3, t4, s3, i3);
              else {
                var a3 = s3 ? s3(fe(e4, l3), o3, l3 + "", e4, n4, i3) : void 0;
                void 0 === a3 && (a3 = o3), vt(e4, l3, a3);
              }
            }, qe);
          }, "t");
          const Oe = /* @__PURE__ */ __name(function(t4) {
            return t4;
          }, "Oe");
          const Te = /* @__PURE__ */ __name(function(t4, e4, n4) {
            switch (n4.length) {
              case 0:
                return t4.call(e4);
              case 1:
                return t4.call(e4, n4[0]);
              case 2:
                return t4.call(e4, n4[0], n4[1]);
              case 3:
                return t4.call(e4, n4[0], n4[1], n4[2]);
            }
            return t4.apply(e4, n4);
          }, "Te");
          var Se = Math.max;
          const Ce = /* @__PURE__ */ __name(function(t4, e4, n4) {
            return e4 = Se(void 0 === e4 ? t4.length - 1 : e4, 0), function() {
              for (var r3 = arguments, s3 = -1, i3 = Se(r3.length - e4, 0), o3 = Array(i3); ++s3 < i3; )
                o3[s3] = r3[e4 + s3];
              s3 = -1;
              for (var l3 = Array(e4 + 1); ++s3 < e4; )
                l3[s3] = r3[s3];
              return l3[e4] = n4(o3), Te(t4, this, l3);
            };
          }, "Ce");
          const je = /* @__PURE__ */ __name(function(t4) {
            return function() {
              return t4;
            };
          }, "je");
          const Re = bt ? function(t4, e4) {
            return bt(t4, "toString", { configurable: true, enumerable: false, value: je(e4), writable: true });
          } : Oe;
          var Ie = Date.now;
          const Me = /* @__PURE__ */ function(t4) {
            var e4 = 0, n4 = 0;
            return function() {
              var r3 = Ie(), s3 = 16 - (r3 - n4);
              if (n4 = r3, s3 > 0) {
                if (++e4 >= 800)
                  return arguments[0];
              } else
                e4 = 0;
              return t4.apply(void 0, arguments);
            };
          }(Re);
          const Be = /* @__PURE__ */ __name(function(t4, e4) {
            return Me(Ce(t4, e4, Oe), t4 + "");
          }, "Be");
          const Ue = /* @__PURE__ */ __name(function(t4, e4, n4) {
            if (!S2(n4))
              return false;
            var r3 = typeof e4;
            return !!("number" == r3 ? Vt(n4) && ve(e4, n4.length) : "string" == r3 && e4 in n4) && i2(n4[e4], t4);
          }, "Ue");
          const De = function(t4) {
            return Be(function(e4, n4) {
              var r3 = -1, s3 = n4.length, i3 = s3 > 1 ? n4[s3 - 1] : void 0, o3 = s3 > 2 ? n4[2] : void 0;
              for (i3 = t4.length > 3 && "function" == typeof i3 ? (s3--, i3) : void 0, o3 && Ue(n4[0], n4[1], o3) && (i3 = s3 < 3 ? void 0 : i3, s3 = 1), e4 = Object(e4); ++r3 < s3; ) {
                var l3 = n4[r3];
                l3 && t4(e4, l3, r3, i3);
              }
              return e4;
            });
          }(function(t4, e4, n4) {
            Le(t4, e4, n4);
          });
          var Pe = ((t4) => (t4[t4.TYPE = 3] = "TYPE", t4[t4.LEVEL = 12] = "LEVEL", t4[t4.ATTRIBUTE = 13] = "ATTRIBUTE", t4[t4.BLOT = 14] = "BLOT", t4[t4.INLINE = 7] = "INLINE", t4[t4.BLOCK = 11] = "BLOCK", t4[t4.BLOCK_BLOT = 10] = "BLOCK_BLOT", t4[t4.INLINE_BLOT = 6] = "INLINE_BLOT", t4[t4.BLOCK_ATTRIBUTE = 9] = "BLOCK_ATTRIBUTE", t4[t4.INLINE_ATTRIBUTE = 5] = "INLINE_ATTRIBUTE", t4[t4.ANY = 15] = "ANY", t4))(Pe || {});
          class ze {
            static {
              __name(this, "ze");
            }
            constructor(t4, e4, n4 = {}) {
              this.attrName = t4, this.keyName = e4;
              const r3 = Pe.TYPE & Pe.ATTRIBUTE;
              this.scope = null != n4.scope ? n4.scope & Pe.LEVEL | r3 : Pe.ATTRIBUTE, null != n4.whitelist && (this.whitelist = n4.whitelist);
            }
            static keys(t4) {
              return Array.from(t4.attributes).map((t5) => t5.name);
            }
            add(t4, e4) {
              return !!this.canAdd(t4, e4) && (t4.setAttribute(this.keyName, e4), true);
            }
            canAdd(t4, e4) {
              return null == this.whitelist || ("string" == typeof e4 ? this.whitelist.indexOf(e4.replace(/["']/g, "")) > -1 : this.whitelist.indexOf(e4) > -1);
            }
            remove(t4) {
              t4.removeAttribute(this.keyName);
            }
            value(t4) {
              const e4 = t4.getAttribute(this.keyName);
              return this.canAdd(t4, e4) && e4 ? e4 : "";
            }
          }
          class He extends Error {
            static {
              __name(this, "He");
            }
            constructor(t4) {
              super(t4 = "[Parchment] " + t4), this.message = t4, this.name = this.constructor.name;
            }
          }
          const Fe = class t4 {
            static {
              __name(this, "t");
            }
            constructor() {
              this.attributes = {}, this.classes = {}, this.tags = {}, this.types = {};
            }
            static find(t5, e4 = false) {
              if (null == t5)
                return null;
              if (this.blots.has(t5))
                return this.blots.get(t5) || null;
              if (e4) {
                let n4 = null;
                try {
                  n4 = t5.parentNode;
                } catch {
                  return null;
                }
                return this.find(n4, e4);
              }
              return null;
            }
            create(e4, n4, r3) {
              const s3 = this.query(n4);
              if (null == s3)
                throw new He(`Unable to create ${n4} blot`);
              const i3 = s3, o3 = n4 instanceof Node || n4.nodeType === Node.TEXT_NODE ? n4 : i3.create(r3), l3 = new i3(e4, o3, r3);
              return t4.blots.set(l3.domNode, l3), l3;
            }
            find(e4, n4 = false) {
              return t4.find(e4, n4);
            }
            query(t5, e4 = Pe.ANY) {
              let n4;
              return "string" == typeof t5 ? n4 = this.types[t5] || this.attributes[t5] : t5 instanceof Text || t5.nodeType === Node.TEXT_NODE ? n4 = this.types.text : "number" == typeof t5 ? t5 & Pe.LEVEL & Pe.BLOCK ? n4 = this.types.block : t5 & Pe.LEVEL & Pe.INLINE && (n4 = this.types.inline) : t5 instanceof Element && ((t5.getAttribute("class") || "").split(/\s+/).some((t6) => (n4 = this.classes[t6], !!n4)), n4 = n4 || this.tags[t5.tagName]), null == n4 ? null : "scope" in n4 && e4 & Pe.LEVEL & n4.scope && e4 & Pe.TYPE & n4.scope ? n4 : null;
            }
            register(...t5) {
              return t5.map((t6) => {
                const e4 = "blotName" in t6, n4 = "attrName" in t6;
                if (!e4 && !n4)
                  throw new He("Invalid definition");
                if (e4 && "abstract" === t6.blotName)
                  throw new He("Cannot register abstract class");
                const r3 = e4 ? t6.blotName : n4 ? t6.attrName : void 0;
                return this.types[r3] = t6, n4 ? "string" == typeof t6.keyName && (this.attributes[t6.keyName] = t6) : e4 && (t6.className && (this.classes[t6.className] = t6), t6.tagName && (Array.isArray(t6.tagName) ? t6.tagName = t6.tagName.map((t7) => t7.toUpperCase()) : t6.tagName = t6.tagName.toUpperCase(), (Array.isArray(t6.tagName) ? t6.tagName : [t6.tagName]).forEach((e5) => {
                  (null == this.tags[e5] || null == t6.className) && (this.tags[e5] = t6);
                }))), t6;
              });
            }
          };
          Fe.blots = /* @__PURE__ */ new WeakMap();
          let $e = Fe;
          function Ve(t4, e4) {
            return (t4.getAttribute("class") || "").split(/\s+/).filter((t5) => 0 === t5.indexOf(`${e4}-`));
          }
          __name(Ve, "Ve");
          const Ke = class extends ze {
            static {
              __name(this, "Ke");
            }
            static keys(t4) {
              return (t4.getAttribute("class") || "").split(/\s+/).map((t5) => t5.split("-").slice(0, -1).join("-"));
            }
            add(t4, e4) {
              return !!this.canAdd(t4, e4) && (this.remove(t4), t4.classList.add(`${this.keyName}-${e4}`), true);
            }
            remove(t4) {
              Ve(t4, this.keyName).forEach((e4) => {
                t4.classList.remove(e4);
              }), 0 === t4.classList.length && t4.removeAttribute("class");
            }
            value(t4) {
              const e4 = (Ve(t4, this.keyName)[0] || "").slice(this.keyName.length + 1);
              return this.canAdd(t4, e4) ? e4 : "";
            }
          };
          function We(t4) {
            const e4 = t4.split("-"), n4 = e4.slice(1).map((t5) => t5[0].toUpperCase() + t5.slice(1)).join("");
            return e4[0] + n4;
          }
          __name(We, "We");
          const Ze = class extends ze {
            static {
              __name(this, "Ze");
            }
            static keys(t4) {
              return (t4.getAttribute("style") || "").split(";").map((t5) => t5.split(":")[0].trim());
            }
            add(t4, e4) {
              return !!this.canAdd(t4, e4) && (t4.style[We(this.keyName)] = e4, true);
            }
            remove(t4) {
              t4.style[We(this.keyName)] = "", t4.getAttribute("style") || t4.removeAttribute("style");
            }
            value(t4) {
              const e4 = t4.style[We(this.keyName)];
              return this.canAdd(t4, e4) ? e4 : "";
            }
          };
          const Ge = class {
            static {
              __name(this, "Ge");
            }
            constructor(t4) {
              this.attributes = {}, this.domNode = t4, this.build();
            }
            attribute(t4, e4) {
              e4 ? t4.add(this.domNode, e4) && (null != t4.value(this.domNode) ? this.attributes[t4.attrName] = t4 : delete this.attributes[t4.attrName]) : (t4.remove(this.domNode), delete this.attributes[t4.attrName]);
            }
            build() {
              this.attributes = {};
              const t4 = $e.find(this.domNode);
              if (null == t4)
                return;
              const e4 = ze.keys(this.domNode), n4 = Ke.keys(this.domNode), r3 = Ze.keys(this.domNode);
              e4.concat(n4).concat(r3).forEach((e5) => {
                const n5 = t4.scroll.query(e5, Pe.ATTRIBUTE);
                n5 instanceof ze && (this.attributes[n5.attrName] = n5);
              });
            }
            copy(t4) {
              Object.keys(this.attributes).forEach((e4) => {
                const n4 = this.attributes[e4].value(this.domNode);
                t4.format(e4, n4);
              });
            }
            move(t4) {
              this.copy(t4), Object.keys(this.attributes).forEach((t5) => {
                this.attributes[t5].remove(this.domNode);
              }), this.attributes = {};
            }
            values() {
              return Object.keys(this.attributes).reduce((t4, e4) => (t4[e4] = this.attributes[e4].value(this.domNode), t4), {});
            }
          }, Xe = class {
            static {
              __name(this, "Xe");
            }
            constructor(t4, e4) {
              this.scroll = t4, this.domNode = e4, $e.blots.set(e4, this), this.prev = null, this.next = null;
            }
            static create(t4) {
              if (null == this.tagName)
                throw new He("Blot definition missing tagName");
              let e4, n4;
              return Array.isArray(this.tagName) ? ("string" == typeof t4 ? (n4 = t4.toUpperCase(), parseInt(n4, 10).toString() === n4 && (n4 = parseInt(n4, 10))) : "number" == typeof t4 && (n4 = t4), e4 = "number" == typeof n4 ? document.createElement(this.tagName[n4 - 1]) : n4 && this.tagName.indexOf(n4) > -1 ? document.createElement(n4) : document.createElement(this.tagName[0])) : e4 = document.createElement(this.tagName), this.className && e4.classList.add(this.className), e4;
            }
            get statics() {
              return this.constructor;
            }
            attach() {
            }
            clone() {
              const t4 = this.domNode.cloneNode(false);
              return this.scroll.create(t4);
            }
            detach() {
              null != this.parent && this.parent.removeChild(this), $e.blots.delete(this.domNode);
            }
            deleteAt(t4, e4) {
              this.isolate(t4, e4).remove();
            }
            formatAt(t4, e4, n4, r3) {
              const s3 = this.isolate(t4, e4);
              if (null != this.scroll.query(n4, Pe.BLOT) && r3)
                s3.wrap(n4, r3);
              else if (null != this.scroll.query(n4, Pe.ATTRIBUTE)) {
                const t5 = this.scroll.create(this.statics.scope);
                s3.wrap(t5), t5.format(n4, r3);
              }
            }
            insertAt(t4, e4, n4) {
              const r3 = null == n4 ? this.scroll.create("text", e4) : this.scroll.create(e4, n4), s3 = this.split(t4);
              this.parent.insertBefore(r3, s3 || void 0);
            }
            isolate(t4, e4) {
              const n4 = this.split(t4);
              if (null == n4)
                throw new Error("Attempt to isolate at end");
              return n4.split(e4), n4;
            }
            length() {
              return 1;
            }
            offset(t4 = this.parent) {
              return null == this.parent || this === t4 ? 0 : this.parent.children.offset(this) + this.parent.offset(t4);
            }
            optimize(t4) {
              this.statics.requiredContainer && !(this.parent instanceof this.statics.requiredContainer) && this.wrap(this.statics.requiredContainer.blotName);
            }
            remove() {
              null != this.domNode.parentNode && this.domNode.parentNode.removeChild(this.domNode), this.detach();
            }
            replaceWith(t4, e4) {
              const n4 = "string" == typeof t4 ? this.scroll.create(t4, e4) : t4;
              return null != this.parent && (this.parent.insertBefore(n4, this.next || void 0), this.remove()), n4;
            }
            split(t4, e4) {
              return 0 === t4 ? this : this.next;
            }
            update(t4, e4) {
            }
            wrap(t4, e4) {
              const n4 = "string" == typeof t4 ? this.scroll.create(t4, e4) : t4;
              if (null != this.parent && this.parent.insertBefore(n4, this.next || void 0), "function" != typeof n4.appendChild)
                throw new He(`Cannot wrap ${t4}`);
              return n4.appendChild(this), n4;
            }
          };
          Xe.blotName = "abstract";
          let Qe = Xe;
          const Ye = class extends Qe {
            static {
              __name(this, "Ye");
            }
            static value(t4) {
              return true;
            }
            index(t4, e4) {
              return this.domNode === t4 || this.domNode.compareDocumentPosition(t4) & Node.DOCUMENT_POSITION_CONTAINED_BY ? Math.min(e4, 1) : -1;
            }
            position(t4, e4) {
              let n4 = Array.from(this.parent.domNode.childNodes).indexOf(this.domNode);
              return t4 > 0 && (n4 += 1), [this.parent.domNode, n4];
            }
            value() {
              return { [this.statics.blotName]: this.statics.value(this.domNode) || true };
            }
          };
          Ye.scope = Pe.INLINE_BLOT;
          const Je = Ye;
          class tn {
            static {
              __name(this, "tn");
            }
            constructor() {
              this.head = null, this.tail = null, this.length = 0;
            }
            append(...t4) {
              if (this.insertBefore(t4[0], null), t4.length > 1) {
                const e4 = t4.slice(1);
                this.append(...e4);
              }
            }
            at(t4) {
              const e4 = this.iterator();
              let n4 = e4();
              for (; n4 && t4 > 0; )
                t4 -= 1, n4 = e4();
              return n4;
            }
            contains(t4) {
              const e4 = this.iterator();
              let n4 = e4();
              for (; n4; ) {
                if (n4 === t4)
                  return true;
                n4 = e4();
              }
              return false;
            }
            indexOf(t4) {
              const e4 = this.iterator();
              let n4 = e4(), r3 = 0;
              for (; n4; ) {
                if (n4 === t4)
                  return r3;
                r3 += 1, n4 = e4();
              }
              return -1;
            }
            insertBefore(t4, e4) {
              null != t4 && (this.remove(t4), t4.next = e4, null != e4 ? (t4.prev = e4.prev, null != e4.prev && (e4.prev.next = t4), e4.prev = t4, e4 === this.head && (this.head = t4)) : null != this.tail ? (this.tail.next = t4, t4.prev = this.tail, this.tail = t4) : (t4.prev = null, this.head = this.tail = t4), this.length += 1);
            }
            offset(t4) {
              let e4 = 0, n4 = this.head;
              for (; null != n4; ) {
                if (n4 === t4)
                  return e4;
                e4 += n4.length(), n4 = n4.next;
              }
              return -1;
            }
            remove(t4) {
              this.contains(t4) && (null != t4.prev && (t4.prev.next = t4.next), null != t4.next && (t4.next.prev = t4.prev), t4 === this.head && (this.head = t4.next), t4 === this.tail && (this.tail = t4.prev), this.length -= 1);
            }
            iterator(t4 = this.head) {
              return () => {
                const e4 = t4;
                return null != t4 && (t4 = t4.next), e4;
              };
            }
            find(t4, e4 = false) {
              const n4 = this.iterator();
              let r3 = n4();
              for (; r3; ) {
                const s3 = r3.length();
                if (t4 < s3 || e4 && t4 === s3 && (null == r3.next || 0 !== r3.next.length()))
                  return [r3, t4];
                t4 -= s3, r3 = n4();
              }
              return [null, 0];
            }
            forEach(t4) {
              const e4 = this.iterator();
              let n4 = e4();
              for (; n4; )
                t4(n4), n4 = e4();
            }
            forEachAt(t4, e4, n4) {
              if (e4 <= 0)
                return;
              const [r3, s3] = this.find(t4);
              let i3 = t4 - s3;
              const o3 = this.iterator(r3);
              let l3 = o3();
              for (; l3 && i3 < t4 + e4; ) {
                const r4 = l3.length();
                t4 > i3 ? n4(l3, t4 - i3, Math.min(e4, i3 + r4 - t4)) : n4(l3, 0, Math.min(r4, t4 + e4 - i3)), i3 += r4, l3 = o3();
              }
            }
            map(t4) {
              return this.reduce((e4, n4) => (e4.push(t4(n4)), e4), []);
            }
            reduce(t4, e4) {
              const n4 = this.iterator();
              let r3 = n4();
              for (; r3; )
                e4 = t4(e4, r3), r3 = n4();
              return e4;
            }
          }
          function en(t4, e4) {
            const n4 = e4.find(t4);
            if (n4)
              return n4;
            try {
              return e4.create(t4);
            } catch {
              const n5 = e4.create(Pe.INLINE);
              return Array.from(t4.childNodes).forEach((t5) => {
                n5.domNode.appendChild(t5);
              }), t4.parentNode && t4.parentNode.replaceChild(n5.domNode, t4), n5.attach(), n5;
            }
          }
          __name(en, "en");
          const nn = class t4 extends Qe {
            static {
              __name(this, "t");
            }
            constructor(t5, e4) {
              super(t5, e4), this.uiNode = null, this.build();
            }
            appendChild(t5) {
              this.insertBefore(t5);
            }
            attach() {
              super.attach(), this.children.forEach((t5) => {
                t5.attach();
              });
            }
            attachUI(e4) {
              null != this.uiNode && this.uiNode.remove(), this.uiNode = e4, t4.uiClass && this.uiNode.classList.add(t4.uiClass), this.uiNode.setAttribute("contenteditable", "false"), this.domNode.insertBefore(this.uiNode, this.domNode.firstChild);
            }
            build() {
              this.children = new tn(), Array.from(this.domNode.childNodes).filter((t5) => t5 !== this.uiNode).reverse().forEach((t5) => {
                try {
                  const e4 = en(t5, this.scroll);
                  this.insertBefore(e4, this.children.head || void 0);
                } catch (t6) {
                  if (t6 instanceof He)
                    return;
                  throw t6;
                }
              });
            }
            deleteAt(t5, e4) {
              if (0 === t5 && e4 === this.length())
                return this.remove();
              this.children.forEachAt(t5, e4, (t6, e5, n4) => {
                t6.deleteAt(e5, n4);
              });
            }
            descendant(e4, n4 = 0) {
              const [r3, s3] = this.children.find(n4);
              return null == e4.blotName && e4(r3) || null != e4.blotName && r3 instanceof e4 ? [r3, s3] : r3 instanceof t4 ? r3.descendant(e4, s3) : [null, -1];
            }
            descendants(e4, n4 = 0, r3 = Number.MAX_VALUE) {
              let s3 = [], i3 = r3;
              return this.children.forEachAt(n4, r3, (n5, r4, o3) => {
                (null == e4.blotName && e4(n5) || null != e4.blotName && n5 instanceof e4) && s3.push(n5), n5 instanceof t4 && (s3 = s3.concat(n5.descendants(e4, r4, i3))), i3 -= o3;
              }), s3;
            }
            detach() {
              this.children.forEach((t5) => {
                t5.detach();
              }), super.detach();
            }
            enforceAllowedChildren() {
              let e4 = false;
              this.children.forEach((n4) => {
                e4 || this.statics.allowedChildren.some((t5) => n4 instanceof t5) || (n4.statics.scope === Pe.BLOCK_BLOT ? (null != n4.next && this.splitAfter(n4), null != n4.prev && this.splitAfter(n4.prev), n4.parent.unwrap(), e4 = true) : n4 instanceof t4 ? n4.unwrap() : n4.remove());
              });
            }
            formatAt(t5, e4, n4, r3) {
              this.children.forEachAt(t5, e4, (t6, e5, s3) => {
                t6.formatAt(e5, s3, n4, r3);
              });
            }
            insertAt(t5, e4, n4) {
              const [r3, s3] = this.children.find(t5);
              if (r3)
                r3.insertAt(s3, e4, n4);
              else {
                const t6 = null == n4 ? this.scroll.create("text", e4) : this.scroll.create(e4, n4);
                this.appendChild(t6);
              }
            }
            insertBefore(t5, e4) {
              null != t5.parent && t5.parent.children.remove(t5);
              let n4 = null;
              this.children.insertBefore(t5, e4 || null), t5.parent = this, null != e4 && (n4 = e4.domNode), (this.domNode.parentNode !== t5.domNode || this.domNode.nextSibling !== n4) && this.domNode.insertBefore(t5.domNode, n4), t5.attach();
            }
            length() {
              return this.children.reduce((t5, e4) => t5 + e4.length(), 0);
            }
            moveChildren(t5, e4) {
              this.children.forEach((n4) => {
                t5.insertBefore(n4, e4);
              });
            }
            optimize(t5) {
              if (super.optimize(t5), this.enforceAllowedChildren(), null != this.uiNode && this.uiNode !== this.domNode.firstChild && this.domNode.insertBefore(this.uiNode, this.domNode.firstChild), 0 === this.children.length)
                if (null != this.statics.defaultChild) {
                  const t6 = this.scroll.create(this.statics.defaultChild.blotName);
                  this.appendChild(t6);
                } else
                  this.remove();
            }
            path(e4, n4 = false) {
              const [r3, s3] = this.children.find(e4, n4), i3 = [[this, e4]];
              return r3 instanceof t4 ? i3.concat(r3.path(s3, n4)) : (null != r3 && i3.push([r3, s3]), i3);
            }
            removeChild(t5) {
              this.children.remove(t5);
            }
            replaceWith(e4, n4) {
              const r3 = "string" == typeof e4 ? this.scroll.create(e4, n4) : e4;
              return r3 instanceof t4 && this.moveChildren(r3), super.replaceWith(r3);
            }
            split(t5, e4 = false) {
              if (!e4) {
                if (0 === t5)
                  return this;
                if (t5 === this.length())
                  return this.next;
              }
              const n4 = this.clone();
              return this.parent && this.parent.insertBefore(n4, this.next || void 0), this.children.forEachAt(t5, this.length(), (t6, r3, s3) => {
                const i3 = t6.split(r3, e4);
                null != i3 && n4.appendChild(i3);
              }), n4;
            }
            splitAfter(t5) {
              const e4 = this.clone();
              for (; null != t5.next; )
                e4.appendChild(t5.next);
              return this.parent && this.parent.insertBefore(e4, this.next || void 0), e4;
            }
            unwrap() {
              this.parent && this.moveChildren(this.parent, this.next || void 0), this.remove();
            }
            update(t5, e4) {
              const n4 = [], r3 = [];
              t5.forEach((t6) => {
                t6.target === this.domNode && "childList" === t6.type && (n4.push(...t6.addedNodes), r3.push(...t6.removedNodes));
              }), r3.forEach((t6) => {
                if (null != t6.parentNode && "IFRAME" !== t6.tagName && document.body.compareDocumentPosition(t6) & Node.DOCUMENT_POSITION_CONTAINED_BY)
                  return;
                const e5 = this.scroll.find(t6);
                null != e5 && (null == e5.domNode.parentNode || e5.domNode.parentNode === this.domNode) && e5.detach();
              }), n4.filter((t6) => t6.parentNode === this.domNode && t6 !== this.uiNode).sort((t6, e5) => t6 === e5 ? 0 : t6.compareDocumentPosition(e5) & Node.DOCUMENT_POSITION_FOLLOWING ? 1 : -1).forEach((t6) => {
                let e5 = null;
                null != t6.nextSibling && (e5 = this.scroll.find(t6.nextSibling));
                const n5 = en(t6, this.scroll);
                (n5.next !== e5 || null == n5.next) && (null != n5.parent && n5.parent.removeChild(this), this.insertBefore(n5, e5 || void 0));
              }), this.enforceAllowedChildren();
            }
          };
          nn.uiClass = "";
          const rn = nn;
          const sn = class t4 extends rn {
            static {
              __name(this, "t");
            }
            static create(t5) {
              return super.create(t5);
            }
            static formats(e4, n4) {
              const r3 = n4.query(t4.blotName);
              if (null == r3 || e4.tagName !== r3.tagName) {
                if ("string" == typeof this.tagName)
                  return true;
                if (Array.isArray(this.tagName))
                  return e4.tagName.toLowerCase();
              }
            }
            constructor(t5, e4) {
              super(t5, e4), this.attributes = new Ge(this.domNode);
            }
            format(e4, n4) {
              if (e4 !== this.statics.blotName || n4) {
                const t5 = this.scroll.query(e4, Pe.INLINE);
                if (null == t5)
                  return;
                t5 instanceof ze ? this.attributes.attribute(t5, n4) : n4 && (e4 !== this.statics.blotName || this.formats()[e4] !== n4) && this.replaceWith(e4, n4);
              } else
                this.children.forEach((e5) => {
                  e5 instanceof t4 || (e5 = e5.wrap(t4.blotName, true)), this.attributes.copy(e5);
                }), this.unwrap();
            }
            formats() {
              const t5 = this.attributes.values(), e4 = this.statics.formats(this.domNode, this.scroll);
              return null != e4 && (t5[this.statics.blotName] = e4), t5;
            }
            formatAt(t5, e4, n4, r3) {
              null != this.formats()[n4] || this.scroll.query(n4, Pe.ATTRIBUTE) ? this.isolate(t5, e4).format(n4, r3) : super.formatAt(t5, e4, n4, r3);
            }
            optimize(e4) {
              super.optimize(e4);
              const n4 = this.formats();
              if (0 === Object.keys(n4).length)
                return this.unwrap();
              const r3 = this.next;
              r3 instanceof t4 && r3.prev === this && function(t5, e5) {
                if (Object.keys(t5).length !== Object.keys(e5).length)
                  return false;
                for (const n5 in t5)
                  if (t5[n5] !== e5[n5])
                    return false;
                return true;
              }(n4, r3.formats()) && (r3.moveChildren(this), r3.remove());
            }
            replaceWith(t5, e4) {
              const n4 = super.replaceWith(t5, e4);
              return this.attributes.copy(n4), n4;
            }
            update(t5, e4) {
              super.update(t5, e4), t5.some((t6) => t6.target === this.domNode && "attributes" === t6.type) && this.attributes.build();
            }
            wrap(e4, n4) {
              const r3 = super.wrap(e4, n4);
              return r3 instanceof t4 && this.attributes.move(r3), r3;
            }
          };
          sn.allowedChildren = [sn, Je], sn.blotName = "inline", sn.scope = Pe.INLINE_BLOT, sn.tagName = "SPAN";
          const on = sn, ln = class t4 extends rn {
            static {
              __name(this, "t");
            }
            static create(t5) {
              return super.create(t5);
            }
            static formats(e4, n4) {
              const r3 = n4.query(t4.blotName);
              if (null == r3 || e4.tagName !== r3.tagName) {
                if ("string" == typeof this.tagName)
                  return true;
                if (Array.isArray(this.tagName))
                  return e4.tagName.toLowerCase();
              }
            }
            constructor(t5, e4) {
              super(t5, e4), this.attributes = new Ge(this.domNode);
            }
            format(e4, n4) {
              const r3 = this.scroll.query(e4, Pe.BLOCK);
              null != r3 && (r3 instanceof ze ? this.attributes.attribute(r3, n4) : e4 !== this.statics.blotName || n4 ? n4 && (e4 !== this.statics.blotName || this.formats()[e4] !== n4) && this.replaceWith(e4, n4) : this.replaceWith(t4.blotName));
            }
            formats() {
              const t5 = this.attributes.values(), e4 = this.statics.formats(this.domNode, this.scroll);
              return null != e4 && (t5[this.statics.blotName] = e4), t5;
            }
            formatAt(t5, e4, n4, r3) {
              null != this.scroll.query(n4, Pe.BLOCK) ? this.format(n4, r3) : super.formatAt(t5, e4, n4, r3);
            }
            insertAt(t5, e4, n4) {
              if (null == n4 || null != this.scroll.query(e4, Pe.INLINE))
                super.insertAt(t5, e4, n4);
              else {
                const r3 = this.split(t5);
                if (null == r3)
                  throw new Error("Attempt to insertAt after block boundaries");
                {
                  const t6 = this.scroll.create(e4, n4);
                  r3.parent.insertBefore(t6, r3);
                }
              }
            }
            replaceWith(t5, e4) {
              const n4 = super.replaceWith(t5, e4);
              return this.attributes.copy(n4), n4;
            }
            update(t5, e4) {
              super.update(t5, e4), t5.some((t6) => t6.target === this.domNode && "attributes" === t6.type) && this.attributes.build();
            }
          };
          ln.blotName = "block", ln.scope = Pe.BLOCK_BLOT, ln.tagName = "P", ln.allowedChildren = [on, ln, Je];
          const an = ln, cn = class extends rn {
            static {
              __name(this, "cn");
            }
            checkMerge() {
              return null !== this.next && this.next.statics.blotName === this.statics.blotName;
            }
            deleteAt(t4, e4) {
              super.deleteAt(t4, e4), this.enforceAllowedChildren();
            }
            formatAt(t4, e4, n4, r3) {
              super.formatAt(t4, e4, n4, r3), this.enforceAllowedChildren();
            }
            insertAt(t4, e4, n4) {
              super.insertAt(t4, e4, n4), this.enforceAllowedChildren();
            }
            optimize(t4) {
              super.optimize(t4), this.children.length > 0 && null != this.next && this.checkMerge() && (this.next.moveChildren(this), this.next.remove());
            }
          };
          cn.blotName = "container", cn.scope = Pe.BLOCK_BLOT;
          const un = cn;
          const hn = class extends Je {
            static {
              __name(this, "hn");
            }
            static formats(t4, e4) {
            }
            format(t4, e4) {
              super.formatAt(0, this.length(), t4, e4);
            }
            formatAt(t4, e4, n4, r3) {
              0 === t4 && e4 === this.length() ? this.format(n4, r3) : super.formatAt(t4, e4, n4, r3);
            }
            formats() {
              return this.statics.formats(this.domNode, this.scroll);
            }
          }, dn = { attributes: true, characterData: true, characterDataOldValue: true, childList: true, subtree: true }, fn = class extends rn {
            static {
              __name(this, "fn");
            }
            constructor(t4, e4) {
              super(null, e4), this.registry = t4, this.scroll = this, this.build(), this.observer = new MutationObserver((t5) => {
                this.update(t5);
              }), this.observer.observe(this.domNode, dn), this.attach();
            }
            create(t4, e4) {
              return this.registry.create(this, t4, e4);
            }
            find(t4, e4 = false) {
              const n4 = this.registry.find(t4, e4);
              return n4 ? n4.scroll === this ? n4 : e4 ? this.find(n4.scroll.domNode.parentNode, true) : null : null;
            }
            query(t4, e4 = Pe.ANY) {
              return this.registry.query(t4, e4);
            }
            register(...t4) {
              return this.registry.register(...t4);
            }
            build() {
              null != this.scroll && super.build();
            }
            detach() {
              super.detach(), this.observer.disconnect();
            }
            deleteAt(t4, e4) {
              this.update(), 0 === t4 && e4 === this.length() ? this.children.forEach((t5) => {
                t5.remove();
              }) : super.deleteAt(t4, e4);
            }
            formatAt(t4, e4, n4, r3) {
              this.update(), super.formatAt(t4, e4, n4, r3);
            }
            insertAt(t4, e4, n4) {
              this.update(), super.insertAt(t4, e4, n4);
            }
            optimize(t4 = [], e4 = {}) {
              super.optimize(e4);
              const n4 = e4.mutationsMap || /* @__PURE__ */ new WeakMap();
              let r3 = Array.from(this.observer.takeRecords());
              for (; r3.length > 0; )
                t4.push(r3.pop());
              const s3 = /* @__PURE__ */ __name((t5, e5 = true) => {
                null == t5 || t5 === this || null != t5.domNode.parentNode && (n4.has(t5.domNode) || n4.set(t5.domNode, []), e5 && s3(t5.parent));
              }, "s"), i3 = /* @__PURE__ */ __name((t5) => {
                n4.has(t5.domNode) && (t5 instanceof rn && t5.children.forEach(i3), n4.delete(t5.domNode), t5.optimize(e4));
              }, "i");
              let o3 = t4;
              for (let e5 = 0; o3.length > 0; e5 += 1) {
                if (e5 >= 100)
                  throw new Error("[Parchment] Maximum optimize iterations reached");
                for (o3.forEach((t5) => {
                  const e6 = this.find(t5.target, true);
                  null != e6 && (e6.domNode === t5.target && ("childList" === t5.type ? (s3(this.find(t5.previousSibling, false)), Array.from(t5.addedNodes).forEach((t6) => {
                    const e7 = this.find(t6, false);
                    s3(e7, false), e7 instanceof rn && e7.children.forEach((t7) => {
                      s3(t7, false);
                    });
                  })) : "attributes" === t5.type && s3(e6.prev)), s3(e6));
                }), this.children.forEach(i3), o3 = Array.from(this.observer.takeRecords()), r3 = o3.slice(); r3.length > 0; )
                  t4.push(r3.pop());
              }
            }
            update(t4, e4 = {}) {
              t4 = t4 || this.observer.takeRecords();
              const n4 = /* @__PURE__ */ new WeakMap();
              t4.map((t5) => {
                const e5 = this.find(t5.target, true);
                return null == e5 ? null : n4.has(e5.domNode) ? (n4.get(e5.domNode).push(t5), null) : (n4.set(e5.domNode, [t5]), e5);
              }).forEach((t5) => {
                null != t5 && t5 !== this && n4.has(t5.domNode) && t5.update(n4.get(t5.domNode) || [], e4);
              }), e4.mutationsMap = n4, n4.has(this.domNode) && super.update(n4.get(this.domNode), e4), this.optimize(t4, e4);
            }
          };
          fn.blotName = "scroll", fn.defaultChild = an, fn.allowedChildren = [an, un], fn.scope = Pe.BLOCK_BLOT, fn.tagName = "DIV";
          const pn = fn, gn = class t4 extends Je {
            static {
              __name(this, "t");
            }
            static create(t5) {
              return document.createTextNode(t5);
            }
            static value(t5) {
              return t5.data;
            }
            constructor(t5, e4) {
              super(t5, e4), this.text = this.statics.value(this.domNode);
            }
            deleteAt(t5, e4) {
              this.domNode.data = this.text = this.text.slice(0, t5) + this.text.slice(t5 + e4);
            }
            index(t5, e4) {
              return this.domNode === t5 ? e4 : -1;
            }
            insertAt(t5, e4, n4) {
              null == n4 ? (this.text = this.text.slice(0, t5) + e4 + this.text.slice(t5), this.domNode.data = this.text) : super.insertAt(t5, e4, n4);
            }
            length() {
              return this.text.length;
            }
            optimize(e4) {
              super.optimize(e4), this.text = this.statics.value(this.domNode), 0 === this.text.length ? this.remove() : this.next instanceof t4 && this.next.prev === this && (this.insertAt(this.length(), this.next.value()), this.next.remove());
            }
            position(t5, e4 = false) {
              return [this.domNode, t5];
            }
            split(t5, e4 = false) {
              if (!e4) {
                if (0 === t5)
                  return this;
                if (t5 === this.length())
                  return this.next;
              }
              const n4 = this.scroll.create(this.domNode.splitText(t5));
              return this.parent.insertBefore(n4, this.next || void 0), this.text = this.statics.value(this.domNode), n4;
            }
            update(t5, e4) {
              t5.some((t6) => "characterData" === t6.type && t6.target === this.domNode) && (this.text = this.statics.value(this.domNode));
            }
            value() {
              return this.text;
            }
          };
          gn.blotName = "text", gn.scope = Pe.INLINE_BLOT;
          const mn = gn;
          var bn = n3(660);
          const yn = /* @__PURE__ */ __name(function(t4, e4) {
            for (var n4 = -1, r3 = null == t4 ? 0 : t4.length; ++n4 < r3 && false !== e4(t4[n4], n4, t4); )
              ;
            return t4;
          }, "yn");
          const vn = Ct(Object.keys, Object);
          var xn = Object.prototype.hasOwnProperty;
          const Nn = /* @__PURE__ */ __name(function(t4) {
            if (!It(t4))
              return vn(t4);
            var e4 = [];
            for (var n4 in Object(t4))
              xn.call(t4, n4) && "constructor" != n4 && e4.push(n4);
            return e4;
          }, "Nn");
          const wn = /* @__PURE__ */ __name(function(t4) {
            return Vt(t4) ? Ne(t4) : Nn(t4);
          }, "wn");
          const En = /* @__PURE__ */ __name(function(t4, e4) {
            return t4 && me(e4, wn(e4), t4);
          }, "En");
          const An = /* @__PURE__ */ __name(function(t4, e4) {
            return t4 && me(e4, qe(e4), t4);
          }, "An");
          const qn = /* @__PURE__ */ __name(function(t4, e4) {
            for (var n4 = -1, r3 = null == t4 ? 0 : t4.length, s3 = 0, i3 = []; ++n4 < r3; ) {
              var o3 = t4[n4];
              e4(o3, n4, t4) && (i3[s3++] = o3);
            }
            return i3;
          }, "qn");
          const kn = /* @__PURE__ */ __name(function() {
            return [];
          }, "kn");
          var _n = Object.prototype.propertyIsEnumerable, Ln = Object.getOwnPropertySymbols;
          const On = Ln ? function(t4) {
            return null == t4 ? [] : (t4 = Object(t4), qn(Ln(t4), function(e4) {
              return _n.call(t4, e4);
            }));
          } : kn;
          const Tn = /* @__PURE__ */ __name(function(t4, e4) {
            return me(t4, On(t4), e4);
          }, "Tn");
          const Sn = /* @__PURE__ */ __name(function(t4, e4) {
            for (var n4 = -1, r3 = e4.length, s3 = t4.length; ++n4 < r3; )
              t4[s3 + n4] = e4[n4];
            return t4;
          }, "Sn");
          const Cn = Object.getOwnPropertySymbols ? function(t4) {
            for (var e4 = []; t4; )
              Sn(e4, On(t4)), t4 = jt(t4);
            return e4;
          } : kn;
          const jn = /* @__PURE__ */ __name(function(t4, e4) {
            return me(t4, Cn(t4), e4);
          }, "jn");
          const Rn = /* @__PURE__ */ __name(function(t4, e4, n4) {
            var r3 = e4(t4);
            return Ft(t4) ? r3 : Sn(r3, n4(t4));
          }, "Rn");
          const In = /* @__PURE__ */ __name(function(t4) {
            return Rn(t4, wn, On);
          }, "In");
          const Mn = /* @__PURE__ */ __name(function(t4) {
            return Rn(t4, qe, Cn);
          }, "Mn");
          const Bn = W2(x2, "DataView");
          const Un = W2(x2, "Promise");
          const Dn = W2(x2, "Set");
          const Pn = W2(x2, "WeakMap");
          var zn = "[object Map]", Hn = "[object Promise]", Fn = "[object Set]", $n = "[object WeakMap]", Vn = "[object DataView]", Kn = U2(Bn), Wn = U2(Z), Zn = U2(Un), Gn = U2(Dn), Xn = U2(Pn), Qn = T2;
          (Bn && Qn(new Bn(new ArrayBuffer(1))) != Vn || Z && Qn(new Z()) != zn || Un && Qn(Un.resolve()) != Hn || Dn && Qn(new Dn()) != Fn || Pn && Qn(new Pn()) != $n) && (Qn = /* @__PURE__ */ __name(function(t4) {
            var e4 = T2(t4), n4 = "[object Object]" == e4 ? t4.constructor : void 0, r3 = n4 ? U2(n4) : "";
            if (r3)
              switch (r3) {
                case Kn:
                  return Vn;
                case Wn:
                  return zn;
                case Zn:
                  return Hn;
                case Gn:
                  return Fn;
                case Xn:
                  return $n;
              }
            return e4;
          }, "Qn"));
          const Yn = Qn;
          var Jn = Object.prototype.hasOwnProperty;
          const tr = /* @__PURE__ */ __name(function(t4) {
            var e4 = t4.length, n4 = new t4.constructor(e4);
            return e4 && "string" == typeof t4[0] && Jn.call(t4, "index") && (n4.index = t4.index, n4.input = t4.input), n4;
          }, "tr");
          const er = /* @__PURE__ */ __name(function(t4, e4) {
            var n4 = e4 ? _t(t4.buffer) : t4.buffer;
            return new t4.constructor(n4, t4.byteOffset, t4.byteLength);
          }, "er");
          var nr = /\w*$/;
          const rr = /* @__PURE__ */ __name(function(t4) {
            var e4 = new t4.constructor(t4.source, nr.exec(t4));
            return e4.lastIndex = t4.lastIndex, e4;
          }, "rr");
          var sr = N2 ? N2.prototype : void 0, ir = sr ? sr.valueOf : void 0;
          const or = /* @__PURE__ */ __name(function(t4) {
            return ir ? Object(ir.call(t4)) : {};
          }, "or");
          const lr = /* @__PURE__ */ __name(function(t4, e4, n4) {
            var r3 = t4.constructor;
            switch (e4) {
              case "[object ArrayBuffer]":
                return _t(t4);
              case "[object Boolean]":
              case "[object Date]":
                return new r3(+t4);
              case "[object DataView]":
                return er(t4, n4);
              case "[object Float32Array]":
              case "[object Float64Array]":
              case "[object Int8Array]":
              case "[object Int16Array]":
              case "[object Int32Array]":
              case "[object Uint8Array]":
              case "[object Uint8ClampedArray]":
              case "[object Uint16Array]":
              case "[object Uint32Array]":
                return Lt(t4, n4);
              case "[object Map]":
              case "[object Set]":
                return new r3();
              case "[object Number]":
              case "[object String]":
                return new r3(t4);
              case "[object RegExp]":
                return rr(t4);
              case "[object Symbol]":
                return or(t4);
            }
          }, "lr");
          const ar = /* @__PURE__ */ __name(function(t4) {
            return Bt(t4) && "[object Map]" == Yn(t4);
          }, "ar");
          var cr = ue && ue.isMap;
          const ur = cr ? oe(cr) : ar;
          const hr = /* @__PURE__ */ __name(function(t4) {
            return Bt(t4) && "[object Set]" == Yn(t4);
          }, "hr");
          var dr = ue && ue.isSet;
          const fr = dr ? oe(dr) : hr;
          var pr = "[object Arguments]", gr = "[object Function]", mr = "[object Object]", br = {};
          br[pr] = br["[object Array]"] = br["[object ArrayBuffer]"] = br["[object DataView]"] = br["[object Boolean]"] = br["[object Date]"] = br["[object Float32Array]"] = br["[object Float64Array]"] = br["[object Int8Array]"] = br["[object Int16Array]"] = br["[object Int32Array]"] = br["[object Map]"] = br["[object Number]"] = br[mr] = br["[object RegExp]"] = br["[object Set]"] = br["[object String]"] = br["[object Symbol]"] = br["[object Uint8Array]"] = br["[object Uint8ClampedArray]"] = br["[object Uint16Array]"] = br["[object Uint32Array]"] = true, br["[object Error]"] = br[gr] = br["[object WeakMap]"] = false;
          const yr = /* @__PURE__ */ __name(function t4(e4, n4, r3, s3, i3, o3) {
            var l3, a3 = 1 & n4, c3 = 2 & n4, u3 = 4 & n4;
            if (r3 && (l3 = i3 ? r3(e4, s3, i3, o3) : r3(e4)), void 0 !== l3)
              return l3;
            if (!S2(e4))
              return e4;
            var h3 = Ft(e4);
            if (h3) {
              if (l3 = tr(e4), !a3)
                return Ot(e4, l3);
            } else {
              var d3 = Yn(e4), f3 = d3 == gr || "[object GeneratorFunction]" == d3;
              if (Qt(e4))
                return qt(e4, a3);
              if (d3 == mr || d3 == pr || f3 && !i3) {
                if (l3 = c3 || f3 ? {} : Mt(e4), !a3)
                  return c3 ? jn(e4, An(l3, e4)) : Tn(e4, En(l3, e4));
              } else {
                if (!br[d3])
                  return i3 ? e4 : {};
                l3 = lr(e4, d3, a3);
              }
            }
            o3 || (o3 = new mt());
            var p3 = o3.get(e4);
            if (p3)
              return p3;
            o3.set(e4, l3), fr(e4) ? e4.forEach(function(s4) {
              l3.add(t4(s4, n4, r3, s4, e4, o3));
            }) : ur(e4) && e4.forEach(function(s4, i4) {
              l3.set(i4, t4(s4, n4, r3, i4, e4, o3));
            });
            var g3 = h3 ? void 0 : (u3 ? c3 ? Mn : In : c3 ? qe : wn)(e4);
            return yn(g3 || e4, function(s4, i4) {
              g3 && (s4 = e4[i4 = s4]), ge(l3, i4, t4(s4, n4, r3, i4, e4, o3));
            }), l3;
          }, "t");
          const vr = /* @__PURE__ */ __name(function(t4) {
            return yr(t4, 5);
          }, "vr");
          const xr = /* @__PURE__ */ __name(function(t4) {
            return this.__data__.set(t4, "__lodash_hash_undefined__"), this;
          }, "xr");
          const Nr = /* @__PURE__ */ __name(function(t4) {
            return this.__data__.has(t4);
          }, "Nr");
          function wr(t4) {
            var e4 = -1, n4 = null == t4 ? 0 : t4.length;
            for (this.__data__ = new ft(); ++e4 < n4; )
              this.add(t4[e4]);
          }
          __name(wr, "wr");
          wr.prototype.add = wr.prototype.push = xr, wr.prototype.has = Nr;
          const Er = wr;
          const Ar = /* @__PURE__ */ __name(function(t4, e4) {
            for (var n4 = -1, r3 = null == t4 ? 0 : t4.length; ++n4 < r3; )
              if (e4(t4[n4], n4, t4))
                return true;
            return false;
          }, "Ar");
          const qr = /* @__PURE__ */ __name(function(t4, e4) {
            return t4.has(e4);
          }, "qr");
          const kr = /* @__PURE__ */ __name(function(t4, e4, n4, r3, s3, i3) {
            var o3 = 1 & n4, l3 = t4.length, a3 = e4.length;
            if (l3 != a3 && !(o3 && a3 > l3))
              return false;
            var c3 = i3.get(t4), u3 = i3.get(e4);
            if (c3 && u3)
              return c3 == e4 && u3 == t4;
            var h3 = -1, d3 = true, f3 = 2 & n4 ? new Er() : void 0;
            for (i3.set(t4, e4), i3.set(e4, t4); ++h3 < l3; ) {
              var p3 = t4[h3], g3 = e4[h3];
              if (r3)
                var m3 = o3 ? r3(g3, p3, h3, e4, t4, i3) : r3(p3, g3, h3, t4, e4, i3);
              if (void 0 !== m3) {
                if (m3)
                  continue;
                d3 = false;
                break;
              }
              if (f3) {
                if (!Ar(e4, function(t5, e5) {
                  if (!qr(f3, e5) && (p3 === t5 || s3(p3, t5, n4, r3, i3)))
                    return f3.push(e5);
                })) {
                  d3 = false;
                  break;
                }
              } else if (p3 !== g3 && !s3(p3, g3, n4, r3, i3)) {
                d3 = false;
                break;
              }
            }
            return i3.delete(t4), i3.delete(e4), d3;
          }, "kr");
          const _r = /* @__PURE__ */ __name(function(t4) {
            var e4 = -1, n4 = Array(t4.size);
            return t4.forEach(function(t5, r3) {
              n4[++e4] = [r3, t5];
            }), n4;
          }, "_r");
          const Lr = /* @__PURE__ */ __name(function(t4) {
            var e4 = -1, n4 = Array(t4.size);
            return t4.forEach(function(t5) {
              n4[++e4] = t5;
            }), n4;
          }, "Lr");
          var Or = N2 ? N2.prototype : void 0, Tr = Or ? Or.valueOf : void 0;
          const Sr = /* @__PURE__ */ __name(function(t4, e4, n4, r3, s3, o3, l3) {
            switch (n4) {
              case "[object DataView]":
                if (t4.byteLength != e4.byteLength || t4.byteOffset != e4.byteOffset)
                  return false;
                t4 = t4.buffer, e4 = e4.buffer;
              case "[object ArrayBuffer]":
                return !(t4.byteLength != e4.byteLength || !o3(new kt(t4), new kt(e4)));
              case "[object Boolean]":
              case "[object Date]":
              case "[object Number]":
                return i2(+t4, +e4);
              case "[object Error]":
                return t4.name == e4.name && t4.message == e4.message;
              case "[object RegExp]":
              case "[object String]":
                return t4 == e4 + "";
              case "[object Map]":
                var a3 = _r;
              case "[object Set]":
                var c3 = 1 & r3;
                if (a3 || (a3 = Lr), t4.size != e4.size && !c3)
                  return false;
                var u3 = l3.get(t4);
                if (u3)
                  return u3 == e4;
                r3 |= 2, l3.set(t4, e4);
                var h3 = kr(a3(t4), a3(e4), r3, s3, o3, l3);
                return l3.delete(t4), h3;
              case "[object Symbol]":
                if (Tr)
                  return Tr.call(t4) == Tr.call(e4);
            }
            return false;
          }, "Sr");
          var Cr = Object.prototype.hasOwnProperty;
          const jr = /* @__PURE__ */ __name(function(t4, e4, n4, r3, s3, i3) {
            var o3 = 1 & n4, l3 = In(t4), a3 = l3.length;
            if (a3 != In(e4).length && !o3)
              return false;
            for (var c3 = a3; c3--; ) {
              var u3 = l3[c3];
              if (!(o3 ? u3 in e4 : Cr.call(e4, u3)))
                return false;
            }
            var h3 = i3.get(t4), d3 = i3.get(e4);
            if (h3 && d3)
              return h3 == e4 && d3 == t4;
            var f3 = true;
            i3.set(t4, e4), i3.set(e4, t4);
            for (var p3 = o3; ++c3 < a3; ) {
              var g3 = t4[u3 = l3[c3]], m3 = e4[u3];
              if (r3)
                var b3 = o3 ? r3(m3, g3, u3, e4, t4, i3) : r3(g3, m3, u3, t4, e4, i3);
              if (!(void 0 === b3 ? g3 === m3 || s3(g3, m3, n4, r3, i3) : b3)) {
                f3 = false;
                break;
              }
              p3 || (p3 = "constructor" == u3);
            }
            if (f3 && !p3) {
              var y3 = t4.constructor, v3 = e4.constructor;
              y3 == v3 || !("constructor" in t4) || !("constructor" in e4) || "function" == typeof y3 && y3 instanceof y3 && "function" == typeof v3 && v3 instanceof v3 || (f3 = false);
            }
            return i3.delete(t4), i3.delete(e4), f3;
          }, "jr");
          var Rr = "[object Arguments]", Ir = "[object Array]", Mr = "[object Object]", Br = Object.prototype.hasOwnProperty;
          const Ur = /* @__PURE__ */ __name(function(t4, e4, n4, r3, s3, i3) {
            var o3 = Ft(t4), l3 = Ft(e4), a3 = o3 ? Ir : Yn(t4), c3 = l3 ? Ir : Yn(e4), u3 = (a3 = a3 == Rr ? Mr : a3) == Mr, h3 = (c3 = c3 == Rr ? Mr : c3) == Mr, d3 = a3 == c3;
            if (d3 && Qt(t4)) {
              if (!Qt(e4))
                return false;
              o3 = true, u3 = false;
            }
            if (d3 && !u3)
              return i3 || (i3 = new mt()), o3 || de(t4) ? kr(t4, e4, n4, r3, s3, i3) : Sr(t4, e4, a3, n4, r3, s3, i3);
            if (!(1 & n4)) {
              var f3 = u3 && Br.call(t4, "__wrapped__"), p3 = h3 && Br.call(e4, "__wrapped__");
              if (f3 || p3) {
                var g3 = f3 ? t4.value() : t4, m3 = p3 ? e4.value() : e4;
                return i3 || (i3 = new mt()), s3(g3, m3, n4, r3, i3);
              }
            }
            return !!d3 && (i3 || (i3 = new mt()), jr(t4, e4, n4, r3, s3, i3));
          }, "Ur");
          const Dr = /* @__PURE__ */ __name(function t4(e4, n4, r3, s3, i3) {
            return e4 === n4 || (null == e4 || null == n4 || !Bt(e4) && !Bt(n4) ? e4 != e4 && n4 != n4 : Ur(e4, n4, r3, s3, t4, i3));
          }, "t");
          const Pr = /* @__PURE__ */ __name(function(t4, e4) {
            return Dr(t4, e4);
          }, "Pr");
          class zr extends hn {
            static {
              __name(this, "zr");
            }
            static value() {
            }
            optimize() {
              (this.prev || this.next) && this.remove();
            }
            length() {
              return 0;
            }
            value() {
              return "";
            }
          }
          zr.blotName = "break", zr.tagName = "BR";
          const Hr = zr;
          class Fr extends mn {
            static {
              __name(this, "Fr");
            }
          }
          function $r(t4) {
            return t4.replace(/[&<>"']/g, (t5) => ({ "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" })[t5]);
          }
          __name($r, "$r");
          class Vr extends on {
            static {
              __name(this, "Vr");
            }
            static allowedChildren = [Vr, Hr, hn, Fr];
            static order = ["cursor", "inline", "link", "underline", "strike", "italic", "bold", "script", "code"];
            static compare(t4, e4) {
              const n4 = Vr.order.indexOf(t4), r3 = Vr.order.indexOf(e4);
              return n4 >= 0 || r3 >= 0 ? n4 - r3 : t4 === e4 ? 0 : t4 < e4 ? -1 : 1;
            }
            formatAt(t4, e4, n4, r3) {
              if (Vr.compare(this.statics.blotName, n4) < 0 && this.scroll.query(n4, Pe.BLOT)) {
                const s3 = this.isolate(t4, e4);
                r3 && s3.wrap(n4, r3);
              } else
                super.formatAt(t4, e4, n4, r3);
            }
            optimize(t4) {
              if (super.optimize(t4), this.parent instanceof Vr && Vr.compare(this.statics.blotName, this.parent.statics.blotName) > 0) {
                const t5 = this.parent.isolate(this.offset(), this.length());
                this.moveChildren(t5), t5.wrap(this);
              }
            }
          }
          const Kr = Vr;
          class Wr extends an {
            static {
              __name(this, "Wr");
            }
            cache = {};
            delta() {
              return null == this.cache.delta && (this.cache.delta = Gr(this)), this.cache.delta;
            }
            deleteAt(t4, e4) {
              super.deleteAt(t4, e4), this.cache = {};
            }
            formatAt(t4, e4, n4, r3) {
              e4 <= 0 || (this.scroll.query(n4, Pe.BLOCK) ? t4 + e4 === this.length() && this.format(n4, r3) : super.formatAt(t4, Math.min(e4, this.length() - t4 - 1), n4, r3), this.cache = {});
            }
            insertAt(t4, e4, n4) {
              if (null != n4)
                return super.insertAt(t4, e4, n4), void (this.cache = {});
              if (0 === e4.length)
                return;
              const r3 = e4.split("\n"), s3 = r3.shift();
              s3.length > 0 && (t4 < this.length() - 1 || null == this.children.tail ? super.insertAt(Math.min(t4, this.length() - 1), s3) : this.children.tail.insertAt(this.children.tail.length(), s3), this.cache = {});
              let i3 = this;
              r3.reduce((t5, e5) => (i3 = i3.split(t5, true), i3.insertAt(0, e5), e5.length), t4 + s3.length);
            }
            insertBefore(t4, e4) {
              const { head: n4 } = this.children;
              super.insertBefore(t4, e4), n4 instanceof Hr && n4.remove(), this.cache = {};
            }
            length() {
              return null == this.cache.length && (this.cache.length = super.length() + 1), this.cache.length;
            }
            moveChildren(t4, e4) {
              super.moveChildren(t4, e4), this.cache = {};
            }
            optimize(t4) {
              super.optimize(t4), this.cache = {};
            }
            path(t4) {
              return super.path(t4, true);
            }
            removeChild(t4) {
              super.removeChild(t4), this.cache = {};
            }
            split(t4) {
              let e4 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
              if (e4 && (0 === t4 || t4 >= this.length() - 1)) {
                const e5 = this.clone();
                return 0 === t4 ? (this.parent.insertBefore(e5, this), this) : (this.parent.insertBefore(e5, this.next), e5);
              }
              const n4 = super.split(t4, e4);
              return this.cache = {}, n4;
            }
          }
          Wr.blotName = "block", Wr.tagName = "P", Wr.defaultChild = Hr, Wr.allowedChildren = [Hr, Kr, hn, Fr];
          class Zr extends hn {
            static {
              __name(this, "Zr");
            }
            attach() {
              super.attach(), this.attributes = new Ge(this.domNode);
            }
            delta() {
              return new bn().insert(this.value(), { ...this.formats(), ...this.attributes.values() });
            }
            format(t4, e4) {
              const n4 = this.scroll.query(t4, Pe.BLOCK_ATTRIBUTE);
              null != n4 && this.attributes.attribute(n4, e4);
            }
            formatAt(t4, e4, n4, r3) {
              this.format(n4, r3);
            }
            insertAt(t4, e4, n4) {
              if (null != n4)
                return void super.insertAt(t4, e4, n4);
              const r3 = e4.split("\n"), s3 = r3.pop(), i3 = r3.map((t5) => {
                const e5 = this.scroll.create(Wr.blotName);
                return e5.insertAt(0, t5), e5;
              }), o3 = this.split(t4);
              i3.forEach((t5) => {
                this.parent.insertBefore(t5, o3);
              }), s3 && this.parent.insertBefore(this.scroll.create("text", s3), o3);
            }
          }
          function Gr(t4) {
            let e4 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
            return t4.descendants(Je).reduce((t5, n4) => 0 === n4.length() ? t5 : t5.insert(n4.value(), Xr(n4, {}, e4)), new bn()).insert("\n", Xr(t4));
          }
          __name(Gr, "Gr");
          function Xr(t4) {
            let e4 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, n4 = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
            return null == t4 ? e4 : ("formats" in t4 && "function" == typeof t4.formats && (e4 = { ...e4, ...t4.formats() }, n4 && delete e4["code-token"]), null == t4.parent || "scroll" === t4.parent.statics.blotName || t4.parent.statics.scope !== t4.statics.scope ? e4 : Xr(t4.parent, e4, n4));
          }
          __name(Xr, "Xr");
          Zr.scope = Pe.BLOCK_BLOT;
          class Qr extends hn {
            static {
              __name(this, "Qr");
            }
            static blotName = "cursor";
            static className = "ql-cursor";
            static tagName = "span";
            static CONTENTS = "\uFEFF";
            static value() {
            }
            constructor(t4, e4, n4) {
              super(t4, e4), this.selection = n4, this.textNode = document.createTextNode(Qr.CONTENTS), this.domNode.appendChild(this.textNode), this.savedLength = 0;
            }
            detach() {
              null != this.parent && this.parent.removeChild(this);
            }
            format(t4, e4) {
              if (0 !== this.savedLength)
                return void super.format(t4, e4);
              let n4 = this, r3 = 0;
              for (; null != n4 && n4.statics.scope !== Pe.BLOCK_BLOT; )
                r3 += n4.offset(n4.parent), n4 = n4.parent;
              null != n4 && (this.savedLength = Qr.CONTENTS.length, n4.optimize(), n4.formatAt(r3, Qr.CONTENTS.length, t4, e4), this.savedLength = 0);
            }
            index(t4, e4) {
              return t4 === this.textNode ? 0 : super.index(t4, e4);
            }
            length() {
              return this.savedLength;
            }
            position() {
              return [this.textNode, this.textNode.data.length];
            }
            remove() {
              super.remove(), this.parent = null;
            }
            restore() {
              if (this.selection.composing || null == this.parent)
                return null;
              const t4 = this.selection.getNativeRange();
              for (; null != this.domNode.lastChild && this.domNode.lastChild !== this.textNode; )
                this.domNode.parentNode.insertBefore(this.domNode.lastChild, this.domNode);
              const e4 = this.prev instanceof Fr ? this.prev : null, n4 = e4 ? e4.length() : 0, r3 = this.next instanceof Fr ? this.next : null, s3 = r3 ? r3.text : "", { textNode: i3 } = this, o3 = i3.data.split(Qr.CONTENTS).join("");
              let l3;
              if (i3.data = Qr.CONTENTS, e4)
                l3 = e4, (o3 || r3) && (e4.insertAt(e4.length(), o3 + s3), r3 && r3.remove());
              else if (r3)
                l3 = r3, r3.insertAt(0, o3);
              else {
                const t5 = document.createTextNode(o3);
                l3 = this.scroll.create(t5), this.parent.insertBefore(l3, this);
              }
              if (this.remove(), t4) {
                const s4 = /* @__PURE__ */ __name((t5, s5) => e4 && t5 === e4.domNode ? s5 : t5 === i3 ? n4 + s5 - 1 : r3 && t5 === r3.domNode ? n4 + o3.length + s5 : null, "s"), a3 = s4(t4.start.node, t4.start.offset), c3 = s4(t4.end.node, t4.end.offset);
                if (null !== a3 && null !== c3)
                  return { startNode: l3.domNode, startOffset: a3, endNode: l3.domNode, endOffset: c3 };
              }
              return null;
            }
            update(t4, e4) {
              if (t4.some((t5) => "characterData" === t5.type && t5.target === this.textNode)) {
                const t5 = this.restore();
                t5 && (e4.range = t5);
              }
            }
            optimize(t4) {
              super.optimize(t4);
              let { parent: e4 } = this;
              for (; e4; ) {
                if ("A" === e4.domNode.tagName) {
                  this.savedLength = Qr.CONTENTS.length, e4.isolate(this.offset(e4), this.length()).unwrap(), this.savedLength = 0;
                  break;
                }
                e4 = e4.parent;
              }
            }
            value() {
              return "";
            }
          }
          const Yr = Qr;
          var Jr = n3(228);
          const ts = /* @__PURE__ */ new WeakMap(), es = ["error", "warn", "log", "info"];
          let ns = "warn";
          function rs(t4) {
            if (ns && es.indexOf(t4) <= es.indexOf(ns)) {
              for (var e4 = arguments.length, n4 = new Array(e4 > 1 ? e4 - 1 : 0), r3 = 1; r3 < e4; r3++)
                n4[r3 - 1] = arguments[r3];
              console[t4](...n4);
            }
          }
          __name(rs, "rs");
          function ss(t4) {
            return es.reduce((e4, n4) => (e4[n4] = rs.bind(console, n4, t4), e4), {});
          }
          __name(ss, "ss");
          ss.level = (t4) => {
            ns = t4;
          }, rs.level = ss.level;
          const is = ss, os = is("quill:events");
          ["selectionchange", "mousedown", "mouseup", "click"].forEach((t4) => {
            document.addEventListener(t4, function() {
              for (var t5 = arguments.length, e4 = new Array(t5), n4 = 0; n4 < t5; n4++)
                e4[n4] = arguments[n4];
              Array.from(document.querySelectorAll(".ql-container")).forEach((t6) => {
                const n5 = ts.get(t6);
                n5 && n5.emitter && n5.emitter.handleDOM(...e4);
              });
            });
          });
          const ls = class extends Jr {
            static {
              __name(this, "ls");
            }
            static events = { EDITOR_CHANGE: "editor-change", SCROLL_BEFORE_UPDATE: "scroll-before-update", SCROLL_BLOT_MOUNT: "scroll-blot-mount", SCROLL_BLOT_UNMOUNT: "scroll-blot-unmount", SCROLL_OPTIMIZE: "scroll-optimize", SCROLL_UPDATE: "scroll-update", SCROLL_EMBED_UPDATE: "scroll-embed-update", SELECTION_CHANGE: "selection-change", TEXT_CHANGE: "text-change", COMPOSITION_BEFORE_START: "composition-before-start", COMPOSITION_START: "composition-start", COMPOSITION_BEFORE_END: "composition-before-end", COMPOSITION_END: "composition-end" };
            static sources = { API: "api", SILENT: "silent", USER: "user" };
            constructor() {
              super(), this.domListeners = {}, this.on("error", os.error);
            }
            emit() {
              for (var t4 = arguments.length, e4 = new Array(t4), n4 = 0; n4 < t4; n4++)
                e4[n4] = arguments[n4];
              return os.log.call(os, ...e4), super.emit(...e4);
            }
            handleDOM(t4) {
              for (var e4 = arguments.length, n4 = new Array(e4 > 1 ? e4 - 1 : 0), r3 = 1; r3 < e4; r3++)
                n4[r3 - 1] = arguments[r3];
              (this.domListeners[t4.type] || []).forEach((e5) => {
                let { node: r4, handler: s3 } = e5;
                (t4.target === r4 || r4.contains(t4.target)) && s3(t4, ...n4);
              });
            }
            listenDOM(t4, e4, n4) {
              this.domListeners[t4] || (this.domListeners[t4] = []), this.domListeners[t4].push({ node: e4, handler: n4 });
            }
          }, as = is("quill:selection");
          class cs {
            static {
              __name(this, "cs");
            }
            constructor(t4) {
              let e4 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
              this.index = t4, this.length = e4;
            }
          }
          function us(t4, e4) {
            try {
              e4.parentNode;
            } catch (t5) {
              return false;
            }
            return t4.contains(e4);
          }
          __name(us, "us");
          const hs = class {
            static {
              __name(this, "hs");
            }
            constructor(t4, e4) {
              this.emitter = e4, this.scroll = t4, this.composing = false, this.mouseDown = false, this.root = this.scroll.domNode, this.cursor = this.scroll.create("cursor", this), this.savedRange = new cs(0, 0), this.lastRange = this.savedRange, this.lastNative = null, this.handleComposition(), this.handleDragging(), this.emitter.listenDOM("selectionchange", document, () => {
                this.mouseDown || this.composing || setTimeout(this.update.bind(this, ls.sources.USER), 1);
              }), this.emitter.on(ls.events.SCROLL_BEFORE_UPDATE, () => {
                if (!this.hasFocus())
                  return;
                const t5 = this.getNativeRange();
                null != t5 && t5.start.node !== this.cursor.textNode && this.emitter.once(ls.events.SCROLL_UPDATE, (e5, n4) => {
                  try {
                    this.root.contains(t5.start.node) && this.root.contains(t5.end.node) && this.setNativeRange(t5.start.node, t5.start.offset, t5.end.node, t5.end.offset);
                    const r3 = n4.some((t6) => "characterData" === t6.type || "childList" === t6.type || "attributes" === t6.type && t6.target === this.root);
                    this.update(r3 ? ls.sources.SILENT : e5);
                  } catch (t6) {
                  }
                });
              }), this.emitter.on(ls.events.SCROLL_OPTIMIZE, (t5, e5) => {
                if (e5.range) {
                  const { startNode: t6, startOffset: n4, endNode: r3, endOffset: s3 } = e5.range;
                  this.setNativeRange(t6, n4, r3, s3), this.update(ls.sources.SILENT);
                }
              }), this.update(ls.sources.SILENT);
            }
            handleComposition() {
              this.emitter.on(ls.events.COMPOSITION_BEFORE_START, () => {
                this.composing = true;
              }), this.emitter.on(ls.events.COMPOSITION_END, () => {
                if (this.composing = false, this.cursor.parent) {
                  const t4 = this.cursor.restore();
                  if (!t4)
                    return;
                  setTimeout(() => {
                    this.setNativeRange(t4.startNode, t4.startOffset, t4.endNode, t4.endOffset);
                  }, 1);
                }
              });
            }
            handleDragging() {
              this.emitter.listenDOM("mousedown", document.body, () => {
                this.mouseDown = true;
              }), this.emitter.listenDOM("mouseup", document.body, () => {
                this.mouseDown = false, this.update(ls.sources.USER);
              });
            }
            focus() {
              this.hasFocus() || (this.root.focus({ preventScroll: true }), this.setRange(this.savedRange));
            }
            format(t4, e4) {
              this.scroll.update();
              const n4 = this.getNativeRange();
              if (null != n4 && n4.native.collapsed && !this.scroll.query(t4, Pe.BLOCK)) {
                if (n4.start.node !== this.cursor.textNode) {
                  const t5 = this.scroll.find(n4.start.node, false);
                  if (null == t5)
                    return;
                  if (t5 instanceof Je) {
                    const e5 = t5.split(n4.start.offset);
                    t5.parent.insertBefore(this.cursor, e5);
                  } else
                    t5.insertBefore(this.cursor, n4.start.node);
                  this.cursor.attach();
                }
                this.cursor.format(t4, e4), this.scroll.optimize(), this.setNativeRange(this.cursor.textNode, this.cursor.textNode.data.length), this.update();
              }
            }
            getBounds(t4) {
              let e4 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
              const n4 = this.scroll.length();
              let r3;
              t4 = Math.min(t4, n4 - 1), e4 = Math.min(t4 + e4, n4 - 1) - t4;
              let [s3, i3] = this.scroll.leaf(t4);
              if (null == s3)
                return null;
              if (e4 > 0 && i3 === s3.length()) {
                const [e5] = this.scroll.leaf(t4 + 1);
                if (e5) {
                  const [n5] = this.scroll.line(t4), [r4] = this.scroll.line(t4 + 1);
                  n5 === r4 && (s3 = e5, i3 = 0);
                }
              }
              [r3, i3] = s3.position(i3, true);
              const o3 = document.createRange();
              if (e4 > 0)
                return o3.setStart(r3, i3), [s3, i3] = this.scroll.leaf(t4 + e4), null == s3 ? null : ([r3, i3] = s3.position(i3, true), o3.setEnd(r3, i3), o3.getBoundingClientRect());
              let l3, a3 = "left";
              if (r3 instanceof Text) {
                if (!r3.data.length)
                  return null;
                i3 < r3.data.length ? (o3.setStart(r3, i3), o3.setEnd(r3, i3 + 1)) : (o3.setStart(r3, i3 - 1), o3.setEnd(r3, i3), a3 = "right"), l3 = o3.getBoundingClientRect();
              } else {
                if (!(s3.domNode instanceof Element))
                  return null;
                l3 = s3.domNode.getBoundingClientRect(), i3 > 0 && (a3 = "right");
              }
              return { bottom: l3.top + l3.height, height: l3.height, left: l3[a3], right: l3[a3], top: l3.top, width: 0 };
            }
            getNativeRange() {
              const t4 = document.getSelection();
              if (null == t4 || t4.rangeCount <= 0)
                return null;
              const e4 = t4.getRangeAt(0);
              if (null == e4)
                return null;
              const n4 = this.normalizeNative(e4);
              return as.info("getNativeRange", n4), n4;
            }
            getRange() {
              const t4 = this.scroll.domNode;
              if ("isConnected" in t4 && !t4.isConnected)
                return [null, null];
              const e4 = this.getNativeRange();
              if (null == e4)
                return [null, null];
              return [this.normalizedToRange(e4), e4];
            }
            hasFocus() {
              return document.activeElement === this.root || null != document.activeElement && us(this.root, document.activeElement);
            }
            normalizedToRange(t4) {
              const e4 = [[t4.start.node, t4.start.offset]];
              t4.native.collapsed || e4.push([t4.end.node, t4.end.offset]);
              const n4 = e4.map((t5) => {
                const [e5, n5] = t5, r4 = this.scroll.find(e5, true), s4 = r4.offset(this.scroll);
                return 0 === n5 ? s4 : r4 instanceof Je ? s4 + r4.index(e5, n5) : s4 + r4.length();
              }), r3 = Math.min(Math.max(...n4), this.scroll.length() - 1), s3 = Math.min(r3, ...n4);
              return new cs(s3, r3 - s3);
            }
            normalizeNative(t4) {
              if (!us(this.root, t4.startContainer) || !t4.collapsed && !us(this.root, t4.endContainer))
                return null;
              const e4 = { start: { node: t4.startContainer, offset: t4.startOffset }, end: { node: t4.endContainer, offset: t4.endOffset }, native: t4 };
              return [e4.start, e4.end].forEach((t5) => {
                let { node: e5, offset: n4 } = t5;
                for (; !(e5 instanceof Text) && e5.childNodes.length > 0; )
                  if (e5.childNodes.length > n4)
                    e5 = e5.childNodes[n4], n4 = 0;
                  else {
                    if (e5.childNodes.length !== n4)
                      break;
                    e5 = e5.lastChild, n4 = e5 instanceof Text ? e5.data.length : e5.childNodes.length > 0 ? e5.childNodes.length : e5.childNodes.length + 1;
                  }
                t5.node = e5, t5.offset = n4;
              }), e4;
            }
            rangeToNative(t4) {
              const e4 = this.scroll.length(), n4 = /* @__PURE__ */ __name((t5, n5) => {
                t5 = Math.min(e4 - 1, t5);
                const [r3, s3] = this.scroll.leaf(t5);
                return r3 ? r3.position(s3, n5) : [null, -1];
              }, "n");
              return [...n4(t4.index, false), ...n4(t4.index + t4.length, true)];
            }
            setNativeRange(t4, e4) {
              let n4 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : t4, r3 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : e4, s3 = arguments.length > 4 && void 0 !== arguments[4] && arguments[4];
              if (as.info("setNativeRange", t4, e4, n4, r3), null != t4 && (null == this.root.parentNode || null == t4.parentNode || null == n4.parentNode))
                return;
              const i3 = document.getSelection();
              if (null != i3)
                if (null != t4) {
                  this.hasFocus() || this.root.focus({ preventScroll: true });
                  const { native: o3 } = this.getNativeRange() || {};
                  if (null == o3 || s3 || t4 !== o3.startContainer || e4 !== o3.startOffset || n4 !== o3.endContainer || r3 !== o3.endOffset) {
                    t4 instanceof Element && "BR" === t4.tagName && (e4 = Array.from(t4.parentNode.childNodes).indexOf(t4), t4 = t4.parentNode), n4 instanceof Element && "BR" === n4.tagName && (r3 = Array.from(n4.parentNode.childNodes).indexOf(n4), n4 = n4.parentNode);
                    const s4 = document.createRange();
                    s4.setStart(t4, e4), s4.setEnd(n4, r3), i3.removeAllRanges(), i3.addRange(s4);
                  }
                } else
                  i3.removeAllRanges(), this.root.blur();
            }
            setRange(t4) {
              let e4 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], n4 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : ls.sources.API;
              if ("string" == typeof e4 && (n4 = e4, e4 = false), as.info("setRange", t4), null != t4) {
                const n5 = this.rangeToNative(t4);
                this.setNativeRange(...n5, e4);
              } else
                this.setNativeRange(null);
              this.update(n4);
            }
            update() {
              let t4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ls.sources.USER;
              const e4 = this.lastRange, [n4, r3] = this.getRange();
              if (this.lastRange = n4, this.lastNative = r3, null != this.lastRange && (this.savedRange = this.lastRange), !Pr(e4, this.lastRange)) {
                if (!this.composing && null != r3 && r3.native.collapsed && r3.start.node !== this.cursor.textNode) {
                  const t5 = this.cursor.restore();
                  t5 && this.setNativeRange(t5.startNode, t5.startOffset, t5.endNode, t5.endOffset);
                }
                const n5 = [ls.events.SELECTION_CHANGE, vr(this.lastRange), vr(e4), t4];
                this.emitter.emit(ls.events.EDITOR_CHANGE, ...n5), t4 !== ls.sources.SILENT && this.emitter.emit(...n5);
              }
            }
          }, ds = /^[ -~]*$/;
          function fs(t4, e4, n4) {
            if (0 === t4.length) {
              const [t5] = ms(n4.pop());
              return e4 <= 0 ? `</li></${t5}>` : `</li></${t5}>${fs([], e4 - 1, n4)}`;
            }
            const [{ child: r3, offset: s3, length: i3, indent: o3, type: l3 }, ...a3] = t4, [c3, u3] = ms(l3);
            if (o3 > e4)
              return n4.push(l3), o3 === e4 + 1 ? `<${c3}><li${u3}>${ps(r3, s3, i3)}${fs(a3, o3, n4)}` : `<${c3}><li>${fs(t4, e4 + 1, n4)}`;
            const h3 = n4[n4.length - 1];
            if (o3 === e4 && l3 === h3)
              return `</li><li${u3}>${ps(r3, s3, i3)}${fs(a3, o3, n4)}`;
            const [d3] = ms(n4.pop());
            return `</li></${d3}>${fs(t4, e4 - 1, n4)}`;
          }
          __name(fs, "fs");
          function ps(t4, e4, n4) {
            let r3 = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
            if ("html" in t4 && "function" == typeof t4.html)
              return t4.html(e4, n4);
            if (t4 instanceof Fr)
              return $r(t4.value().slice(e4, e4 + n4));
            if (t4 instanceof rn) {
              if ("list-container" === t4.statics.blotName) {
                const r4 = [];
                return t4.children.forEachAt(e4, n4, (t5, e5, n5) => {
                  const s4 = "formats" in t5 && "function" == typeof t5.formats ? t5.formats() : {};
                  r4.push({ child: t5, offset: e5, length: n5, indent: s4.indent || 0, type: s4.list });
                }), fs(r4, -1, []);
              }
              const s3 = [];
              if (t4.children.forEachAt(e4, n4, (t5, e5, n5) => {
                s3.push(ps(t5, e5, n5));
              }), r3 || "list" === t4.statics.blotName)
                return s3.join("");
              const { outerHTML: i3, innerHTML: o3 } = t4.domNode, [l3, a3] = i3.split(`>${o3}<`);
              return "<table" === l3 ? `<table style="border: 1px solid #000;">${s3.join("")}<${a3}` : `${l3}>${s3.join("")}<${a3}`;
            }
            return t4.domNode instanceof Element ? t4.domNode.outerHTML : "";
          }
          __name(ps, "ps");
          function gs(t4, e4) {
            return Object.keys(e4).reduce((n4, r3) => {
              if (null == t4[r3])
                return n4;
              const s3 = e4[r3];
              return s3 === t4[r3] ? n4[r3] = s3 : Array.isArray(s3) ? s3.indexOf(t4[r3]) < 0 ? n4[r3] = s3.concat([t4[r3]]) : n4[r3] = s3 : n4[r3] = [s3, t4[r3]], n4;
            }, {});
          }
          __name(gs, "gs");
          function ms(t4) {
            const e4 = "ordered" === t4 ? "ol" : "ul";
            switch (t4) {
              case "checked":
                return [e4, ' data-list="checked"'];
              case "unchecked":
                return [e4, ' data-list="unchecked"'];
              default:
                return [e4, ""];
            }
          }
          __name(ms, "ms");
          function bs(t4) {
            return t4.reduce((t5, e4) => {
              if ("string" == typeof e4.insert) {
                const n4 = e4.insert.replace(/\r\n/g, "\n").replace(/\r/g, "\n");
                return t5.insert(n4, e4.attributes);
              }
              return t5.push(e4);
            }, new bn());
          }
          __name(bs, "bs");
          function ys(t4, e4) {
            let { index: n4, length: r3 } = t4;
            return new cs(n4 + e4, r3);
          }
          __name(ys, "ys");
          const vs = class {
            static {
              __name(this, "vs");
            }
            constructor(t4) {
              this.scroll = t4, this.delta = this.getDelta();
            }
            applyDelta(t4) {
              this.scroll.update();
              let e4 = this.scroll.length();
              this.scroll.batchStart();
              const n4 = bs(t4), r3 = new bn();
              return function(t5) {
                const e5 = [];
                return t5.forEach((t6) => {
                  if ("string" == typeof t6.insert) {
                    t6.insert.split("\n").forEach((n5, r4) => {
                      r4 && e5.push({ insert: "\n", attributes: t6.attributes }), n5 && e5.push({ insert: n5, attributes: t6.attributes });
                    });
                  } else
                    e5.push(t6);
                }), e5;
              }(n4.ops.slice()).reduce((t5, n5) => {
                const s3 = bn.Op.length(n5);
                let i3 = n5.attributes || {}, o3 = false, l3 = false;
                if (null != n5.insert) {
                  if (r3.retain(s3), "string" == typeof n5.insert) {
                    const r4 = n5.insert;
                    l3 = !r4.endsWith("\n") && (e4 <= t5 || !!this.scroll.descendant(Zr, t5)[0]), this.scroll.insertAt(t5, r4);
                    const [s4, o4] = this.scroll.line(t5);
                    let a4 = De({}, Xr(s4));
                    if (s4 instanceof Wr) {
                      const [t6] = s4.descendant(Je, o4);
                      t6 && (a4 = De(a4, Xr(t6)));
                    }
                    i3 = bn.AttributeMap.diff(a4, i3) || {};
                  } else if ("object" == typeof n5.insert) {
                    const r4 = Object.keys(n5.insert)[0];
                    if (null == r4)
                      return t5;
                    const s4 = null != this.scroll.query(r4, Pe.INLINE);
                    if (s4)
                      (e4 <= t5 || this.scroll.descendant(Zr, t5)[0]) && (l3 = true);
                    else if (t5 > 0) {
                      const [e5, n6] = this.scroll.descendant(Je, t5 - 1);
                      if (e5 instanceof Fr) {
                        "\n" !== e5.value()[n6] && (o3 = true);
                      } else
                        e5 instanceof hn && e5.statics.scope === Pe.INLINE_BLOT && (o3 = true);
                    }
                    if (this.scroll.insertAt(t5, r4, n5.insert[r4]), s4) {
                      const [e5] = this.scroll.descendant(Je, t5);
                      if (e5) {
                        const t6 = De({}, Xr(e5));
                        i3 = bn.AttributeMap.diff(t6, i3) || {};
                      }
                    }
                  }
                  e4 += s3;
                } else if (r3.push(n5), null !== n5.retain && "object" == typeof n5.retain) {
                  const e5 = Object.keys(n5.retain)[0];
                  if (null == e5)
                    return t5;
                  this.scroll.updateEmbedAt(t5, e5, n5.retain[e5]);
                }
                Object.keys(i3).forEach((e5) => {
                  this.scroll.formatAt(t5, s3, e5, i3[e5]);
                });
                const a3 = o3 ? 1 : 0, c3 = l3 ? 1 : 0;
                return e4 += a3 + c3, r3.retain(a3), r3.delete(c3), t5 + s3 + a3 + c3;
              }, 0), r3.reduce((t5, e5) => "number" == typeof e5.delete ? (this.scroll.deleteAt(t5, e5.delete), t5) : t5 + bn.Op.length(e5), 0), this.scroll.batchEnd(), this.scroll.optimize(), this.update(n4);
            }
            deleteText(t4, e4) {
              return this.scroll.deleteAt(t4, e4), this.update(new bn().retain(t4).delete(e4));
            }
            formatLine(t4, e4) {
              let n4 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
              this.scroll.update(), Object.keys(n4).forEach((r4) => {
                this.scroll.lines(t4, Math.max(e4, 1)).forEach((t5) => {
                  t5.format(r4, n4[r4]);
                });
              }), this.scroll.optimize();
              const r3 = new bn().retain(t4).retain(e4, vr(n4));
              return this.update(r3);
            }
            formatText(t4, e4) {
              let n4 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
              Object.keys(n4).forEach((r4) => {
                this.scroll.formatAt(t4, e4, r4, n4[r4]);
              });
              const r3 = new bn().retain(t4).retain(e4, vr(n4));
              return this.update(r3);
            }
            getContents(t4, e4) {
              return this.delta.slice(t4, t4 + e4);
            }
            getDelta() {
              return this.scroll.lines().reduce((t4, e4) => t4.concat(e4.delta()), new bn());
            }
            getFormat(t4) {
              let e4 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, n4 = [], r3 = [];
              0 === e4 ? this.scroll.path(t4).forEach((t5) => {
                const [e5] = t5;
                e5 instanceof Wr ? n4.push(e5) : e5 instanceof Je && r3.push(e5);
              }) : (n4 = this.scroll.lines(t4, e4), r3 = this.scroll.descendants(Je, t4, e4));
              const [s3, i3] = [n4, r3].map((t5) => {
                const e5 = t5.shift();
                if (null == e5)
                  return {};
                let n5 = Xr(e5);
                for (; Object.keys(n5).length > 0; ) {
                  const e6 = t5.shift();
                  if (null == e6)
                    return n5;
                  n5 = gs(Xr(e6), n5);
                }
                return n5;
              });
              return { ...s3, ...i3 };
            }
            getHTML(t4, e4) {
              const [n4, r3] = this.scroll.line(t4);
              if (n4) {
                const s3 = n4.length();
                return !(n4.length() >= r3 + e4) || 0 === r3 && e4 === s3 ? ps(this.scroll, t4, e4, true) : ps(n4, r3, e4, true);
              }
              return "";
            }
            getText(t4, e4) {
              return this.getContents(t4, e4).filter((t5) => "string" == typeof t5.insert).map((t5) => t5.insert).join("");
            }
            insertContents(t4, e4) {
              const n4 = bs(e4), r3 = new bn().retain(t4).concat(n4);
              return this.scroll.insertContents(t4, n4), this.update(r3);
            }
            insertEmbed(t4, e4, n4) {
              return this.scroll.insertAt(t4, e4, n4), this.update(new bn().retain(t4).insert({ [e4]: n4 }));
            }
            insertText(t4, e4) {
              let n4 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
              return e4 = e4.replace(/\r\n/g, "\n").replace(/\r/g, "\n"), this.scroll.insertAt(t4, e4), Object.keys(n4).forEach((r3) => {
                this.scroll.formatAt(t4, e4.length, r3, n4[r3]);
              }), this.update(new bn().retain(t4).insert(e4, vr(n4)));
            }
            isBlank() {
              if (0 === this.scroll.children.length)
                return true;
              if (this.scroll.children.length > 1)
                return false;
              const t4 = this.scroll.children.head;
              if (t4?.statics.blotName !== Wr.blotName)
                return false;
              const e4 = t4;
              return !(e4.children.length > 1) && e4.children.head instanceof Hr;
            }
            removeFormat(t4, e4) {
              const n4 = this.getText(t4, e4), [r3, s3] = this.scroll.line(t4 + e4);
              let i3 = 0, o3 = new bn();
              null != r3 && (i3 = r3.length() - s3, o3 = r3.delta().slice(s3, s3 + i3 - 1).insert("\n"));
              const l3 = this.getContents(t4, e4 + i3).diff(new bn().insert(n4).concat(o3)), a3 = new bn().retain(t4).concat(l3);
              return this.applyDelta(a3);
            }
            update(t4) {
              let e4 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [], n4 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : void 0;
              const r3 = this.delta;
              if (1 === e4.length && "characterData" === e4[0].type && e4[0].target.data.match(ds) && this.scroll.find(e4[0].target)) {
                const s3 = this.scroll.find(e4[0].target), i3 = Xr(s3), o3 = s3.offset(this.scroll), l3 = e4[0].oldValue.replace(Yr.CONTENTS, ""), a3 = new bn().insert(l3), c3 = new bn().insert(s3.value()), u3 = n4 && { oldRange: ys(n4.oldRange, -o3), newRange: ys(n4.newRange, -o3) };
                t4 = new bn().retain(o3).concat(a3.diff(c3, u3)).reduce((t5, e5) => e5.insert ? t5.insert(e5.insert, i3) : t5.push(e5), new bn()), this.delta = r3.compose(t4);
              } else
                this.delta = this.getDelta(), t4 && Pr(r3.compose(t4), this.delta) || (t4 = r3.diff(this.delta, n4));
              return t4;
            }
          };
          const xs = class {
            static {
              __name(this, "xs");
            }
            static DEFAULTS = {};
            constructor(t4) {
              let e4 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
              this.quill = t4, this.options = e4;
            }
          }, Ns = "\uFEFF";
          const ws = class extends hn {
            static {
              __name(this, "ws");
            }
            constructor(t4, e4) {
              super(t4, e4), this.contentNode = document.createElement("span"), this.contentNode.setAttribute("contenteditable", "false"), Array.from(this.domNode.childNodes).forEach((t5) => {
                this.contentNode.appendChild(t5);
              }), this.leftGuard = document.createTextNode(Ns), this.rightGuard = document.createTextNode(Ns), this.domNode.appendChild(this.leftGuard), this.domNode.appendChild(this.contentNode), this.domNode.appendChild(this.rightGuard);
            }
            index(t4, e4) {
              return t4 === this.leftGuard ? 0 : t4 === this.rightGuard ? 1 : super.index(t4, e4);
            }
            restore(t4) {
              let e4, n4 = null;
              const r3 = t4.data.split(Ns).join("");
              if (t4 === this.leftGuard)
                if (this.prev instanceof Fr) {
                  const t5 = this.prev.length();
                  this.prev.insertAt(t5, r3), n4 = { startNode: this.prev.domNode, startOffset: t5 + r3.length };
                } else
                  e4 = document.createTextNode(r3), this.parent.insertBefore(this.scroll.create(e4), this), n4 = { startNode: e4, startOffset: r3.length };
              else
                t4 === this.rightGuard && (this.next instanceof Fr ? (this.next.insertAt(0, r3), n4 = { startNode: this.next.domNode, startOffset: r3.length }) : (e4 = document.createTextNode(r3), this.parent.insertBefore(this.scroll.create(e4), this.next), n4 = { startNode: e4, startOffset: r3.length }));
              return t4.data = Ns, n4;
            }
            update(t4, e4) {
              t4.forEach((t5) => {
                if ("characterData" === t5.type && (t5.target === this.leftGuard || t5.target === this.rightGuard)) {
                  const n4 = this.restore(t5.target);
                  n4 && (e4.range = n4);
                }
              });
            }
          };
          const Es = class {
            static {
              __name(this, "Es");
            }
            isComposing = false;
            constructor(t4, e4) {
              this.scroll = t4, this.emitter = e4, this.setupListeners();
            }
            setupListeners() {
              this.scroll.domNode.addEventListener("compositionstart", (t4) => {
                this.isComposing || this.handleCompositionStart(t4);
              }), this.scroll.domNode.addEventListener("compositionend", (t4) => {
                this.isComposing && queueMicrotask(() => {
                  this.handleCompositionEnd(t4);
                });
              });
            }
            handleCompositionStart(t4) {
              const e4 = t4.target instanceof Node ? this.scroll.find(t4.target, true) : null;
              !e4 || e4 instanceof ws || (this.emitter.emit(ls.events.COMPOSITION_BEFORE_START, t4), this.scroll.batchStart(), this.emitter.emit(ls.events.COMPOSITION_START, t4), this.isComposing = true);
            }
            handleCompositionEnd(t4) {
              this.emitter.emit(ls.events.COMPOSITION_BEFORE_END, t4), this.scroll.batchEnd(), this.emitter.emit(ls.events.COMPOSITION_END, t4), this.isComposing = false;
            }
          };
          class As {
            static {
              __name(this, "As");
            }
            static DEFAULTS = { modules: {} };
            static themes = { default: As };
            modules = {};
            constructor(t4, e4) {
              this.quill = t4, this.options = e4;
            }
            init() {
              Object.keys(this.options.modules).forEach((t4) => {
                null == this.modules[t4] && this.addModule(t4);
              });
            }
            addModule(t4) {
              const e4 = this.quill.constructor.import(`modules/${t4}`);
              return this.modules[t4] = new e4(this.quill, this.options.modules[t4] || {}), this.modules[t4];
            }
          }
          const qs = As, ks = /* @__PURE__ */ __name((t4) => {
            const e4 = t4.getBoundingClientRect(), n4 = "offsetWidth" in t4 && Math.abs(e4.width) / t4.offsetWidth || 1, r3 = "offsetHeight" in t4 && Math.abs(e4.height) / t4.offsetHeight || 1;
            return { top: e4.top, right: e4.left + t4.clientWidth * n4, bottom: e4.top + t4.clientHeight * r3, left: e4.left };
          }, "ks"), _s = /* @__PURE__ */ __name((t4) => {
            const e4 = parseInt(t4, 10);
            return Number.isNaN(e4) ? 0 : e4;
          }, "_s"), Ls = /* @__PURE__ */ __name((t4, e4, n4, r3, s3, i3) => t4 < n4 && e4 > r3 ? 0 : t4 < n4 ? -(n4 - t4 + s3) : e4 > r3 ? e4 - t4 > r3 - n4 ? t4 + s3 - n4 : e4 - r3 + i3 : 0, "Ls"), Os = /* @__PURE__ */ __name((t4, e4) => {
            const n4 = t4.ownerDocument;
            let r3 = e4, s3 = t4;
            for (; s3; ) {
              const t5 = s3 === n4.body, e5 = t5 ? { top: 0, right: window.visualViewport?.width ?? n4.documentElement.clientWidth, bottom: window.visualViewport?.height ?? n4.documentElement.clientHeight, left: 0 } : ks(s3), o3 = getComputedStyle(s3), l3 = Ls(r3.left, r3.right, e5.left, e5.right, _s(o3.scrollPaddingLeft), _s(o3.scrollPaddingRight)), a3 = Ls(r3.top, r3.bottom, e5.top, e5.bottom, _s(o3.scrollPaddingTop), _s(o3.scrollPaddingBottom));
              if (l3 || a3)
                if (t5)
                  n4.defaultView?.scrollBy(l3, a3);
                else {
                  const { scrollLeft: t6, scrollTop: e6 } = s3;
                  a3 && (s3.scrollTop += a3), l3 && (s3.scrollLeft += l3);
                  const n5 = s3.scrollLeft - t6, i4 = s3.scrollTop - e6;
                  r3 = { left: r3.left - n5, top: r3.top - i4, right: r3.right - n5, bottom: r3.bottom - i4 };
                }
              s3 = t5 || "fixed" === o3.position ? null : (i3 = s3).parentElement || i3.getRootNode().host || null;
            }
            var i3;
          }, "Os"), Ts = ["block", "break", "cursor", "inline", "scroll", "text"], Ss = /* @__PURE__ */ __name((t4, e4, n4) => {
            const r3 = new $e();
            return Ts.forEach((t5) => {
              const n5 = e4.query(t5);
              n5 && r3.register(n5);
            }), t4.forEach((t5) => {
              let s3 = e4.query(t5);
              s3 || n4.error(`Cannot register "${t5}" specified in "formats" config. Are you sure it was registered?`);
              let i3 = 0;
              for (; s3; )
                if (r3.register(s3), s3 = "blotName" in s3 ? s3.requiredContainer ?? null : null, i3 += 1, i3 > 100) {
                  n4.error(`Cycle detected in registering blot requiredContainer: "${t5}"`);
                  break;
                }
            }), r3;
          }, "Ss"), Cs = is("quill"), js = new $e();
          rn.uiClass = "ql-ui";
          class Rs {
            static {
              __name(this, "Rs");
            }
            static DEFAULTS = { bounds: null, modules: { clipboard: true, keyboard: true, history: true, uploader: true }, placeholder: "", readOnly: false, registry: js, theme: "default" };
            static events = ls.events;
            static sources = ls.sources;
            static version = "2.0.2";
            static imports = { delta: bn, parchment: r2, "core/module": xs, "core/theme": qs };
            static debug(t4) {
              true === t4 && (t4 = "log"), is.level(t4);
            }
            static find(t4) {
              let e4 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
              return ts.get(t4) || js.find(t4, e4);
            }
            static import(t4) {
              return null == this.imports[t4] && Cs.error(`Cannot import ${t4}. Are you sure it was registered?`), this.imports[t4];
            }
            static register() {
              if ("string" != typeof (arguments.length <= 0 ? void 0 : arguments[0])) {
                const t4 = arguments.length <= 0 ? void 0 : arguments[0], e4 = !!(arguments.length <= 1 ? void 0 : arguments[1]), n4 = "attrName" in t4 ? t4.attrName : t4.blotName;
                "string" == typeof n4 ? this.register(`formats/${n4}`, t4, e4) : Object.keys(t4).forEach((n5) => {
                  this.register(n5, t4[n5], e4);
                });
              } else {
                const t4 = arguments.length <= 0 ? void 0 : arguments[0], e4 = arguments.length <= 1 ? void 0 : arguments[1], n4 = !!(arguments.length <= 2 ? void 0 : arguments[2]);
                null == this.imports[t4] || n4 || Cs.warn(`Overwriting ${t4} with`, e4), this.imports[t4] = e4, (t4.startsWith("blots/") || t4.startsWith("formats/")) && e4 && "boolean" != typeof e4 && "abstract" !== e4.blotName && js.register(e4), "function" == typeof e4.register && e4.register(js);
              }
            }
            constructor(t4) {
              let e4 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
              if (this.options = function(t5, e5) {
                const n5 = Is(t5);
                if (!n5)
                  throw new Error("Invalid Quill container");
                const r4 = !e5.theme || e5.theme === Rs.DEFAULTS.theme, s4 = r4 ? qs : Rs.import(`themes/${e5.theme}`);
                if (!s4)
                  throw new Error(`Invalid theme ${e5.theme}. Did you register it?`);
                const { modules: i3, ...o3 } = Rs.DEFAULTS, { modules: l3, ...a3 } = s4.DEFAULTS;
                let c3 = Ms(e5.modules);
                null != c3 && c3.toolbar && c3.toolbar.constructor !== Object && (c3 = { ...c3, toolbar: { container: c3.toolbar } });
                const u3 = De({}, Ms(i3), Ms(l3), c3), h3 = { ...o3, ...Bs(a3), ...Bs(e5) };
                let d3 = e5.registry;
                d3 ? e5.formats && Cs.warn('Ignoring "formats" option because "registry" is specified') : d3 = e5.formats ? Ss(e5.formats, h3.registry, Cs) : h3.registry;
                return { ...h3, registry: d3, container: n5, theme: s4, modules: Object.entries(u3).reduce((t6, e6) => {
                  let [n6, r5] = e6;
                  if (!r5)
                    return t6;
                  const s5 = Rs.import(`modules/${n6}`);
                  return null == s5 ? (Cs.error(`Cannot load ${n6} module. Are you sure you registered it?`), t6) : { ...t6, [n6]: De({}, s5.DEFAULTS || {}, r5) };
                }, {}), bounds: Is(h3.bounds) };
              }(t4, e4), this.container = this.options.container, null == this.container)
                return void Cs.error("Invalid Quill container", t4);
              this.options.debug && Rs.debug(this.options.debug);
              const n4 = this.container.innerHTML.trim();
              this.container.classList.add("ql-container"), this.container.innerHTML = "", ts.set(this.container, this), this.root = this.addContainer("ql-editor"), this.root.classList.add("ql-blank"), this.emitter = new ls();
              const r3 = pn.blotName, s3 = this.options.registry.query(r3);
              if (!s3 || !("blotName" in s3))
                throw new Error(`Cannot initialize Quill without "${r3}" blot`);
              if (this.scroll = new s3(this.options.registry, this.root, { emitter: this.emitter }), this.editor = new vs(this.scroll), this.selection = new hs(this.scroll, this.emitter), this.composition = new Es(this.scroll, this.emitter), this.theme = new this.options.theme(this, this.options), this.keyboard = this.theme.addModule("keyboard"), this.clipboard = this.theme.addModule("clipboard"), this.history = this.theme.addModule("history"), this.uploader = this.theme.addModule("uploader"), this.theme.addModule("input"), this.theme.addModule("uiNode"), this.theme.init(), this.emitter.on(ls.events.EDITOR_CHANGE, (t5) => {
                t5 === ls.events.TEXT_CHANGE && this.root.classList.toggle("ql-blank", this.editor.isBlank());
              }), this.emitter.on(ls.events.SCROLL_UPDATE, (t5, e5) => {
                const n5 = this.selection.lastRange, [r4] = this.selection.getRange(), s4 = n5 && r4 ? { oldRange: n5, newRange: r4 } : void 0;
                Us.call(this, () => this.editor.update(null, e5, s4), t5);
              }), this.emitter.on(ls.events.SCROLL_EMBED_UPDATE, (t5, e5) => {
                const n5 = this.selection.lastRange, [r4] = this.selection.getRange(), s4 = n5 && r4 ? { oldRange: n5, newRange: r4 } : void 0;
                Us.call(this, () => {
                  const n6 = new bn().retain(t5.offset(this)).retain({ [t5.statics.blotName]: e5 });
                  return this.editor.update(n6, [], s4);
                }, Rs.sources.USER);
              }), n4) {
                const t5 = this.clipboard.convert({ html: `${n4}<p><br></p>`, text: "\n" });
                this.setContents(t5);
              }
              this.history.clear(), this.options.placeholder && this.root.setAttribute("data-placeholder", this.options.placeholder), this.options.readOnly && this.disable(), this.allowReadOnlyEdits = false;
            }
            addContainer(t4) {
              let e4 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
              if ("string" == typeof t4) {
                const e5 = t4;
                (t4 = document.createElement("div")).classList.add(e5);
              }
              return this.container.insertBefore(t4, e4), t4;
            }
            blur() {
              this.selection.setRange(null);
            }
            deleteText(t4, e4, n4) {
              return [t4, e4, , n4] = Ds(t4, e4, n4), Us.call(this, () => this.editor.deleteText(t4, e4), n4, t4, -1 * e4);
            }
            disable() {
              this.enable(false);
            }
            editReadOnly(t4) {
              this.allowReadOnlyEdits = true;
              const e4 = t4();
              return this.allowReadOnlyEdits = false, e4;
            }
            enable() {
              let t4 = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
              this.scroll.enable(t4), this.container.classList.toggle("ql-disabled", !t4);
            }
            focus() {
              let t4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
              this.selection.focus(), t4.preventScroll || this.scrollSelectionIntoView();
            }
            format(t4, e4) {
              let n4 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : ls.sources.API;
              return Us.call(this, () => {
                const n5 = this.getSelection(true);
                let r3 = new bn();
                if (null == n5)
                  return r3;
                if (this.scroll.query(t4, Pe.BLOCK))
                  r3 = this.editor.formatLine(n5.index, n5.length, { [t4]: e4 });
                else {
                  if (0 === n5.length)
                    return this.selection.format(t4, e4), r3;
                  r3 = this.editor.formatText(n5.index, n5.length, { [t4]: e4 });
                }
                return this.setSelection(n5, ls.sources.SILENT), r3;
              }, n4);
            }
            formatLine(t4, e4, n4, r3, s3) {
              let i3;
              return [t4, e4, i3, s3] = Ds(t4, e4, n4, r3, s3), Us.call(this, () => this.editor.formatLine(t4, e4, i3), s3, t4, 0);
            }
            formatText(t4, e4, n4, r3, s3) {
              let i3;
              return [t4, e4, i3, s3] = Ds(t4, e4, n4, r3, s3), Us.call(this, () => this.editor.formatText(t4, e4, i3), s3, t4, 0);
            }
            getBounds(t4) {
              let e4 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, n4 = null;
              if (n4 = "number" == typeof t4 ? this.selection.getBounds(t4, e4) : this.selection.getBounds(t4.index, t4.length), !n4)
                return null;
              const r3 = this.container.getBoundingClientRect();
              return { bottom: n4.bottom - r3.top, height: n4.height, left: n4.left - r3.left, right: n4.right - r3.left, top: n4.top - r3.top, width: n4.width };
            }
            getContents() {
              let t4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, e4 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.getLength() - t4;
              return [t4, e4] = Ds(t4, e4), this.editor.getContents(t4, e4);
            }
            getFormat() {
              let t4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.getSelection(true), e4 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
              return "number" == typeof t4 ? this.editor.getFormat(t4, e4) : this.editor.getFormat(t4.index, t4.length);
            }
            getIndex(t4) {
              return t4.offset(this.scroll);
            }
            getLength() {
              return this.scroll.length();
            }
            getLeaf(t4) {
              return this.scroll.leaf(t4);
            }
            getLine(t4) {
              return this.scroll.line(t4);
            }
            getLines() {
              let t4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, e4 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Number.MAX_VALUE;
              return "number" != typeof t4 ? this.scroll.lines(t4.index, t4.length) : this.scroll.lines(t4, e4);
            }
            getModule(t4) {
              return this.theme.modules[t4];
            }
            getSelection() {
              return arguments.length > 0 && void 0 !== arguments[0] && arguments[0] && this.focus(), this.update(), this.selection.getRange()[0];
            }
            getSemanticHTML() {
              let t4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, e4 = arguments.length > 1 ? arguments[1] : void 0;
              return "number" == typeof t4 && (e4 = e4 ?? this.getLength() - t4), [t4, e4] = Ds(t4, e4), this.editor.getHTML(t4, e4);
            }
            getText() {
              let t4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, e4 = arguments.length > 1 ? arguments[1] : void 0;
              return "number" == typeof t4 && (e4 = e4 ?? this.getLength() - t4), [t4, e4] = Ds(t4, e4), this.editor.getText(t4, e4);
            }
            hasFocus() {
              return this.selection.hasFocus();
            }
            insertEmbed(t4, e4, n4) {
              let r3 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : Rs.sources.API;
              return Us.call(this, () => this.editor.insertEmbed(t4, e4, n4), r3, t4);
            }
            insertText(t4, e4, n4, r3, s3) {
              let i3;
              return [t4, , i3, s3] = Ds(t4, 0, n4, r3, s3), Us.call(this, () => this.editor.insertText(t4, e4, i3), s3, t4, e4.length);
            }
            isEnabled() {
              return this.scroll.isEnabled();
            }
            off() {
              return this.emitter.off(...arguments);
            }
            on() {
              return this.emitter.on(...arguments);
            }
            once() {
              return this.emitter.once(...arguments);
            }
            removeFormat(t4, e4, n4) {
              return [t4, e4, , n4] = Ds(t4, e4, n4), Us.call(this, () => this.editor.removeFormat(t4, e4), n4, t4);
            }
            scrollRectIntoView(t4) {
              Os(this.root, t4);
            }
            scrollIntoView() {
              console.warn("Quill#scrollIntoView() has been deprecated and will be removed in the near future. Please use Quill#scrollSelectionIntoView() instead."), this.scrollSelectionIntoView();
            }
            scrollSelectionIntoView() {
              const t4 = this.selection.lastRange, e4 = t4 && this.selection.getBounds(t4.index, t4.length);
              e4 && this.scrollRectIntoView(e4);
            }
            setContents(t4) {
              let e4 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : ls.sources.API;
              return Us.call(this, () => {
                t4 = new bn(t4);
                const e5 = this.getLength(), n4 = this.editor.deleteText(0, e5), r3 = this.editor.insertContents(0, t4), s3 = this.editor.deleteText(this.getLength() - 1, 1);
                return n4.compose(r3).compose(s3);
              }, e4);
            }
            setSelection(t4, e4, n4) {
              null == t4 ? this.selection.setRange(null, e4 || Rs.sources.API) : ([t4, e4, , n4] = Ds(t4, e4, n4), this.selection.setRange(new cs(Math.max(0, t4), e4), n4), n4 !== ls.sources.SILENT && this.scrollSelectionIntoView());
            }
            setText(t4) {
              let e4 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : ls.sources.API;
              const n4 = new bn().insert(t4);
              return this.setContents(n4, e4);
            }
            update() {
              let t4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ls.sources.USER;
              const e4 = this.scroll.update(t4);
              return this.selection.update(t4), e4;
            }
            updateContents(t4) {
              let e4 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : ls.sources.API;
              return Us.call(this, () => (t4 = new bn(t4), this.editor.applyDelta(t4)), e4, true);
            }
          }
          function Is(t4) {
            return "string" == typeof t4 ? document.querySelector(t4) : t4;
          }
          __name(Is, "Is");
          function Ms(t4) {
            return Object.entries(t4 ?? {}).reduce((t5, e4) => {
              let [n4, r3] = e4;
              return { ...t5, [n4]: true === r3 ? {} : r3 };
            }, {});
          }
          __name(Ms, "Ms");
          function Bs(t4) {
            return Object.fromEntries(Object.entries(t4).filter((t5) => void 0 !== t5[1]));
          }
          __name(Bs, "Bs");
          function Us(t4, e4, n4, r3) {
            if (!this.isEnabled() && e4 === ls.sources.USER && !this.allowReadOnlyEdits)
              return new bn();
            let s3 = null == n4 ? null : this.getSelection();
            const i3 = this.editor.delta, o3 = t4();
            if (null != s3 && (true === n4 && (n4 = s3.index), null == r3 ? s3 = Ps(s3, o3, e4) : 0 !== r3 && (s3 = Ps(s3, n4, r3, e4)), this.setSelection(s3, ls.sources.SILENT)), o3.length() > 0) {
              const t5 = [ls.events.TEXT_CHANGE, o3, i3, e4];
              this.emitter.emit(ls.events.EDITOR_CHANGE, ...t5), e4 !== ls.sources.SILENT && this.emitter.emit(...t5);
            }
            return o3;
          }
          __name(Us, "Us");
          function Ds(t4, e4, n4, r3, s3) {
            let i3 = {};
            return "number" == typeof t4.index && "number" == typeof t4.length ? "number" != typeof e4 ? (s3 = r3, r3 = n4, n4 = e4, e4 = t4.length, t4 = t4.index) : (e4 = t4.length, t4 = t4.index) : "number" != typeof e4 && (s3 = r3, r3 = n4, n4 = e4, e4 = 0), "object" == typeof n4 ? (i3 = n4, s3 = r3) : "string" == typeof n4 && (null != r3 ? i3[n4] = r3 : s3 = n4), [t4, e4, i3, s3 = s3 || ls.sources.API];
          }
          __name(Ds, "Ds");
          function Ps(t4, e4, n4, r3) {
            const s3 = "number" == typeof n4 ? n4 : 0;
            if (null == t4)
              return null;
            let i3, o3;
            return e4 && "function" == typeof e4.transformPosition ? [i3, o3] = [t4.index, t4.index + t4.length].map((t5) => e4.transformPosition(t5, r3 !== ls.sources.USER)) : [i3, o3] = [t4.index, t4.index + t4.length].map((t5) => t5 < e4 || t5 === e4 && r3 === ls.sources.USER ? t5 : s3 >= 0 ? t5 + s3 : Math.max(e4, t5 + s3)), new cs(i3, o3 - i3);
          }
          __name(Ps, "Ps");
          const zs = class extends un {
            static {
              __name(this, "zs");
            }
          };
          function Hs(t4) {
            return t4 instanceof Wr || t4 instanceof Zr;
          }
          __name(Hs, "Hs");
          function Fs(t4) {
            return "function" == typeof t4.updateContent;
          }
          __name(Fs, "Fs");
          function $s(t4, e4, n4) {
            n4.reduce((e5, n5) => {
              const r3 = bn.Op.length(n5);
              let s3 = n5.attributes || {};
              if (null != n5.insert) {
                if ("string" == typeof n5.insert) {
                  const r4 = n5.insert;
                  t4.insertAt(e5, r4);
                  const [i3] = t4.descendant(Je, e5), o3 = Xr(i3);
                  s3 = bn.AttributeMap.diff(o3, s3) || {};
                } else if ("object" == typeof n5.insert) {
                  const r4 = Object.keys(n5.insert)[0];
                  if (null == r4)
                    return e5;
                  t4.insertAt(e5, r4, n5.insert[r4]);
                  if (null != t4.scroll.query(r4, Pe.INLINE)) {
                    const [n6] = t4.descendant(Je, e5), r5 = Xr(n6);
                    s3 = bn.AttributeMap.diff(r5, s3) || {};
                  }
                }
              }
              return Object.keys(s3).forEach((n6) => {
                t4.formatAt(e5, r3, n6, s3[n6]);
              }), e5 + r3;
            }, e4);
          }
          __name($s, "$s");
          const Vs = class extends pn {
            static {
              __name(this, "Vs");
            }
            static blotName = "scroll";
            static className = "ql-editor";
            static tagName = "DIV";
            static defaultChild = Wr;
            static allowedChildren = [Wr, Zr, zs];
            constructor(t4, e4, n4) {
              let { emitter: r3 } = n4;
              super(t4, e4), this.emitter = r3, this.batch = false, this.optimize(), this.enable(), this.domNode.addEventListener("dragstart", (t5) => this.handleDragStart(t5));
            }
            batchStart() {
              Array.isArray(this.batch) || (this.batch = []);
            }
            batchEnd() {
              if (!this.batch)
                return;
              const t4 = this.batch;
              this.batch = false, this.update(t4);
            }
            emitMount(t4) {
              this.emitter.emit(ls.events.SCROLL_BLOT_MOUNT, t4);
            }
            emitUnmount(t4) {
              this.emitter.emit(ls.events.SCROLL_BLOT_UNMOUNT, t4);
            }
            emitEmbedUpdate(t4, e4) {
              this.emitter.emit(ls.events.SCROLL_EMBED_UPDATE, t4, e4);
            }
            deleteAt(t4, e4) {
              const [n4, r3] = this.line(t4), [s3] = this.line(t4 + e4);
              if (super.deleteAt(t4, e4), null != s3 && n4 !== s3 && r3 > 0) {
                if (n4 instanceof Zr || s3 instanceof Zr)
                  return void this.optimize();
                const t5 = s3.children.head instanceof Hr ? null : s3.children.head;
                n4.moveChildren(s3, t5), n4.remove();
              }
              this.optimize();
            }
            enable() {
              let t4 = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
              this.domNode.setAttribute("contenteditable", t4 ? "true" : "false");
            }
            formatAt(t4, e4, n4, r3) {
              super.formatAt(t4, e4, n4, r3), this.optimize();
            }
            insertAt(t4, e4, n4) {
              if (t4 >= this.length())
                if (null == n4 || null == this.scroll.query(e4, Pe.BLOCK)) {
                  const t5 = this.scroll.create(this.statics.defaultChild.blotName);
                  this.appendChild(t5), null == n4 && e4.endsWith("\n") ? t5.insertAt(0, e4.slice(0, -1), n4) : t5.insertAt(0, e4, n4);
                } else {
                  const t5 = this.scroll.create(e4, n4);
                  this.appendChild(t5);
                }
              else
                super.insertAt(t4, e4, n4);
              this.optimize();
            }
            insertBefore(t4, e4) {
              if (t4.statics.scope === Pe.INLINE_BLOT) {
                const n4 = this.scroll.create(this.statics.defaultChild.blotName);
                n4.appendChild(t4), super.insertBefore(n4, e4);
              } else
                super.insertBefore(t4, e4);
            }
            insertContents(t4, e4) {
              const n4 = this.deltaToRenderBlocks(e4.concat(new bn().insert("\n"))), r3 = n4.pop();
              if (null == r3)
                return;
              this.batchStart();
              const s3 = n4.shift();
              if (s3) {
                const e5 = "block" === s3.type && (0 === s3.delta.length() || !this.descendant(Zr, t4)[0] && t4 < this.length()), n5 = "block" === s3.type ? s3.delta : new bn().insert({ [s3.key]: s3.value });
                $s(this, t4, n5);
                const r4 = "block" === s3.type ? 1 : 0, i4 = t4 + n5.length() + r4;
                e5 && this.insertAt(i4 - 1, "\n");
                const o4 = Xr(this.line(t4)[0]), l3 = bn.AttributeMap.diff(o4, s3.attributes) || {};
                Object.keys(l3).forEach((t5) => {
                  this.formatAt(i4 - 1, 1, t5, l3[t5]);
                }), t4 = i4;
              }
              let [i3, o3] = this.children.find(t4);
              if (n4.length && (i3 && (i3 = i3.split(o3), o3 = 0), n4.forEach((t5) => {
                if ("block" === t5.type) {
                  $s(this.createBlock(t5.attributes, i3 || void 0), 0, t5.delta);
                } else {
                  const e5 = this.create(t5.key, t5.value);
                  this.insertBefore(e5, i3 || void 0), Object.keys(t5.attributes).forEach((n5) => {
                    e5.format(n5, t5.attributes[n5]);
                  });
                }
              })), "block" === r3.type && r3.delta.length()) {
                $s(this, i3 ? i3.offset(i3.scroll) + o3 : this.length(), r3.delta);
              }
              this.batchEnd(), this.optimize();
            }
            isEnabled() {
              return "true" === this.domNode.getAttribute("contenteditable");
            }
            leaf(t4) {
              const e4 = this.path(t4).pop();
              if (!e4)
                return [null, -1];
              const [n4, r3] = e4;
              return n4 instanceof Je ? [n4, r3] : [null, -1];
            }
            line(t4) {
              return t4 === this.length() ? this.line(t4 - 1) : this.descendant(Hs, t4);
            }
            lines() {
              let t4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, e4 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Number.MAX_VALUE;
              const n4 = /* @__PURE__ */ __name((t5, e5, r3) => {
                let s3 = [], i3 = r3;
                return t5.children.forEachAt(e5, r3, (t6, e6, r4) => {
                  Hs(t6) ? s3.push(t6) : t6 instanceof un && (s3 = s3.concat(n4(t6, e6, i3))), i3 -= r4;
                }), s3;
              }, "n");
              return n4(this, t4, e4);
            }
            optimize() {
              let t4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [], e4 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
              this.batch || (super.optimize(t4, e4), t4.length > 0 && this.emitter.emit(ls.events.SCROLL_OPTIMIZE, t4, e4));
            }
            path(t4) {
              return super.path(t4).slice(1);
            }
            remove() {
            }
            update(t4) {
              if (this.batch)
                return void (Array.isArray(t4) && (this.batch = this.batch.concat(t4)));
              let e4 = ls.sources.USER;
              "string" == typeof t4 && (e4 = t4), Array.isArray(t4) || (t4 = this.observer.takeRecords()), (t4 = t4.filter((t5) => {
                let { target: e5 } = t5;
                const n4 = this.find(e5, true);
                return n4 && !Fs(n4);
              })).length > 0 && this.emitter.emit(ls.events.SCROLL_BEFORE_UPDATE, e4, t4), super.update(t4.concat([])), t4.length > 0 && this.emitter.emit(ls.events.SCROLL_UPDATE, e4, t4);
            }
            updateEmbedAt(t4, e4, n4) {
              const [r3] = this.descendant((t5) => t5 instanceof Zr, t4);
              r3 && r3.statics.blotName === e4 && Fs(r3) && r3.updateContent(n4);
            }
            handleDragStart(t4) {
              t4.preventDefault();
            }
            deltaToRenderBlocks(t4) {
              const e4 = [];
              let n4 = new bn();
              return t4.forEach((t5) => {
                const r3 = t5?.insert;
                if (r3)
                  if ("string" == typeof r3) {
                    const s3 = r3.split("\n");
                    s3.slice(0, -1).forEach((r4) => {
                      n4.insert(r4, t5.attributes), e4.push({ type: "block", delta: n4, attributes: t5.attributes ?? {} }), n4 = new bn();
                    });
                    const i3 = s3[s3.length - 1];
                    i3 && n4.insert(i3, t5.attributes);
                  } else {
                    const s3 = Object.keys(r3)[0];
                    if (!s3)
                      return;
                    this.query(s3, Pe.INLINE) ? n4.push(t5) : (n4.length() && e4.push({ type: "block", delta: n4, attributes: {} }), n4 = new bn(), e4.push({ type: "blockEmbed", key: s3, value: r3[s3], attributes: t5.attributes ?? {} }));
                  }
              }), n4.length() && e4.push({ type: "block", delta: n4, attributes: {} }), e4;
            }
            createBlock(t4, e4) {
              let n4;
              const r3 = {};
              Object.entries(t4).forEach((t5) => {
                let [e5, s4] = t5;
                null != this.query(e5, Pe.BLOCK & Pe.BLOT) ? n4 = e5 : r3[e5] = s4;
              });
              const s3 = this.create(n4 || this.statics.defaultChild.blotName, n4 ? t4[n4] : void 0);
              this.insertBefore(s3, e4 || void 0);
              const i3 = s3.length();
              return Object.entries(r3).forEach((t5) => {
                let [e5, n5] = t5;
                s3.formatAt(0, i3, e5, n5);
              }), s3;
            }
          }, Ks = { scope: Pe.BLOCK, whitelist: ["right", "center", "justify"] }, Ws = new ze("align", "align", Ks), Zs = new Ke("align", "ql-align", Ks), Gs = new Ze("align", "text-align", Ks);
          class Xs extends Ze {
            static {
              __name(this, "Xs");
            }
            value(t4) {
              let e4 = super.value(t4);
              if (!e4.startsWith("rgb("))
                return e4;
              e4 = e4.replace(/^[^\d]+/, "").replace(/[^\d]+$/, "");
              return `#${e4.split(",").map((t5) => `00${parseInt(t5, 10).toString(16)}`.slice(-2)).join("")}`;
            }
          }
          const Qs = new Ke("color", "ql-color", { scope: Pe.INLINE }), Ys = new Xs("color", "color", { scope: Pe.INLINE }), Js = new Ke("background", "ql-bg", { scope: Pe.INLINE }), ti = new Xs("background", "background-color", { scope: Pe.INLINE });
          class ei extends zs {
            static {
              __name(this, "ei");
            }
            static create(t4) {
              const e4 = super.create(t4);
              return e4.setAttribute("spellcheck", "false"), e4;
            }
            code(t4, e4) {
              return this.children.map((t5) => t5.length() <= 1 ? "" : t5.domNode.innerText).join("\n").slice(t4, t4 + e4);
            }
            html(t4, e4) {
              return `<pre>
${$r(this.code(t4, e4))}
</pre>`;
            }
          }
          class ni extends Wr {
            static {
              __name(this, "ni");
            }
            static TAB = "  ";
            static register() {
              Rs.register(ei);
            }
          }
          class ri extends Kr {
            static {
              __name(this, "ri");
            }
          }
          ri.blotName = "code", ri.tagName = "CODE", ni.blotName = "code-block", ni.className = "ql-code-block", ni.tagName = "DIV", ei.blotName = "code-block-container", ei.className = "ql-code-block-container", ei.tagName = "DIV", ei.allowedChildren = [ni], ni.allowedChildren = [Fr, Hr, Yr], ni.requiredContainer = ei;
          const si = { scope: Pe.BLOCK, whitelist: ["rtl"] }, ii = new ze("direction", "dir", si), oi = new Ke("direction", "ql-direction", si), li = new Ze("direction", "direction", si), ai = { scope: Pe.INLINE, whitelist: ["serif", "monospace"] }, ci = new Ke("font", "ql-font", ai);
          const ui = new class extends Ze {
            value(t4) {
              return super.value(t4).replace(/["']/g, "");
            }
          }("font", "font-family", ai), hi = new Ke("size", "ql-size", { scope: Pe.INLINE, whitelist: ["small", "large", "huge"] }), di = new Ze("size", "font-size", { scope: Pe.INLINE, whitelist: ["10px", "18px", "32px"] }), fi = is("quill:keyboard"), pi = /Mac/i.test(navigator.platform) ? "metaKey" : "ctrlKey";
          class gi extends xs {
            static {
              __name(this, "gi");
            }
            static match(t4, e4) {
              return !["altKey", "ctrlKey", "metaKey", "shiftKey"].some((n4) => !!e4[n4] !== t4[n4] && null !== e4[n4]) && (e4.key === t4.key || e4.key === t4.which);
            }
            constructor(t4, e4) {
              super(t4, e4), this.bindings = {}, Object.keys(this.options.bindings).forEach((t5) => {
                this.options.bindings[t5] && this.addBinding(this.options.bindings[t5]);
              }), this.addBinding({ key: "Enter", shiftKey: null }, this.handleEnter), this.addBinding({ key: "Enter", metaKey: null, ctrlKey: null, altKey: null }, () => {
              }), /Firefox/i.test(navigator.userAgent) ? (this.addBinding({ key: "Backspace" }, { collapsed: true }, this.handleBackspace), this.addBinding({ key: "Delete" }, { collapsed: true }, this.handleDelete)) : (this.addBinding({ key: "Backspace" }, { collapsed: true, prefix: /^.?$/ }, this.handleBackspace), this.addBinding({ key: "Delete" }, { collapsed: true, suffix: /^.?$/ }, this.handleDelete)), this.addBinding({ key: "Backspace" }, { collapsed: false }, this.handleDeleteRange), this.addBinding({ key: "Delete" }, { collapsed: false }, this.handleDeleteRange), this.addBinding({ key: "Backspace", altKey: null, ctrlKey: null, metaKey: null, shiftKey: null }, { collapsed: true, offset: 0 }, this.handleBackspace), this.listen();
            }
            addBinding(t4) {
              let e4 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, n4 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
              const r3 = function(t5) {
                if ("string" == typeof t5 || "number" == typeof t5)
                  t5 = { key: t5 };
                else {
                  if ("object" != typeof t5)
                    return null;
                  t5 = vr(t5);
                }
                t5.shortKey && (t5[pi] = t5.shortKey, delete t5.shortKey);
                return t5;
              }(t4);
              if (null == r3)
                return void fi.warn("Attempted to add invalid keyboard binding", r3);
              "function" == typeof e4 && (e4 = { handler: e4 }), "function" == typeof n4 && (n4 = { handler: n4 });
              (Array.isArray(r3.key) ? r3.key : [r3.key]).forEach((t5) => {
                const s3 = { ...r3, key: t5, ...e4, ...n4 };
                this.bindings[s3.key] = this.bindings[s3.key] || [], this.bindings[s3.key].push(s3);
              });
            }
            listen() {
              this.quill.root.addEventListener("keydown", (t4) => {
                if (t4.defaultPrevented || t4.isComposing)
                  return;
                if (229 === t4.keyCode && ("Enter" === t4.key || "Backspace" === t4.key))
                  return;
                const e4 = (this.bindings[t4.key] || []).concat(this.bindings[t4.which] || []).filter((e5) => gi.match(t4, e5));
                if (0 === e4.length)
                  return;
                const n4 = Rs.find(t4.target, true);
                if (n4 && n4.scroll !== this.quill.scroll)
                  return;
                const r3 = this.quill.getSelection();
                if (null == r3 || !this.quill.hasFocus())
                  return;
                const [s3, i3] = this.quill.getLine(r3.index), [o3, l3] = this.quill.getLeaf(r3.index), [a3, c3] = 0 === r3.length ? [o3, l3] : this.quill.getLeaf(r3.index + r3.length), u3 = o3 instanceof mn ? o3.value().slice(0, l3) : "", h3 = a3 instanceof mn ? a3.value().slice(c3) : "", d3 = { collapsed: 0 === r3.length, empty: 0 === r3.length && s3.length() <= 1, format: this.quill.getFormat(r3), line: s3, offset: i3, prefix: u3, suffix: h3, event: t4 };
                e4.some((t5) => {
                  if (null != t5.collapsed && t5.collapsed !== d3.collapsed)
                    return false;
                  if (null != t5.empty && t5.empty !== d3.empty)
                    return false;
                  if (null != t5.offset && t5.offset !== d3.offset)
                    return false;
                  if (Array.isArray(t5.format)) {
                    if (t5.format.every((t6) => null == d3.format[t6]))
                      return false;
                  } else if ("object" == typeof t5.format && !Object.keys(t5.format).every((e5) => true === t5.format[e5] ? null != d3.format[e5] : false === t5.format[e5] ? null == d3.format[e5] : Pr(t5.format[e5], d3.format[e5])))
                    return false;
                  return !(null != t5.prefix && !t5.prefix.test(d3.prefix)) && (!(null != t5.suffix && !t5.suffix.test(d3.suffix)) && true !== t5.handler.call(this, r3, d3, t5));
                }) && t4.preventDefault();
              });
            }
            handleBackspace(t4, e4) {
              const n4 = /[\uD800-\uDBFF][\uDC00-\uDFFF]$/.test(e4.prefix) ? 2 : 1;
              if (0 === t4.index || this.quill.getLength() <= 1)
                return;
              let r3 = {};
              const [s3] = this.quill.getLine(t4.index);
              let i3 = new bn().retain(t4.index - n4).delete(n4);
              if (0 === e4.offset) {
                const [e5] = this.quill.getLine(t4.index - 1);
                if (e5) {
                  if (!("block" === e5.statics.blotName && e5.length() <= 1)) {
                    const e6 = s3.formats(), n5 = this.quill.getFormat(t4.index - 1, 1);
                    if (r3 = bn.AttributeMap.diff(e6, n5) || {}, Object.keys(r3).length > 0) {
                      const e7 = new bn().retain(t4.index + s3.length() - 2).retain(1, r3);
                      i3 = i3.compose(e7);
                    }
                  }
                }
              }
              this.quill.updateContents(i3, Rs.sources.USER), this.quill.focus();
            }
            handleDelete(t4, e4) {
              const n4 = /^[\uD800-\uDBFF][\uDC00-\uDFFF]/.test(e4.suffix) ? 2 : 1;
              if (t4.index >= this.quill.getLength() - n4)
                return;
              let r3 = {};
              const [s3] = this.quill.getLine(t4.index);
              let i3 = new bn().retain(t4.index).delete(n4);
              if (e4.offset >= s3.length() - 1) {
                const [e5] = this.quill.getLine(t4.index + 1);
                if (e5) {
                  const n5 = s3.formats(), o3 = this.quill.getFormat(t4.index, 1);
                  r3 = bn.AttributeMap.diff(n5, o3) || {}, Object.keys(r3).length > 0 && (i3 = i3.retain(e5.length() - 1).retain(1, r3));
                }
              }
              this.quill.updateContents(i3, Rs.sources.USER), this.quill.focus();
            }
            handleDeleteRange(t4) {
              Ni({ range: t4, quill: this.quill }), this.quill.focus();
            }
            handleEnter(t4, e4) {
              const n4 = Object.keys(e4.format).reduce((t5, n5) => (this.quill.scroll.query(n5, Pe.BLOCK) && !Array.isArray(e4.format[n5]) && (t5[n5] = e4.format[n5]), t5), {}), r3 = new bn().retain(t4.index).delete(t4.length).insert("\n", n4);
              this.quill.updateContents(r3, Rs.sources.USER), this.quill.setSelection(t4.index + 1, Rs.sources.SILENT), this.quill.focus();
            }
          }
          const mi = { bindings: { bold: vi("bold"), italic: vi("italic"), underline: vi("underline"), indent: { key: "Tab", format: ["blockquote", "indent", "list"], handler(t4, e4) {
            return !(!e4.collapsed || 0 === e4.offset) || (this.quill.format("indent", "+1", Rs.sources.USER), false);
          } }, outdent: { key: "Tab", shiftKey: true, format: ["blockquote", "indent", "list"], handler(t4, e4) {
            return !(!e4.collapsed || 0 === e4.offset) || (this.quill.format("indent", "-1", Rs.sources.USER), false);
          } }, "outdent backspace": { key: "Backspace", collapsed: true, shiftKey: null, metaKey: null, ctrlKey: null, altKey: null, format: ["indent", "list"], offset: 0, handler(t4, e4) {
            null != e4.format.indent ? this.quill.format("indent", "-1", Rs.sources.USER) : null != e4.format.list && this.quill.format("list", false, Rs.sources.USER);
          } }, "indent code-block": bi(true), "outdent code-block": bi(false), "remove tab": { key: "Tab", shiftKey: true, collapsed: true, prefix: /\t$/, handler(t4) {
            this.quill.deleteText(t4.index - 1, 1, Rs.sources.USER);
          } }, tab: { key: "Tab", handler(t4, e4) {
            if (e4.format.table)
              return true;
            this.quill.history.cutoff();
            const n4 = new bn().retain(t4.index).delete(t4.length).insert("	");
            return this.quill.updateContents(n4, Rs.sources.USER), this.quill.history.cutoff(), this.quill.setSelection(t4.index + 1, Rs.sources.SILENT), false;
          } }, "blockquote empty enter": { key: "Enter", collapsed: true, format: ["blockquote"], empty: true, handler() {
            this.quill.format("blockquote", false, Rs.sources.USER);
          } }, "list empty enter": { key: "Enter", collapsed: true, format: ["list"], empty: true, handler(t4, e4) {
            const n4 = { list: false };
            e4.format.indent && (n4.indent = false), this.quill.formatLine(t4.index, t4.length, n4, Rs.sources.USER);
          } }, "checklist enter": { key: "Enter", collapsed: true, format: { list: "checked" }, handler(t4) {
            const [e4, n4] = this.quill.getLine(t4.index), r3 = { ...e4.formats(), list: "checked" }, s3 = new bn().retain(t4.index).insert("\n", r3).retain(e4.length() - n4 - 1).retain(1, { list: "unchecked" });
            this.quill.updateContents(s3, Rs.sources.USER), this.quill.setSelection(t4.index + 1, Rs.sources.SILENT), this.quill.scrollSelectionIntoView();
          } }, "header enter": { key: "Enter", collapsed: true, format: ["header"], suffix: /^$/, handler(t4, e4) {
            const [n4, r3] = this.quill.getLine(t4.index), s3 = new bn().retain(t4.index).insert("\n", e4.format).retain(n4.length() - r3 - 1).retain(1, { header: null });
            this.quill.updateContents(s3, Rs.sources.USER), this.quill.setSelection(t4.index + 1, Rs.sources.SILENT), this.quill.scrollSelectionIntoView();
          } }, "table backspace": { key: "Backspace", format: ["table"], collapsed: true, offset: 0, handler() {
          } }, "table delete": { key: "Delete", format: ["table"], collapsed: true, suffix: /^$/, handler() {
          } }, "table enter": { key: "Enter", shiftKey: null, format: ["table"], handler(t4) {
            const e4 = this.quill.getModule("table");
            if (e4) {
              const [n4, r3, s3, i3] = e4.getTable(t4), o3 = function(t5, e5, n5, r4) {
                if (null == e5.prev && null == e5.next)
                  return null == n5.prev && null == n5.next ? 0 === r4 ? -1 : 1 : null == n5.prev ? -1 : 1;
                if (null == e5.prev)
                  return -1;
                if (null == e5.next)
                  return 1;
                return null;
              }(0, r3, s3, i3);
              if (null == o3)
                return;
              let l3 = n4.offset();
              if (o3 < 0) {
                const e5 = new bn().retain(l3).insert("\n");
                this.quill.updateContents(e5, Rs.sources.USER), this.quill.setSelection(t4.index + 1, t4.length, Rs.sources.SILENT);
              } else if (o3 > 0) {
                l3 += n4.length();
                const t5 = new bn().retain(l3).insert("\n");
                this.quill.updateContents(t5, Rs.sources.USER), this.quill.setSelection(l3, Rs.sources.USER);
              }
            }
          } }, "table tab": { key: "Tab", shiftKey: null, format: ["table"], handler(t4, e4) {
            const { event: n4, line: r3 } = e4, s3 = r3.offset(this.quill.scroll);
            n4.shiftKey ? this.quill.setSelection(s3 - 1, Rs.sources.USER) : this.quill.setSelection(s3 + r3.length(), Rs.sources.USER);
          } }, "list autofill": { key: " ", shiftKey: null, collapsed: true, format: { "code-block": false, blockquote: false, table: false }, prefix: /^\s*?(\d+\.|-|\*|\[ ?\]|\[x\])$/, handler(t4, e4) {
            if (null == this.quill.scroll.query("list"))
              return true;
            const { length: n4 } = e4.prefix, [r3, s3] = this.quill.getLine(t4.index);
            if (s3 > n4)
              return true;
            let i3;
            switch (e4.prefix.trim()) {
              case "[]":
              case "[ ]":
                i3 = "unchecked";
                break;
              case "[x]":
                i3 = "checked";
                break;
              case "-":
              case "*":
                i3 = "bullet";
                break;
              default:
                i3 = "ordered";
            }
            this.quill.insertText(t4.index, " ", Rs.sources.USER), this.quill.history.cutoff();
            const o3 = new bn().retain(t4.index - s3).delete(n4 + 1).retain(r3.length() - 2 - s3).retain(1, { list: i3 });
            return this.quill.updateContents(o3, Rs.sources.USER), this.quill.history.cutoff(), this.quill.setSelection(t4.index - n4, Rs.sources.SILENT), false;
          } }, "code exit": { key: "Enter", collapsed: true, format: ["code-block"], prefix: /^$/, suffix: /^\s*$/, handler(t4) {
            const [e4, n4] = this.quill.getLine(t4.index);
            let r3 = 2, s3 = e4;
            for (; null != s3 && s3.length() <= 1 && s3.formats()["code-block"]; )
              if (s3 = s3.prev, r3 -= 1, r3 <= 0) {
                const r4 = new bn().retain(t4.index + e4.length() - n4 - 2).retain(1, { "code-block": null }).delete(1);
                return this.quill.updateContents(r4, Rs.sources.USER), this.quill.setSelection(t4.index - 1, Rs.sources.SILENT), false;
              }
            return true;
          } }, "embed left": yi("ArrowLeft", false), "embed left shift": yi("ArrowLeft", true), "embed right": yi("ArrowRight", false), "embed right shift": yi("ArrowRight", true), "table down": xi(false), "table up": xi(true) } };
          function bi(t4) {
            return { key: "Tab", shiftKey: !t4, format: { "code-block": true }, handler(e4, n4) {
              let { event: r3 } = n4;
              const s3 = this.quill.scroll.query("code-block"), { TAB: i3 } = s3;
              if (0 === e4.length && !r3.shiftKey)
                return this.quill.insertText(e4.index, i3, Rs.sources.USER), void this.quill.setSelection(e4.index + i3.length, Rs.sources.SILENT);
              const o3 = 0 === e4.length ? this.quill.getLines(e4.index, 1) : this.quill.getLines(e4);
              let { index: l3, length: a3 } = e4;
              o3.forEach((e5, n5) => {
                t4 ? (e5.insertAt(0, i3), 0 === n5 ? l3 += i3.length : a3 += i3.length) : e5.domNode.textContent.startsWith(i3) && (e5.deleteAt(0, i3.length), 0 === n5 ? l3 -= i3.length : a3 -= i3.length);
              }), this.quill.update(Rs.sources.USER), this.quill.setSelection(l3, a3, Rs.sources.SILENT);
            } };
          }
          __name(bi, "bi");
          function yi(t4, e4) {
            const n4 = "ArrowLeft" === t4 ? "prefix" : "suffix";
            return { key: t4, shiftKey: e4, altKey: null, [n4]: /^$/, handler(n5) {
              let { index: r3 } = n5;
              "ArrowRight" === t4 && (r3 += n5.length + 1);
              const [s3] = this.quill.getLeaf(r3);
              return !(s3 instanceof hn) || ("ArrowLeft" === t4 ? e4 ? this.quill.setSelection(n5.index - 1, n5.length + 1, Rs.sources.USER) : this.quill.setSelection(n5.index - 1, Rs.sources.USER) : e4 ? this.quill.setSelection(n5.index, n5.length + 1, Rs.sources.USER) : this.quill.setSelection(n5.index + n5.length + 1, Rs.sources.USER), false);
            } };
          }
          __name(yi, "yi");
          function vi(t4) {
            return { key: t4[0], shortKey: true, handler(e4, n4) {
              this.quill.format(t4, !n4.format[t4], Rs.sources.USER);
            } };
          }
          __name(vi, "vi");
          function xi(t4) {
            return { key: t4 ? "ArrowUp" : "ArrowDown", collapsed: true, format: ["table"], handler(e4, n4) {
              const r3 = t4 ? "prev" : "next", s3 = n4.line, i3 = s3.parent[r3];
              if (null != i3) {
                if ("table-row" === i3.statics.blotName) {
                  let t5 = i3.children.head, e5 = s3;
                  for (; null != e5.prev; )
                    e5 = e5.prev, t5 = t5.next;
                  const r4 = t5.offset(this.quill.scroll) + Math.min(n4.offset, t5.length() - 1);
                  this.quill.setSelection(r4, 0, Rs.sources.USER);
                }
              } else {
                const e5 = s3.table()[r3];
                null != e5 && (t4 ? this.quill.setSelection(e5.offset(this.quill.scroll) + e5.length() - 1, 0, Rs.sources.USER) : this.quill.setSelection(e5.offset(this.quill.scroll), 0, Rs.sources.USER));
              }
              return false;
            } };
          }
          __name(xi, "xi");
          function Ni(t4) {
            let { quill: e4, range: n4 } = t4;
            const r3 = e4.getLines(n4);
            let s3 = {};
            if (r3.length > 1) {
              const t5 = r3[0].formats(), e5 = r3[r3.length - 1].formats();
              s3 = bn.AttributeMap.diff(e5, t5) || {};
            }
            e4.deleteText(n4, Rs.sources.USER), Object.keys(s3).length > 0 && e4.formatLine(n4.index, 1, s3, Rs.sources.USER), e4.setSelection(n4.index, Rs.sources.SILENT);
          }
          __name(Ni, "Ni");
          gi.DEFAULTS = mi;
          const wi = /font-weight:\s*normal/, Ei = ["P", "OL", "UL"], Ai = /* @__PURE__ */ __name((t4) => t4 && Ei.includes(t4.tagName), "Ai");
          const qi = /\bmso-list:[^;]*ignore/i, ki = /\bmso-list:[^;]*\bl(\d+)/i, _i = /\bmso-list:[^;]*\blevel(\d+)/i, Li = /* @__PURE__ */ __name((t4) => {
            const e4 = Array.from(t4.querySelectorAll("[style*=mso-list]")), n4 = [], r3 = [];
            e4.forEach((t5) => {
              (t5.getAttribute("style") || "").match(qi) ? n4.push(t5) : r3.push(t5);
            }), n4.forEach((t5) => t5.parentNode?.removeChild(t5));
            const s3 = t4.documentElement.innerHTML, i3 = r3.map((t5) => ((t6, e5) => {
              const n5 = t6.getAttribute("style"), r4 = n5?.match(ki);
              if (!r4)
                return null;
              const s4 = Number(r4[1]), i4 = n5?.match(_i), o3 = i4 ? Number(i4[1]) : 1, l3 = new RegExp(`@list l${s4}:level${o3}\\s*\\{[^\\}]*mso-level-number-format:\\s*([\\w-]+)`, "i"), a3 = e5.match(l3);
              return { id: s4, indent: o3, type: a3 && "bullet" === a3[1] ? "bullet" : "ordered", element: t6 };
            })(t5, s3)).filter((t5) => t5);
            for (; i3.length; ) {
              const t5 = [];
              let e5 = i3.shift();
              for (; e5; )
                t5.push(e5), e5 = i3.length && i3[0]?.element === e5.element.nextElementSibling && i3[0].id === e5.id ? i3.shift() : null;
              const n5 = document.createElement("ul");
              t5.forEach((t6) => {
                const e6 = document.createElement("li");
                e6.setAttribute("data-list", t6.type), t6.indent > 1 && e6.setAttribute("class", "ql-indent-" + (t6.indent - 1)), e6.innerHTML = t6.element.innerHTML, n5.appendChild(e6);
              });
              const r4 = t5[0]?.element, { parentNode: s4 } = r4 ?? {};
              r4 && s4?.replaceChild(n5, r4), t5.slice(1).forEach((t6) => {
                let { element: e6 } = t6;
                s4?.removeChild(e6);
              });
            }
          }, "Li");
          const Oi = [function(t4) {
            "urn:schemas-microsoft-com:office:word" === t4.documentElement.getAttribute("xmlns:w") && Li(t4);
          }, function(t4) {
            t4.querySelector('[id^="docs-internal-guid-"]') && (((t5) => {
              Array.from(t5.querySelectorAll('b[style*="font-weight"]')).filter((t6) => t6.getAttribute("style")?.match(wi)).forEach((e4) => {
                const n4 = t5.createDocumentFragment();
                n4.append(...e4.childNodes), e4.parentNode?.replaceChild(n4, e4);
              });
            })(t4), ((t5) => {
              Array.from(t5.querySelectorAll("br")).filter((t6) => Ai(t6.previousElementSibling) && Ai(t6.nextElementSibling)).forEach((t6) => {
                t6.parentNode?.removeChild(t6);
              });
            })(t4));
          }], Ti = /* @__PURE__ */ __name((t4) => {
            t4.documentElement && Oi.forEach((e4) => {
              e4(t4);
            });
          }, "Ti"), Si = is("quill:clipboard"), Ci = [[Node.TEXT_NODE, function(t4, e4, n4) {
            let r3 = t4.data;
            if ("O:P" === t4.parentElement?.tagName)
              return e4.insert(r3.trim());
            if (!Di(t4)) {
              if (0 === r3.trim().length && r3.includes("\n") && !function(t5, e5) {
                return t5.previousElementSibling && t5.nextElementSibling && !Bi(t5.previousElementSibling, e5) && !Bi(t5.nextElementSibling, e5);
              }(t4, n4))
                return e4;
              const s3 = /* @__PURE__ */ __name((t5, e5) => {
                const n5 = e5.replace(/[^\u00a0]/g, "");
                return n5.length < 1 && t5 ? " " : n5;
              }, "s");
              r3 = r3.replace(/\r\n/g, " ").replace(/\n/g, " "), r3 = r3.replace(/\s\s+/g, s3.bind(s3, true)), (null == t4.previousSibling && null != t4.parentElement && Bi(t4.parentElement, n4) || t4.previousSibling instanceof Element && Bi(t4.previousSibling, n4)) && (r3 = r3.replace(/^\s+/, s3.bind(s3, false))), (null == t4.nextSibling && null != t4.parentElement && Bi(t4.parentElement, n4) || t4.nextSibling instanceof Element && Bi(t4.nextSibling, n4)) && (r3 = r3.replace(/\s+$/, s3.bind(s3, false)));
            }
            return e4.insert(r3);
          }], [Node.TEXT_NODE, Hi], ["br", function(t4, e4) {
            Mi(e4, "\n") || e4.insert("\n");
            return e4;
          }], [Node.ELEMENT_NODE, Hi], [Node.ELEMENT_NODE, function(t4, e4, n4) {
            const r3 = n4.query(t4);
            if (null == r3)
              return e4;
            if (r3.prototype instanceof hn) {
              const e5 = {}, s3 = r3.value(t4);
              if (null != s3)
                return e5[r3.blotName] = s3, new bn().insert(e5, r3.formats(t4, n4));
            } else if (r3.prototype instanceof an && !Mi(e4, "\n") && e4.insert("\n"), "blotName" in r3 && "formats" in r3 && "function" == typeof r3.formats)
              return Ii(e4, r3.blotName, r3.formats(t4, n4), n4);
            return e4;
          }], [Node.ELEMENT_NODE, function(t4, e4, n4) {
            const r3 = ze.keys(t4), s3 = Ke.keys(t4), i3 = Ze.keys(t4), o3 = {};
            return r3.concat(s3).concat(i3).forEach((e5) => {
              let r4 = n4.query(e5, Pe.ATTRIBUTE);
              null != r4 && (o3[r4.attrName] = r4.value(t4), o3[r4.attrName]) || (r4 = ji[e5], null == r4 || r4.attrName !== e5 && r4.keyName !== e5 || (o3[r4.attrName] = r4.value(t4) || void 0), r4 = Ri[e5], null == r4 || r4.attrName !== e5 && r4.keyName !== e5 || (r4 = Ri[e5], o3[r4.attrName] = r4.value(t4) || void 0));
            }), Object.entries(o3).reduce((t5, e5) => {
              let [r4, s4] = e5;
              return Ii(t5, r4, s4, n4);
            }, e4);
          }], [Node.ELEMENT_NODE, function(t4, e4, n4) {
            const r3 = {}, s3 = t4.style || {};
            "italic" === s3.fontStyle && (r3.italic = true);
            "underline" === s3.textDecoration && (r3.underline = true);
            "line-through" === s3.textDecoration && (r3.strike = true);
            (s3.fontWeight?.startsWith("bold") || parseInt(s3.fontWeight, 10) >= 700) && (r3.bold = true);
            if (e4 = Object.entries(r3).reduce((t5, e5) => {
              let [r4, s4] = e5;
              return Ii(t5, r4, s4, n4);
            }, e4), parseFloat(s3.textIndent || 0) > 0)
              return new bn().insert("	").concat(e4);
            return e4;
          }], ["li", function(t4, e4, n4) {
            const r3 = n4.query(t4);
            if (null == r3 || "list" !== r3.blotName || !Mi(e4, "\n"))
              return e4;
            let s3 = -1, i3 = t4.parentNode;
            for (; null != i3; )
              ["OL", "UL"].includes(i3.tagName) && (s3 += 1), i3 = i3.parentNode;
            return s3 <= 0 ? e4 : e4.reduce((t5, e5) => e5.insert ? e5.attributes && "number" == typeof e5.attributes.indent ? t5.push(e5) : t5.insert(e5.insert, { indent: s3, ...e5.attributes || {} }) : t5, new bn());
          }], ["ol, ul", function(t4, e4, n4) {
            const r3 = t4;
            let s3 = "OL" === r3.tagName ? "ordered" : "bullet";
            const i3 = r3.getAttribute("data-checked");
            i3 && (s3 = "true" === i3 ? "checked" : "unchecked");
            return Ii(e4, "list", s3, n4);
          }], ["pre", function(t4, e4, n4) {
            const r3 = n4.query("code-block"), s3 = !r3 || !("formats" in r3) || "function" != typeof r3.formats || r3.formats(t4, n4);
            return Ii(e4, "code-block", s3, n4);
          }], ["tr", function(t4, e4, n4) {
            const r3 = "TABLE" === t4.parentElement?.tagName ? t4.parentElement : t4.parentElement?.parentElement;
            if (null != r3) {
              return Ii(e4, "table", Array.from(r3.querySelectorAll("tr")).indexOf(t4) + 1, n4);
            }
            return e4;
          }], ["b", zi("bold")], ["i", zi("italic")], ["strike", zi("strike")], ["style", function() {
            return new bn();
          }]], ji = [Ws, ii].reduce((t4, e4) => (t4[e4.keyName] = e4, t4), {}), Ri = [Gs, ti, Ys, li, ui, di].reduce((t4, e4) => (t4[e4.keyName] = e4, t4), {});
          function Ii(t4, e4, n4, r3) {
            return r3.query(e4) ? t4.reduce((t5, r4) => {
              if (!r4.insert)
                return t5;
              if (r4.attributes && r4.attributes[e4])
                return t5.push(r4);
              const s3 = n4 ? { [e4]: n4 } : {};
              return t5.insert(r4.insert, { ...s3, ...r4.attributes });
            }, new bn()) : t4;
          }
          __name(Ii, "Ii");
          function Mi(t4, e4) {
            let n4 = "";
            for (let r3 = t4.ops.length - 1; r3 >= 0 && n4.length < e4.length; --r3) {
              const e5 = t4.ops[r3];
              if ("string" != typeof e5.insert)
                break;
              n4 = e5.insert + n4;
            }
            return n4.slice(-1 * e4.length) === e4;
          }
          __name(Mi, "Mi");
          function Bi(t4, e4) {
            if (!(t4 instanceof Element))
              return false;
            const n4 = e4.query(t4);
            return !(n4 && n4.prototype instanceof hn) && ["address", "article", "blockquote", "canvas", "dd", "div", "dl", "dt", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "header", "iframe", "li", "main", "nav", "ol", "output", "p", "pre", "section", "table", "td", "tr", "ul", "video"].includes(t4.tagName.toLowerCase());
          }
          __name(Bi, "Bi");
          const Ui = /* @__PURE__ */ new WeakMap();
          function Di(t4) {
            return null != t4 && (Ui.has(t4) || ("PRE" === t4.tagName ? Ui.set(t4, true) : Ui.set(t4, Di(t4.parentNode))), Ui.get(t4));
          }
          __name(Di, "Di");
          function Pi(t4, e4, n4, r3, s3) {
            return e4.nodeType === e4.TEXT_NODE ? r3.reduce((n5, r4) => r4(e4, n5, t4), new bn()) : e4.nodeType === e4.ELEMENT_NODE ? Array.from(e4.childNodes || []).reduce((i3, o3) => {
              let l3 = Pi(t4, o3, n4, r3, s3);
              return o3.nodeType === e4.ELEMENT_NODE && (l3 = n4.reduce((e5, n5) => n5(o3, e5, t4), l3), l3 = (s3.get(o3) || []).reduce((e5, n5) => n5(o3, e5, t4), l3)), i3.concat(l3);
            }, new bn()) : new bn();
          }
          __name(Pi, "Pi");
          function zi(t4) {
            return (e4, n4, r3) => Ii(n4, t4, true, r3);
          }
          __name(zi, "zi");
          function Hi(t4, e4, n4) {
            if (!Mi(e4, "\n")) {
              if (Bi(t4, n4) && (t4.childNodes.length > 0 || t4 instanceof HTMLParagraphElement))
                return e4.insert("\n");
              if (e4.length() > 0 && t4.nextSibling) {
                let r3 = t4.nextSibling;
                for (; null != r3; ) {
                  if (Bi(r3, n4))
                    return e4.insert("\n");
                  const t5 = n4.query(r3);
                  if (t5 && t5.prototype instanceof Zr)
                    return e4.insert("\n");
                  r3 = r3.firstChild;
                }
              }
            }
            return e4;
          }
          __name(Hi, "Hi");
          function Fi(t4, e4) {
            let n4 = e4;
            for (let e5 = t4.length - 1; e5 >= 0; e5 -= 1) {
              const r3 = t4[e5];
              t4[e5] = { delta: n4.transform(r3.delta, true), range: r3.range && $i(r3.range, n4) }, n4 = r3.delta.transform(n4), 0 === t4[e5].delta.length() && t4.splice(e5, 1);
            }
          }
          __name(Fi, "Fi");
          function $i(t4, e4) {
            if (!t4)
              return t4;
            const n4 = e4.transformPosition(t4.index);
            return { index: n4, length: e4.transformPosition(t4.index + t4.length) - n4 };
          }
          __name($i, "$i");
          class Vi extends xs {
            static {
              __name(this, "Vi");
            }
            constructor(t4, e4) {
              super(t4, e4), t4.root.addEventListener("drop", (e5) => {
                e5.preventDefault();
                let n4 = null;
                if (document.caretRangeFromPoint)
                  n4 = document.caretRangeFromPoint(e5.clientX, e5.clientY);
                else if (document.caretPositionFromPoint) {
                  const t5 = document.caretPositionFromPoint(e5.clientX, e5.clientY);
                  n4 = document.createRange(), n4.setStart(t5.offsetNode, t5.offset), n4.setEnd(t5.offsetNode, t5.offset);
                }
                const r3 = n4 && t4.selection.normalizeNative(n4);
                if (r3) {
                  const n5 = t4.selection.normalizedToRange(r3);
                  e5.dataTransfer?.files && this.upload(n5, e5.dataTransfer.files);
                }
              });
            }
            upload(t4, e4) {
              const n4 = [];
              Array.from(e4).forEach((t5) => {
                t5 && this.options.mimetypes?.includes(t5.type) && n4.push(t5);
              }), n4.length > 0 && this.options.handler.call(this, t4, n4);
            }
          }
          Vi.DEFAULTS = { mimetypes: ["image/png", "image/jpeg"], handler(t4, e4) {
            if (!this.quill.scroll.query("image"))
              return;
            const n4 = e4.map((t5) => new Promise((e5) => {
              const n5 = new FileReader();
              n5.onload = () => {
                e5(n5.result);
              }, n5.readAsDataURL(t5);
            }));
            Promise.all(n4).then((e5) => {
              const n5 = e5.reduce((t5, e6) => t5.insert({ image: e6 }), new bn().retain(t4.index).delete(t4.length));
              this.quill.updateContents(n5, ls.sources.USER), this.quill.setSelection(t4.index + e5.length, ls.sources.SILENT);
            });
          } };
          const Ki = Vi, Wi = ["insertText", "insertReplacementText"];
          const Zi = class extends xs {
            static {
              __name(this, "Zi");
            }
            constructor(t4, e4) {
              super(t4, e4), t4.root.addEventListener("beforeinput", (t5) => {
                this.handleBeforeInput(t5);
              }), /Android/i.test(navigator.userAgent) || t4.on(Rs.events.COMPOSITION_BEFORE_START, () => {
                this.handleCompositionStart();
              });
            }
            deleteRange(t4) {
              Ni({ range: t4, quill: this.quill });
            }
            replaceText(t4) {
              let e4 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "";
              if (0 === t4.length)
                return false;
              if (e4) {
                const n4 = this.quill.getFormat(t4.index, 1);
                this.deleteRange(t4), this.quill.updateContents(new bn().retain(t4.index).insert(e4, n4), Rs.sources.USER);
              } else
                this.deleteRange(t4);
              return this.quill.setSelection(t4.index + e4.length, 0, Rs.sources.SILENT), true;
            }
            handleBeforeInput(t4) {
              if (this.quill.composition.isComposing || t4.defaultPrevented || !Wi.includes(t4.inputType))
                return;
              const e4 = t4.getTargetRanges ? t4.getTargetRanges()[0] : null;
              if (!e4 || true === e4.collapsed)
                return;
              const n4 = function(t5) {
                if ("string" == typeof t5.data)
                  return t5.data;
                if (t5.dataTransfer?.types.includes("text/plain"))
                  return t5.dataTransfer.getData("text/plain");
                return null;
              }(t4);
              if (null == n4)
                return;
              const r3 = this.quill.selection.normalizeNative(e4), s3 = r3 ? this.quill.selection.normalizedToRange(r3) : null;
              s3 && this.replaceText(s3, n4) && t4.preventDefault();
            }
            handleCompositionStart() {
              const t4 = this.quill.getSelection();
              t4 && this.replaceText(t4);
            }
          }, Gi = /Mac/i.test(navigator.platform);
          const Xi = class extends xs {
            static {
              __name(this, "Xi");
            }
            isListening = false;
            selectionChangeDeadline = 0;
            constructor(t4, e4) {
              super(t4, e4), this.handleArrowKeys(), this.handleNavigationShortcuts();
            }
            handleArrowKeys() {
              this.quill.keyboard.addBinding({ key: ["ArrowLeft", "ArrowRight"], offset: 0, shiftKey: null, handler(t4, e4) {
                let { line: n4, event: r3 } = e4;
                if (!(n4 instanceof rn && n4.uiNode))
                  return true;
                const s3 = "rtl" === getComputedStyle(n4.domNode).direction;
                return !!(s3 && "ArrowRight" !== r3.key || !s3 && "ArrowLeft" !== r3.key) || (this.quill.setSelection(t4.index - 1, t4.length + (r3.shiftKey ? 1 : 0), Rs.sources.USER), false);
              } });
            }
            handleNavigationShortcuts() {
              this.quill.root.addEventListener("keydown", (t4) => {
                !t4.defaultPrevented && ((t5) => "ArrowLeft" === t5.key || "ArrowRight" === t5.key || "ArrowUp" === t5.key || "ArrowDown" === t5.key || "Home" === t5.key || !(!Gi || "a" !== t5.key || true !== t5.ctrlKey))(t4) && this.ensureListeningToSelectionChange();
              });
            }
            ensureListeningToSelectionChange() {
              if (this.selectionChangeDeadline = Date.now() + 100, this.isListening)
                return;
              this.isListening = true;
              document.addEventListener("selectionchange", () => {
                this.isListening = false, Date.now() <= this.selectionChangeDeadline && this.handleSelectionChange();
              }, { once: true });
            }
            handleSelectionChange() {
              const t4 = document.getSelection();
              if (!t4)
                return;
              const e4 = t4.getRangeAt(0);
              if (true !== e4.collapsed || 0 !== e4.startOffset)
                return;
              const n4 = this.quill.scroll.find(e4.startContainer);
              if (!(n4 instanceof rn && n4.uiNode))
                return;
              const r3 = document.createRange();
              r3.setStartAfter(n4.uiNode), r3.setEndAfter(n4.uiNode), t4.removeAllRanges(), t4.addRange(r3);
            }
          };
          Rs.register({ "blots/block": Wr, "blots/block/embed": Zr, "blots/break": Hr, "blots/container": zs, "blots/cursor": Yr, "blots/embed": ws, "blots/inline": Kr, "blots/scroll": Vs, "blots/text": Fr, "modules/clipboard": class extends xs {
            static DEFAULTS = { matchers: [] };
            constructor(t4, e4) {
              super(t4, e4), this.quill.root.addEventListener("copy", (t5) => this.onCaptureCopy(t5, false)), this.quill.root.addEventListener("cut", (t5) => this.onCaptureCopy(t5, true)), this.quill.root.addEventListener("paste", this.onCapturePaste.bind(this)), this.matchers = [], Ci.concat(this.options.matchers ?? []).forEach((t5) => {
                let [e5, n4] = t5;
                this.addMatcher(e5, n4);
              });
            }
            addMatcher(t4, e4) {
              this.matchers.push([t4, e4]);
            }
            convert(t4) {
              let { html: e4, text: n4 } = t4, r3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
              if (r3[ni.blotName])
                return new bn().insert(n4 || "", { [ni.blotName]: r3[ni.blotName] });
              if (!e4)
                return new bn().insert(n4 || "", r3);
              const s3 = this.convertHTML(e4);
              return Mi(s3, "\n") && (null == s3.ops[s3.ops.length - 1].attributes || r3.table) ? s3.compose(new bn().retain(s3.length() - 1).delete(1)) : s3;
            }
            normalizeHTML(t4) {
              Ti(t4);
            }
            convertHTML(t4) {
              const e4 = new DOMParser().parseFromString(t4, "text/html");
              this.normalizeHTML(e4);
              const n4 = e4.body, r3 = /* @__PURE__ */ new WeakMap(), [s3, i3] = this.prepareMatching(n4, r3);
              return Pi(this.quill.scroll, n4, s3, i3, r3);
            }
            dangerouslyPasteHTML(t4, e4) {
              let n4 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : Rs.sources.API;
              if ("string" == typeof t4) {
                const n5 = this.convert({ html: t4, text: "" });
                this.quill.setContents(n5, e4), this.quill.setSelection(0, Rs.sources.SILENT);
              } else {
                const r3 = this.convert({ html: e4, text: "" });
                this.quill.updateContents(new bn().retain(t4).concat(r3), n4), this.quill.setSelection(t4 + r3.length(), Rs.sources.SILENT);
              }
            }
            onCaptureCopy(t4) {
              let e4 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
              if (t4.defaultPrevented)
                return;
              t4.preventDefault();
              const [n4] = this.quill.selection.getRange();
              if (null == n4)
                return;
              const { html: r3, text: s3 } = this.onCopy(n4, e4);
              t4.clipboardData?.setData("text/plain", s3), t4.clipboardData?.setData("text/html", r3), e4 && Ni({ range: n4, quill: this.quill });
            }
            normalizeURIList(t4) {
              return t4.split(/\r?\n/).filter((t5) => "#" !== t5[0]).join("\n");
            }
            onCapturePaste(t4) {
              if (t4.defaultPrevented || !this.quill.isEnabled())
                return;
              t4.preventDefault();
              const e4 = this.quill.getSelection(true);
              if (null == e4)
                return;
              const n4 = t4.clipboardData?.getData("text/html");
              let r3 = t4.clipboardData?.getData("text/plain");
              if (!n4 && !r3) {
                const e5 = t4.clipboardData?.getData("text/uri-list");
                e5 && (r3 = this.normalizeURIList(e5));
              }
              const s3 = Array.from(t4.clipboardData?.files || []);
              if (!n4 && s3.length > 0)
                this.quill.uploader.upload(e4, s3);
              else {
                if (n4 && s3.length > 0) {
                  const t5 = new DOMParser().parseFromString(n4, "text/html");
                  if (1 === t5.body.childElementCount && "IMG" === t5.body.firstElementChild?.tagName)
                    return void this.quill.uploader.upload(e4, s3);
                }
                this.onPaste(e4, { html: n4, text: r3 });
              }
            }
            onCopy(t4) {
              const e4 = this.quill.getText(t4);
              return { html: this.quill.getSemanticHTML(t4), text: e4 };
            }
            onPaste(t4, e4) {
              let { text: n4, html: r3 } = e4;
              const s3 = this.quill.getFormat(t4.index), i3 = this.convert({ text: n4, html: r3 }, s3);
              Si.log("onPaste", i3, { text: n4, html: r3 });
              const o3 = new bn().retain(t4.index).delete(t4.length).concat(i3);
              this.quill.updateContents(o3, Rs.sources.USER), this.quill.setSelection(o3.length() - t4.length, Rs.sources.SILENT), this.quill.scrollSelectionIntoView();
            }
            prepareMatching(t4, e4) {
              const n4 = [], r3 = [];
              return this.matchers.forEach((s3) => {
                const [i3, o3] = s3;
                switch (i3) {
                  case Node.TEXT_NODE:
                    r3.push(o3);
                    break;
                  case Node.ELEMENT_NODE:
                    n4.push(o3);
                    break;
                  default:
                    Array.from(t4.querySelectorAll(i3)).forEach((t5) => {
                      if (e4.has(t5)) {
                        const n5 = e4.get(t5);
                        n5?.push(o3);
                      } else
                        e4.set(t5, [o3]);
                    });
                }
              }), [n4, r3];
            }
          }, "modules/history": class extends xs {
            static DEFAULTS = { delay: 1e3, maxStack: 100, userOnly: false };
            lastRecorded = 0;
            ignoreChange = false;
            stack = { undo: [], redo: [] };
            currentRange = null;
            constructor(t4, e4) {
              super(t4, e4), this.quill.on(Rs.events.EDITOR_CHANGE, (t5, e5, n4, r3) => {
                t5 === Rs.events.SELECTION_CHANGE ? e5 && r3 !== Rs.sources.SILENT && (this.currentRange = e5) : t5 === Rs.events.TEXT_CHANGE && (this.ignoreChange || (this.options.userOnly && r3 !== Rs.sources.USER ? this.transform(e5) : this.record(e5, n4)), this.currentRange = $i(this.currentRange, e5));
              }), this.quill.keyboard.addBinding({ key: "z", shortKey: true }, this.undo.bind(this)), this.quill.keyboard.addBinding({ key: ["z", "Z"], shortKey: true, shiftKey: true }, this.redo.bind(this)), /Win/i.test(navigator.platform) && this.quill.keyboard.addBinding({ key: "y", shortKey: true }, this.redo.bind(this)), this.quill.root.addEventListener("beforeinput", (t5) => {
                "historyUndo" === t5.inputType ? (this.undo(), t5.preventDefault()) : "historyRedo" === t5.inputType && (this.redo(), t5.preventDefault());
              });
            }
            change(t4, e4) {
              if (0 === this.stack[t4].length)
                return;
              const n4 = this.stack[t4].pop();
              if (!n4)
                return;
              const r3 = this.quill.getContents(), s3 = n4.delta.invert(r3);
              this.stack[e4].push({ delta: s3, range: $i(n4.range, s3) }), this.lastRecorded = 0, this.ignoreChange = true, this.quill.updateContents(n4.delta, Rs.sources.USER), this.ignoreChange = false, this.restoreSelection(n4);
            }
            clear() {
              this.stack = { undo: [], redo: [] };
            }
            cutoff() {
              this.lastRecorded = 0;
            }
            record(t4, e4) {
              if (0 === t4.ops.length)
                return;
              this.stack.redo = [];
              let n4 = t4.invert(e4), r3 = this.currentRange;
              const s3 = Date.now();
              if (this.lastRecorded + this.options.delay > s3 && this.stack.undo.length > 0) {
                const t5 = this.stack.undo.pop();
                t5 && (n4 = n4.compose(t5.delta), r3 = t5.range);
              } else
                this.lastRecorded = s3;
              0 !== n4.length() && (this.stack.undo.push({ delta: n4, range: r3 }), this.stack.undo.length > this.options.maxStack && this.stack.undo.shift());
            }
            redo() {
              this.change("redo", "undo");
            }
            transform(t4) {
              Fi(this.stack.undo, t4), Fi(this.stack.redo, t4);
            }
            undo() {
              this.change("undo", "redo");
            }
            restoreSelection(t4) {
              if (t4.range)
                this.quill.setSelection(t4.range, Rs.sources.USER);
              else {
                const e4 = function(t5, e5) {
                  const n4 = e5.reduce((t6, e6) => t6 + (e6.delete || 0), 0);
                  let r3 = e5.length() - n4;
                  (function(t6, e6) {
                    const n5 = e6.ops[e6.ops.length - 1];
                    if (null == n5)
                      return false;
                    if (null != n5.insert)
                      return "string" == typeof n5.insert && n5.insert.endsWith("\n");
                    if (null != n5.attributes)
                      return Object.keys(n5.attributes).some((e7) => null != t6.query(e7, Pe.BLOCK));
                    return false;
                  })(t5, e5) && (r3 -= 1);
                  return r3;
                }(this.quill.scroll, t4.delta);
                this.quill.setSelection(e4, Rs.sources.USER);
              }
            }
          }, "modules/keyboard": gi, "modules/uploader": Ki, "modules/input": Zi, "modules/uiNode": Xi });
          const Qi = Rs;
          const Yi = new class extends Ke {
            add(t4, e4) {
              let n4 = 0;
              if ("+1" === e4 || "-1" === e4) {
                const r3 = this.value(t4) || 0;
                n4 = "+1" === e4 ? r3 + 1 : r3 - 1;
              } else
                "number" == typeof e4 && (n4 = e4);
              return 0 === n4 ? (this.remove(t4), true) : super.add(t4, n4.toString());
            }
            canAdd(t4, e4) {
              return super.canAdd(t4, e4) || super.canAdd(t4, parseInt(e4, 10));
            }
            value(t4) {
              return parseInt(super.value(t4), 10) || void 0;
            }
          }("indent", "ql-indent", { scope: Pe.BLOCK, whitelist: [1, 2, 3, 4, 5, 6, 7, 8] }), Ji = Yi;
          const to = class extends Wr {
            static {
              __name(this, "to");
            }
            static blotName = "blockquote";
            static tagName = "blockquote";
          };
          const eo = class extends Wr {
            static {
              __name(this, "eo");
            }
            static blotName = "header";
            static tagName = ["H1", "H2", "H3", "H4", "H5", "H6"];
            static formats(t4) {
              return this.tagName.indexOf(t4.tagName) + 1;
            }
          };
          class no extends zs {
            static {
              __name(this, "no");
            }
          }
          no.blotName = "list-container", no.tagName = "OL";
          class ro extends Wr {
            static {
              __name(this, "ro");
            }
            static create(t4) {
              const e4 = super.create();
              return e4.setAttribute("data-list", t4), e4;
            }
            static formats(t4) {
              return t4.getAttribute("data-list") || void 0;
            }
            static register() {
              Rs.register(no);
            }
            constructor(t4, e4) {
              super(t4, e4);
              const n4 = e4.ownerDocument.createElement("span"), r3 = /* @__PURE__ */ __name((n5) => {
                if (!t4.isEnabled())
                  return;
                const r4 = this.statics.formats(e4, t4);
                "checked" === r4 ? (this.format("list", "unchecked"), n5.preventDefault()) : "unchecked" === r4 && (this.format("list", "checked"), n5.preventDefault());
              }, "r");
              n4.addEventListener("mousedown", r3), n4.addEventListener("touchstart", r3), this.attachUI(n4);
            }
            format(t4, e4) {
              t4 === this.statics.blotName && e4 ? this.domNode.setAttribute("data-list", e4) : super.format(t4, e4);
            }
          }
          ro.blotName = "list", ro.tagName = "LI", no.allowedChildren = [ro], ro.requiredContainer = no;
          const so = class extends Kr {
            static {
              __name(this, "so");
            }
            static blotName = "bold";
            static tagName = ["STRONG", "B"];
            static create() {
              return super.create();
            }
            static formats() {
              return true;
            }
            optimize(t4) {
              super.optimize(t4), this.domNode.tagName !== this.statics.tagName[0] && this.replaceWith(this.statics.blotName);
            }
          };
          const io = class extends so {
            static {
              __name(this, "io");
            }
            static blotName = "italic";
            static tagName = ["EM", "I"];
          };
          class oo extends Kr {
            static {
              __name(this, "oo");
            }
            static blotName = "link";
            static tagName = "A";
            static SANITIZED_URL = "about:blank";
            static PROTOCOL_WHITELIST = ["http", "https", "mailto", "tel", "sms"];
            static create(t4) {
              const e4 = super.create(t4);
              return e4.setAttribute("href", this.sanitize(t4)), e4.setAttribute("rel", "noopener noreferrer"), e4.setAttribute("target", "_blank"), e4;
            }
            static formats(t4) {
              return t4.getAttribute("href");
            }
            static sanitize(t4) {
              return lo(t4, this.PROTOCOL_WHITELIST) ? t4 : this.SANITIZED_URL;
            }
            format(t4, e4) {
              t4 === this.statics.blotName && e4 ? this.domNode.setAttribute("href", this.constructor.sanitize(e4)) : super.format(t4, e4);
            }
          }
          function lo(t4, e4) {
            const n4 = document.createElement("a");
            n4.href = t4;
            const r3 = n4.href.slice(0, n4.href.indexOf(":"));
            return e4.indexOf(r3) > -1;
          }
          __name(lo, "lo");
          const ao = class extends Kr {
            static {
              __name(this, "ao");
            }
            static blotName = "script";
            static tagName = ["SUB", "SUP"];
            static create(t4) {
              return "super" === t4 ? document.createElement("sup") : "sub" === t4 ? document.createElement("sub") : super.create(t4);
            }
            static formats(t4) {
              return "SUB" === t4.tagName ? "sub" : "SUP" === t4.tagName ? "super" : void 0;
            }
          };
          const co = class extends so {
            static {
              __name(this, "co");
            }
            static blotName = "strike";
            static tagName = ["S", "STRIKE"];
          };
          const uo = class extends Kr {
            static {
              __name(this, "uo");
            }
            static blotName = "underline";
            static tagName = "U";
          };
          const ho = class extends ws {
            static {
              __name(this, "ho");
            }
            static blotName = "formula";
            static className = "ql-formula";
            static tagName = "SPAN";
            static create(t4) {
              if (null == window.katex)
                throw new Error("Formula module requires KaTeX.");
              const e4 = super.create(t4);
              return "string" == typeof t4 && (window.katex.render(t4, e4, { throwOnError: false, errorColor: "#f00" }), e4.setAttribute("data-value", t4)), e4;
            }
            static value(t4) {
              return t4.getAttribute("data-value");
            }
            html() {
              const { formula: t4 } = this.value();
              return `<span>${t4}</span>`;
            }
          }, fo = ["alt", "height", "width"];
          const po = class extends hn {
            static {
              __name(this, "po");
            }
            static blotName = "image";
            static tagName = "IMG";
            static create(t4) {
              const e4 = super.create(t4);
              return "string" == typeof t4 && e4.setAttribute("src", this.sanitize(t4)), e4;
            }
            static formats(t4) {
              return fo.reduce((e4, n4) => (t4.hasAttribute(n4) && (e4[n4] = t4.getAttribute(n4)), e4), {});
            }
            static match(t4) {
              return /\.(jpe?g|gif|png)$/.test(t4) || /^data:image\/.+;base64/.test(t4);
            }
            static sanitize(t4) {
              return lo(t4, ["http", "https", "data"]) ? t4 : "//:0";
            }
            static value(t4) {
              return t4.getAttribute("src");
            }
            format(t4, e4) {
              fo.indexOf(t4) > -1 ? e4 ? this.domNode.setAttribute(t4, e4) : this.domNode.removeAttribute(t4) : super.format(t4, e4);
            }
          }, go = ["height", "width"];
          const mo = class extends Zr {
            static {
              __name(this, "mo");
            }
            static blotName = "video";
            static className = "ql-video";
            static tagName = "IFRAME";
            static create(t4) {
              const e4 = super.create(t4);
              return e4.setAttribute("frameborder", "0"), e4.setAttribute("allowfullscreen", "true"), e4.setAttribute("src", this.sanitize(t4)), e4;
            }
            static formats(t4) {
              return go.reduce((e4, n4) => (t4.hasAttribute(n4) && (e4[n4] = t4.getAttribute(n4)), e4), {});
            }
            static sanitize(t4) {
              return oo.sanitize(t4);
            }
            static value(t4) {
              return t4.getAttribute("src");
            }
            format(t4, e4) {
              go.indexOf(t4) > -1 ? e4 ? this.domNode.setAttribute(t4, e4) : this.domNode.removeAttribute(t4) : super.format(t4, e4);
            }
            html() {
              const { video: t4 } = this.value();
              return `<a href="${t4}">${t4}</a>`;
            }
          }, bo = new Ke("code-token", "hljs", { scope: Pe.INLINE });
          class yo extends Kr {
            static {
              __name(this, "yo");
            }
            static formats(t4, e4) {
              for (; null != t4 && t4 !== e4.domNode; ) {
                if (t4.classList && t4.classList.contains(ni.className))
                  return super.formats(t4, e4);
                t4 = t4.parentNode;
              }
            }
            constructor(t4, e4, n4) {
              super(t4, e4, n4), bo.add(this.domNode, n4);
            }
            format(t4, e4) {
              t4 !== yo.blotName ? super.format(t4, e4) : e4 ? bo.add(this.domNode, e4) : (bo.remove(this.domNode), this.domNode.classList.remove(this.statics.className));
            }
            optimize() {
              super.optimize(...arguments), bo.value(this.domNode) || this.unwrap();
            }
          }
          yo.blotName = "code-token", yo.className = "ql-token";
          class vo extends ni {
            static {
              __name(this, "vo");
            }
            static create(t4) {
              const e4 = super.create(t4);
              return "string" == typeof t4 && e4.setAttribute("data-language", t4), e4;
            }
            static formats(t4) {
              return t4.getAttribute("data-language") || "plain";
            }
            static register() {
            }
            format(t4, e4) {
              t4 === this.statics.blotName && e4 ? this.domNode.setAttribute("data-language", e4) : super.format(t4, e4);
            }
            replaceWith(t4, e4) {
              return this.formatAt(0, this.length(), yo.blotName, false), super.replaceWith(t4, e4);
            }
          }
          class xo extends ei {
            static {
              __name(this, "xo");
            }
            attach() {
              super.attach(), this.forceNext = false, this.scroll.emitMount(this);
            }
            format(t4, e4) {
              t4 === vo.blotName && (this.forceNext = true, this.children.forEach((n4) => {
                n4.format(t4, e4);
              }));
            }
            formatAt(t4, e4, n4, r3) {
              n4 === vo.blotName && (this.forceNext = true), super.formatAt(t4, e4, n4, r3);
            }
            highlight(t4) {
              let e4 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
              if (null == this.children.head)
                return;
              const n4 = `${Array.from(this.domNode.childNodes).filter((t5) => t5 !== this.uiNode).map((t5) => t5.textContent).join("\n")}
`, r3 = vo.formats(this.children.head.domNode);
              if (e4 || this.forceNext || this.cachedText !== n4) {
                if (n4.trim().length > 0 || null == this.cachedText) {
                  const e5 = this.children.reduce((t5, e6) => t5.concat(Gr(e6, false)), new bn()), s3 = t4(n4, r3);
                  e5.diff(s3).reduce((t5, e6) => {
                    let { retain: n5, attributes: r4 } = e6;
                    return n5 ? (r4 && Object.keys(r4).forEach((e7) => {
                      [vo.blotName, yo.blotName].includes(e7) && this.formatAt(t5, n5, e7, r4[e7]);
                    }), t5 + n5) : t5;
                  }, 0);
                }
                this.cachedText = n4, this.forceNext = false;
              }
            }
            html(t4, e4) {
              const [n4] = this.children.find(t4);
              return `<pre data-language="${n4 ? vo.formats(n4.domNode) : "plain"}">
${$r(this.code(t4, e4))}
</pre>`;
            }
            optimize(t4) {
              if (super.optimize(t4), null != this.parent && null != this.children.head && null != this.uiNode) {
                const t5 = vo.formats(this.children.head.domNode);
                t5 !== this.uiNode.value && (this.uiNode.value = t5);
              }
            }
          }
          xo.allowedChildren = [vo], vo.requiredContainer = xo, vo.allowedChildren = [yo, Yr, Fr, Hr];
          class No extends xs {
            static {
              __name(this, "No");
            }
            static register() {
              Rs.register(yo, true), Rs.register(vo, true), Rs.register(xo, true);
            }
            constructor(t4, e4) {
              if (super(t4, e4), null == this.options.hljs)
                throw new Error("Syntax module requires highlight.js. Please include the library on the page before Quill.");
              this.languages = this.options.languages.reduce((t5, e5) => {
                let { key: n4 } = e5;
                return t5[n4] = true, t5;
              }, {}), this.highlightBlot = this.highlightBlot.bind(this), this.initListener(), this.initTimer();
            }
            initListener() {
              this.quill.on(Rs.events.SCROLL_BLOT_MOUNT, (t4) => {
                if (!(t4 instanceof xo))
                  return;
                const e4 = this.quill.root.ownerDocument.createElement("select");
                this.options.languages.forEach((t5) => {
                  let { key: n4, label: r3 } = t5;
                  const s3 = e4.ownerDocument.createElement("option");
                  s3.textContent = r3, s3.setAttribute("value", n4), e4.appendChild(s3);
                }), e4.addEventListener("change", () => {
                  t4.format(vo.blotName, e4.value), this.quill.root.focus(), this.highlight(t4, true);
                }), null == t4.uiNode && (t4.attachUI(e4), t4.children.head && (e4.value = vo.formats(t4.children.head.domNode)));
              });
            }
            initTimer() {
              let t4 = null;
              this.quill.on(Rs.events.SCROLL_OPTIMIZE, () => {
                t4 && clearTimeout(t4), t4 = setTimeout(() => {
                  this.highlight(), t4 = null;
                }, this.options.interval);
              });
            }
            highlight() {
              let t4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null, e4 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
              if (this.quill.selection.composing)
                return;
              this.quill.update(Rs.sources.USER);
              const n4 = this.quill.getSelection();
              (null == t4 ? this.quill.scroll.descendants(xo) : [t4]).forEach((t5) => {
                t5.highlight(this.highlightBlot, e4);
              }), this.quill.update(Rs.sources.SILENT), null != n4 && this.quill.setSelection(n4, Rs.sources.SILENT);
            }
            highlightBlot(t4) {
              let e4 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "plain";
              if (e4 = this.languages[e4] ? e4 : "plain", "plain" === e4)
                return $r(t4).split("\n").reduce((t5, n5, r3) => (0 !== r3 && t5.insert("\n", { [ni.blotName]: e4 }), t5.insert(n5)), new bn());
              const n4 = this.quill.root.ownerDocument.createElement("div");
              return n4.classList.add(ni.className), n4.innerHTML = ((t5, e5, n5) => {
                if ("string" == typeof t5.versionString) {
                  const r3 = t5.versionString.split(".")[0];
                  if (parseInt(r3, 10) >= 11)
                    return t5.highlight(n5, { language: e5 }).value;
                }
                return t5.highlight(e5, n5).value;
              })(this.options.hljs, e4, t4), Pi(this.quill.scroll, n4, [(t5, e5) => {
                const n5 = bo.value(t5);
                return n5 ? e5.compose(new bn().retain(e5.length(), { [yo.blotName]: n5 })) : e5;
              }], [(t5, n5) => t5.data.split("\n").reduce((t6, n6, r3) => (0 !== r3 && t6.insert("\n", { [ni.blotName]: e4 }), t6.insert(n6)), n5)], /* @__PURE__ */ new WeakMap());
            }
          }
          No.DEFAULTS = { hljs: window.hljs, interval: 1e3, languages: [{ key: "plain", label: "Plain" }, { key: "bash", label: "Bash" }, { key: "cpp", label: "C++" }, { key: "cs", label: "C#" }, { key: "css", label: "CSS" }, { key: "diff", label: "Diff" }, { key: "xml", label: "HTML/XML" }, { key: "java", label: "Java" }, { key: "javascript", label: "JavaScript" }, { key: "markdown", label: "Markdown" }, { key: "php", label: "PHP" }, { key: "python", label: "Python" }, { key: "ruby", label: "Ruby" }, { key: "sql", label: "SQL" }] };
          class wo extends Wr {
            static {
              __name(this, "wo");
            }
            static blotName = "table";
            static tagName = "TD";
            static create(t4) {
              const e4 = super.create();
              return t4 ? e4.setAttribute("data-row", t4) : e4.setAttribute("data-row", ko()), e4;
            }
            static formats(t4) {
              if (t4.hasAttribute("data-row"))
                return t4.getAttribute("data-row");
            }
            cellOffset() {
              return this.parent ? this.parent.children.indexOf(this) : -1;
            }
            format(t4, e4) {
              t4 === wo.blotName && e4 ? this.domNode.setAttribute("data-row", e4) : super.format(t4, e4);
            }
            row() {
              return this.parent;
            }
            rowOffset() {
              return this.row() ? this.row().rowOffset() : -1;
            }
            table() {
              return this.row() && this.row().table();
            }
          }
          class Eo extends zs {
            static {
              __name(this, "Eo");
            }
            static blotName = "table-row";
            static tagName = "TR";
            checkMerge() {
              if (super.checkMerge() && null != this.next.children.head) {
                const t4 = this.children.head.formats(), e4 = this.children.tail.formats(), n4 = this.next.children.head.formats(), r3 = this.next.children.tail.formats();
                return t4.table === e4.table && t4.table === n4.table && t4.table === r3.table;
              }
              return false;
            }
            optimize(t4) {
              super.optimize(t4), this.children.forEach((t5) => {
                if (null == t5.next)
                  return;
                const e4 = t5.formats(), n4 = t5.next.formats();
                if (e4.table !== n4.table) {
                  const e5 = this.splitAfter(t5);
                  e5 && e5.optimize(), this.prev && this.prev.optimize();
                }
              });
            }
            rowOffset() {
              return this.parent ? this.parent.children.indexOf(this) : -1;
            }
            table() {
              return this.parent && this.parent.parent;
            }
          }
          class Ao extends zs {
            static {
              __name(this, "Ao");
            }
            static blotName = "table-body";
            static tagName = "TBODY";
          }
          class qo extends zs {
            static {
              __name(this, "qo");
            }
            static blotName = "table-container";
            static tagName = "TABLE";
            balanceCells() {
              const t4 = this.descendants(Eo), e4 = t4.reduce((t5, e5) => Math.max(e5.children.length, t5), 0);
              t4.forEach((t5) => {
                new Array(e4 - t5.children.length).fill(0).forEach(() => {
                  let e5;
                  null != t5.children.head && (e5 = wo.formats(t5.children.head.domNode));
                  const n4 = this.scroll.create(wo.blotName, e5);
                  t5.appendChild(n4), n4.optimize();
                });
              });
            }
            cells(t4) {
              return this.rows().map((e4) => e4.children.at(t4));
            }
            deleteColumn(t4) {
              const [e4] = this.descendant(Ao);
              null != e4 && null != e4.children.head && e4.children.forEach((e5) => {
                const n4 = e5.children.at(t4);
                null != n4 && n4.remove();
              });
            }
            insertColumn(t4) {
              const [e4] = this.descendant(Ao);
              null != e4 && null != e4.children.head && e4.children.forEach((e5) => {
                const n4 = e5.children.at(t4), r3 = wo.formats(e5.children.head.domNode), s3 = this.scroll.create(wo.blotName, r3);
                e5.insertBefore(s3, n4);
              });
            }
            insertRow(t4) {
              const [e4] = this.descendant(Ao);
              if (null == e4 || null == e4.children.head)
                return;
              const n4 = ko(), r3 = this.scroll.create(Eo.blotName);
              e4.children.head.children.forEach(() => {
                const t5 = this.scroll.create(wo.blotName, n4);
                r3.appendChild(t5);
              });
              const s3 = e4.children.at(t4);
              e4.insertBefore(r3, s3);
            }
            rows() {
              const t4 = this.children.head;
              return null == t4 ? [] : t4.children.map((t5) => t5);
            }
          }
          function ko() {
            return `row-${Math.random().toString(36).slice(2, 6)}`;
          }
          __name(ko, "ko");
          qo.allowedChildren = [Ao], Ao.requiredContainer = qo, Ao.allowedChildren = [Eo], Eo.requiredContainer = Ao, Eo.allowedChildren = [wo], wo.requiredContainer = Eo;
          const _o = class extends xs {
            static {
              __name(this, "_o");
            }
            static register() {
              Rs.register(wo), Rs.register(Eo), Rs.register(Ao), Rs.register(qo);
            }
            constructor() {
              super(...arguments), this.listenBalanceCells();
            }
            balanceTables() {
              this.quill.scroll.descendants(qo).forEach((t4) => {
                t4.balanceCells();
              });
            }
            deleteColumn() {
              const [t4, , e4] = this.getTable();
              null != e4 && (t4.deleteColumn(e4.cellOffset()), this.quill.update(Rs.sources.USER));
            }
            deleteRow() {
              const [, t4] = this.getTable();
              null != t4 && (t4.remove(), this.quill.update(Rs.sources.USER));
            }
            deleteTable() {
              const [t4] = this.getTable();
              if (null == t4)
                return;
              const e4 = t4.offset();
              t4.remove(), this.quill.update(Rs.sources.USER), this.quill.setSelection(e4, Rs.sources.SILENT);
            }
            getTable() {
              let t4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.quill.getSelection();
              if (null == t4)
                return [null, null, null, -1];
              const [e4, n4] = this.quill.getLine(t4.index);
              if (null == e4 || e4.statics.blotName !== wo.blotName)
                return [null, null, null, -1];
              const r3 = e4.parent;
              return [r3.parent.parent, r3, e4, n4];
            }
            insertColumn(t4) {
              const e4 = this.quill.getSelection();
              if (!e4)
                return;
              const [n4, r3, s3] = this.getTable(e4);
              if (null == s3)
                return;
              const i3 = s3.cellOffset();
              n4.insertColumn(i3 + t4), this.quill.update(Rs.sources.USER);
              let o3 = r3.rowOffset();
              0 === t4 && (o3 += 1), this.quill.setSelection(e4.index + o3, e4.length, Rs.sources.SILENT);
            }
            insertColumnLeft() {
              this.insertColumn(0);
            }
            insertColumnRight() {
              this.insertColumn(1);
            }
            insertRow(t4) {
              const e4 = this.quill.getSelection();
              if (!e4)
                return;
              const [n4, r3, s3] = this.getTable(e4);
              if (null == s3)
                return;
              const i3 = r3.rowOffset();
              n4.insertRow(i3 + t4), this.quill.update(Rs.sources.USER), t4 > 0 ? this.quill.setSelection(e4, Rs.sources.SILENT) : this.quill.setSelection(e4.index + r3.children.length, e4.length, Rs.sources.SILENT);
            }
            insertRowAbove() {
              this.insertRow(0);
            }
            insertRowBelow() {
              this.insertRow(1);
            }
            insertTable(t4, e4) {
              const n4 = this.quill.getSelection();
              if (null == n4)
                return;
              const r3 = new Array(t4).fill(0).reduce((t5) => {
                const n5 = new Array(e4).fill("\n").join("");
                return t5.insert(n5, { table: ko() });
              }, new bn().retain(n4.index));
              this.quill.updateContents(r3, Rs.sources.USER), this.quill.setSelection(n4.index, Rs.sources.SILENT), this.balanceTables();
            }
            listenBalanceCells() {
              this.quill.on(Rs.events.SCROLL_OPTIMIZE, (t4) => {
                t4.some((t5) => !!["TD", "TR", "TBODY", "TABLE"].includes(t5.target.tagName) && (this.quill.once(Rs.events.TEXT_CHANGE, (t6, e4, n4) => {
                  n4 === Rs.sources.USER && this.balanceTables();
                }), true));
              });
            }
          }, Lo = is("quill:toolbar");
          class Oo extends xs {
            static {
              __name(this, "Oo");
            }
            constructor(t4, e4) {
              if (super(t4, e4), Array.isArray(this.options.container)) {
                const e5 = document.createElement("div");
                e5.setAttribute("role", "toolbar"), function(t5, e6) {
                  Array.isArray(e6[0]) || (e6 = [e6]);
                  e6.forEach((e7) => {
                    const n4 = document.createElement("span");
                    n4.classList.add("ql-formats"), e7.forEach((t6) => {
                      if ("string" == typeof t6)
                        To(n4, t6);
                      else {
                        const e8 = Object.keys(t6)[0], r3 = t6[e8];
                        Array.isArray(r3) ? function(t7, e9, n5) {
                          const r4 = document.createElement("select");
                          r4.classList.add(`ql-${e9}`), n5.forEach((t8) => {
                            const e10 = document.createElement("option");
                            false !== t8 ? e10.setAttribute("value", String(t8)) : e10.setAttribute("selected", "selected"), r4.appendChild(e10);
                          }), t7.appendChild(r4);
                        }(n4, e8, r3) : To(n4, e8, r3);
                      }
                    }), t5.appendChild(n4);
                  });
                }(e5, this.options.container), t4.container?.parentNode?.insertBefore(e5, t4.container), this.container = e5;
              } else
                "string" == typeof this.options.container ? this.container = document.querySelector(this.options.container) : this.container = this.options.container;
              this.container instanceof HTMLElement ? (this.container.classList.add("ql-toolbar"), this.controls = [], this.handlers = {}, this.options.handlers && Object.keys(this.options.handlers).forEach((t5) => {
                const e5 = this.options.handlers?.[t5];
                e5 && this.addHandler(t5, e5);
              }), Array.from(this.container.querySelectorAll("button, select")).forEach((t5) => {
                this.attach(t5);
              }), this.quill.on(Rs.events.EDITOR_CHANGE, () => {
                const [t5] = this.quill.selection.getRange();
                this.update(t5);
              })) : Lo.error("Container required for toolbar", this.options);
            }
            addHandler(t4, e4) {
              this.handlers[t4] = e4;
            }
            attach(t4) {
              let e4 = Array.from(t4.classList).find((t5) => 0 === t5.indexOf("ql-"));
              if (!e4)
                return;
              if (e4 = e4.slice(3), "BUTTON" === t4.tagName && t4.setAttribute("type", "button"), null == this.handlers[e4] && null == this.quill.scroll.query(e4))
                return void Lo.warn("ignoring attaching to nonexistent format", e4, t4);
              const n4 = "SELECT" === t4.tagName ? "change" : "click";
              t4.addEventListener(n4, (n5) => {
                let r3;
                if ("SELECT" === t4.tagName) {
                  if (t4.selectedIndex < 0)
                    return;
                  const e5 = t4.options[t4.selectedIndex];
                  r3 = !e5.hasAttribute("selected") && (e5.value || false);
                } else
                  r3 = !t4.classList.contains("ql-active") && (t4.value || !t4.hasAttribute("value")), n5.preventDefault();
                this.quill.focus();
                const [s3] = this.quill.selection.getRange();
                if (null != this.handlers[e4])
                  this.handlers[e4].call(this, r3);
                else if (this.quill.scroll.query(e4).prototype instanceof hn) {
                  if (r3 = prompt(`Enter ${e4}`), !r3)
                    return;
                  this.quill.updateContents(new bn().retain(s3.index).delete(s3.length).insert({ [e4]: r3 }), Rs.sources.USER);
                } else
                  this.quill.format(e4, r3, Rs.sources.USER);
                this.update(s3);
              }), this.controls.push([e4, t4]);
            }
            update(t4) {
              const e4 = null == t4 ? {} : this.quill.getFormat(t4);
              this.controls.forEach((n4) => {
                const [r3, s3] = n4;
                if ("SELECT" === s3.tagName) {
                  let n5 = null;
                  if (null == t4)
                    n5 = null;
                  else if (null == e4[r3])
                    n5 = s3.querySelector("option[selected]");
                  else if (!Array.isArray(e4[r3])) {
                    let t5 = e4[r3];
                    "string" == typeof t5 && (t5 = t5.replace(/"/g, '\\"')), n5 = s3.querySelector(`option[value="${t5}"]`);
                  }
                  null == n5 ? (s3.value = "", s3.selectedIndex = -1) : n5.selected = true;
                } else if (null == t4)
                  s3.classList.remove("ql-active"), s3.setAttribute("aria-pressed", "false");
                else if (s3.hasAttribute("value")) {
                  const t5 = e4[r3], n5 = t5 === s3.getAttribute("value") || null != t5 && t5.toString() === s3.getAttribute("value") || null == t5 && !s3.getAttribute("value");
                  s3.classList.toggle("ql-active", n5), s3.setAttribute("aria-pressed", n5.toString());
                } else {
                  const t5 = null != e4[r3];
                  s3.classList.toggle("ql-active", t5), s3.setAttribute("aria-pressed", t5.toString());
                }
              });
            }
          }
          function To(t4, e4, n4) {
            const r3 = document.createElement("button");
            r3.setAttribute("type", "button"), r3.classList.add(`ql-${e4}`), r3.setAttribute("aria-pressed", "false"), null != n4 ? (r3.value = n4, r3.setAttribute("aria-label", `${e4}: ${n4}`)) : r3.setAttribute("aria-label", e4), t4.appendChild(r3);
          }
          __name(To, "To");
          Oo.DEFAULTS = {}, Oo.DEFAULTS = { container: null, handlers: { clean() {
            const t4 = this.quill.getSelection();
            if (null != t4)
              if (0 === t4.length) {
                const t5 = this.quill.getFormat();
                Object.keys(t5).forEach((t6) => {
                  null != this.quill.scroll.query(t6, Pe.INLINE) && this.quill.format(t6, false, Rs.sources.USER);
                });
              } else
                this.quill.removeFormat(t4.index, t4.length, Rs.sources.USER);
          }, direction(t4) {
            const { align: e4 } = this.quill.getFormat();
            "rtl" === t4 && null == e4 ? this.quill.format("align", "right", Rs.sources.USER) : t4 || "right" !== e4 || this.quill.format("align", false, Rs.sources.USER), this.quill.format("direction", t4, Rs.sources.USER);
          }, indent(t4) {
            const e4 = this.quill.getSelection(), n4 = this.quill.getFormat(e4), r3 = parseInt(n4.indent || 0, 10);
            if ("+1" === t4 || "-1" === t4) {
              let e5 = "+1" === t4 ? 1 : -1;
              "rtl" === n4.direction && (e5 *= -1), this.quill.format("indent", r3 + e5, Rs.sources.USER);
            }
          }, link(t4) {
            true === t4 && (t4 = prompt("Enter link URL:")), this.quill.format("link", t4, Rs.sources.USER);
          }, list(t4) {
            const e4 = this.quill.getSelection(), n4 = this.quill.getFormat(e4);
            "check" === t4 ? "checked" === n4.list || "unchecked" === n4.list ? this.quill.format("list", false, Rs.sources.USER) : this.quill.format("list", "unchecked", Rs.sources.USER) : this.quill.format("list", t4, Rs.sources.USER);
          } } };
          const So = '<svg viewbox="0 0 18 18"><polyline class="ql-even ql-stroke" points="5 7 3 9 5 11"/><polyline class="ql-even ql-stroke" points="13 7 15 9 13 11"/><line class="ql-stroke" x1="10" x2="8" y1="5" y2="13"/></svg>', Co = { align: { "": '<svg viewbox="0 0 18 18"><line class="ql-stroke" x1="3" x2="15" y1="9" y2="9"/><line class="ql-stroke" x1="3" x2="13" y1="14" y2="14"/><line class="ql-stroke" x1="3" x2="9" y1="4" y2="4"/></svg>', center: '<svg viewbox="0 0 18 18"><line class="ql-stroke" x1="15" x2="3" y1="9" y2="9"/><line class="ql-stroke" x1="14" x2="4" y1="14" y2="14"/><line class="ql-stroke" x1="12" x2="6" y1="4" y2="4"/></svg>', right: '<svg viewbox="0 0 18 18"><line class="ql-stroke" x1="15" x2="3" y1="9" y2="9"/><line class="ql-stroke" x1="15" x2="5" y1="14" y2="14"/><line class="ql-stroke" x1="15" x2="9" y1="4" y2="4"/></svg>', justify: '<svg viewbox="0 0 18 18"><line class="ql-stroke" x1="15" x2="3" y1="9" y2="9"/><line class="ql-stroke" x1="15" x2="3" y1="14" y2="14"/><line class="ql-stroke" x1="15" x2="3" y1="4" y2="4"/></svg>' }, background: '<svg viewbox="0 0 18 18"><g class="ql-fill ql-color-label"><polygon points="6 6.868 6 6 5 6 5 7 5.942 7 6 6.868"/><rect height="1" width="1" x="4" y="4"/><polygon points="6.817 5 6 5 6 6 6.38 6 6.817 5"/><rect height="1" width="1" x="2" y="6"/><rect height="1" width="1" x="3" y="5"/><rect height="1" width="1" x="4" y="7"/><polygon points="4 11.439 4 11 3 11 3 12 3.755 12 4 11.439"/><rect height="1" width="1" x="2" y="12"/><rect height="1" width="1" x="2" y="9"/><rect height="1" width="1" x="2" y="15"/><polygon points="4.63 10 4 10 4 11 4.192 11 4.63 10"/><rect height="1" width="1" x="3" y="8"/><path d="M10.832,4.2L11,4.582V4H10.708A1.948,1.948,0,0,1,10.832,4.2Z"/><path d="M7,4.582L7.168,4.2A1.929,1.929,0,0,1,7.292,4H7V4.582Z"/><path d="M8,13H7.683l-0.351.8a1.933,1.933,0,0,1-.124.2H8V13Z"/><rect height="1" width="1" x="12" y="2"/><rect height="1" width="1" x="11" y="3"/><path d="M9,3H8V3.282A1.985,1.985,0,0,1,9,3Z"/><rect height="1" width="1" x="2" y="3"/><rect height="1" width="1" x="6" y="2"/><rect height="1" width="1" x="3" y="2"/><rect height="1" width="1" x="5" y="3"/><rect height="1" width="1" x="9" y="2"/><rect height="1" width="1" x="15" y="14"/><polygon points="13.447 10.174 13.469 10.225 13.472 10.232 13.808 11 14 11 14 10 13.37 10 13.447 10.174"/><rect height="1" width="1" x="13" y="7"/><rect height="1" width="1" x="15" y="5"/><rect height="1" width="1" x="14" y="6"/><rect height="1" width="1" x="15" y="8"/><rect height="1" width="1" x="14" y="9"/><path d="M3.775,14H3v1H4V14.314A1.97,1.97,0,0,1,3.775,14Z"/><rect height="1" width="1" x="14" y="3"/><polygon points="12 6.868 12 6 11.62 6 12 6.868"/><rect height="1" width="1" x="15" y="2"/><rect height="1" width="1" x="12" y="5"/><rect height="1" width="1" x="13" y="4"/><polygon points="12.933 9 13 9 13 8 12.495 8 12.933 9"/><rect height="1" width="1" x="9" y="14"/><rect height="1" width="1" x="8" y="15"/><path d="M6,14.926V15H7V14.316A1.993,1.993,0,0,1,6,14.926Z"/><rect height="1" width="1" x="5" y="15"/><path d="M10.668,13.8L10.317,13H10v1h0.792A1.947,1.947,0,0,1,10.668,13.8Z"/><rect height="1" width="1" x="11" y="15"/><path d="M14.332,12.2a1.99,1.99,0,0,1,.166.8H15V12H14.245Z"/><rect height="1" width="1" x="14" y="15"/><rect height="1" width="1" x="15" y="11"/></g><polyline class="ql-stroke" points="5.5 13 9 5 12.5 13"/><line class="ql-stroke" x1="11.63" x2="6.38" y1="11" y2="11"/></svg>', blockquote: '<svg viewbox="0 0 18 18"><rect class="ql-fill ql-stroke" height="3" width="3" x="4" y="5"/><rect class="ql-fill ql-stroke" height="3" width="3" x="11" y="5"/><path class="ql-even ql-fill ql-stroke" d="M7,8c0,4.031-3,5-3,5"/><path class="ql-even ql-fill ql-stroke" d="M14,8c0,4.031-3,5-3,5"/></svg>', bold: '<svg viewbox="0 0 18 18"><path class="ql-stroke" d="M5,4H9.5A2.5,2.5,0,0,1,12,6.5v0A2.5,2.5,0,0,1,9.5,9H5A0,0,0,0,1,5,9V4A0,0,0,0,1,5,4Z"/><path class="ql-stroke" d="M5,9h5.5A2.5,2.5,0,0,1,13,11.5v0A2.5,2.5,0,0,1,10.5,14H5a0,0,0,0,1,0,0V9A0,0,0,0,1,5,9Z"/></svg>', clean: '<svg class="" viewbox="0 0 18 18"><line class="ql-stroke" x1="5" x2="13" y1="3" y2="3"/><line class="ql-stroke" x1="6" x2="9.35" y1="12" y2="3"/><line class="ql-stroke" x1="11" x2="15" y1="11" y2="15"/><line class="ql-stroke" x1="15" x2="11" y1="11" y2="15"/><rect class="ql-fill" height="1" rx="0.5" ry="0.5" width="7" x="2" y="14"/></svg>', code: So, "code-block": So, color: '<svg viewbox="0 0 18 18"><line class="ql-color-label ql-stroke ql-transparent" x1="3" x2="15" y1="15" y2="15"/><polyline class="ql-stroke" points="5.5 11 9 3 12.5 11"/><line class="ql-stroke" x1="11.63" x2="6.38" y1="9" y2="9"/></svg>', direction: { "": '<svg viewbox="0 0 18 18"><polygon class="ql-stroke ql-fill" points="3 11 5 9 3 7 3 11"/><line class="ql-stroke ql-fill" x1="15" x2="11" y1="4" y2="4"/><path class="ql-fill" d="M11,3a3,3,0,0,0,0,6h1V3H11Z"/><rect class="ql-fill" height="11" width="1" x="11" y="4"/><rect class="ql-fill" height="11" width="1" x="13" y="4"/></svg>', rtl: '<svg viewbox="0 0 18 18"><polygon class="ql-stroke ql-fill" points="15 12 13 10 15 8 15 12"/><line class="ql-stroke ql-fill" x1="9" x2="5" y1="4" y2="4"/><path class="ql-fill" d="M5,3A3,3,0,0,0,5,9H6V3H5Z"/><rect class="ql-fill" height="11" width="1" x="5" y="4"/><rect class="ql-fill" height="11" width="1" x="7" y="4"/></svg>' }, formula: '<svg viewbox="0 0 18 18"><path class="ql-fill" d="M11.759,2.482a2.561,2.561,0,0,0-3.53.607A7.656,7.656,0,0,0,6.8,6.2C6.109,9.188,5.275,14.677,4.15,14.927a1.545,1.545,0,0,0-1.3-.933A0.922,0.922,0,0,0,2,15.036S1.954,16,4.119,16s3.091-2.691,3.7-5.553c0.177-.826.36-1.726,0.554-2.6L8.775,6.2c0.381-1.421.807-2.521,1.306-2.676a1.014,1.014,0,0,0,1.02.56A0.966,0.966,0,0,0,11.759,2.482Z"/><rect class="ql-fill" height="1.6" rx="0.8" ry="0.8" width="5" x="5.15" y="6.2"/><path class="ql-fill" d="M13.663,12.027a1.662,1.662,0,0,1,.266-0.276q0.193,0.069.456,0.138a2.1,2.1,0,0,0,.535.069,1.075,1.075,0,0,0,.767-0.3,1.044,1.044,0,0,0,.314-0.8,0.84,0.84,0,0,0-.238-0.619,0.8,0.8,0,0,0-.594-0.239,1.154,1.154,0,0,0-.781.3,4.607,4.607,0,0,0-.781,1q-0.091.15-.218,0.346l-0.246.38c-0.068-.288-0.137-0.582-0.212-0.885-0.459-1.847-2.494-.984-2.941-0.8-0.482.2-.353,0.647-0.094,0.529a0.869,0.869,0,0,1,1.281.585c0.217,0.751.377,1.436,0.527,2.038a5.688,5.688,0,0,1-.362.467,2.69,2.69,0,0,1-.264.271q-0.221-.08-0.471-0.147a2.029,2.029,0,0,0-.522-0.066,1.079,1.079,0,0,0-.768.3A1.058,1.058,0,0,0,9,15.131a0.82,0.82,0,0,0,.832.852,1.134,1.134,0,0,0,.787-0.3,5.11,5.11,0,0,0,.776-0.993q0.141-.219.215-0.34c0.046-.076.122-0.194,0.223-0.346a2.786,2.786,0,0,0,.918,1.726,2.582,2.582,0,0,0,2.376-.185c0.317-.181.212-0.565,0-0.494A0.807,0.807,0,0,1,14.176,15a5.159,5.159,0,0,1-.913-2.446l0,0Q13.487,12.24,13.663,12.027Z"/></svg>', header: { 1: '<svg viewBox="0 0 18 18"><path class="ql-fill" d="M10,4V14a1,1,0,0,1-2,0V10H3v4a1,1,0,0,1-2,0V4A1,1,0,0,1,3,4V8H8V4a1,1,0,0,1,2,0Zm6.06787,9.209H14.98975V7.59863a.54085.54085,0,0,0-.605-.60547h-.62744a1.01119,1.01119,0,0,0-.748.29688L11.645,8.56641a.5435.5435,0,0,0-.022.8584l.28613.30762a.53861.53861,0,0,0,.84717.0332l.09912-.08789a1.2137,1.2137,0,0,0,.2417-.35254h.02246s-.01123.30859-.01123.60547V13.209H12.041a.54085.54085,0,0,0-.605.60547v.43945a.54085.54085,0,0,0,.605.60547h4.02686a.54085.54085,0,0,0,.605-.60547v-.43945A.54085.54085,0,0,0,16.06787,13.209Z"/></svg>', 2: '<svg viewBox="0 0 18 18"><path class="ql-fill" d="M16.73975,13.81445v.43945a.54085.54085,0,0,1-.605.60547H11.855a.58392.58392,0,0,1-.64893-.60547V14.0127c0-2.90527,3.39941-3.42187,3.39941-4.55469a.77675.77675,0,0,0-.84717-.78125,1.17684,1.17684,0,0,0-.83594.38477c-.2749.26367-.561.374-.85791.13184l-.4292-.34082c-.30811-.24219-.38525-.51758-.1543-.81445a2.97155,2.97155,0,0,1,2.45361-1.17676,2.45393,2.45393,0,0,1,2.68408,2.40918c0,2.45312-3.1792,2.92676-3.27832,3.93848h2.79443A.54085.54085,0,0,1,16.73975,13.81445ZM9,3A.99974.99974,0,0,0,8,4V8H3V4A1,1,0,0,0,1,4V14a1,1,0,0,0,2,0V10H8v4a1,1,0,0,0,2,0V4A.99974.99974,0,0,0,9,3Z"/></svg>', 3: '<svg viewBox="0 0 18 18"><path class="ql-fill" d="M16.65186,12.30664a2.6742,2.6742,0,0,1-2.915,2.68457,3.96592,3.96592,0,0,1-2.25537-.6709.56007.56007,0,0,1-.13232-.83594L11.64648,13c.209-.34082.48389-.36328.82471-.1543a2.32654,2.32654,0,0,0,1.12256.33008c.71484,0,1.12207-.35156,1.12207-.78125,0-.61523-.61621-.86816-1.46338-.86816H13.2085a.65159.65159,0,0,1-.68213-.41895l-.05518-.10937a.67114.67114,0,0,1,.14307-.78125l.71533-.86914a8.55289,8.55289,0,0,1,.68213-.7373V8.58887a3.93913,3.93913,0,0,1-.748.05469H11.9873a.54085.54085,0,0,1-.605-.60547V7.59863a.54085.54085,0,0,1,.605-.60547h3.75146a.53773.53773,0,0,1,.60547.59375v.17676a1.03723,1.03723,0,0,1-.27539.748L14.74854,10.0293A2.31132,2.31132,0,0,1,16.65186,12.30664ZM9,3A.99974.99974,0,0,0,8,4V8H3V4A1,1,0,0,0,1,4V14a1,1,0,0,0,2,0V10H8v4a1,1,0,0,0,2,0V4A.99974.99974,0,0,0,9,3Z"/></svg>', 4: '<svg viewBox="0 0 18 18"><path class="ql-fill" d="M10,4V14a1,1,0,0,1-2,0V10H3v4a1,1,0,0,1-2,0V4A1,1,0,0,1,3,4V8H8V4a1,1,0,0,1,2,0Zm7.05371,7.96582v.38477c0,.39648-.165.60547-.46191.60547h-.47314v1.29785a.54085.54085,0,0,1-.605.60547h-.69336a.54085.54085,0,0,1-.605-.60547V12.95605H11.333a.5412.5412,0,0,1-.60547-.60547v-.15332a1.199,1.199,0,0,1,.22021-.748l2.56348-4.05957a.7819.7819,0,0,1,.72607-.39648h1.27637a.54085.54085,0,0,1,.605.60547v3.7627h.33008A.54055.54055,0,0,1,17.05371,11.96582ZM14.28125,8.7207h-.022a4.18969,4.18969,0,0,1-.38525.81348l-1.188,1.80469v.02246h1.5293V9.60059A7.04058,7.04058,0,0,1,14.28125,8.7207Z"/></svg>', 5: '<svg viewBox="0 0 18 18"><path class="ql-fill" d="M16.74023,12.18555a2.75131,2.75131,0,0,1-2.91553,2.80566,3.908,3.908,0,0,1-2.25537-.68164.54809.54809,0,0,1-.13184-.8252L11.73438,13c.209-.34082.48389-.36328.8252-.1543a2.23757,2.23757,0,0,0,1.1001.33008,1.01827,1.01827,0,0,0,1.1001-.96777c0-.61621-.53906-.97949-1.25439-.97949a2.15554,2.15554,0,0,0-.64893.09961,1.15209,1.15209,0,0,1-.814.01074l-.12109-.04395a.64116.64116,0,0,1-.45117-.71484l.231-3.00391a.56666.56666,0,0,1,.62744-.583H15.541a.54085.54085,0,0,1,.605.60547v.43945a.54085.54085,0,0,1-.605.60547H13.41748l-.04395.72559a1.29306,1.29306,0,0,1-.04395.30859h.022a2.39776,2.39776,0,0,1,.57227-.07715A2.53266,2.53266,0,0,1,16.74023,12.18555ZM9,3A.99974.99974,0,0,0,8,4V8H3V4A1,1,0,0,0,1,4V14a1,1,0,0,0,2,0V10H8v4a1,1,0,0,0,2,0V4A.99974.99974,0,0,0,9,3Z"/></svg>', 6: '<svg viewBox="0 0 18 18"><path class="ql-fill" d="M14.51758,9.64453a1.85627,1.85627,0,0,0-1.24316.38477H13.252a1.73532,1.73532,0,0,1,1.72754-1.4082,2.66491,2.66491,0,0,1,.5498.06641c.35254.05469.57227.01074.70508-.40723l.16406-.5166a.53393.53393,0,0,0-.373-.75977,4.83723,4.83723,0,0,0-1.17773-.14258c-2.43164,0-3.7627,2.17773-3.7627,4.43359,0,2.47559,1.60645,3.69629,3.19043,3.69629A2.70585,2.70585,0,0,0,16.96,12.19727,2.43861,2.43861,0,0,0,14.51758,9.64453Zm-.23047,3.58691c-.67187,0-1.22168-.81445-1.22168-1.45215,0-.47363.30762-.583.72559-.583.96875,0,1.27734.59375,1.27734,1.12207A.82182.82182,0,0,1,14.28711,13.23145ZM10,4V14a1,1,0,0,1-2,0V10H3v4a1,1,0,0,1-2,0V4A1,1,0,0,1,3,4V8H8V4a1,1,0,0,1,2,0Z"/></svg>' }, italic: '<svg viewbox="0 0 18 18"><line class="ql-stroke" x1="7" x2="13" y1="4" y2="4"/><line class="ql-stroke" x1="5" x2="11" y1="14" y2="14"/><line class="ql-stroke" x1="8" x2="10" y1="14" y2="4"/></svg>', image: '<svg viewbox="0 0 18 18"><rect class="ql-stroke" height="10" width="12" x="3" y="4"/><circle class="ql-fill" cx="6" cy="7" r="1"/><polyline class="ql-even ql-fill" points="5 12 5 11 7 9 8 10 11 7 13 9 13 12 5 12"/></svg>', indent: { "+1": '<svg viewbox="0 0 18 18"><line class="ql-stroke" x1="3" x2="15" y1="14" y2="14"/><line class="ql-stroke" x1="3" x2="15" y1="4" y2="4"/><line class="ql-stroke" x1="9" x2="15" y1="9" y2="9"/><polyline class="ql-fill ql-stroke" points="3 7 3 11 5 9 3 7"/></svg>', "-1": '<svg viewbox="0 0 18 18"><line class="ql-stroke" x1="3" x2="15" y1="14" y2="14"/><line class="ql-stroke" x1="3" x2="15" y1="4" y2="4"/><line class="ql-stroke" x1="9" x2="15" y1="9" y2="9"/><polyline class="ql-stroke" points="5 7 5 11 3 9 5 7"/></svg>' }, link: '<svg viewbox="0 0 18 18"><line class="ql-stroke" x1="7" x2="11" y1="7" y2="11"/><path class="ql-even ql-stroke" d="M8.9,4.577a3.476,3.476,0,0,1,.36,4.679A3.476,3.476,0,0,1,4.577,8.9C3.185,7.5,2.035,6.4,4.217,4.217S7.5,3.185,8.9,4.577Z"/><path class="ql-even ql-stroke" d="M13.423,9.1a3.476,3.476,0,0,0-4.679-.36,3.476,3.476,0,0,0,.36,4.679c1.392,1.392,2.5,2.542,4.679.36S14.815,10.5,13.423,9.1Z"/></svg>', list: { bullet: '<svg viewbox="0 0 18 18"><line class="ql-stroke" x1="6" x2="15" y1="4" y2="4"/><line class="ql-stroke" x1="6" x2="15" y1="9" y2="9"/><line class="ql-stroke" x1="6" x2="15" y1="14" y2="14"/><line class="ql-stroke" x1="3" x2="3" y1="4" y2="4"/><line class="ql-stroke" x1="3" x2="3" y1="9" y2="9"/><line class="ql-stroke" x1="3" x2="3" y1="14" y2="14"/></svg>', check: '<svg class="" viewbox="0 0 18 18"><line class="ql-stroke" x1="9" x2="15" y1="4" y2="4"/><polyline class="ql-stroke" points="3 4 4 5 6 3"/><line class="ql-stroke" x1="9" x2="15" y1="14" y2="14"/><polyline class="ql-stroke" points="3 14 4 15 6 13"/><line class="ql-stroke" x1="9" x2="15" y1="9" y2="9"/><polyline class="ql-stroke" points="3 9 4 10 6 8"/></svg>', ordered: '<svg viewbox="0 0 18 18"><line class="ql-stroke" x1="7" x2="15" y1="4" y2="4"/><line class="ql-stroke" x1="7" x2="15" y1="9" y2="9"/><line class="ql-stroke" x1="7" x2="15" y1="14" y2="14"/><line class="ql-stroke ql-thin" x1="2.5" x2="4.5" y1="5.5" y2="5.5"/><path class="ql-fill" d="M3.5,6A0.5,0.5,0,0,1,3,5.5V3.085l-0.276.138A0.5,0.5,0,0,1,2.053,3c-0.124-.247-0.023-0.324.224-0.447l1-.5A0.5,0.5,0,0,1,4,2.5v3A0.5,0.5,0,0,1,3.5,6Z"/><path class="ql-stroke ql-thin" d="M4.5,10.5h-2c0-.234,1.85-1.076,1.85-2.234A0.959,0.959,0,0,0,2.5,8.156"/><path class="ql-stroke ql-thin" d="M2.5,14.846a0.959,0.959,0,0,0,1.85-.109A0.7,0.7,0,0,0,3.75,14a0.688,0.688,0,0,0,.6-0.736,0.959,0.959,0,0,0-1.85-.109"/></svg>' }, script: { sub: '<svg viewbox="0 0 18 18"><path class="ql-fill" d="M15.5,15H13.861a3.858,3.858,0,0,0,1.914-2.975,1.8,1.8,0,0,0-1.6-1.751A1.921,1.921,0,0,0,12.021,11.7a0.50013,0.50013,0,1,0,.957.291h0a0.914,0.914,0,0,1,1.053-.725,0.81,0.81,0,0,1,.744.762c0,1.076-1.16971,1.86982-1.93971,2.43082A1.45639,1.45639,0,0,0,12,15.5a0.5,0.5,0,0,0,.5.5h3A0.5,0.5,0,0,0,15.5,15Z"/><path class="ql-fill" d="M9.65,5.241a1,1,0,0,0-1.409.108L6,7.964,3.759,5.349A1,1,0,0,0,2.192,6.59178Q2.21541,6.6213,2.241,6.649L4.684,9.5,2.241,12.35A1,1,0,0,0,3.71,13.70722q0.02557-.02768.049-0.05722L6,11.036,8.241,13.65a1,1,0,1,0,1.567-1.24277Q9.78459,12.3777,9.759,12.35L7.316,9.5,9.759,6.651A1,1,0,0,0,9.65,5.241Z"/></svg>', super: '<svg viewbox="0 0 18 18"><path class="ql-fill" d="M15.5,7H13.861a4.015,4.015,0,0,0,1.914-2.975,1.8,1.8,0,0,0-1.6-1.751A1.922,1.922,0,0,0,12.021,3.7a0.5,0.5,0,1,0,.957.291,0.917,0.917,0,0,1,1.053-.725,0.81,0.81,0,0,1,.744.762c0,1.077-1.164,1.925-1.934,2.486A1.423,1.423,0,0,0,12,7.5a0.5,0.5,0,0,0,.5.5h3A0.5,0.5,0,0,0,15.5,7Z"/><path class="ql-fill" d="M9.651,5.241a1,1,0,0,0-1.41.108L6,7.964,3.759,5.349a1,1,0,1,0-1.519,1.3L4.683,9.5,2.241,12.35a1,1,0,1,0,1.519,1.3L6,11.036,8.241,13.65a1,1,0,0,0,1.519-1.3L7.317,9.5,9.759,6.651A1,1,0,0,0,9.651,5.241Z"/></svg>' }, strike: '<svg viewbox="0 0 18 18"><line class="ql-stroke ql-thin" x1="15.5" x2="2.5" y1="8.5" y2="9.5"/><path class="ql-fill" d="M9.007,8C6.542,7.791,6,7.519,6,6.5,6,5.792,7.283,5,9,5c1.571,0,2.765.679,2.969,1.309a1,1,0,0,0,1.9-.617C13.356,4.106,11.354,3,9,3,6.2,3,4,4.538,4,6.5a3.2,3.2,0,0,0,.5,1.843Z"/><path class="ql-fill" d="M8.984,10C11.457,10.208,12,10.479,12,11.5c0,0.708-1.283,1.5-3,1.5-1.571,0-2.765-.679-2.969-1.309a1,1,0,1,0-1.9.617C4.644,13.894,6.646,15,9,15c2.8,0,5-1.538,5-3.5a3.2,3.2,0,0,0-.5-1.843Z"/></svg>', table: '<svg viewbox="0 0 18 18"><rect class="ql-stroke" height="12" width="12" x="3" y="3"/><rect class="ql-fill" height="2" width="3" x="5" y="5"/><rect class="ql-fill" height="2" width="4" x="9" y="5"/><g class="ql-fill ql-transparent"><rect height="2" width="3" x="5" y="8"/><rect height="2" width="4" x="9" y="8"/><rect height="2" width="3" x="5" y="11"/><rect height="2" width="4" x="9" y="11"/></g></svg>', underline: '<svg viewbox="0 0 18 18"><path class="ql-stroke" d="M5,3V9a4.012,4.012,0,0,0,4,4H9a4.012,4.012,0,0,0,4-4V3"/><rect class="ql-fill" height="1" rx="0.5" ry="0.5" width="12" x="3" y="15"/></svg>', video: '<svg viewbox="0 0 18 18"><rect class="ql-stroke" height="12" width="12" x="3" y="3"/><rect class="ql-fill" height="12" width="1" x="5" y="3"/><rect class="ql-fill" height="12" width="1" x="12" y="3"/><rect class="ql-fill" height="2" width="8" x="5" y="8"/><rect class="ql-fill" height="1" width="3" x="3" y="5"/><rect class="ql-fill" height="1" width="3" x="3" y="7"/><rect class="ql-fill" height="1" width="3" x="3" y="10"/><rect class="ql-fill" height="1" width="3" x="3" y="12"/><rect class="ql-fill" height="1" width="3" x="12" y="5"/><rect class="ql-fill" height="1" width="3" x="12" y="7"/><rect class="ql-fill" height="1" width="3" x="12" y="10"/><rect class="ql-fill" height="1" width="3" x="12" y="12"/></svg>' };
          let jo = 0;
          function Ro(t4, e4) {
            t4.setAttribute(e4, `${!("true" === t4.getAttribute(e4))}`);
          }
          __name(Ro, "Ro");
          const Io = class {
            static {
              __name(this, "Io");
            }
            constructor(t4) {
              this.select = t4, this.container = document.createElement("span"), this.buildPicker(), this.select.style.display = "none", this.select.parentNode.insertBefore(this.container, this.select), this.label.addEventListener("mousedown", () => {
                this.togglePicker();
              }), this.label.addEventListener("keydown", (t5) => {
                switch (t5.key) {
                  case "Enter":
                    this.togglePicker();
                    break;
                  case "Escape":
                    this.escape(), t5.preventDefault();
                }
              }), this.select.addEventListener("change", this.update.bind(this));
            }
            togglePicker() {
              this.container.classList.toggle("ql-expanded"), Ro(this.label, "aria-expanded"), Ro(this.options, "aria-hidden");
            }
            buildItem(t4) {
              const e4 = document.createElement("span");
              e4.tabIndex = "0", e4.setAttribute("role", "button"), e4.classList.add("ql-picker-item");
              const n4 = t4.getAttribute("value");
              return n4 && e4.setAttribute("data-value", n4), t4.textContent && e4.setAttribute("data-label", t4.textContent), e4.addEventListener("click", () => {
                this.selectItem(e4, true);
              }), e4.addEventListener("keydown", (t5) => {
                switch (t5.key) {
                  case "Enter":
                    this.selectItem(e4, true), t5.preventDefault();
                    break;
                  case "Escape":
                    this.escape(), t5.preventDefault();
                }
              }), e4;
            }
            buildLabel() {
              const t4 = document.createElement("span");
              return t4.classList.add("ql-picker-label"), t4.innerHTML = '<svg viewbox="0 0 18 18"><polygon class="ql-stroke" points="7 11 9 13 11 11 7 11"/><polygon class="ql-stroke" points="7 7 9 5 11 7 7 7"/></svg>', t4.tabIndex = "0", t4.setAttribute("role", "button"), t4.setAttribute("aria-expanded", "false"), this.container.appendChild(t4), t4;
            }
            buildOptions() {
              const t4 = document.createElement("span");
              t4.classList.add("ql-picker-options"), t4.setAttribute("aria-hidden", "true"), t4.tabIndex = "-1", t4.id = `ql-picker-options-${jo}`, jo += 1, this.label.setAttribute("aria-controls", t4.id), this.options = t4, Array.from(this.select.options).forEach((e4) => {
                const n4 = this.buildItem(e4);
                t4.appendChild(n4), true === e4.selected && this.selectItem(n4);
              }), this.container.appendChild(t4);
            }
            buildPicker() {
              Array.from(this.select.attributes).forEach((t4) => {
                this.container.setAttribute(t4.name, t4.value);
              }), this.container.classList.add("ql-picker"), this.label = this.buildLabel(), this.buildOptions();
            }
            escape() {
              this.close(), setTimeout(() => this.label.focus(), 1);
            }
            close() {
              this.container.classList.remove("ql-expanded"), this.label.setAttribute("aria-expanded", "false"), this.options.setAttribute("aria-hidden", "true");
            }
            selectItem(t4) {
              let e4 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
              const n4 = this.container.querySelector(".ql-selected");
              t4 !== n4 && (null != n4 && n4.classList.remove("ql-selected"), null != t4 && (t4.classList.add("ql-selected"), this.select.selectedIndex = Array.from(t4.parentNode.children).indexOf(t4), t4.hasAttribute("data-value") ? this.label.setAttribute("data-value", t4.getAttribute("data-value")) : this.label.removeAttribute("data-value"), t4.hasAttribute("data-label") ? this.label.setAttribute("data-label", t4.getAttribute("data-label")) : this.label.removeAttribute("data-label"), e4 && (this.select.dispatchEvent(new Event("change")), this.close())));
            }
            update() {
              let t4;
              if (this.select.selectedIndex > -1) {
                const e5 = this.container.querySelector(".ql-picker-options").children[this.select.selectedIndex];
                t4 = this.select.options[this.select.selectedIndex], this.selectItem(e5);
              } else
                this.selectItem(null);
              const e4 = null != t4 && t4 !== this.select.querySelector("option[selected]");
              this.label.classList.toggle("ql-active", e4);
            }
          };
          const Mo = class extends Io {
            static {
              __name(this, "Mo");
            }
            constructor(t4, e4) {
              super(t4), this.label.innerHTML = e4, this.container.classList.add("ql-color-picker"), Array.from(this.container.querySelectorAll(".ql-picker-item")).slice(0, 7).forEach((t5) => {
                t5.classList.add("ql-primary");
              });
            }
            buildItem(t4) {
              const e4 = super.buildItem(t4);
              return e4.style.backgroundColor = t4.getAttribute("value") || "", e4;
            }
            selectItem(t4, e4) {
              super.selectItem(t4, e4);
              const n4 = this.label.querySelector(".ql-color-label"), r3 = t4 && t4.getAttribute("data-value") || "";
              n4 && ("line" === n4.tagName ? n4.style.stroke = r3 : n4.style.fill = r3);
            }
          };
          const Bo = class extends Io {
            static {
              __name(this, "Bo");
            }
            constructor(t4, e4) {
              super(t4), this.container.classList.add("ql-icon-picker"), Array.from(this.container.querySelectorAll(".ql-picker-item")).forEach((t5) => {
                t5.innerHTML = e4[t5.getAttribute("data-value") || ""];
              }), this.defaultItem = this.container.querySelector(".ql-selected"), this.selectItem(this.defaultItem);
            }
            selectItem(t4, e4) {
              super.selectItem(t4, e4);
              const n4 = t4 || this.defaultItem;
              if (null != n4) {
                if (this.label.innerHTML === n4.innerHTML)
                  return;
                this.label.innerHTML = n4.innerHTML;
              }
            }
          };
          const Uo = class {
            static {
              __name(this, "Uo");
            }
            constructor(t4, e4) {
              this.quill = t4, this.boundsContainer = e4 || document.body, this.root = t4.addContainer("ql-tooltip"), this.root.innerHTML = this.constructor.TEMPLATE, ((t5) => {
                const { overflowY: e5 } = getComputedStyle(t5, null);
                return "visible" !== e5 && "clip" !== e5;
              })(this.quill.root) && this.quill.root.addEventListener("scroll", () => {
                this.root.style.marginTop = -1 * this.quill.root.scrollTop + "px";
              }), this.hide();
            }
            hide() {
              this.root.classList.add("ql-hidden");
            }
            position(t4) {
              const e4 = t4.left + t4.width / 2 - this.root.offsetWidth / 2, n4 = t4.bottom + this.quill.root.scrollTop;
              this.root.style.left = `${e4}px`, this.root.style.top = `${n4}px`, this.root.classList.remove("ql-flip");
              const r3 = this.boundsContainer.getBoundingClientRect(), s3 = this.root.getBoundingClientRect();
              let i3 = 0;
              if (s3.right > r3.right && (i3 = r3.right - s3.right, this.root.style.left = `${e4 + i3}px`), s3.left < r3.left && (i3 = r3.left - s3.left, this.root.style.left = `${e4 + i3}px`), s3.bottom > r3.bottom) {
                const e5 = s3.bottom - s3.top, r4 = t4.bottom - t4.top + e5;
                this.root.style.top = n4 - r4 + "px", this.root.classList.add("ql-flip");
              }
              return i3;
            }
            show() {
              this.root.classList.remove("ql-editing"), this.root.classList.remove("ql-hidden");
            }
          }, Do = [false, "center", "right", "justify"], Po = ["#000000", "#e60000", "#ff9900", "#ffff00", "#008a00", "#0066cc", "#9933ff", "#ffffff", "#facccc", "#ffebcc", "#ffffcc", "#cce8cc", "#cce0f5", "#ebd6ff", "#bbbbbb", "#f06666", "#ffc266", "#ffff66", "#66b966", "#66a3e0", "#c285ff", "#888888", "#a10000", "#b26b00", "#b2b200", "#006100", "#0047b2", "#6b24b2", "#444444", "#5c0000", "#663d00", "#666600", "#003700", "#002966", "#3d1466"], zo = [false, "serif", "monospace"], Ho = ["1", "2", "3", false], Fo = ["small", false, "large", "huge"];
          class $o extends qs {
            static {
              __name(this, "$o");
            }
            constructor(t4, e4) {
              super(t4, e4);
              const n4 = /* @__PURE__ */ __name((e5) => {
                document.body.contains(t4.root) ? (null == this.tooltip || this.tooltip.root.contains(e5.target) || document.activeElement === this.tooltip.textbox || this.quill.hasFocus() || this.tooltip.hide(), null != this.pickers && this.pickers.forEach((t5) => {
                  t5.container.contains(e5.target) || t5.close();
                })) : document.body.removeEventListener("click", n4);
              }, "n");
              t4.emitter.listenDOM("click", document.body, n4);
            }
            addModule(t4) {
              const e4 = super.addModule(t4);
              return "toolbar" === t4 && this.extendToolbar(e4), e4;
            }
            buildButtons(t4, e4) {
              Array.from(t4).forEach((t5) => {
                (t5.getAttribute("class") || "").split(/\s+/).forEach((n4) => {
                  if (n4.startsWith("ql-") && (n4 = n4.slice(3), null != e4[n4]))
                    if ("direction" === n4)
                      t5.innerHTML = e4[n4][""] + e4[n4].rtl;
                    else if ("string" == typeof e4[n4])
                      t5.innerHTML = e4[n4];
                    else {
                      const r3 = t5.value || "";
                      null != r3 && e4[n4][r3] && (t5.innerHTML = e4[n4][r3]);
                    }
                });
              });
            }
            buildPickers(t4, e4) {
              this.pickers = Array.from(t4).map((t5) => {
                if (t5.classList.contains("ql-align") && (null == t5.querySelector("option") && Ko(t5, Do), "object" == typeof e4.align))
                  return new Bo(t5, e4.align);
                if (t5.classList.contains("ql-background") || t5.classList.contains("ql-color")) {
                  const n4 = t5.classList.contains("ql-background") ? "background" : "color";
                  return null == t5.querySelector("option") && Ko(t5, Po, "background" === n4 ? "#ffffff" : "#000000"), new Mo(t5, e4[n4]);
                }
                return null == t5.querySelector("option") && (t5.classList.contains("ql-font") ? Ko(t5, zo) : t5.classList.contains("ql-header") ? Ko(t5, Ho) : t5.classList.contains("ql-size") && Ko(t5, Fo)), new Io(t5);
              });
              this.quill.on(ls.events.EDITOR_CHANGE, () => {
                this.pickers.forEach((t5) => {
                  t5.update();
                });
              });
            }
          }
          $o.DEFAULTS = De({}, qs.DEFAULTS, { modules: { toolbar: { handlers: { formula() {
            this.quill.theme.tooltip.edit("formula");
          }, image() {
            let t4 = this.container.querySelector("input.ql-image[type=file]");
            null == t4 && (t4 = document.createElement("input"), t4.setAttribute("type", "file"), t4.setAttribute("accept", this.quill.uploader.options.mimetypes.join(", ")), t4.classList.add("ql-image"), t4.addEventListener("change", () => {
              const e4 = this.quill.getSelection(true);
              this.quill.uploader.upload(e4, t4.files), t4.value = "";
            }), this.container.appendChild(t4)), t4.click();
          }, video() {
            this.quill.theme.tooltip.edit("video");
          } } } } });
          class Vo extends Uo {
            static {
              __name(this, "Vo");
            }
            constructor(t4, e4) {
              super(t4, e4), this.textbox = this.root.querySelector('input[type="text"]'), this.listen();
            }
            listen() {
              this.textbox.addEventListener("keydown", (t4) => {
                "Enter" === t4.key ? (this.save(), t4.preventDefault()) : "Escape" === t4.key && (this.cancel(), t4.preventDefault());
              });
            }
            cancel() {
              this.hide(), this.restoreFocus();
            }
            edit() {
              let t4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "link", e4 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
              if (this.root.classList.remove("ql-hidden"), this.root.classList.add("ql-editing"), null == this.textbox)
                return;
              null != e4 ? this.textbox.value = e4 : t4 !== this.root.getAttribute("data-mode") && (this.textbox.value = "");
              const n4 = this.quill.getBounds(this.quill.selection.savedRange);
              null != n4 && this.position(n4), this.textbox.select(), this.textbox.setAttribute("placeholder", this.textbox.getAttribute(`data-${t4}`) || ""), this.root.setAttribute("data-mode", t4);
            }
            restoreFocus() {
              this.quill.focus({ preventScroll: true });
            }
            save() {
              let { value: t4 } = this.textbox;
              switch (this.root.getAttribute("data-mode")) {
                case "link": {
                  const { scrollTop: e4 } = this.quill.root;
                  this.linkRange ? (this.quill.formatText(this.linkRange, "link", t4, ls.sources.USER), delete this.linkRange) : (this.restoreFocus(), this.quill.format("link", t4, ls.sources.USER)), this.quill.root.scrollTop = e4;
                  break;
                }
                case "video":
                  t4 = function(t5) {
                    let e4 = t5.match(/^(?:(https?):\/\/)?(?:(?:www|m)\.)?youtube\.com\/watch.*v=([a-zA-Z0-9_-]+)/) || t5.match(/^(?:(https?):\/\/)?(?:(?:www|m)\.)?youtu\.be\/([a-zA-Z0-9_-]+)/);
                    if (e4)
                      return `${e4[1] || "https"}://www.youtube.com/embed/${e4[2]}?showinfo=0`;
                    if (e4 = t5.match(/^(?:(https?):\/\/)?(?:www\.)?vimeo\.com\/(\d+)/))
                      return `${e4[1] || "https"}://player.vimeo.com/video/${e4[2]}/`;
                    return t5;
                  }(t4);
                case "formula": {
                  if (!t4)
                    break;
                  const e4 = this.quill.getSelection(true);
                  if (null != e4) {
                    const n4 = e4.index + e4.length;
                    this.quill.insertEmbed(n4, this.root.getAttribute("data-mode"), t4, ls.sources.USER), "formula" === this.root.getAttribute("data-mode") && this.quill.insertText(n4 + 1, " ", ls.sources.USER), this.quill.setSelection(n4 + 2, ls.sources.USER);
                  }
                  break;
                }
              }
              this.textbox.value = "", this.hide();
            }
          }
          function Ko(t4, e4) {
            let n4 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
            e4.forEach((e5) => {
              const r3 = document.createElement("option");
              e5 === n4 ? r3.setAttribute("selected", "selected") : r3.setAttribute("value", String(e5)), t4.appendChild(r3);
            });
          }
          __name(Ko, "Ko");
          const Wo = [["bold", "italic", "link"], [{ header: 1 }, { header: 2 }, "blockquote"]];
          class Zo extends Vo {
            static {
              __name(this, "Zo");
            }
            static TEMPLATE = ['<span class="ql-tooltip-arrow"></span>', '<div class="ql-tooltip-editor">', '<input type="text" data-formula="e=mc^2" data-link="https://quilljs.com" data-video="Embed URL">', '<a class="ql-close"></a>', "</div>"].join("");
            constructor(t4, e4) {
              super(t4, e4), this.quill.on(ls.events.EDITOR_CHANGE, (t5, e5, n4, r3) => {
                if (t5 === ls.events.SELECTION_CHANGE)
                  if (null != e5 && e5.length > 0 && r3 === ls.sources.USER) {
                    this.show(), this.root.style.left = "0px", this.root.style.width = "", this.root.style.width = `${this.root.offsetWidth}px`;
                    const t6 = this.quill.getLines(e5.index, e5.length);
                    if (1 === t6.length) {
                      const t7 = this.quill.getBounds(e5);
                      null != t7 && this.position(t7);
                    } else {
                      const n5 = t6[t6.length - 1], r4 = this.quill.getIndex(n5), s3 = Math.min(n5.length() - 1, e5.index + e5.length - r4), i3 = this.quill.getBounds(new cs(r4, s3));
                      null != i3 && this.position(i3);
                    }
                  } else
                    document.activeElement !== this.textbox && this.quill.hasFocus() && this.hide();
              });
            }
            listen() {
              super.listen(), this.root.querySelector(".ql-close").addEventListener("click", () => {
                this.root.classList.remove("ql-editing");
              }), this.quill.on(ls.events.SCROLL_OPTIMIZE, () => {
                setTimeout(() => {
                  if (this.root.classList.contains("ql-hidden"))
                    return;
                  const t4 = this.quill.getSelection();
                  if (null != t4) {
                    const e4 = this.quill.getBounds(t4);
                    null != e4 && this.position(e4);
                  }
                }, 1);
              });
            }
            cancel() {
              this.show();
            }
            position(t4) {
              const e4 = super.position(t4), n4 = this.root.querySelector(".ql-tooltip-arrow");
              return n4.style.marginLeft = "", 0 !== e4 && (n4.style.marginLeft = -1 * e4 - n4.offsetWidth / 2 + "px"), e4;
            }
          }
          class Go extends $o {
            static {
              __name(this, "Go");
            }
            constructor(t4, e4) {
              null != e4.modules.toolbar && null == e4.modules.toolbar.container && (e4.modules.toolbar.container = Wo), super(t4, e4), this.quill.container.classList.add("ql-bubble");
            }
            extendToolbar(t4) {
              this.tooltip = new Zo(this.quill, this.options.bounds), null != t4.container && (this.tooltip.root.appendChild(t4.container), this.buildButtons(t4.container.querySelectorAll("button"), Co), this.buildPickers(t4.container.querySelectorAll("select"), Co));
            }
          }
          Go.DEFAULTS = De({}, $o.DEFAULTS, { modules: { toolbar: { handlers: { link(t4) {
            t4 ? this.quill.theme.tooltip.edit() : this.quill.format("link", false, Rs.sources.USER);
          } } } } });
          const Xo = [[{ header: ["1", "2", "3", false] }], ["bold", "italic", "underline", "link"], [{ list: "ordered" }, { list: "bullet" }], ["clean"]];
          class Qo extends Vo {
            static {
              __name(this, "Qo");
            }
            static TEMPLATE = ['<a class="ql-preview" rel="noopener noreferrer" target="_blank" href="about:blank"></a>', '<input type="text" data-formula="e=mc^2" data-link="https://quilljs.com" data-video="Embed URL">', '<a class="ql-action"></a>', '<a class="ql-remove"></a>'].join("");
            preview = this.root.querySelector("a.ql-preview");
            listen() {
              super.listen(), this.root.querySelector("a.ql-action").addEventListener("click", (t4) => {
                this.root.classList.contains("ql-editing") ? this.save() : this.edit("link", this.preview.textContent), t4.preventDefault();
              }), this.root.querySelector("a.ql-remove").addEventListener("click", (t4) => {
                if (null != this.linkRange) {
                  const t5 = this.linkRange;
                  this.restoreFocus(), this.quill.formatText(t5, "link", false, ls.sources.USER), delete this.linkRange;
                }
                t4.preventDefault(), this.hide();
              }), this.quill.on(ls.events.SELECTION_CHANGE, (t4, e4, n4) => {
                if (null != t4) {
                  if (0 === t4.length && n4 === ls.sources.USER) {
                    const [e5, n5] = this.quill.scroll.descendant(oo, t4.index);
                    if (null != e5) {
                      this.linkRange = new cs(t4.index - n5, e5.length());
                      const r3 = oo.formats(e5.domNode);
                      this.preview.textContent = r3, this.preview.setAttribute("href", r3), this.show();
                      const s3 = this.quill.getBounds(this.linkRange);
                      return void (null != s3 && this.position(s3));
                    }
                  } else
                    delete this.linkRange;
                  this.hide();
                }
              });
            }
            show() {
              super.show(), this.root.removeAttribute("data-mode");
            }
          }
          class Yo extends $o {
            static {
              __name(this, "Yo");
            }
            constructor(t4, e4) {
              null != e4.modules.toolbar && null == e4.modules.toolbar.container && (e4.modules.toolbar.container = Xo), super(t4, e4), this.quill.container.classList.add("ql-snow");
            }
            extendToolbar(t4) {
              null != t4.container && (t4.container.classList.add("ql-snow"), this.buildButtons(t4.container.querySelectorAll("button"), Co), this.buildPickers(t4.container.querySelectorAll("select"), Co), this.tooltip = new Qo(this.quill, this.options.bounds), t4.container.querySelector(".ql-link") && this.quill.keyboard.addBinding({ key: "k", shortKey: true }, (e4, n4) => {
                t4.handlers.link.call(t4, !n4.format.link);
              }));
            }
          }
          Yo.DEFAULTS = De({}, $o.DEFAULTS, { modules: { toolbar: { handlers: { link(t4) {
            if (t4) {
              const t5 = this.quill.getSelection();
              if (null == t5 || 0 === t5.length)
                return;
              let e4 = this.quill.getText(t5);
              /^\S+@\S+\.\S+$/.test(e4) && 0 !== e4.indexOf("mailto:") && (e4 = `mailto:${e4}`);
              const { tooltip: n4 } = this.quill.theme;
              n4.edit("link", e4);
            } else
              this.quill.format("link", false, Rs.sources.USER);
          } } } } });
          const Jo = Yo;
          Qi.register({ "attributors/attribute/direction": ii, "attributors/class/align": Zs, "attributors/class/background": Js, "attributors/class/color": Qs, "attributors/class/direction": oi, "attributors/class/font": ci, "attributors/class/size": hi, "attributors/style/align": Gs, "attributors/style/background": ti, "attributors/style/color": Ys, "attributors/style/direction": li, "attributors/style/font": ui, "attributors/style/size": di }, true), Qi.register({ "formats/align": Zs, "formats/direction": oi, "formats/indent": Ji, "formats/background": ti, "formats/color": Ys, "formats/font": ci, "formats/size": hi, "formats/blockquote": to, "formats/code-block": ni, "formats/header": eo, "formats/list": ro, "formats/bold": so, "formats/code": ri, "formats/italic": io, "formats/link": oo, "formats/script": ao, "formats/strike": co, "formats/underline": uo, "formats/formula": ho, "formats/image": po, "formats/video": mo, "modules/syntax": No, "modules/table": _o, "modules/toolbar": Oo, "themes/bubble": Go, "themes/snow": Jo, "ui/icons": Co, "ui/picker": Io, "ui/icon-picker": Bo, "ui/color-picker": Mo, "ui/tooltip": Uo }, true);
          const tl = Qi;
        } }, e2 = {};
        function n2(r2) {
          var s2 = e2[r2];
          if (void 0 !== s2)
            return s2.exports;
          var i2 = e2[r2] = { id: r2, loaded: false, exports: {} };
          return t2[r2].call(i2.exports, i2, i2.exports, n2), i2.loaded = true, i2.exports;
        }
        __name(n2, "n");
        return n2.d = (t3, e3) => {
          for (var r2 in e3)
            n2.o(e3, r2) && !n2.o(t3, r2) && Object.defineProperty(t3, r2, { enumerable: true, get: e3[r2] });
        }, n2.g = function() {
          if ("object" == typeof globalThis)
            return globalThis;
          try {
            return this || new Function("return this")();
          } catch (t3) {
            if ("object" == typeof window)
              return window;
          }
        }(), n2.o = (t3, e3) => Object.prototype.hasOwnProperty.call(t3, e3), n2.r = (t3) => {
          "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t3, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t3, "__esModule", { value: true });
        }, n2.nmd = (t3) => (t3.paths = [], t3.children || (t3.children = []), t3), n2(190);
      })());
    }
  });

  // node_modules/@hotwired/turbo/dist/turbo.es2017-esm.js
  var turbo_es2017_esm_exports = {};
  __export(turbo_es2017_esm_exports, {
    FetchEnctype: () => FetchEnctype,
    FetchMethod: () => FetchMethod,
    FetchRequest: () => FetchRequest,
    FetchResponse: () => FetchResponse,
    FrameElement: () => FrameElement,
    FrameLoadingStyle: () => FrameLoadingStyle,
    FrameRenderer: () => FrameRenderer,
    PageRenderer: () => PageRenderer,
    PageSnapshot: () => PageSnapshot,
    StreamActions: () => StreamActions,
    StreamElement: () => StreamElement,
    StreamSourceElement: () => StreamSourceElement,
    cache: () => cache,
    clearCache: () => clearCache,
    connectStreamSource: () => connectStreamSource,
    disconnectStreamSource: () => disconnectStreamSource,
    fetch: () => fetchWithTurboHeaders,
    fetchEnctypeFromString: () => fetchEnctypeFromString,
    fetchMethodFromString: () => fetchMethodFromString,
    isSafe: () => isSafe,
    navigator: () => navigator$1,
    registerAdapter: () => registerAdapter,
    renderStreamMessage: () => renderStreamMessage,
    session: () => session,
    setConfirmMethod: () => setConfirmMethod,
    setFormMode: () => setFormMode,
    setProgressBarDelay: () => setProgressBarDelay,
    start: () => start,
    visit: () => visit
  });
  (function(prototype) {
    if (typeof prototype.requestSubmit == "function")
      return;
    prototype.requestSubmit = function(submitter) {
      if (submitter) {
        validateSubmitter(submitter, this);
        submitter.click();
      } else {
        submitter = document.createElement("input");
        submitter.type = "submit";
        submitter.hidden = true;
        this.appendChild(submitter);
        submitter.click();
        this.removeChild(submitter);
      }
    };
    function validateSubmitter(submitter, form) {
      submitter instanceof HTMLElement || raise(TypeError, "parameter 1 is not of type 'HTMLElement'");
      submitter.type == "submit" || raise(TypeError, "The specified element is not a submit button");
      submitter.form == form || raise(DOMException, "The specified element is not owned by this form element", "NotFoundError");
    }
    __name(validateSubmitter, "validateSubmitter");
    function raise(errorConstructor, message, name) {
      throw new errorConstructor("Failed to execute 'requestSubmit' on 'HTMLFormElement': " + message + ".", name);
    }
    __name(raise, "raise");
  })(HTMLFormElement.prototype);
  var submittersByForm = /* @__PURE__ */ new WeakMap();
  function findSubmitterFromClickTarget(target) {
    const element = target instanceof Element ? target : target instanceof Node ? target.parentElement : null;
    const candidate = element ? element.closest("input, button") : null;
    return candidate?.type == "submit" ? candidate : null;
  }
  __name(findSubmitterFromClickTarget, "findSubmitterFromClickTarget");
  function clickCaptured(event) {
    const submitter = findSubmitterFromClickTarget(event.target);
    if (submitter && submitter.form) {
      submittersByForm.set(submitter.form, submitter);
    }
  }
  __name(clickCaptured, "clickCaptured");
  (function() {
    if ("submitter" in Event.prototype)
      return;
    let prototype = window.Event.prototype;
    if ("SubmitEvent" in window) {
      const prototypeOfSubmitEvent = window.SubmitEvent.prototype;
      if (/Apple Computer/.test(navigator.vendor) && !("submitter" in prototypeOfSubmitEvent)) {
        prototype = prototypeOfSubmitEvent;
      } else {
        return;
      }
    }
    addEventListener("click", clickCaptured, true);
    Object.defineProperty(prototype, "submitter", {
      get() {
        if (this.type == "submit" && this.target instanceof HTMLFormElement) {
          return submittersByForm.get(this.target);
        }
      }
    });
  })();
  var FrameLoadingStyle = {
    eager: "eager",
    lazy: "lazy"
  };
  var FrameElement = class _FrameElement extends HTMLElement {
    static {
      __name(this, "FrameElement");
    }
    static delegateConstructor = void 0;
    loaded = Promise.resolve();
    static get observedAttributes() {
      return ["disabled", "loading", "src"];
    }
    constructor() {
      super();
      this.delegate = new _FrameElement.delegateConstructor(this);
    }
    connectedCallback() {
      this.delegate.connect();
    }
    disconnectedCallback() {
      this.delegate.disconnect();
    }
    reload() {
      return this.delegate.sourceURLReloaded();
    }
    attributeChangedCallback(name) {
      if (name == "loading") {
        this.delegate.loadingStyleChanged();
      } else if (name == "src") {
        this.delegate.sourceURLChanged();
      } else if (name == "disabled") {
        this.delegate.disabledChanged();
      }
    }
    /**
     * Gets the URL to lazily load source HTML from
     */
    get src() {
      return this.getAttribute("src");
    }
    /**
     * Sets the URL to lazily load source HTML from
     */
    set src(value) {
      if (value) {
        this.setAttribute("src", value);
      } else {
        this.removeAttribute("src");
      }
    }
    /**
     * Gets the refresh mode for the frame.
     */
    get refresh() {
      return this.getAttribute("refresh");
    }
    /**
     * Sets the refresh mode for the frame.
     */
    set refresh(value) {
      if (value) {
        this.setAttribute("refresh", value);
      } else {
        this.removeAttribute("refresh");
      }
    }
    /**
     * Determines if the element is loading
     */
    get loading() {
      return frameLoadingStyleFromString(this.getAttribute("loading") || "");
    }
    /**
     * Sets the value of if the element is loading
     */
    set loading(value) {
      if (value) {
        this.setAttribute("loading", value);
      } else {
        this.removeAttribute("loading");
      }
    }
    /**
     * Gets the disabled state of the frame.
     *
     * If disabled, no requests will be intercepted by the frame.
     */
    get disabled() {
      return this.hasAttribute("disabled");
    }
    /**
     * Sets the disabled state of the frame.
     *
     * If disabled, no requests will be intercepted by the frame.
     */
    set disabled(value) {
      if (value) {
        this.setAttribute("disabled", "");
      } else {
        this.removeAttribute("disabled");
      }
    }
    /**
     * Gets the autoscroll state of the frame.
     *
     * If true, the frame will be scrolled into view automatically on update.
     */
    get autoscroll() {
      return this.hasAttribute("autoscroll");
    }
    /**
     * Sets the autoscroll state of the frame.
     *
     * If true, the frame will be scrolled into view automatically on update.
     */
    set autoscroll(value) {
      if (value) {
        this.setAttribute("autoscroll", "");
      } else {
        this.removeAttribute("autoscroll");
      }
    }
    /**
     * Determines if the element has finished loading
     */
    get complete() {
      return !this.delegate.isLoading;
    }
    /**
     * Gets the active state of the frame.
     *
     * If inactive, source changes will not be observed.
     */
    get isActive() {
      return this.ownerDocument === document && !this.isPreview;
    }
    /**
     * Sets the active state of the frame.
     *
     * If inactive, source changes will not be observed.
     */
    get isPreview() {
      return this.ownerDocument?.documentElement?.hasAttribute("data-turbo-preview");
    }
  };
  function frameLoadingStyleFromString(style) {
    switch (style.toLowerCase()) {
      case "lazy":
        return FrameLoadingStyle.lazy;
      default:
        return FrameLoadingStyle.eager;
    }
  }
  __name(frameLoadingStyleFromString, "frameLoadingStyleFromString");
  function expandURL(locatable) {
    return new URL(locatable.toString(), document.baseURI);
  }
  __name(expandURL, "expandURL");
  function getAnchor(url) {
    let anchorMatch;
    if (url.hash) {
      return url.hash.slice(1);
    } else if (anchorMatch = url.href.match(/#(.*)$/)) {
      return anchorMatch[1];
    }
  }
  __name(getAnchor, "getAnchor");
  function getAction$1(form, submitter) {
    const action = submitter?.getAttribute("formaction") || form.getAttribute("action") || form.action;
    return expandURL(action);
  }
  __name(getAction$1, "getAction$1");
  function getExtension(url) {
    return (getLastPathComponent(url).match(/\.[^.]*$/) || [])[0] || "";
  }
  __name(getExtension, "getExtension");
  function isHTML(url) {
    return !!getExtension(url).match(/^(?:|\.(?:htm|html|xhtml|php))$/);
  }
  __name(isHTML, "isHTML");
  function isPrefixedBy(baseURL, url) {
    const prefix = getPrefix(url);
    return baseURL.href === expandURL(prefix).href || baseURL.href.startsWith(prefix);
  }
  __name(isPrefixedBy, "isPrefixedBy");
  function locationIsVisitable(location2, rootLocation) {
    return isPrefixedBy(location2, rootLocation) && isHTML(location2);
  }
  __name(locationIsVisitable, "locationIsVisitable");
  function getRequestURL(url) {
    const anchor = getAnchor(url);
    return anchor != null ? url.href.slice(0, -(anchor.length + 1)) : url.href;
  }
  __name(getRequestURL, "getRequestURL");
  function toCacheKey(url) {
    return getRequestURL(url);
  }
  __name(toCacheKey, "toCacheKey");
  function urlsAreEqual(left, right) {
    return expandURL(left).href == expandURL(right).href;
  }
  __name(urlsAreEqual, "urlsAreEqual");
  function getPathComponents(url) {
    return url.pathname.split("/").slice(1);
  }
  __name(getPathComponents, "getPathComponents");
  function getLastPathComponent(url) {
    return getPathComponents(url).slice(-1)[0];
  }
  __name(getLastPathComponent, "getLastPathComponent");
  function getPrefix(url) {
    return addTrailingSlash(url.origin + url.pathname);
  }
  __name(getPrefix, "getPrefix");
  function addTrailingSlash(value) {
    return value.endsWith("/") ? value : value + "/";
  }
  __name(addTrailingSlash, "addTrailingSlash");
  var FetchResponse = class {
    static {
      __name(this, "FetchResponse");
    }
    constructor(response) {
      this.response = response;
    }
    get succeeded() {
      return this.response.ok;
    }
    get failed() {
      return !this.succeeded;
    }
    get clientError() {
      return this.statusCode >= 400 && this.statusCode <= 499;
    }
    get serverError() {
      return this.statusCode >= 500 && this.statusCode <= 599;
    }
    get redirected() {
      return this.response.redirected;
    }
    get location() {
      return expandURL(this.response.url);
    }
    get isHTML() {
      return this.contentType && this.contentType.match(/^(?:text\/([^\s;,]+\b)?html|application\/xhtml\+xml)\b/);
    }
    get statusCode() {
      return this.response.status;
    }
    get contentType() {
      return this.header("Content-Type");
    }
    get responseText() {
      return this.response.clone().text();
    }
    get responseHTML() {
      if (this.isHTML) {
        return this.response.clone().text();
      } else {
        return Promise.resolve(void 0);
      }
    }
    header(name) {
      return this.response.headers.get(name);
    }
  };
  function activateScriptElement(element) {
    if (element.getAttribute("data-turbo-eval") == "false") {
      return element;
    } else {
      const createdScriptElement = document.createElement("script");
      const cspNonce = getMetaContent("csp-nonce");
      if (cspNonce) {
        createdScriptElement.nonce = cspNonce;
      }
      createdScriptElement.textContent = element.textContent;
      createdScriptElement.async = false;
      copyElementAttributes(createdScriptElement, element);
      return createdScriptElement;
    }
  }
  __name(activateScriptElement, "activateScriptElement");
  function copyElementAttributes(destinationElement, sourceElement) {
    for (const { name, value } of sourceElement.attributes) {
      destinationElement.setAttribute(name, value);
    }
  }
  __name(copyElementAttributes, "copyElementAttributes");
  function createDocumentFragment(html) {
    const template = document.createElement("template");
    template.innerHTML = html;
    return template.content;
  }
  __name(createDocumentFragment, "createDocumentFragment");
  function dispatch(eventName, { target, cancelable, detail } = {}) {
    const event = new CustomEvent(eventName, {
      cancelable,
      bubbles: true,
      composed: true,
      detail
    });
    if (target && target.isConnected) {
      target.dispatchEvent(event);
    } else {
      document.documentElement.dispatchEvent(event);
    }
    return event;
  }
  __name(dispatch, "dispatch");
  function nextRepaint() {
    if (document.visibilityState === "hidden") {
      return nextEventLoopTick();
    } else {
      return nextAnimationFrame();
    }
  }
  __name(nextRepaint, "nextRepaint");
  function nextAnimationFrame() {
    return new Promise((resolve) => requestAnimationFrame(() => resolve()));
  }
  __name(nextAnimationFrame, "nextAnimationFrame");
  function nextEventLoopTick() {
    return new Promise((resolve) => setTimeout(() => resolve(), 0));
  }
  __name(nextEventLoopTick, "nextEventLoopTick");
  function nextMicrotask() {
    return Promise.resolve();
  }
  __name(nextMicrotask, "nextMicrotask");
  function parseHTMLDocument(html = "") {
    return new DOMParser().parseFromString(html, "text/html");
  }
  __name(parseHTMLDocument, "parseHTMLDocument");
  function unindent(strings, ...values) {
    const lines = interpolate(strings, values).replace(/^\n/, "").split("\n");
    const match2 = lines[0].match(/^\s+/);
    const indent = match2 ? match2[0].length : 0;
    return lines.map((line) => line.slice(indent)).join("\n");
  }
  __name(unindent, "unindent");
  function interpolate(strings, values) {
    return strings.reduce((result, string, i2) => {
      const value = values[i2] == void 0 ? "" : values[i2];
      return result + string + value;
    }, "");
  }
  __name(interpolate, "interpolate");
  function uuid() {
    return Array.from({ length: 36 }).map((_2, i2) => {
      if (i2 == 8 || i2 == 13 || i2 == 18 || i2 == 23) {
        return "-";
      } else if (i2 == 14) {
        return "4";
      } else if (i2 == 19) {
        return (Math.floor(Math.random() * 4) + 8).toString(16);
      } else {
        return Math.floor(Math.random() * 15).toString(16);
      }
    }).join("");
  }
  __name(uuid, "uuid");
  function getAttribute(attributeName, ...elements) {
    for (const value of elements.map((element) => element?.getAttribute(attributeName))) {
      if (typeof value == "string")
        return value;
    }
    return null;
  }
  __name(getAttribute, "getAttribute");
  function hasAttribute(attributeName, ...elements) {
    return elements.some((element) => element && element.hasAttribute(attributeName));
  }
  __name(hasAttribute, "hasAttribute");
  function markAsBusy(...elements) {
    for (const element of elements) {
      if (element.localName == "turbo-frame") {
        element.setAttribute("busy", "");
      }
      element.setAttribute("aria-busy", "true");
    }
  }
  __name(markAsBusy, "markAsBusy");
  function clearBusyState(...elements) {
    for (const element of elements) {
      if (element.localName == "turbo-frame") {
        element.removeAttribute("busy");
      }
      element.removeAttribute("aria-busy");
    }
  }
  __name(clearBusyState, "clearBusyState");
  function waitForLoad(element, timeoutInMilliseconds = 2e3) {
    return new Promise((resolve) => {
      const onComplete = /* @__PURE__ */ __name(() => {
        element.removeEventListener("error", onComplete);
        element.removeEventListener("load", onComplete);
        resolve();
      }, "onComplete");
      element.addEventListener("load", onComplete, { once: true });
      element.addEventListener("error", onComplete, { once: true });
      setTimeout(resolve, timeoutInMilliseconds);
    });
  }
  __name(waitForLoad, "waitForLoad");
  function getHistoryMethodForAction(action) {
    switch (action) {
      case "replace":
        return history.replaceState;
      case "advance":
      case "restore":
        return history.pushState;
    }
  }
  __name(getHistoryMethodForAction, "getHistoryMethodForAction");
  function isAction(action) {
    return action == "advance" || action == "replace" || action == "restore";
  }
  __name(isAction, "isAction");
  function getVisitAction(...elements) {
    const action = getAttribute("data-turbo-action", ...elements);
    return isAction(action) ? action : null;
  }
  __name(getVisitAction, "getVisitAction");
  function getMetaElement(name) {
    return document.querySelector(`meta[name="${name}"]`);
  }
  __name(getMetaElement, "getMetaElement");
  function getMetaContent(name) {
    const element = getMetaElement(name);
    return element && element.content;
  }
  __name(getMetaContent, "getMetaContent");
  function setMetaContent(name, content) {
    let element = getMetaElement(name);
    if (!element) {
      element = document.createElement("meta");
      element.setAttribute("name", name);
      document.head.appendChild(element);
    }
    element.setAttribute("content", content);
    return element;
  }
  __name(setMetaContent, "setMetaContent");
  function findClosestRecursively(element, selector) {
    if (element instanceof Element) {
      return element.closest(selector) || findClosestRecursively(element.assignedSlot || element.getRootNode()?.host, selector);
    }
  }
  __name(findClosestRecursively, "findClosestRecursively");
  function elementIsFocusable(element) {
    const inertDisabledOrHidden = "[inert], :disabled, [hidden], details:not([open]), dialog:not([open])";
    return !!element && element.closest(inertDisabledOrHidden) == null && typeof element.focus == "function";
  }
  __name(elementIsFocusable, "elementIsFocusable");
  function queryAutofocusableElement(elementOrDocumentFragment) {
    return Array.from(elementOrDocumentFragment.querySelectorAll("[autofocus]")).find(elementIsFocusable);
  }
  __name(queryAutofocusableElement, "queryAutofocusableElement");
  async function around(callback, reader) {
    const before = reader();
    callback();
    await nextAnimationFrame();
    const after = reader();
    return [before, after];
  }
  __name(around, "around");
  function doesNotTargetIFrame(anchor) {
    if (anchor.hasAttribute("target")) {
      for (const element of document.getElementsByName(anchor.target)) {
        if (element instanceof HTMLIFrameElement)
          return false;
      }
    }
    return true;
  }
  __name(doesNotTargetIFrame, "doesNotTargetIFrame");
  function findLinkFromClickTarget(target) {
    return findClosestRecursively(target, "a[href]:not([target^=_]):not([download])");
  }
  __name(findLinkFromClickTarget, "findLinkFromClickTarget");
  function getLocationForLink(link) {
    return expandURL(link.getAttribute("href") || "");
  }
  __name(getLocationForLink, "getLocationForLink");
  function debounce(fn, delay) {
    let timeoutId = null;
    return (...args) => {
      const callback = /* @__PURE__ */ __name(() => fn.apply(this, args), "callback");
      clearTimeout(timeoutId);
      timeoutId = setTimeout(callback, delay);
    };
  }
  __name(debounce, "debounce");
  var LimitedSet = class extends Set {
    static {
      __name(this, "LimitedSet");
    }
    constructor(maxSize) {
      super();
      this.maxSize = maxSize;
    }
    add(value) {
      if (this.size >= this.maxSize) {
        const iterator = this.values();
        const oldestValue = iterator.next().value;
        this.delete(oldestValue);
      }
      super.add(value);
    }
  };
  var recentRequests = new LimitedSet(20);
  var nativeFetch = window.fetch;
  function fetchWithTurboHeaders(url, options = {}) {
    const modifiedHeaders = new Headers(options.headers || {});
    const requestUID = uuid();
    recentRequests.add(requestUID);
    modifiedHeaders.append("X-Turbo-Request-Id", requestUID);
    return nativeFetch(url, {
      ...options,
      headers: modifiedHeaders
    });
  }
  __name(fetchWithTurboHeaders, "fetchWithTurboHeaders");
  function fetchMethodFromString(method) {
    switch (method.toLowerCase()) {
      case "get":
        return FetchMethod.get;
      case "post":
        return FetchMethod.post;
      case "put":
        return FetchMethod.put;
      case "patch":
        return FetchMethod.patch;
      case "delete":
        return FetchMethod.delete;
    }
  }
  __name(fetchMethodFromString, "fetchMethodFromString");
  var FetchMethod = {
    get: "get",
    post: "post",
    put: "put",
    patch: "patch",
    delete: "delete"
  };
  function fetchEnctypeFromString(encoding) {
    switch (encoding.toLowerCase()) {
      case FetchEnctype.multipart:
        return FetchEnctype.multipart;
      case FetchEnctype.plain:
        return FetchEnctype.plain;
      default:
        return FetchEnctype.urlEncoded;
    }
  }
  __name(fetchEnctypeFromString, "fetchEnctypeFromString");
  var FetchEnctype = {
    urlEncoded: "application/x-www-form-urlencoded",
    multipart: "multipart/form-data",
    plain: "text/plain"
  };
  var FetchRequest = class {
    static {
      __name(this, "FetchRequest");
    }
    abortController = new AbortController();
    #resolveRequestPromise = (_value) => {
    };
    constructor(delegate, method, location2, requestBody = new URLSearchParams(), target = null, enctype = FetchEnctype.urlEncoded) {
      const [url, body] = buildResourceAndBody(expandURL(location2), method, requestBody, enctype);
      this.delegate = delegate;
      this.url = url;
      this.target = target;
      this.fetchOptions = {
        credentials: "same-origin",
        redirect: "follow",
        method,
        headers: { ...this.defaultHeaders },
        body,
        signal: this.abortSignal,
        referrer: this.delegate.referrer?.href
      };
      this.enctype = enctype;
    }
    get method() {
      return this.fetchOptions.method;
    }
    set method(value) {
      const fetchBody = this.isSafe ? this.url.searchParams : this.fetchOptions.body || new FormData();
      const fetchMethod = fetchMethodFromString(value) || FetchMethod.get;
      this.url.search = "";
      const [url, body] = buildResourceAndBody(this.url, fetchMethod, fetchBody, this.enctype);
      this.url = url;
      this.fetchOptions.body = body;
      this.fetchOptions.method = fetchMethod;
    }
    get headers() {
      return this.fetchOptions.headers;
    }
    set headers(value) {
      this.fetchOptions.headers = value;
    }
    get body() {
      if (this.isSafe) {
        return this.url.searchParams;
      } else {
        return this.fetchOptions.body;
      }
    }
    set body(value) {
      this.fetchOptions.body = value;
    }
    get location() {
      return this.url;
    }
    get params() {
      return this.url.searchParams;
    }
    get entries() {
      return this.body ? Array.from(this.body.entries()) : [];
    }
    cancel() {
      this.abortController.abort();
    }
    async perform() {
      const { fetchOptions } = this;
      this.delegate.prepareRequest(this);
      const event = await this.#allowRequestToBeIntercepted(fetchOptions);
      try {
        this.delegate.requestStarted(this);
        if (event.detail.fetchRequest) {
          this.response = event.detail.fetchRequest.response;
        } else {
          this.response = fetchWithTurboHeaders(this.url.href, fetchOptions);
        }
        const response = await this.response;
        return await this.receive(response);
      } catch (error) {
        if (error.name !== "AbortError") {
          if (this.#willDelegateErrorHandling(error)) {
            this.delegate.requestErrored(this, error);
          }
          throw error;
        }
      } finally {
        this.delegate.requestFinished(this);
      }
    }
    async receive(response) {
      const fetchResponse = new FetchResponse(response);
      const event = dispatch("turbo:before-fetch-response", {
        cancelable: true,
        detail: { fetchResponse },
        target: this.target
      });
      if (event.defaultPrevented) {
        this.delegate.requestPreventedHandlingResponse(this, fetchResponse);
      } else if (fetchResponse.succeeded) {
        this.delegate.requestSucceededWithResponse(this, fetchResponse);
      } else {
        this.delegate.requestFailedWithResponse(this, fetchResponse);
      }
      return fetchResponse;
    }
    get defaultHeaders() {
      return {
        Accept: "text/html, application/xhtml+xml"
      };
    }
    get isSafe() {
      return isSafe(this.method);
    }
    get abortSignal() {
      return this.abortController.signal;
    }
    acceptResponseType(mimeType) {
      this.headers["Accept"] = [mimeType, this.headers["Accept"]].join(", ");
    }
    async #allowRequestToBeIntercepted(fetchOptions) {
      const requestInterception = new Promise((resolve) => this.#resolveRequestPromise = resolve);
      const event = dispatch("turbo:before-fetch-request", {
        cancelable: true,
        detail: {
          fetchOptions,
          url: this.url,
          resume: this.#resolveRequestPromise
        },
        target: this.target
      });
      this.url = event.detail.url;
      if (event.defaultPrevented)
        await requestInterception;
      return event;
    }
    #willDelegateErrorHandling(error) {
      const event = dispatch("turbo:fetch-request-error", {
        target: this.target,
        cancelable: true,
        detail: { request: this, error }
      });
      return !event.defaultPrevented;
    }
  };
  function isSafe(fetchMethod) {
    return fetchMethodFromString(fetchMethod) == FetchMethod.get;
  }
  __name(isSafe, "isSafe");
  function buildResourceAndBody(resource, method, requestBody, enctype) {
    const searchParams = Array.from(requestBody).length > 0 ? new URLSearchParams(entriesExcludingFiles(requestBody)) : resource.searchParams;
    if (isSafe(method)) {
      return [mergeIntoURLSearchParams(resource, searchParams), null];
    } else if (enctype == FetchEnctype.urlEncoded) {
      return [resource, searchParams];
    } else {
      return [resource, requestBody];
    }
  }
  __name(buildResourceAndBody, "buildResourceAndBody");
  function entriesExcludingFiles(requestBody) {
    const entries = [];
    for (const [name, value] of requestBody) {
      if (value instanceof File)
        continue;
      else
        entries.push([name, value]);
    }
    return entries;
  }
  __name(entriesExcludingFiles, "entriesExcludingFiles");
  function mergeIntoURLSearchParams(url, requestBody) {
    const searchParams = new URLSearchParams(entriesExcludingFiles(requestBody));
    url.search = searchParams.toString();
    return url;
  }
  __name(mergeIntoURLSearchParams, "mergeIntoURLSearchParams");
  var AppearanceObserver = class {
    static {
      __name(this, "AppearanceObserver");
    }
    started = false;
    constructor(delegate, element) {
      this.delegate = delegate;
      this.element = element;
      this.intersectionObserver = new IntersectionObserver(this.intersect);
    }
    start() {
      if (!this.started) {
        this.started = true;
        this.intersectionObserver.observe(this.element);
      }
    }
    stop() {
      if (this.started) {
        this.started = false;
        this.intersectionObserver.unobserve(this.element);
      }
    }
    intersect = (entries) => {
      const lastEntry = entries.slice(-1)[0];
      if (lastEntry?.isIntersecting) {
        this.delegate.elementAppearedInViewport(this.element);
      }
    };
  };
  var StreamMessage = class {
    static {
      __name(this, "StreamMessage");
    }
    static contentType = "text/vnd.turbo-stream.html";
    static wrap(message) {
      if (typeof message == "string") {
        return new this(createDocumentFragment(message));
      } else {
        return message;
      }
    }
    constructor(fragment) {
      this.fragment = importStreamElements(fragment);
    }
  };
  function importStreamElements(fragment) {
    for (const element of fragment.querySelectorAll("turbo-stream")) {
      const streamElement = document.importNode(element, true);
      for (const inertScriptElement of streamElement.templateElement.content.querySelectorAll("script")) {
        inertScriptElement.replaceWith(activateScriptElement(inertScriptElement));
      }
      element.replaceWith(streamElement);
    }
    return fragment;
  }
  __name(importStreamElements, "importStreamElements");
  var PREFETCH_DELAY = 100;
  var PrefetchCache = class {
    static {
      __name(this, "PrefetchCache");
    }
    #prefetchTimeout = null;
    #prefetched = null;
    get(url) {
      if (this.#prefetched && this.#prefetched.url === url && this.#prefetched.expire > Date.now()) {
        return this.#prefetched.request;
      }
    }
    setLater(url, request, ttl) {
      this.clear();
      this.#prefetchTimeout = setTimeout(() => {
        request.perform();
        this.set(url, request, ttl);
        this.#prefetchTimeout = null;
      }, PREFETCH_DELAY);
    }
    set(url, request, ttl) {
      this.#prefetched = { url, request, expire: new Date((/* @__PURE__ */ new Date()).getTime() + ttl) };
    }
    clear() {
      if (this.#prefetchTimeout)
        clearTimeout(this.#prefetchTimeout);
      this.#prefetched = null;
    }
  };
  var cacheTtl = 10 * 1e3;
  var prefetchCache = new PrefetchCache();
  var FormSubmissionState = {
    initialized: "initialized",
    requesting: "requesting",
    waiting: "waiting",
    receiving: "receiving",
    stopping: "stopping",
    stopped: "stopped"
  };
  var FormSubmission = class _FormSubmission {
    static {
      __name(this, "FormSubmission");
    }
    state = FormSubmissionState.initialized;
    static confirmMethod(message, _element, _submitter) {
      return Promise.resolve(confirm(message));
    }
    constructor(delegate, formElement, submitter, mustRedirect = false) {
      const method = getMethod(formElement, submitter);
      const action = getAction(getFormAction(formElement, submitter), method);
      const body = buildFormData(formElement, submitter);
      const enctype = getEnctype(formElement, submitter);
      this.delegate = delegate;
      this.formElement = formElement;
      this.submitter = submitter;
      this.fetchRequest = new FetchRequest(this, method, action, body, formElement, enctype);
      this.mustRedirect = mustRedirect;
    }
    get method() {
      return this.fetchRequest.method;
    }
    set method(value) {
      this.fetchRequest.method = value;
    }
    get action() {
      return this.fetchRequest.url.toString();
    }
    set action(value) {
      this.fetchRequest.url = expandURL(value);
    }
    get body() {
      return this.fetchRequest.body;
    }
    get enctype() {
      return this.fetchRequest.enctype;
    }
    get isSafe() {
      return this.fetchRequest.isSafe;
    }
    get location() {
      return this.fetchRequest.url;
    }
    // The submission process
    async start() {
      const { initialized, requesting } = FormSubmissionState;
      const confirmationMessage = getAttribute("data-turbo-confirm", this.submitter, this.formElement);
      if (typeof confirmationMessage === "string") {
        const answer = await _FormSubmission.confirmMethod(confirmationMessage, this.formElement, this.submitter);
        if (!answer) {
          return;
        }
      }
      if (this.state == initialized) {
        this.state = requesting;
        return this.fetchRequest.perform();
      }
    }
    stop() {
      const { stopping, stopped } = FormSubmissionState;
      if (this.state != stopping && this.state != stopped) {
        this.state = stopping;
        this.fetchRequest.cancel();
        return true;
      }
    }
    // Fetch request delegate
    prepareRequest(request) {
      if (!request.isSafe) {
        const token = getCookieValue(getMetaContent("csrf-param")) || getMetaContent("csrf-token");
        if (token) {
          request.headers["X-CSRF-Token"] = token;
        }
      }
      if (this.requestAcceptsTurboStreamResponse(request)) {
        request.acceptResponseType(StreamMessage.contentType);
      }
    }
    requestStarted(_request) {
      this.state = FormSubmissionState.waiting;
      this.submitter?.setAttribute("disabled", "");
      this.setSubmitsWith();
      markAsBusy(this.formElement);
      dispatch("turbo:submit-start", {
        target: this.formElement,
        detail: { formSubmission: this }
      });
      this.delegate.formSubmissionStarted(this);
    }
    requestPreventedHandlingResponse(request, response) {
      prefetchCache.clear();
      this.result = { success: response.succeeded, fetchResponse: response };
    }
    requestSucceededWithResponse(request, response) {
      if (response.clientError || response.serverError) {
        this.delegate.formSubmissionFailedWithResponse(this, response);
        return;
      }
      prefetchCache.clear();
      if (this.requestMustRedirect(request) && responseSucceededWithoutRedirect(response)) {
        const error = new Error("Form responses must redirect to another location");
        this.delegate.formSubmissionErrored(this, error);
      } else {
        this.state = FormSubmissionState.receiving;
        this.result = { success: true, fetchResponse: response };
        this.delegate.formSubmissionSucceededWithResponse(this, response);
      }
    }
    requestFailedWithResponse(request, response) {
      this.result = { success: false, fetchResponse: response };
      this.delegate.formSubmissionFailedWithResponse(this, response);
    }
    requestErrored(request, error) {
      this.result = { success: false, error };
      this.delegate.formSubmissionErrored(this, error);
    }
    requestFinished(_request) {
      this.state = FormSubmissionState.stopped;
      this.submitter?.removeAttribute("disabled");
      this.resetSubmitterText();
      clearBusyState(this.formElement);
      dispatch("turbo:submit-end", {
        target: this.formElement,
        detail: { formSubmission: this, ...this.result }
      });
      this.delegate.formSubmissionFinished(this);
    }
    // Private
    setSubmitsWith() {
      if (!this.submitter || !this.submitsWith)
        return;
      if (this.submitter.matches("button")) {
        this.originalSubmitText = this.submitter.innerHTML;
        this.submitter.innerHTML = this.submitsWith;
      } else if (this.submitter.matches("input")) {
        const input = this.submitter;
        this.originalSubmitText = input.value;
        input.value = this.submitsWith;
      }
    }
    resetSubmitterText() {
      if (!this.submitter || !this.originalSubmitText)
        return;
      if (this.submitter.matches("button")) {
        this.submitter.innerHTML = this.originalSubmitText;
      } else if (this.submitter.matches("input")) {
        const input = this.submitter;
        input.value = this.originalSubmitText;
      }
    }
    requestMustRedirect(request) {
      return !request.isSafe && this.mustRedirect;
    }
    requestAcceptsTurboStreamResponse(request) {
      return !request.isSafe || hasAttribute("data-turbo-stream", this.submitter, this.formElement);
    }
    get submitsWith() {
      return this.submitter?.getAttribute("data-turbo-submits-with");
    }
  };
  function buildFormData(formElement, submitter) {
    const formData = new FormData(formElement);
    const name = submitter?.getAttribute("name");
    const value = submitter?.getAttribute("value");
    if (name) {
      formData.append(name, value || "");
    }
    return formData;
  }
  __name(buildFormData, "buildFormData");
  function getCookieValue(cookieName) {
    if (cookieName != null) {
      const cookies = document.cookie ? document.cookie.split("; ") : [];
      const cookie = cookies.find((cookie2) => cookie2.startsWith(cookieName));
      if (cookie) {
        const value = cookie.split("=").slice(1).join("=");
        return value ? decodeURIComponent(value) : void 0;
      }
    }
  }
  __name(getCookieValue, "getCookieValue");
  function responseSucceededWithoutRedirect(response) {
    return response.statusCode == 200 && !response.redirected;
  }
  __name(responseSucceededWithoutRedirect, "responseSucceededWithoutRedirect");
  function getFormAction(formElement, submitter) {
    const formElementAction = typeof formElement.action === "string" ? formElement.action : null;
    if (submitter?.hasAttribute("formaction")) {
      return submitter.getAttribute("formaction") || "";
    } else {
      return formElement.getAttribute("action") || formElementAction || "";
    }
  }
  __name(getFormAction, "getFormAction");
  function getAction(formAction, fetchMethod) {
    const action = expandURL(formAction);
    if (isSafe(fetchMethod)) {
      action.search = "";
    }
    return action;
  }
  __name(getAction, "getAction");
  function getMethod(formElement, submitter) {
    const method = submitter?.getAttribute("formmethod") || formElement.getAttribute("method") || "";
    return fetchMethodFromString(method.toLowerCase()) || FetchMethod.get;
  }
  __name(getMethod, "getMethod");
  function getEnctype(formElement, submitter) {
    return fetchEnctypeFromString(submitter?.getAttribute("formenctype") || formElement.enctype);
  }
  __name(getEnctype, "getEnctype");
  var Snapshot = class {
    static {
      __name(this, "Snapshot");
    }
    constructor(element) {
      this.element = element;
    }
    get activeElement() {
      return this.element.ownerDocument.activeElement;
    }
    get children() {
      return [...this.element.children];
    }
    hasAnchor(anchor) {
      return this.getElementForAnchor(anchor) != null;
    }
    getElementForAnchor(anchor) {
      return anchor ? this.element.querySelector(`[id='${anchor}'], a[name='${anchor}']`) : null;
    }
    get isConnected() {
      return this.element.isConnected;
    }
    get firstAutofocusableElement() {
      return queryAutofocusableElement(this.element);
    }
    get permanentElements() {
      return queryPermanentElementsAll(this.element);
    }
    getPermanentElementById(id) {
      return getPermanentElementById(this.element, id);
    }
    getPermanentElementMapForSnapshot(snapshot) {
      const permanentElementMap = {};
      for (const currentPermanentElement of this.permanentElements) {
        const { id } = currentPermanentElement;
        const newPermanentElement = snapshot.getPermanentElementById(id);
        if (newPermanentElement) {
          permanentElementMap[id] = [currentPermanentElement, newPermanentElement];
        }
      }
      return permanentElementMap;
    }
  };
  function getPermanentElementById(node, id) {
    return node.querySelector(`#${id}[data-turbo-permanent]`);
  }
  __name(getPermanentElementById, "getPermanentElementById");
  function queryPermanentElementsAll(node) {
    return node.querySelectorAll("[id][data-turbo-permanent]");
  }
  __name(queryPermanentElementsAll, "queryPermanentElementsAll");
  var FormSubmitObserver = class {
    static {
      __name(this, "FormSubmitObserver");
    }
    started = false;
    constructor(delegate, eventTarget) {
      this.delegate = delegate;
      this.eventTarget = eventTarget;
    }
    start() {
      if (!this.started) {
        this.eventTarget.addEventListener("submit", this.submitCaptured, true);
        this.started = true;
      }
    }
    stop() {
      if (this.started) {
        this.eventTarget.removeEventListener("submit", this.submitCaptured, true);
        this.started = false;
      }
    }
    submitCaptured = () => {
      this.eventTarget.removeEventListener("submit", this.submitBubbled, false);
      this.eventTarget.addEventListener("submit", this.submitBubbled, false);
    };
    submitBubbled = (event) => {
      if (!event.defaultPrevented) {
        const form = event.target instanceof HTMLFormElement ? event.target : void 0;
        const submitter = event.submitter || void 0;
        if (form && submissionDoesNotDismissDialog(form, submitter) && submissionDoesNotTargetIFrame(form, submitter) && this.delegate.willSubmitForm(form, submitter)) {
          event.preventDefault();
          event.stopImmediatePropagation();
          this.delegate.formSubmitted(form, submitter);
        }
      }
    };
  };
  function submissionDoesNotDismissDialog(form, submitter) {
    const method = submitter?.getAttribute("formmethod") || form.getAttribute("method");
    return method != "dialog";
  }
  __name(submissionDoesNotDismissDialog, "submissionDoesNotDismissDialog");
  function submissionDoesNotTargetIFrame(form, submitter) {
    if (submitter?.hasAttribute("formtarget") || form.hasAttribute("target")) {
      const target = submitter?.getAttribute("formtarget") || form.target;
      for (const element of document.getElementsByName(target)) {
        if (element instanceof HTMLIFrameElement)
          return false;
      }
      return true;
    } else {
      return true;
    }
  }
  __name(submissionDoesNotTargetIFrame, "submissionDoesNotTargetIFrame");
  var View = class {
    static {
      __name(this, "View");
    }
    #resolveRenderPromise = (_value) => {
    };
    #resolveInterceptionPromise = (_value) => {
    };
    constructor(delegate, element) {
      this.delegate = delegate;
      this.element = element;
    }
    // Scrolling
    scrollToAnchor(anchor) {
      const element = this.snapshot.getElementForAnchor(anchor);
      if (element) {
        this.scrollToElement(element);
        this.focusElement(element);
      } else {
        this.scrollToPosition({ x: 0, y: 0 });
      }
    }
    scrollToAnchorFromLocation(location2) {
      this.scrollToAnchor(getAnchor(location2));
    }
    scrollToElement(element) {
      element.scrollIntoView();
    }
    focusElement(element) {
      if (element instanceof HTMLElement) {
        if (element.hasAttribute("tabindex")) {
          element.focus();
        } else {
          element.setAttribute("tabindex", "-1");
          element.focus();
          element.removeAttribute("tabindex");
        }
      }
    }
    scrollToPosition({ x: x2, y: y2 }) {
      this.scrollRoot.scrollTo(x2, y2);
    }
    scrollToTop() {
      this.scrollToPosition({ x: 0, y: 0 });
    }
    get scrollRoot() {
      return window;
    }
    // Rendering
    async render(renderer) {
      const { isPreview, shouldRender, willRender, newSnapshot: snapshot } = renderer;
      const shouldInvalidate = willRender;
      if (shouldRender) {
        try {
          this.renderPromise = new Promise((resolve) => this.#resolveRenderPromise = resolve);
          this.renderer = renderer;
          await this.prepareToRenderSnapshot(renderer);
          const renderInterception = new Promise((resolve) => this.#resolveInterceptionPromise = resolve);
          const options = { resume: this.#resolveInterceptionPromise, render: this.renderer.renderElement, renderMethod: this.renderer.renderMethod };
          const immediateRender = this.delegate.allowsImmediateRender(snapshot, options);
          if (!immediateRender)
            await renderInterception;
          await this.renderSnapshot(renderer);
          this.delegate.viewRenderedSnapshot(snapshot, isPreview, this.renderer.renderMethod);
          this.delegate.preloadOnLoadLinksForView(this.element);
          this.finishRenderingSnapshot(renderer);
        } finally {
          delete this.renderer;
          this.#resolveRenderPromise(void 0);
          delete this.renderPromise;
        }
      } else if (shouldInvalidate) {
        this.invalidate(renderer.reloadReason);
      }
    }
    invalidate(reason) {
      this.delegate.viewInvalidated(reason);
    }
    async prepareToRenderSnapshot(renderer) {
      this.markAsPreview(renderer.isPreview);
      await renderer.prepareToRender();
    }
    markAsPreview(isPreview) {
      if (isPreview) {
        this.element.setAttribute("data-turbo-preview", "");
      } else {
        this.element.removeAttribute("data-turbo-preview");
      }
    }
    markVisitDirection(direction) {
      this.element.setAttribute("data-turbo-visit-direction", direction);
    }
    unmarkVisitDirection() {
      this.element.removeAttribute("data-turbo-visit-direction");
    }
    async renderSnapshot(renderer) {
      await renderer.render();
    }
    finishRenderingSnapshot(renderer) {
      renderer.finishRendering();
    }
  };
  var FrameView = class extends View {
    static {
      __name(this, "FrameView");
    }
    missing() {
      this.element.innerHTML = `<strong class="turbo-frame-error">Content missing</strong>`;
    }
    get snapshot() {
      return new Snapshot(this.element);
    }
  };
  var LinkInterceptor = class {
    static {
      __name(this, "LinkInterceptor");
    }
    constructor(delegate, element) {
      this.delegate = delegate;
      this.element = element;
    }
    start() {
      this.element.addEventListener("click", this.clickBubbled);
      document.addEventListener("turbo:click", this.linkClicked);
      document.addEventListener("turbo:before-visit", this.willVisit);
    }
    stop() {
      this.element.removeEventListener("click", this.clickBubbled);
      document.removeEventListener("turbo:click", this.linkClicked);
      document.removeEventListener("turbo:before-visit", this.willVisit);
    }
    clickBubbled = (event) => {
      if (this.respondsToEventTarget(event.target)) {
        this.clickEvent = event;
      } else {
        delete this.clickEvent;
      }
    };
    linkClicked = (event) => {
      if (this.clickEvent && this.respondsToEventTarget(event.target) && event.target instanceof Element) {
        if (this.delegate.shouldInterceptLinkClick(event.target, event.detail.url, event.detail.originalEvent)) {
          this.clickEvent.preventDefault();
          event.preventDefault();
          this.delegate.linkClickIntercepted(event.target, event.detail.url, event.detail.originalEvent);
        }
      }
      delete this.clickEvent;
    };
    willVisit = (_event) => {
      delete this.clickEvent;
    };
    respondsToEventTarget(target) {
      const element = target instanceof Element ? target : target instanceof Node ? target.parentElement : null;
      return element && element.closest("turbo-frame, html") == this.element;
    }
  };
  var LinkClickObserver = class {
    static {
      __name(this, "LinkClickObserver");
    }
    started = false;
    constructor(delegate, eventTarget) {
      this.delegate = delegate;
      this.eventTarget = eventTarget;
    }
    start() {
      if (!this.started) {
        this.eventTarget.addEventListener("click", this.clickCaptured, true);
        this.started = true;
      }
    }
    stop() {
      if (this.started) {
        this.eventTarget.removeEventListener("click", this.clickCaptured, true);
        this.started = false;
      }
    }
    clickCaptured = () => {
      this.eventTarget.removeEventListener("click", this.clickBubbled, false);
      this.eventTarget.addEventListener("click", this.clickBubbled, false);
    };
    clickBubbled = (event) => {
      if (event instanceof MouseEvent && this.clickEventIsSignificant(event)) {
        const target = event.composedPath && event.composedPath()[0] || event.target;
        const link = findLinkFromClickTarget(target);
        if (link && doesNotTargetIFrame(link)) {
          const location2 = getLocationForLink(link);
          if (this.delegate.willFollowLinkToLocation(link, location2, event)) {
            event.preventDefault();
            this.delegate.followedLinkToLocation(link, location2);
          }
        }
      }
    };
    clickEventIsSignificant(event) {
      return !(event.target && event.target.isContentEditable || event.defaultPrevented || event.which > 1 || event.altKey || event.ctrlKey || event.metaKey || event.shiftKey);
    }
  };
  var FormLinkClickObserver = class {
    static {
      __name(this, "FormLinkClickObserver");
    }
    constructor(delegate, element) {
      this.delegate = delegate;
      this.linkInterceptor = new LinkClickObserver(this, element);
    }
    start() {
      this.linkInterceptor.start();
    }
    stop() {
      this.linkInterceptor.stop();
    }
    // Link hover observer delegate
    canPrefetchRequestToLocation(link, location2) {
      return false;
    }
    prefetchAndCacheRequestToLocation(link, location2) {
      return;
    }
    // Link click observer delegate
    willFollowLinkToLocation(link, location2, originalEvent) {
      return this.delegate.willSubmitFormLinkToLocation(link, location2, originalEvent) && (link.hasAttribute("data-turbo-method") || link.hasAttribute("data-turbo-stream"));
    }
    followedLinkToLocation(link, location2) {
      const form = document.createElement("form");
      const type = "hidden";
      for (const [name, value] of location2.searchParams) {
        form.append(Object.assign(document.createElement("input"), { type, name, value }));
      }
      const action = Object.assign(location2, { search: "" });
      form.setAttribute("data-turbo", "true");
      form.setAttribute("action", action.href);
      form.setAttribute("hidden", "");
      const method = link.getAttribute("data-turbo-method");
      if (method)
        form.setAttribute("method", method);
      const turboFrame = link.getAttribute("data-turbo-frame");
      if (turboFrame)
        form.setAttribute("data-turbo-frame", turboFrame);
      const turboAction = getVisitAction(link);
      if (turboAction)
        form.setAttribute("data-turbo-action", turboAction);
      const turboConfirm = link.getAttribute("data-turbo-confirm");
      if (turboConfirm)
        form.setAttribute("data-turbo-confirm", turboConfirm);
      const turboStream = link.hasAttribute("data-turbo-stream");
      if (turboStream)
        form.setAttribute("data-turbo-stream", "");
      this.delegate.submittedFormLinkToLocation(link, location2, form);
      document.body.appendChild(form);
      form.addEventListener("turbo:submit-end", () => form.remove(), { once: true });
      requestAnimationFrame(() => form.requestSubmit());
    }
  };
  var Bardo = class {
    static {
      __name(this, "Bardo");
    }
    static async preservingPermanentElements(delegate, permanentElementMap, callback) {
      const bardo = new this(delegate, permanentElementMap);
      bardo.enter();
      await callback();
      bardo.leave();
    }
    constructor(delegate, permanentElementMap) {
      this.delegate = delegate;
      this.permanentElementMap = permanentElementMap;
    }
    enter() {
      for (const id in this.permanentElementMap) {
        const [currentPermanentElement, newPermanentElement] = this.permanentElementMap[id];
        this.delegate.enteringBardo(currentPermanentElement, newPermanentElement);
        this.replaceNewPermanentElementWithPlaceholder(newPermanentElement);
      }
    }
    leave() {
      for (const id in this.permanentElementMap) {
        const [currentPermanentElement] = this.permanentElementMap[id];
        this.replaceCurrentPermanentElementWithClone(currentPermanentElement);
        this.replacePlaceholderWithPermanentElement(currentPermanentElement);
        this.delegate.leavingBardo(currentPermanentElement);
      }
    }
    replaceNewPermanentElementWithPlaceholder(permanentElement) {
      const placeholder = createPlaceholderForPermanentElement(permanentElement);
      permanentElement.replaceWith(placeholder);
    }
    replaceCurrentPermanentElementWithClone(permanentElement) {
      const clone = permanentElement.cloneNode(true);
      permanentElement.replaceWith(clone);
    }
    replacePlaceholderWithPermanentElement(permanentElement) {
      const placeholder = this.getPlaceholderById(permanentElement.id);
      placeholder?.replaceWith(permanentElement);
    }
    getPlaceholderById(id) {
      return this.placeholders.find((element) => element.content == id);
    }
    get placeholders() {
      return [...document.querySelectorAll("meta[name=turbo-permanent-placeholder][content]")];
    }
  };
  function createPlaceholderForPermanentElement(permanentElement) {
    const element = document.createElement("meta");
    element.setAttribute("name", "turbo-permanent-placeholder");
    element.setAttribute("content", permanentElement.id);
    return element;
  }
  __name(createPlaceholderForPermanentElement, "createPlaceholderForPermanentElement");
  var Renderer = class {
    static {
      __name(this, "Renderer");
    }
    #activeElement = null;
    constructor(currentSnapshot, newSnapshot, renderElement, isPreview, willRender = true) {
      this.currentSnapshot = currentSnapshot;
      this.newSnapshot = newSnapshot;
      this.isPreview = isPreview;
      this.willRender = willRender;
      this.renderElement = renderElement;
      this.promise = new Promise((resolve, reject) => this.resolvingFunctions = { resolve, reject });
    }
    get shouldRender() {
      return true;
    }
    get reloadReason() {
      return;
    }
    prepareToRender() {
      return;
    }
    render() {
    }
    finishRendering() {
      if (this.resolvingFunctions) {
        this.resolvingFunctions.resolve();
        delete this.resolvingFunctions;
      }
    }
    async preservingPermanentElements(callback) {
      await Bardo.preservingPermanentElements(this, this.permanentElementMap, callback);
    }
    focusFirstAutofocusableElement() {
      const element = this.connectedSnapshot.firstAutofocusableElement;
      if (element) {
        element.focus();
      }
    }
    // Bardo delegate
    enteringBardo(currentPermanentElement) {
      if (this.#activeElement)
        return;
      if (currentPermanentElement.contains(this.currentSnapshot.activeElement)) {
        this.#activeElement = this.currentSnapshot.activeElement;
      }
    }
    leavingBardo(currentPermanentElement) {
      if (currentPermanentElement.contains(this.#activeElement) && this.#activeElement instanceof HTMLElement) {
        this.#activeElement.focus();
        this.#activeElement = null;
      }
    }
    get connectedSnapshot() {
      return this.newSnapshot.isConnected ? this.newSnapshot : this.currentSnapshot;
    }
    get currentElement() {
      return this.currentSnapshot.element;
    }
    get newElement() {
      return this.newSnapshot.element;
    }
    get permanentElementMap() {
      return this.currentSnapshot.getPermanentElementMapForSnapshot(this.newSnapshot);
    }
    get renderMethod() {
      return "replace";
    }
  };
  var FrameRenderer = class extends Renderer {
    static {
      __name(this, "FrameRenderer");
    }
    static renderElement(currentElement, newElement) {
      const destinationRange = document.createRange();
      destinationRange.selectNodeContents(currentElement);
      destinationRange.deleteContents();
      const frameElement = newElement;
      const sourceRange = frameElement.ownerDocument?.createRange();
      if (sourceRange) {
        sourceRange.selectNodeContents(frameElement);
        currentElement.appendChild(sourceRange.extractContents());
      }
    }
    constructor(delegate, currentSnapshot, newSnapshot, renderElement, isPreview, willRender = true) {
      super(currentSnapshot, newSnapshot, renderElement, isPreview, willRender);
      this.delegate = delegate;
    }
    get shouldRender() {
      return true;
    }
    async render() {
      await nextRepaint();
      this.preservingPermanentElements(() => {
        this.loadFrameElement();
      });
      this.scrollFrameIntoView();
      await nextRepaint();
      this.focusFirstAutofocusableElement();
      await nextRepaint();
      this.activateScriptElements();
    }
    loadFrameElement() {
      this.delegate.willRenderFrame(this.currentElement, this.newElement);
      this.renderElement(this.currentElement, this.newElement);
    }
    scrollFrameIntoView() {
      if (this.currentElement.autoscroll || this.newElement.autoscroll) {
        const element = this.currentElement.firstElementChild;
        const block = readScrollLogicalPosition(this.currentElement.getAttribute("data-autoscroll-block"), "end");
        const behavior = readScrollBehavior(this.currentElement.getAttribute("data-autoscroll-behavior"), "auto");
        if (element) {
          element.scrollIntoView({ block, behavior });
          return true;
        }
      }
      return false;
    }
    activateScriptElements() {
      for (const inertScriptElement of this.newScriptElements) {
        const activatedScriptElement = activateScriptElement(inertScriptElement);
        inertScriptElement.replaceWith(activatedScriptElement);
      }
    }
    get newScriptElements() {
      return this.currentElement.querySelectorAll("script");
    }
  };
  function readScrollLogicalPosition(value, defaultValue) {
    if (value == "end" || value == "start" || value == "center" || value == "nearest") {
      return value;
    } else {
      return defaultValue;
    }
  }
  __name(readScrollLogicalPosition, "readScrollLogicalPosition");
  function readScrollBehavior(value, defaultValue) {
    if (value == "auto" || value == "smooth") {
      return value;
    } else {
      return defaultValue;
    }
  }
  __name(readScrollBehavior, "readScrollBehavior");
  var ProgressBar = class _ProgressBar {
    static {
      __name(this, "ProgressBar");
    }
    static animationDuration = 300;
    /*ms*/
    static get defaultCSS() {
      return unindent`
      .turbo-progress-bar {
        position: fixed;
        display: block;
        top: 0;
        left: 0;
        height: 3px;
        background: #0076ff;
        z-index: 2147483647;
        transition:
          width ${_ProgressBar.animationDuration}ms ease-out,
          opacity ${_ProgressBar.animationDuration / 2}ms ${_ProgressBar.animationDuration / 2}ms ease-in;
        transform: translate3d(0, 0, 0);
      }
    `;
    }
    hiding = false;
    value = 0;
    visible = false;
    constructor() {
      this.stylesheetElement = this.createStylesheetElement();
      this.progressElement = this.createProgressElement();
      this.installStylesheetElement();
      this.setValue(0);
    }
    show() {
      if (!this.visible) {
        this.visible = true;
        this.installProgressElement();
        this.startTrickling();
      }
    }
    hide() {
      if (this.visible && !this.hiding) {
        this.hiding = true;
        this.fadeProgressElement(() => {
          this.uninstallProgressElement();
          this.stopTrickling();
          this.visible = false;
          this.hiding = false;
        });
      }
    }
    setValue(value) {
      this.value = value;
      this.refresh();
    }
    // Private
    installStylesheetElement() {
      document.head.insertBefore(this.stylesheetElement, document.head.firstChild);
    }
    installProgressElement() {
      this.progressElement.style.width = "0";
      this.progressElement.style.opacity = "1";
      document.documentElement.insertBefore(this.progressElement, document.body);
      this.refresh();
    }
    fadeProgressElement(callback) {
      this.progressElement.style.opacity = "0";
      setTimeout(callback, _ProgressBar.animationDuration * 1.5);
    }
    uninstallProgressElement() {
      if (this.progressElement.parentNode) {
        document.documentElement.removeChild(this.progressElement);
      }
    }
    startTrickling() {
      if (!this.trickleInterval) {
        this.trickleInterval = window.setInterval(this.trickle, _ProgressBar.animationDuration);
      }
    }
    stopTrickling() {
      window.clearInterval(this.trickleInterval);
      delete this.trickleInterval;
    }
    trickle = () => {
      this.setValue(this.value + Math.random() / 100);
    };
    refresh() {
      requestAnimationFrame(() => {
        this.progressElement.style.width = `${10 + this.value * 90}%`;
      });
    }
    createStylesheetElement() {
      const element = document.createElement("style");
      element.type = "text/css";
      element.textContent = _ProgressBar.defaultCSS;
      if (this.cspNonce) {
        element.nonce = this.cspNonce;
      }
      return element;
    }
    createProgressElement() {
      const element = document.createElement("div");
      element.className = "turbo-progress-bar";
      return element;
    }
    get cspNonce() {
      return getMetaContent("csp-nonce");
    }
  };
  var HeadSnapshot = class extends Snapshot {
    static {
      __name(this, "HeadSnapshot");
    }
    detailsByOuterHTML = this.children.filter((element) => !elementIsNoscript(element)).map((element) => elementWithoutNonce(element)).reduce((result, element) => {
      const { outerHTML } = element;
      const details = outerHTML in result ? result[outerHTML] : {
        type: elementType(element),
        tracked: elementIsTracked(element),
        elements: []
      };
      return {
        ...result,
        [outerHTML]: {
          ...details,
          elements: [...details.elements, element]
        }
      };
    }, {});
    get trackedElementSignature() {
      return Object.keys(this.detailsByOuterHTML).filter((outerHTML) => this.detailsByOuterHTML[outerHTML].tracked).join("");
    }
    getScriptElementsNotInSnapshot(snapshot) {
      return this.getElementsMatchingTypeNotInSnapshot("script", snapshot);
    }
    getStylesheetElementsNotInSnapshot(snapshot) {
      return this.getElementsMatchingTypeNotInSnapshot("stylesheet", snapshot);
    }
    getElementsMatchingTypeNotInSnapshot(matchedType, snapshot) {
      return Object.keys(this.detailsByOuterHTML).filter((outerHTML) => !(outerHTML in snapshot.detailsByOuterHTML)).map((outerHTML) => this.detailsByOuterHTML[outerHTML]).filter(({ type }) => type == matchedType).map(({ elements: [element] }) => element);
    }
    get provisionalElements() {
      return Object.keys(this.detailsByOuterHTML).reduce((result, outerHTML) => {
        const { type, tracked, elements } = this.detailsByOuterHTML[outerHTML];
        if (type == null && !tracked) {
          return [...result, ...elements];
        } else if (elements.length > 1) {
          return [...result, ...elements.slice(1)];
        } else {
          return result;
        }
      }, []);
    }
    getMetaValue(name) {
      const element = this.findMetaElementByName(name);
      return element ? element.getAttribute("content") : null;
    }
    findMetaElementByName(name) {
      return Object.keys(this.detailsByOuterHTML).reduce((result, outerHTML) => {
        const {
          elements: [element]
        } = this.detailsByOuterHTML[outerHTML];
        return elementIsMetaElementWithName(element, name) ? element : result;
      }, void 0 | void 0);
    }
  };
  function elementType(element) {
    if (elementIsScript(element)) {
      return "script";
    } else if (elementIsStylesheet(element)) {
      return "stylesheet";
    }
  }
  __name(elementType, "elementType");
  function elementIsTracked(element) {
    return element.getAttribute("data-turbo-track") == "reload";
  }
  __name(elementIsTracked, "elementIsTracked");
  function elementIsScript(element) {
    const tagName = element.localName;
    return tagName == "script";
  }
  __name(elementIsScript, "elementIsScript");
  function elementIsNoscript(element) {
    const tagName = element.localName;
    return tagName == "noscript";
  }
  __name(elementIsNoscript, "elementIsNoscript");
  function elementIsStylesheet(element) {
    const tagName = element.localName;
    return tagName == "style" || tagName == "link" && element.getAttribute("rel") == "stylesheet";
  }
  __name(elementIsStylesheet, "elementIsStylesheet");
  function elementIsMetaElementWithName(element, name) {
    const tagName = element.localName;
    return tagName == "meta" && element.getAttribute("name") == name;
  }
  __name(elementIsMetaElementWithName, "elementIsMetaElementWithName");
  function elementWithoutNonce(element) {
    if (element.hasAttribute("nonce")) {
      element.setAttribute("nonce", "");
    }
    return element;
  }
  __name(elementWithoutNonce, "elementWithoutNonce");
  var PageSnapshot = class _PageSnapshot extends Snapshot {
    static {
      __name(this, "PageSnapshot");
    }
    static fromHTMLString(html = "") {
      return this.fromDocument(parseHTMLDocument(html));
    }
    static fromElement(element) {
      return this.fromDocument(element.ownerDocument);
    }
    static fromDocument({ documentElement, body, head }) {
      return new this(documentElement, body, new HeadSnapshot(head));
    }
    constructor(documentElement, body, headSnapshot) {
      super(body);
      this.documentElement = documentElement;
      this.headSnapshot = headSnapshot;
    }
    clone() {
      const clonedElement = this.element.cloneNode(true);
      const selectElements = this.element.querySelectorAll("select");
      const clonedSelectElements = clonedElement.querySelectorAll("select");
      for (const [index, source] of selectElements.entries()) {
        const clone = clonedSelectElements[index];
        for (const option of clone.selectedOptions)
          option.selected = false;
        for (const option of source.selectedOptions)
          clone.options[option.index].selected = true;
      }
      for (const clonedPasswordInput of clonedElement.querySelectorAll('input[type="password"]')) {
        clonedPasswordInput.value = "";
      }
      return new _PageSnapshot(this.documentElement, clonedElement, this.headSnapshot);
    }
    get lang() {
      return this.documentElement.getAttribute("lang");
    }
    get headElement() {
      return this.headSnapshot.element;
    }
    get rootLocation() {
      const root2 = this.getSetting("root") ?? "/";
      return expandURL(root2);
    }
    get cacheControlValue() {
      return this.getSetting("cache-control");
    }
    get isPreviewable() {
      return this.cacheControlValue != "no-preview";
    }
    get isCacheable() {
      return this.cacheControlValue != "no-cache";
    }
    get isVisitable() {
      return this.getSetting("visit-control") != "reload";
    }
    get prefersViewTransitions() {
      return this.headSnapshot.getMetaValue("view-transition") === "same-origin";
    }
    get shouldMorphPage() {
      return this.getSetting("refresh-method") === "morph";
    }
    get shouldPreserveScrollPosition() {
      return this.getSetting("refresh-scroll") === "preserve";
    }
    // Private
    getSetting(name) {
      return this.headSnapshot.getMetaValue(`turbo-${name}`);
    }
  };
  var ViewTransitioner = class {
    static {
      __name(this, "ViewTransitioner");
    }
    #viewTransitionStarted = false;
    #lastOperation = Promise.resolve();
    renderChange(useViewTransition, render) {
      if (useViewTransition && this.viewTransitionsAvailable && !this.#viewTransitionStarted) {
        this.#viewTransitionStarted = true;
        this.#lastOperation = this.#lastOperation.then(async () => {
          await document.startViewTransition(render).finished;
        });
      } else {
        this.#lastOperation = this.#lastOperation.then(render);
      }
      return this.#lastOperation;
    }
    get viewTransitionsAvailable() {
      return document.startViewTransition;
    }
  };
  var defaultOptions = {
    action: "advance",
    historyChanged: false,
    visitCachedSnapshot: () => {
    },
    willRender: true,
    updateHistory: true,
    shouldCacheSnapshot: true,
    acceptsStreamResponse: false
  };
  var TimingMetric = {
    visitStart: "visitStart",
    requestStart: "requestStart",
    requestEnd: "requestEnd",
    visitEnd: "visitEnd"
  };
  var VisitState = {
    initialized: "initialized",
    started: "started",
    canceled: "canceled",
    failed: "failed",
    completed: "completed"
  };
  var SystemStatusCode = {
    networkFailure: 0,
    timeoutFailure: -1,
    contentTypeMismatch: -2
  };
  var Direction = {
    advance: "forward",
    restore: "back",
    replace: "none"
  };
  var Visit = class {
    static {
      __name(this, "Visit");
    }
    identifier = uuid();
    // Required by turbo-ios
    timingMetrics = {};
    followedRedirect = false;
    historyChanged = false;
    scrolled = false;
    shouldCacheSnapshot = true;
    acceptsStreamResponse = false;
    snapshotCached = false;
    state = VisitState.initialized;
    viewTransitioner = new ViewTransitioner();
    constructor(delegate, location2, restorationIdentifier, options = {}) {
      this.delegate = delegate;
      this.location = location2;
      this.restorationIdentifier = restorationIdentifier || uuid();
      const {
        action,
        historyChanged,
        referrer,
        snapshot,
        snapshotHTML,
        response,
        visitCachedSnapshot,
        willRender,
        updateHistory,
        shouldCacheSnapshot,
        acceptsStreamResponse,
        direction
      } = {
        ...defaultOptions,
        ...options
      };
      this.action = action;
      this.historyChanged = historyChanged;
      this.referrer = referrer;
      this.snapshot = snapshot;
      this.snapshotHTML = snapshotHTML;
      this.response = response;
      this.isSamePage = this.delegate.locationWithActionIsSamePage(this.location, this.action);
      this.isPageRefresh = this.view.isPageRefresh(this);
      this.visitCachedSnapshot = visitCachedSnapshot;
      this.willRender = willRender;
      this.updateHistory = updateHistory;
      this.scrolled = !willRender;
      this.shouldCacheSnapshot = shouldCacheSnapshot;
      this.acceptsStreamResponse = acceptsStreamResponse;
      this.direction = direction || Direction[action];
    }
    get adapter() {
      return this.delegate.adapter;
    }
    get view() {
      return this.delegate.view;
    }
    get history() {
      return this.delegate.history;
    }
    get restorationData() {
      return this.history.getRestorationDataForIdentifier(this.restorationIdentifier);
    }
    get silent() {
      return this.isSamePage;
    }
    start() {
      if (this.state == VisitState.initialized) {
        this.recordTimingMetric(TimingMetric.visitStart);
        this.state = VisitState.started;
        this.adapter.visitStarted(this);
        this.delegate.visitStarted(this);
      }
    }
    cancel() {
      if (this.state == VisitState.started) {
        if (this.request) {
          this.request.cancel();
        }
        this.cancelRender();
        this.state = VisitState.canceled;
      }
    }
    complete() {
      if (this.state == VisitState.started) {
        this.recordTimingMetric(TimingMetric.visitEnd);
        this.adapter.visitCompleted(this);
        this.state = VisitState.completed;
        this.followRedirect();
        if (!this.followedRedirect) {
          this.delegate.visitCompleted(this);
        }
      }
    }
    fail() {
      if (this.state == VisitState.started) {
        this.state = VisitState.failed;
        this.adapter.visitFailed(this);
        this.delegate.visitCompleted(this);
      }
    }
    changeHistory() {
      if (!this.historyChanged && this.updateHistory) {
        const actionForHistory = this.location.href === this.referrer?.href ? "replace" : this.action;
        const method = getHistoryMethodForAction(actionForHistory);
        this.history.update(method, this.location, this.restorationIdentifier);
        this.historyChanged = true;
      }
    }
    issueRequest() {
      if (this.hasPreloadedResponse()) {
        this.simulateRequest();
      } else if (this.shouldIssueRequest() && !this.request) {
        this.request = new FetchRequest(this, FetchMethod.get, this.location);
        this.request.perform();
      }
    }
    simulateRequest() {
      if (this.response) {
        this.startRequest();
        this.recordResponse();
        this.finishRequest();
      }
    }
    startRequest() {
      this.recordTimingMetric(TimingMetric.requestStart);
      this.adapter.visitRequestStarted(this);
    }
    recordResponse(response = this.response) {
      this.response = response;
      if (response) {
        const { statusCode } = response;
        if (isSuccessful(statusCode)) {
          this.adapter.visitRequestCompleted(this);
        } else {
          this.adapter.visitRequestFailedWithStatusCode(this, statusCode);
        }
      }
    }
    finishRequest() {
      this.recordTimingMetric(TimingMetric.requestEnd);
      this.adapter.visitRequestFinished(this);
    }
    loadResponse() {
      if (this.response) {
        const { statusCode, responseHTML } = this.response;
        this.render(async () => {
          if (this.shouldCacheSnapshot)
            this.cacheSnapshot();
          if (this.view.renderPromise)
            await this.view.renderPromise;
          if (isSuccessful(statusCode) && responseHTML != null) {
            const snapshot = PageSnapshot.fromHTMLString(responseHTML);
            await this.renderPageSnapshot(snapshot, false);
            this.adapter.visitRendered(this);
            this.complete();
          } else {
            await this.view.renderError(PageSnapshot.fromHTMLString(responseHTML), this);
            this.adapter.visitRendered(this);
            this.fail();
          }
        });
      }
    }
    getCachedSnapshot() {
      const snapshot = this.view.getCachedSnapshotForLocation(this.location) || this.getPreloadedSnapshot();
      if (snapshot && (!getAnchor(this.location) || snapshot.hasAnchor(getAnchor(this.location)))) {
        if (this.action == "restore" || snapshot.isPreviewable) {
          return snapshot;
        }
      }
    }
    getPreloadedSnapshot() {
      if (this.snapshotHTML) {
        return PageSnapshot.fromHTMLString(this.snapshotHTML);
      }
    }
    hasCachedSnapshot() {
      return this.getCachedSnapshot() != null;
    }
    loadCachedSnapshot() {
      const snapshot = this.getCachedSnapshot();
      if (snapshot) {
        const isPreview = this.shouldIssueRequest();
        this.render(async () => {
          this.cacheSnapshot();
          if (this.isSamePage || this.isPageRefresh) {
            this.adapter.visitRendered(this);
          } else {
            if (this.view.renderPromise)
              await this.view.renderPromise;
            await this.renderPageSnapshot(snapshot, isPreview);
            this.adapter.visitRendered(this);
            if (!isPreview) {
              this.complete();
            }
          }
        });
      }
    }
    followRedirect() {
      if (this.redirectedToLocation && !this.followedRedirect && this.response?.redirected) {
        this.adapter.visitProposedToLocation(this.redirectedToLocation, {
          action: "replace",
          response: this.response,
          shouldCacheSnapshot: false,
          willRender: false
        });
        this.followedRedirect = true;
      }
    }
    goToSamePageAnchor() {
      if (this.isSamePage) {
        this.render(async () => {
          this.cacheSnapshot();
          this.performScroll();
          this.changeHistory();
          this.adapter.visitRendered(this);
        });
      }
    }
    // Fetch request delegate
    prepareRequest(request) {
      if (this.acceptsStreamResponse) {
        request.acceptResponseType(StreamMessage.contentType);
      }
    }
    requestStarted() {
      this.startRequest();
    }
    requestPreventedHandlingResponse(_request, _response) {
    }
    async requestSucceededWithResponse(request, response) {
      const responseHTML = await response.responseHTML;
      const { redirected, statusCode } = response;
      if (responseHTML == void 0) {
        this.recordResponse({
          statusCode: SystemStatusCode.contentTypeMismatch,
          redirected
        });
      } else {
        this.redirectedToLocation = response.redirected ? response.location : void 0;
        this.recordResponse({ statusCode, responseHTML, redirected });
      }
    }
    async requestFailedWithResponse(request, response) {
      const responseHTML = await response.responseHTML;
      const { redirected, statusCode } = response;
      if (responseHTML == void 0) {
        this.recordResponse({
          statusCode: SystemStatusCode.contentTypeMismatch,
          redirected
        });
      } else {
        this.recordResponse({ statusCode, responseHTML, redirected });
      }
    }
    requestErrored(_request, _error) {
      this.recordResponse({
        statusCode: SystemStatusCode.networkFailure,
        redirected: false
      });
    }
    requestFinished() {
      this.finishRequest();
    }
    // Scrolling
    performScroll() {
      if (!this.scrolled && !this.view.forceReloaded && !this.view.shouldPreserveScrollPosition(this)) {
        if (this.action == "restore") {
          this.scrollToRestoredPosition() || this.scrollToAnchor() || this.view.scrollToTop();
        } else {
          this.scrollToAnchor() || this.view.scrollToTop();
        }
        if (this.isSamePage) {
          this.delegate.visitScrolledToSamePageLocation(this.view.lastRenderedLocation, this.location);
        }
        this.scrolled = true;
      }
    }
    scrollToRestoredPosition() {
      const { scrollPosition } = this.restorationData;
      if (scrollPosition) {
        this.view.scrollToPosition(scrollPosition);
        return true;
      }
    }
    scrollToAnchor() {
      const anchor = getAnchor(this.location);
      if (anchor != null) {
        this.view.scrollToAnchor(anchor);
        return true;
      }
    }
    // Instrumentation
    recordTimingMetric(metric) {
      this.timingMetrics[metric] = (/* @__PURE__ */ new Date()).getTime();
    }
    getTimingMetrics() {
      return { ...this.timingMetrics };
    }
    // Private
    getHistoryMethodForAction(action) {
      switch (action) {
        case "replace":
          return history.replaceState;
        case "advance":
        case "restore":
          return history.pushState;
      }
    }
    hasPreloadedResponse() {
      return typeof this.response == "object";
    }
    shouldIssueRequest() {
      if (this.isSamePage) {
        return false;
      } else if (this.action == "restore") {
        return !this.hasCachedSnapshot();
      } else {
        return this.willRender;
      }
    }
    cacheSnapshot() {
      if (!this.snapshotCached) {
        this.view.cacheSnapshot(this.snapshot).then((snapshot) => snapshot && this.visitCachedSnapshot(snapshot));
        this.snapshotCached = true;
      }
    }
    async render(callback) {
      this.cancelRender();
      this.frame = await nextRepaint();
      await callback();
      delete this.frame;
    }
    async renderPageSnapshot(snapshot, isPreview) {
      await this.viewTransitioner.renderChange(this.view.shouldTransitionTo(snapshot), async () => {
        await this.view.renderPage(snapshot, isPreview, this.willRender, this);
        this.performScroll();
      });
    }
    cancelRender() {
      if (this.frame) {
        cancelAnimationFrame(this.frame);
        delete this.frame;
      }
    }
  };
  function isSuccessful(statusCode) {
    return statusCode >= 200 && statusCode < 300;
  }
  __name(isSuccessful, "isSuccessful");
  var BrowserAdapter = class {
    static {
      __name(this, "BrowserAdapter");
    }
    progressBar = new ProgressBar();
    constructor(session2) {
      this.session = session2;
    }
    visitProposedToLocation(location2, options) {
      if (locationIsVisitable(location2, this.navigator.rootLocation)) {
        this.navigator.startVisit(location2, options?.restorationIdentifier || uuid(), options);
      } else {
        window.location.href = location2.toString();
      }
    }
    visitStarted(visit2) {
      this.location = visit2.location;
      visit2.loadCachedSnapshot();
      visit2.issueRequest();
      visit2.goToSamePageAnchor();
    }
    visitRequestStarted(visit2) {
      this.progressBar.setValue(0);
      if (visit2.hasCachedSnapshot() || visit2.action != "restore") {
        this.showVisitProgressBarAfterDelay();
      } else {
        this.showProgressBar();
      }
    }
    visitRequestCompleted(visit2) {
      visit2.loadResponse();
    }
    visitRequestFailedWithStatusCode(visit2, statusCode) {
      switch (statusCode) {
        case SystemStatusCode.networkFailure:
        case SystemStatusCode.timeoutFailure:
        case SystemStatusCode.contentTypeMismatch:
          return this.reload({
            reason: "request_failed",
            context: {
              statusCode
            }
          });
        default:
          return visit2.loadResponse();
      }
    }
    visitRequestFinished(_visit) {
    }
    visitCompleted(_visit) {
      this.progressBar.setValue(1);
      this.hideVisitProgressBar();
    }
    pageInvalidated(reason) {
      this.reload(reason);
    }
    visitFailed(_visit) {
      this.progressBar.setValue(1);
      this.hideVisitProgressBar();
    }
    visitRendered(_visit) {
    }
    // Form Submission Delegate
    formSubmissionStarted(_formSubmission) {
      this.progressBar.setValue(0);
      this.showFormProgressBarAfterDelay();
    }
    formSubmissionFinished(_formSubmission) {
      this.progressBar.setValue(1);
      this.hideFormProgressBar();
    }
    // Private
    showVisitProgressBarAfterDelay() {
      this.visitProgressBarTimeout = window.setTimeout(this.showProgressBar, this.session.progressBarDelay);
    }
    hideVisitProgressBar() {
      this.progressBar.hide();
      if (this.visitProgressBarTimeout != null) {
        window.clearTimeout(this.visitProgressBarTimeout);
        delete this.visitProgressBarTimeout;
      }
    }
    showFormProgressBarAfterDelay() {
      if (this.formProgressBarTimeout == null) {
        this.formProgressBarTimeout = window.setTimeout(this.showProgressBar, this.session.progressBarDelay);
      }
    }
    hideFormProgressBar() {
      this.progressBar.hide();
      if (this.formProgressBarTimeout != null) {
        window.clearTimeout(this.formProgressBarTimeout);
        delete this.formProgressBarTimeout;
      }
    }
    showProgressBar = () => {
      this.progressBar.show();
    };
    reload(reason) {
      dispatch("turbo:reload", { detail: reason });
      window.location.href = this.location?.toString() || window.location.href;
    }
    get navigator() {
      return this.session.navigator;
    }
  };
  var CacheObserver = class {
    static {
      __name(this, "CacheObserver");
    }
    selector = "[data-turbo-temporary]";
    deprecatedSelector = "[data-turbo-cache=false]";
    started = false;
    start() {
      if (!this.started) {
        this.started = true;
        addEventListener("turbo:before-cache", this.removeTemporaryElements, false);
      }
    }
    stop() {
      if (this.started) {
        this.started = false;
        removeEventListener("turbo:before-cache", this.removeTemporaryElements, false);
      }
    }
    removeTemporaryElements = (_event) => {
      for (const element of this.temporaryElements) {
        element.remove();
      }
    };
    get temporaryElements() {
      return [...document.querySelectorAll(this.selector), ...this.temporaryElementsWithDeprecation];
    }
    get temporaryElementsWithDeprecation() {
      const elements = document.querySelectorAll(this.deprecatedSelector);
      if (elements.length) {
        console.warn(
          `The ${this.deprecatedSelector} selector is deprecated and will be removed in a future version. Use ${this.selector} instead.`
        );
      }
      return [...elements];
    }
  };
  var FrameRedirector = class {
    static {
      __name(this, "FrameRedirector");
    }
    constructor(session2, element) {
      this.session = session2;
      this.element = element;
      this.linkInterceptor = new LinkInterceptor(this, element);
      this.formSubmitObserver = new FormSubmitObserver(this, element);
    }
    start() {
      this.linkInterceptor.start();
      this.formSubmitObserver.start();
    }
    stop() {
      this.linkInterceptor.stop();
      this.formSubmitObserver.stop();
    }
    // Link interceptor delegate
    shouldInterceptLinkClick(element, _location, _event) {
      return this.#shouldRedirect(element);
    }
    linkClickIntercepted(element, url, event) {
      const frame = this.#findFrameElement(element);
      if (frame) {
        frame.delegate.linkClickIntercepted(element, url, event);
      }
    }
    // Form submit observer delegate
    willSubmitForm(element, submitter) {
      return element.closest("turbo-frame") == null && this.#shouldSubmit(element, submitter) && this.#shouldRedirect(element, submitter);
    }
    formSubmitted(element, submitter) {
      const frame = this.#findFrameElement(element, submitter);
      if (frame) {
        frame.delegate.formSubmitted(element, submitter);
      }
    }
    #shouldSubmit(form, submitter) {
      const action = getAction$1(form, submitter);
      const meta = this.element.ownerDocument.querySelector(`meta[name="turbo-root"]`);
      const rootLocation = expandURL(meta?.content ?? "/");
      return this.#shouldRedirect(form, submitter) && locationIsVisitable(action, rootLocation);
    }
    #shouldRedirect(element, submitter) {
      const isNavigatable = element instanceof HTMLFormElement ? this.session.submissionIsNavigatable(element, submitter) : this.session.elementIsNavigatable(element);
      if (isNavigatable) {
        const frame = this.#findFrameElement(element, submitter);
        return frame ? frame != element.closest("turbo-frame") : false;
      } else {
        return false;
      }
    }
    #findFrameElement(element, submitter) {
      const id = submitter?.getAttribute("data-turbo-frame") || element.getAttribute("data-turbo-frame");
      if (id && id != "_top") {
        const frame = this.element.querySelector(`#${id}:not([disabled])`);
        if (frame instanceof FrameElement) {
          return frame;
        }
      }
    }
  };
  var History = class {
    static {
      __name(this, "History");
    }
    location;
    restorationIdentifier = uuid();
    restorationData = {};
    started = false;
    pageLoaded = false;
    currentIndex = 0;
    constructor(delegate) {
      this.delegate = delegate;
    }
    start() {
      if (!this.started) {
        addEventListener("popstate", this.onPopState, false);
        addEventListener("load", this.onPageLoad, false);
        this.currentIndex = history.state?.turbo?.restorationIndex || 0;
        this.started = true;
        this.replace(new URL(window.location.href));
      }
    }
    stop() {
      if (this.started) {
        removeEventListener("popstate", this.onPopState, false);
        removeEventListener("load", this.onPageLoad, false);
        this.started = false;
      }
    }
    push(location2, restorationIdentifier) {
      this.update(history.pushState, location2, restorationIdentifier);
    }
    replace(location2, restorationIdentifier) {
      this.update(history.replaceState, location2, restorationIdentifier);
    }
    update(method, location2, restorationIdentifier = uuid()) {
      if (method === history.pushState)
        ++this.currentIndex;
      const state = { turbo: { restorationIdentifier, restorationIndex: this.currentIndex } };
      method.call(history, state, "", location2.href);
      this.location = location2;
      this.restorationIdentifier = restorationIdentifier;
    }
    // Restoration data
    getRestorationDataForIdentifier(restorationIdentifier) {
      return this.restorationData[restorationIdentifier] || {};
    }
    updateRestorationData(additionalData) {
      const { restorationIdentifier } = this;
      const restorationData = this.restorationData[restorationIdentifier];
      this.restorationData[restorationIdentifier] = {
        ...restorationData,
        ...additionalData
      };
    }
    // Scroll restoration
    assumeControlOfScrollRestoration() {
      if (!this.previousScrollRestoration) {
        this.previousScrollRestoration = history.scrollRestoration ?? "auto";
        history.scrollRestoration = "manual";
      }
    }
    relinquishControlOfScrollRestoration() {
      if (this.previousScrollRestoration) {
        history.scrollRestoration = this.previousScrollRestoration;
        delete this.previousScrollRestoration;
      }
    }
    // Event handlers
    onPopState = (event) => {
      if (this.shouldHandlePopState()) {
        const { turbo } = event.state || {};
        if (turbo) {
          this.location = new URL(window.location.href);
          const { restorationIdentifier, restorationIndex } = turbo;
          this.restorationIdentifier = restorationIdentifier;
          const direction = restorationIndex > this.currentIndex ? "forward" : "back";
          this.delegate.historyPoppedToLocationWithRestorationIdentifierAndDirection(this.location, restorationIdentifier, direction);
          this.currentIndex = restorationIndex;
        }
      }
    };
    onPageLoad = async (_event) => {
      await nextMicrotask();
      this.pageLoaded = true;
    };
    // Private
    shouldHandlePopState() {
      return this.pageIsLoaded();
    }
    pageIsLoaded() {
      return this.pageLoaded || document.readyState == "complete";
    }
  };
  var LinkPrefetchObserver = class {
    static {
      __name(this, "LinkPrefetchObserver");
    }
    started = false;
    #prefetchedLink = null;
    constructor(delegate, eventTarget) {
      this.delegate = delegate;
      this.eventTarget = eventTarget;
    }
    start() {
      if (this.started)
        return;
      if (this.eventTarget.readyState === "loading") {
        this.eventTarget.addEventListener("DOMContentLoaded", this.#enable, { once: true });
      } else {
        this.#enable();
      }
    }
    stop() {
      if (!this.started)
        return;
      this.eventTarget.removeEventListener("mouseenter", this.#tryToPrefetchRequest, {
        capture: true,
        passive: true
      });
      this.eventTarget.removeEventListener("mouseleave", this.#cancelRequestIfObsolete, {
        capture: true,
        passive: true
      });
      this.eventTarget.removeEventListener("turbo:before-fetch-request", this.#tryToUsePrefetchedRequest, true);
      this.started = false;
    }
    #enable = () => {
      this.eventTarget.addEventListener("mouseenter", this.#tryToPrefetchRequest, {
        capture: true,
        passive: true
      });
      this.eventTarget.addEventListener("mouseleave", this.#cancelRequestIfObsolete, {
        capture: true,
        passive: true
      });
      this.eventTarget.addEventListener("turbo:before-fetch-request", this.#tryToUsePrefetchedRequest, true);
      this.started = true;
    };
    #tryToPrefetchRequest = (event) => {
      if (getMetaContent("turbo-prefetch") === "false")
        return;
      const target = event.target;
      const isLink = target.matches && target.matches("a[href]:not([target^=_]):not([download])");
      if (isLink && this.#isPrefetchable(target)) {
        const link = target;
        const location2 = getLocationForLink(link);
        if (this.delegate.canPrefetchRequestToLocation(link, location2)) {
          this.#prefetchedLink = link;
          const fetchRequest = new FetchRequest(
            this,
            FetchMethod.get,
            location2,
            new URLSearchParams(),
            target
          );
          prefetchCache.setLater(location2.toString(), fetchRequest, this.#cacheTtl);
        }
      }
    };
    #cancelRequestIfObsolete = (event) => {
      if (event.target === this.#prefetchedLink)
        this.#cancelPrefetchRequest();
    };
    #cancelPrefetchRequest = () => {
      prefetchCache.clear();
      this.#prefetchedLink = null;
    };
    #tryToUsePrefetchedRequest = (event) => {
      if (event.target.tagName !== "FORM" && event.detail.fetchOptions.method === "get") {
        const cached = prefetchCache.get(event.detail.url.toString());
        if (cached) {
          event.detail.fetchRequest = cached;
        }
        prefetchCache.clear();
      }
    };
    prepareRequest(request) {
      const link = request.target;
      request.headers["X-Sec-Purpose"] = "prefetch";
      const turboFrame = link.closest("turbo-frame");
      const turboFrameTarget = link.getAttribute("data-turbo-frame") || turboFrame?.getAttribute("target") || turboFrame?.id;
      if (turboFrameTarget && turboFrameTarget !== "_top") {
        request.headers["Turbo-Frame"] = turboFrameTarget;
      }
    }
    // Fetch request interface
    requestSucceededWithResponse() {
    }
    requestStarted(fetchRequest) {
    }
    requestErrored(fetchRequest) {
    }
    requestFinished(fetchRequest) {
    }
    requestPreventedHandlingResponse(fetchRequest, fetchResponse) {
    }
    requestFailedWithResponse(fetchRequest, fetchResponse) {
    }
    get #cacheTtl() {
      return Number(getMetaContent("turbo-prefetch-cache-time")) || cacheTtl;
    }
    #isPrefetchable(link) {
      const href = link.getAttribute("href");
      if (!href)
        return false;
      if (unfetchableLink(link))
        return false;
      if (linkToTheSamePage(link))
        return false;
      if (linkOptsOut(link))
        return false;
      if (nonSafeLink(link))
        return false;
      if (eventPrevented(link))
        return false;
      return true;
    }
  };
  var unfetchableLink = /* @__PURE__ */ __name((link) => {
    return link.origin !== document.location.origin || !["http:", "https:"].includes(link.protocol) || link.hasAttribute("target");
  }, "unfetchableLink");
  var linkToTheSamePage = /* @__PURE__ */ __name((link) => {
    return link.pathname + link.search === document.location.pathname + document.location.search || link.href.startsWith("#");
  }, "linkToTheSamePage");
  var linkOptsOut = /* @__PURE__ */ __name((link) => {
    if (link.getAttribute("data-turbo-prefetch") === "false")
      return true;
    if (link.getAttribute("data-turbo") === "false")
      return true;
    const turboPrefetchParent = findClosestRecursively(link, "[data-turbo-prefetch]");
    if (turboPrefetchParent && turboPrefetchParent.getAttribute("data-turbo-prefetch") === "false")
      return true;
    return false;
  }, "linkOptsOut");
  var nonSafeLink = /* @__PURE__ */ __name((link) => {
    const turboMethod = link.getAttribute("data-turbo-method");
    if (turboMethod && turboMethod.toLowerCase() !== "get")
      return true;
    if (isUJS(link))
      return true;
    if (link.hasAttribute("data-turbo-confirm"))
      return true;
    if (link.hasAttribute("data-turbo-stream"))
      return true;
    return false;
  }, "nonSafeLink");
  var isUJS = /* @__PURE__ */ __name((link) => {
    return link.hasAttribute("data-remote") || link.hasAttribute("data-behavior") || link.hasAttribute("data-confirm") || link.hasAttribute("data-method");
  }, "isUJS");
  var eventPrevented = /* @__PURE__ */ __name((link) => {
    const event = dispatch("turbo:before-prefetch", { target: link, cancelable: true });
    return event.defaultPrevented;
  }, "eventPrevented");
  var Navigator = class {
    static {
      __name(this, "Navigator");
    }
    constructor(delegate) {
      this.delegate = delegate;
    }
    proposeVisit(location2, options = {}) {
      if (this.delegate.allowsVisitingLocationWithAction(location2, options.action)) {
        this.delegate.visitProposedToLocation(location2, options);
      }
    }
    startVisit(locatable, restorationIdentifier, options = {}) {
      this.stop();
      this.currentVisit = new Visit(this, expandURL(locatable), restorationIdentifier, {
        referrer: this.location,
        ...options
      });
      this.currentVisit.start();
    }
    submitForm(form, submitter) {
      this.stop();
      this.formSubmission = new FormSubmission(this, form, submitter, true);
      this.formSubmission.start();
    }
    stop() {
      if (this.formSubmission) {
        this.formSubmission.stop();
        delete this.formSubmission;
      }
      if (this.currentVisit) {
        this.currentVisit.cancel();
        delete this.currentVisit;
      }
    }
    get adapter() {
      return this.delegate.adapter;
    }
    get view() {
      return this.delegate.view;
    }
    get rootLocation() {
      return this.view.snapshot.rootLocation;
    }
    get history() {
      return this.delegate.history;
    }
    // Form submission delegate
    formSubmissionStarted(formSubmission) {
      if (typeof this.adapter.formSubmissionStarted === "function") {
        this.adapter.formSubmissionStarted(formSubmission);
      }
    }
    async formSubmissionSucceededWithResponse(formSubmission, fetchResponse) {
      if (formSubmission == this.formSubmission) {
        const responseHTML = await fetchResponse.responseHTML;
        if (responseHTML) {
          const shouldCacheSnapshot = formSubmission.isSafe;
          if (!shouldCacheSnapshot) {
            this.view.clearSnapshotCache();
          }
          const { statusCode, redirected } = fetchResponse;
          const action = this.#getActionForFormSubmission(formSubmission, fetchResponse);
          const visitOptions = {
            action,
            shouldCacheSnapshot,
            response: { statusCode, responseHTML, redirected }
          };
          this.proposeVisit(fetchResponse.location, visitOptions);
        }
      }
    }
    async formSubmissionFailedWithResponse(formSubmission, fetchResponse) {
      const responseHTML = await fetchResponse.responseHTML;
      if (responseHTML) {
        const snapshot = PageSnapshot.fromHTMLString(responseHTML);
        if (fetchResponse.serverError) {
          await this.view.renderError(snapshot, this.currentVisit);
        } else {
          await this.view.renderPage(snapshot, false, true, this.currentVisit);
        }
        if (!snapshot.shouldPreserveScrollPosition) {
          this.view.scrollToTop();
        }
        this.view.clearSnapshotCache();
      }
    }
    formSubmissionErrored(formSubmission, error) {
      console.error(error);
    }
    formSubmissionFinished(formSubmission) {
      if (typeof this.adapter.formSubmissionFinished === "function") {
        this.adapter.formSubmissionFinished(formSubmission);
      }
    }
    // Visit delegate
    visitStarted(visit2) {
      this.delegate.visitStarted(visit2);
    }
    visitCompleted(visit2) {
      this.delegate.visitCompleted(visit2);
    }
    locationWithActionIsSamePage(location2, action) {
      const anchor = getAnchor(location2);
      const currentAnchor = getAnchor(this.view.lastRenderedLocation);
      const isRestorationToTop = action === "restore" && typeof anchor === "undefined";
      return action !== "replace" && getRequestURL(location2) === getRequestURL(this.view.lastRenderedLocation) && (isRestorationToTop || anchor != null && anchor !== currentAnchor);
    }
    visitScrolledToSamePageLocation(oldURL, newURL) {
      this.delegate.visitScrolledToSamePageLocation(oldURL, newURL);
    }
    // Visits
    get location() {
      return this.history.location;
    }
    get restorationIdentifier() {
      return this.history.restorationIdentifier;
    }
    #getActionForFormSubmission(formSubmission, fetchResponse) {
      const { submitter, formElement } = formSubmission;
      return getVisitAction(submitter, formElement) || this.#getDefaultAction(fetchResponse);
    }
    #getDefaultAction(fetchResponse) {
      const sameLocationRedirect = fetchResponse.redirected && fetchResponse.location.href === this.location?.href;
      return sameLocationRedirect ? "replace" : "advance";
    }
  };
  var PageStage = {
    initial: 0,
    loading: 1,
    interactive: 2,
    complete: 3
  };
  var PageObserver = class {
    static {
      __name(this, "PageObserver");
    }
    stage = PageStage.initial;
    started = false;
    constructor(delegate) {
      this.delegate = delegate;
    }
    start() {
      if (!this.started) {
        if (this.stage == PageStage.initial) {
          this.stage = PageStage.loading;
        }
        document.addEventListener("readystatechange", this.interpretReadyState, false);
        addEventListener("pagehide", this.pageWillUnload, false);
        this.started = true;
      }
    }
    stop() {
      if (this.started) {
        document.removeEventListener("readystatechange", this.interpretReadyState, false);
        removeEventListener("pagehide", this.pageWillUnload, false);
        this.started = false;
      }
    }
    interpretReadyState = () => {
      const { readyState } = this;
      if (readyState == "interactive") {
        this.pageIsInteractive();
      } else if (readyState == "complete") {
        this.pageIsComplete();
      }
    };
    pageIsInteractive() {
      if (this.stage == PageStage.loading) {
        this.stage = PageStage.interactive;
        this.delegate.pageBecameInteractive();
      }
    }
    pageIsComplete() {
      this.pageIsInteractive();
      if (this.stage == PageStage.interactive) {
        this.stage = PageStage.complete;
        this.delegate.pageLoaded();
      }
    }
    pageWillUnload = () => {
      this.delegate.pageWillUnload();
    };
    get readyState() {
      return document.readyState;
    }
  };
  var ScrollObserver = class {
    static {
      __name(this, "ScrollObserver");
    }
    started = false;
    constructor(delegate) {
      this.delegate = delegate;
    }
    start() {
      if (!this.started) {
        addEventListener("scroll", this.onScroll, false);
        this.onScroll();
        this.started = true;
      }
    }
    stop() {
      if (this.started) {
        removeEventListener("scroll", this.onScroll, false);
        this.started = false;
      }
    }
    onScroll = () => {
      this.updatePosition({ x: window.pageXOffset, y: window.pageYOffset });
    };
    // Private
    updatePosition(position) {
      this.delegate.scrollPositionChanged(position);
    }
  };
  var StreamMessageRenderer = class {
    static {
      __name(this, "StreamMessageRenderer");
    }
    render({ fragment }) {
      Bardo.preservingPermanentElements(this, getPermanentElementMapForFragment(fragment), () => {
        withAutofocusFromFragment(fragment, () => {
          withPreservedFocus(() => {
            document.documentElement.appendChild(fragment);
          });
        });
      });
    }
    // Bardo delegate
    enteringBardo(currentPermanentElement, newPermanentElement) {
      newPermanentElement.replaceWith(currentPermanentElement.cloneNode(true));
    }
    leavingBardo() {
    }
  };
  function getPermanentElementMapForFragment(fragment) {
    const permanentElementsInDocument = queryPermanentElementsAll(document.documentElement);
    const permanentElementMap = {};
    for (const permanentElementInDocument of permanentElementsInDocument) {
      const { id } = permanentElementInDocument;
      for (const streamElement of fragment.querySelectorAll("turbo-stream")) {
        const elementInStream = getPermanentElementById(streamElement.templateElement.content, id);
        if (elementInStream) {
          permanentElementMap[id] = [permanentElementInDocument, elementInStream];
        }
      }
    }
    return permanentElementMap;
  }
  __name(getPermanentElementMapForFragment, "getPermanentElementMapForFragment");
  async function withAutofocusFromFragment(fragment, callback) {
    const generatedID = `turbo-stream-autofocus-${uuid()}`;
    const turboStreams = fragment.querySelectorAll("turbo-stream");
    const elementWithAutofocus = firstAutofocusableElementInStreams(turboStreams);
    let willAutofocusId = null;
    if (elementWithAutofocus) {
      if (elementWithAutofocus.id) {
        willAutofocusId = elementWithAutofocus.id;
      } else {
        willAutofocusId = generatedID;
      }
      elementWithAutofocus.id = willAutofocusId;
    }
    callback();
    await nextRepaint();
    const hasNoActiveElement = document.activeElement == null || document.activeElement == document.body;
    if (hasNoActiveElement && willAutofocusId) {
      const elementToAutofocus = document.getElementById(willAutofocusId);
      if (elementIsFocusable(elementToAutofocus)) {
        elementToAutofocus.focus();
      }
      if (elementToAutofocus && elementToAutofocus.id == generatedID) {
        elementToAutofocus.removeAttribute("id");
      }
    }
  }
  __name(withAutofocusFromFragment, "withAutofocusFromFragment");
  async function withPreservedFocus(callback) {
    const [activeElementBeforeRender, activeElementAfterRender] = await around(callback, () => document.activeElement);
    const restoreFocusTo = activeElementBeforeRender && activeElementBeforeRender.id;
    if (restoreFocusTo) {
      const elementToFocus = document.getElementById(restoreFocusTo);
      if (elementIsFocusable(elementToFocus) && elementToFocus != activeElementAfterRender) {
        elementToFocus.focus();
      }
    }
  }
  __name(withPreservedFocus, "withPreservedFocus");
  function firstAutofocusableElementInStreams(nodeListOfStreamElements) {
    for (const streamElement of nodeListOfStreamElements) {
      const elementWithAutofocus = queryAutofocusableElement(streamElement.templateElement.content);
      if (elementWithAutofocus)
        return elementWithAutofocus;
    }
    return null;
  }
  __name(firstAutofocusableElementInStreams, "firstAutofocusableElementInStreams");
  var StreamObserver = class {
    static {
      __name(this, "StreamObserver");
    }
    sources = /* @__PURE__ */ new Set();
    #started = false;
    constructor(delegate) {
      this.delegate = delegate;
    }
    start() {
      if (!this.#started) {
        this.#started = true;
        addEventListener("turbo:before-fetch-response", this.inspectFetchResponse, false);
      }
    }
    stop() {
      if (this.#started) {
        this.#started = false;
        removeEventListener("turbo:before-fetch-response", this.inspectFetchResponse, false);
      }
    }
    connectStreamSource(source) {
      if (!this.streamSourceIsConnected(source)) {
        this.sources.add(source);
        source.addEventListener("message", this.receiveMessageEvent, false);
      }
    }
    disconnectStreamSource(source) {
      if (this.streamSourceIsConnected(source)) {
        this.sources.delete(source);
        source.removeEventListener("message", this.receiveMessageEvent, false);
      }
    }
    streamSourceIsConnected(source) {
      return this.sources.has(source);
    }
    inspectFetchResponse = (event) => {
      const response = fetchResponseFromEvent(event);
      if (response && fetchResponseIsStream(response)) {
        event.preventDefault();
        this.receiveMessageResponse(response);
      }
    };
    receiveMessageEvent = (event) => {
      if (this.#started && typeof event.data == "string") {
        this.receiveMessageHTML(event.data);
      }
    };
    async receiveMessageResponse(response) {
      const html = await response.responseHTML;
      if (html) {
        this.receiveMessageHTML(html);
      }
    }
    receiveMessageHTML(html) {
      this.delegate.receivedMessageFromStream(StreamMessage.wrap(html));
    }
  };
  function fetchResponseFromEvent(event) {
    const fetchResponse = event.detail?.fetchResponse;
    if (fetchResponse instanceof FetchResponse) {
      return fetchResponse;
    }
  }
  __name(fetchResponseFromEvent, "fetchResponseFromEvent");
  function fetchResponseIsStream(response) {
    const contentType = response.contentType ?? "";
    return contentType.startsWith(StreamMessage.contentType);
  }
  __name(fetchResponseIsStream, "fetchResponseIsStream");
  var ErrorRenderer = class extends Renderer {
    static {
      __name(this, "ErrorRenderer");
    }
    static renderElement(currentElement, newElement) {
      const { documentElement, body } = document;
      documentElement.replaceChild(newElement, body);
    }
    async render() {
      this.replaceHeadAndBody();
      this.activateScriptElements();
    }
    replaceHeadAndBody() {
      const { documentElement, head } = document;
      documentElement.replaceChild(this.newHead, head);
      this.renderElement(this.currentElement, this.newElement);
    }
    activateScriptElements() {
      for (const replaceableElement of this.scriptElements) {
        const parentNode = replaceableElement.parentNode;
        if (parentNode) {
          const element = activateScriptElement(replaceableElement);
          parentNode.replaceChild(element, replaceableElement);
        }
      }
    }
    get newHead() {
      return this.newSnapshot.headSnapshot.element;
    }
    get scriptElements() {
      return document.documentElement.querySelectorAll("script");
    }
  };
  var Idiomorph = /* @__PURE__ */ function() {
    let EMPTY_SET = /* @__PURE__ */ new Set();
    let defaults2 = {
      morphStyle: "outerHTML",
      callbacks: {
        beforeNodeAdded: noOp,
        afterNodeAdded: noOp,
        beforeNodeMorphed: noOp,
        afterNodeMorphed: noOp,
        beforeNodeRemoved: noOp,
        afterNodeRemoved: noOp,
        beforeAttributeUpdated: noOp
      },
      head: {
        style: "merge",
        shouldPreserve: function(elt) {
          return elt.getAttribute("im-preserve") === "true";
        },
        shouldReAppend: function(elt) {
          return elt.getAttribute("im-re-append") === "true";
        },
        shouldRemove: noOp,
        afterHeadMorphed: noOp
      }
    };
    function morph(oldNode, newContent, config4 = {}) {
      if (oldNode instanceof Document) {
        oldNode = oldNode.documentElement;
      }
      if (typeof newContent === "string") {
        newContent = parseContent(newContent);
      }
      let normalizedContent = normalizeContent(newContent);
      let ctx = createMorphContext(oldNode, normalizedContent, config4);
      return morphNormalizedContent(oldNode, normalizedContent, ctx);
    }
    __name(morph, "morph");
    function morphNormalizedContent(oldNode, normalizedNewContent, ctx) {
      if (ctx.head.block) {
        let oldHead = oldNode.querySelector("head");
        let newHead = normalizedNewContent.querySelector("head");
        if (oldHead && newHead) {
          let promises = handleHeadElement(newHead, oldHead, ctx);
          Promise.all(promises).then(function() {
            morphNormalizedContent(oldNode, normalizedNewContent, Object.assign(ctx, {
              head: {
                block: false,
                ignore: true
              }
            }));
          });
          return;
        }
      }
      if (ctx.morphStyle === "innerHTML") {
        morphChildren(normalizedNewContent, oldNode, ctx);
        return oldNode.children;
      } else if (ctx.morphStyle === "outerHTML" || ctx.morphStyle == null) {
        let bestMatch = findBestNodeMatch(normalizedNewContent, oldNode, ctx);
        let previousSibling = bestMatch?.previousSibling;
        let nextSibling = bestMatch?.nextSibling;
        let morphedNode = morphOldNodeTo(oldNode, bestMatch, ctx);
        if (bestMatch) {
          return insertSiblings(previousSibling, morphedNode, nextSibling);
        } else {
          return [];
        }
      } else {
        throw "Do not understand how to morph style " + ctx.morphStyle;
      }
    }
    __name(morphNormalizedContent, "morphNormalizedContent");
    function ignoreValueOfActiveElement(possibleActiveElement, ctx) {
      return ctx.ignoreActiveValue && possibleActiveElement === document.activeElement && possibleActiveElement !== document.body;
    }
    __name(ignoreValueOfActiveElement, "ignoreValueOfActiveElement");
    function morphOldNodeTo(oldNode, newContent, ctx) {
      if (ctx.ignoreActive && oldNode === document.activeElement)
        ;
      else if (newContent == null) {
        if (ctx.callbacks.beforeNodeRemoved(oldNode) === false)
          return oldNode;
        oldNode.remove();
        ctx.callbacks.afterNodeRemoved(oldNode);
        return null;
      } else if (!isSoftMatch(oldNode, newContent)) {
        if (ctx.callbacks.beforeNodeRemoved(oldNode) === false)
          return oldNode;
        if (ctx.callbacks.beforeNodeAdded(newContent) === false)
          return oldNode;
        oldNode.parentElement.replaceChild(newContent, oldNode);
        ctx.callbacks.afterNodeAdded(newContent);
        ctx.callbacks.afterNodeRemoved(oldNode);
        return newContent;
      } else {
        if (ctx.callbacks.beforeNodeMorphed(oldNode, newContent) === false)
          return oldNode;
        if (oldNode instanceof HTMLHeadElement && ctx.head.ignore)
          ;
        else if (oldNode instanceof HTMLHeadElement && ctx.head.style !== "morph") {
          handleHeadElement(newContent, oldNode, ctx);
        } else {
          syncNodeFrom(newContent, oldNode, ctx);
          if (!ignoreValueOfActiveElement(oldNode, ctx)) {
            morphChildren(newContent, oldNode, ctx);
          }
        }
        ctx.callbacks.afterNodeMorphed(oldNode, newContent);
        return oldNode;
      }
    }
    __name(morphOldNodeTo, "morphOldNodeTo");
    function morphChildren(newParent, oldParent, ctx) {
      let nextNewChild = newParent.firstChild;
      let insertionPoint = oldParent.firstChild;
      let newChild;
      while (nextNewChild) {
        newChild = nextNewChild;
        nextNewChild = newChild.nextSibling;
        if (insertionPoint == null) {
          if (ctx.callbacks.beforeNodeAdded(newChild) === false)
            return;
          oldParent.appendChild(newChild);
          ctx.callbacks.afterNodeAdded(newChild);
          removeIdsFromConsideration(ctx, newChild);
          continue;
        }
        if (isIdSetMatch(newChild, insertionPoint, ctx)) {
          morphOldNodeTo(insertionPoint, newChild, ctx);
          insertionPoint = insertionPoint.nextSibling;
          removeIdsFromConsideration(ctx, newChild);
          continue;
        }
        let idSetMatch = findIdSetMatch(newParent, oldParent, newChild, insertionPoint, ctx);
        if (idSetMatch) {
          insertionPoint = removeNodesBetween(insertionPoint, idSetMatch, ctx);
          morphOldNodeTo(idSetMatch, newChild, ctx);
          removeIdsFromConsideration(ctx, newChild);
          continue;
        }
        let softMatch = findSoftMatch(newParent, oldParent, newChild, insertionPoint, ctx);
        if (softMatch) {
          insertionPoint = removeNodesBetween(insertionPoint, softMatch, ctx);
          morphOldNodeTo(softMatch, newChild, ctx);
          removeIdsFromConsideration(ctx, newChild);
          continue;
        }
        if (ctx.callbacks.beforeNodeAdded(newChild) === false)
          return;
        oldParent.insertBefore(newChild, insertionPoint);
        ctx.callbacks.afterNodeAdded(newChild);
        removeIdsFromConsideration(ctx, newChild);
      }
      while (insertionPoint !== null) {
        let tempNode = insertionPoint;
        insertionPoint = insertionPoint.nextSibling;
        removeNode(tempNode, ctx);
      }
    }
    __name(morphChildren, "morphChildren");
    function ignoreAttribute(attr, to, updateType, ctx) {
      if (attr === "value" && ctx.ignoreActiveValue && to === document.activeElement) {
        return true;
      }
      return ctx.callbacks.beforeAttributeUpdated(attr, to, updateType) === false;
    }
    __name(ignoreAttribute, "ignoreAttribute");
    function syncNodeFrom(from, to, ctx) {
      let type = from.nodeType;
      if (type === 1) {
        const fromAttributes = from.attributes;
        const toAttributes = to.attributes;
        for (const fromAttribute of fromAttributes) {
          if (ignoreAttribute(fromAttribute.name, to, "update", ctx)) {
            continue;
          }
          if (to.getAttribute(fromAttribute.name) !== fromAttribute.value) {
            to.setAttribute(fromAttribute.name, fromAttribute.value);
          }
        }
        for (let i2 = toAttributes.length - 1; 0 <= i2; i2--) {
          const toAttribute = toAttributes[i2];
          if (ignoreAttribute(toAttribute.name, to, "remove", ctx)) {
            continue;
          }
          if (!from.hasAttribute(toAttribute.name)) {
            to.removeAttribute(toAttribute.name);
          }
        }
      }
      if (type === 8 || type === 3) {
        if (to.nodeValue !== from.nodeValue) {
          to.nodeValue = from.nodeValue;
        }
      }
      if (!ignoreValueOfActiveElement(to, ctx)) {
        syncInputValue(from, to, ctx);
      }
    }
    __name(syncNodeFrom, "syncNodeFrom");
    function syncBooleanAttribute(from, to, attributeName, ctx) {
      if (from[attributeName] !== to[attributeName]) {
        let ignoreUpdate = ignoreAttribute(attributeName, to, "update", ctx);
        if (!ignoreUpdate) {
          to[attributeName] = from[attributeName];
        }
        if (from[attributeName]) {
          if (!ignoreUpdate) {
            to.setAttribute(attributeName, from[attributeName]);
          }
        } else {
          if (!ignoreAttribute(attributeName, to, "remove", ctx)) {
            to.removeAttribute(attributeName);
          }
        }
      }
    }
    __name(syncBooleanAttribute, "syncBooleanAttribute");
    function syncInputValue(from, to, ctx) {
      if (from instanceof HTMLInputElement && to instanceof HTMLInputElement && from.type !== "file") {
        let fromValue = from.value;
        let toValue = to.value;
        syncBooleanAttribute(from, to, "checked", ctx);
        syncBooleanAttribute(from, to, "disabled", ctx);
        if (!from.hasAttribute("value")) {
          if (!ignoreAttribute("value", to, "remove", ctx)) {
            to.value = "";
            to.removeAttribute("value");
          }
        } else if (fromValue !== toValue) {
          if (!ignoreAttribute("value", to, "update", ctx)) {
            to.setAttribute("value", fromValue);
            to.value = fromValue;
          }
        }
      } else if (from instanceof HTMLOptionElement) {
        syncBooleanAttribute(from, to, "selected", ctx);
      } else if (from instanceof HTMLTextAreaElement && to instanceof HTMLTextAreaElement) {
        let fromValue = from.value;
        let toValue = to.value;
        if (ignoreAttribute("value", to, "update", ctx)) {
          return;
        }
        if (fromValue !== toValue) {
          to.value = fromValue;
        }
        if (to.firstChild && to.firstChild.nodeValue !== fromValue) {
          to.firstChild.nodeValue = fromValue;
        }
      }
    }
    __name(syncInputValue, "syncInputValue");
    function handleHeadElement(newHeadTag, currentHead, ctx) {
      let added = [];
      let removed = [];
      let preserved = [];
      let nodesToAppend = [];
      let headMergeStyle = ctx.head.style;
      let srcToNewHeadNodes = /* @__PURE__ */ new Map();
      for (const newHeadChild of newHeadTag.children) {
        srcToNewHeadNodes.set(newHeadChild.outerHTML, newHeadChild);
      }
      for (const currentHeadElt of currentHead.children) {
        let inNewContent = srcToNewHeadNodes.has(currentHeadElt.outerHTML);
        let isReAppended = ctx.head.shouldReAppend(currentHeadElt);
        let isPreserved = ctx.head.shouldPreserve(currentHeadElt);
        if (inNewContent || isPreserved) {
          if (isReAppended) {
            removed.push(currentHeadElt);
          } else {
            srcToNewHeadNodes.delete(currentHeadElt.outerHTML);
            preserved.push(currentHeadElt);
          }
        } else {
          if (headMergeStyle === "append") {
            if (isReAppended) {
              removed.push(currentHeadElt);
              nodesToAppend.push(currentHeadElt);
            }
          } else {
            if (ctx.head.shouldRemove(currentHeadElt) !== false) {
              removed.push(currentHeadElt);
            }
          }
        }
      }
      nodesToAppend.push(...srcToNewHeadNodes.values());
      let promises = [];
      for (const newNode of nodesToAppend) {
        let newElt = document.createRange().createContextualFragment(newNode.outerHTML).firstChild;
        if (ctx.callbacks.beforeNodeAdded(newElt) !== false) {
          if (newElt.href || newElt.src) {
            let resolve = null;
            let promise = new Promise(function(_resolve) {
              resolve = _resolve;
            });
            newElt.addEventListener("load", function() {
              resolve();
            });
            promises.push(promise);
          }
          currentHead.appendChild(newElt);
          ctx.callbacks.afterNodeAdded(newElt);
          added.push(newElt);
        }
      }
      for (const removedElement of removed) {
        if (ctx.callbacks.beforeNodeRemoved(removedElement) !== false) {
          currentHead.removeChild(removedElement);
          ctx.callbacks.afterNodeRemoved(removedElement);
        }
      }
      ctx.head.afterHeadMorphed(currentHead, { added, kept: preserved, removed });
      return promises;
    }
    __name(handleHeadElement, "handleHeadElement");
    function noOp() {
    }
    __name(noOp, "noOp");
    function mergeDefaults(config4) {
      let finalConfig = {};
      Object.assign(finalConfig, defaults2);
      Object.assign(finalConfig, config4);
      finalConfig.callbacks = {};
      Object.assign(finalConfig.callbacks, defaults2.callbacks);
      Object.assign(finalConfig.callbacks, config4.callbacks);
      finalConfig.head = {};
      Object.assign(finalConfig.head, defaults2.head);
      Object.assign(finalConfig.head, config4.head);
      return finalConfig;
    }
    __name(mergeDefaults, "mergeDefaults");
    function createMorphContext(oldNode, newContent, config4) {
      config4 = mergeDefaults(config4);
      return {
        target: oldNode,
        newContent,
        config: config4,
        morphStyle: config4.morphStyle,
        ignoreActive: config4.ignoreActive,
        ignoreActiveValue: config4.ignoreActiveValue,
        idMap: createIdMap(oldNode, newContent),
        deadIds: /* @__PURE__ */ new Set(),
        callbacks: config4.callbacks,
        head: config4.head
      };
    }
    __name(createMorphContext, "createMorphContext");
    function isIdSetMatch(node1, node2, ctx) {
      if (node1 == null || node2 == null) {
        return false;
      }
      if (node1.nodeType === node2.nodeType && node1.tagName === node2.tagName) {
        if (node1.id !== "" && node1.id === node2.id) {
          return true;
        } else {
          return getIdIntersectionCount(ctx, node1, node2) > 0;
        }
      }
      return false;
    }
    __name(isIdSetMatch, "isIdSetMatch");
    function isSoftMatch(node1, node2) {
      if (node1 == null || node2 == null) {
        return false;
      }
      return node1.nodeType === node2.nodeType && node1.tagName === node2.tagName;
    }
    __name(isSoftMatch, "isSoftMatch");
    function removeNodesBetween(startInclusive, endExclusive, ctx) {
      while (startInclusive !== endExclusive) {
        let tempNode = startInclusive;
        startInclusive = startInclusive.nextSibling;
        removeNode(tempNode, ctx);
      }
      removeIdsFromConsideration(ctx, endExclusive);
      return endExclusive.nextSibling;
    }
    __name(removeNodesBetween, "removeNodesBetween");
    function findIdSetMatch(newContent, oldParent, newChild, insertionPoint, ctx) {
      let newChildPotentialIdCount = getIdIntersectionCount(ctx, newChild, oldParent);
      let potentialMatch = null;
      if (newChildPotentialIdCount > 0) {
        let potentialMatch2 = insertionPoint;
        let otherMatchCount = 0;
        while (potentialMatch2 != null) {
          if (isIdSetMatch(newChild, potentialMatch2, ctx)) {
            return potentialMatch2;
          }
          otherMatchCount += getIdIntersectionCount(ctx, potentialMatch2, newContent);
          if (otherMatchCount > newChildPotentialIdCount) {
            return null;
          }
          potentialMatch2 = potentialMatch2.nextSibling;
        }
      }
      return potentialMatch;
    }
    __name(findIdSetMatch, "findIdSetMatch");
    function findSoftMatch(newContent, oldParent, newChild, insertionPoint, ctx) {
      let potentialSoftMatch = insertionPoint;
      let nextSibling = newChild.nextSibling;
      let siblingSoftMatchCount = 0;
      while (potentialSoftMatch != null) {
        if (getIdIntersectionCount(ctx, potentialSoftMatch, newContent) > 0) {
          return null;
        }
        if (isSoftMatch(newChild, potentialSoftMatch)) {
          return potentialSoftMatch;
        }
        if (isSoftMatch(nextSibling, potentialSoftMatch)) {
          siblingSoftMatchCount++;
          nextSibling = nextSibling.nextSibling;
          if (siblingSoftMatchCount >= 2) {
            return null;
          }
        }
        potentialSoftMatch = potentialSoftMatch.nextSibling;
      }
      return potentialSoftMatch;
    }
    __name(findSoftMatch, "findSoftMatch");
    function parseContent(newContent) {
      let parser = new DOMParser();
      let contentWithSvgsRemoved = newContent.replace(/<svg(\s[^>]*>|>)([\s\S]*?)<\/svg>/gim, "");
      if (contentWithSvgsRemoved.match(/<\/html>/) || contentWithSvgsRemoved.match(/<\/head>/) || contentWithSvgsRemoved.match(/<\/body>/)) {
        let content = parser.parseFromString(newContent, "text/html");
        if (contentWithSvgsRemoved.match(/<\/html>/)) {
          content.generatedByIdiomorph = true;
          return content;
        } else {
          let htmlElement = content.firstChild;
          if (htmlElement) {
            htmlElement.generatedByIdiomorph = true;
            return htmlElement;
          } else {
            return null;
          }
        }
      } else {
        let responseDoc = parser.parseFromString("<body><template>" + newContent + "</template></body>", "text/html");
        let content = responseDoc.body.querySelector("template").content;
        content.generatedByIdiomorph = true;
        return content;
      }
    }
    __name(parseContent, "parseContent");
    function normalizeContent(newContent) {
      if (newContent == null) {
        const dummyParent = document.createElement("div");
        return dummyParent;
      } else if (newContent.generatedByIdiomorph) {
        return newContent;
      } else if (newContent instanceof Node) {
        const dummyParent = document.createElement("div");
        dummyParent.append(newContent);
        return dummyParent;
      } else {
        const dummyParent = document.createElement("div");
        for (const elt of [...newContent]) {
          dummyParent.append(elt);
        }
        return dummyParent;
      }
    }
    __name(normalizeContent, "normalizeContent");
    function insertSiblings(previousSibling, morphedNode, nextSibling) {
      let stack = [];
      let added = [];
      while (previousSibling != null) {
        stack.push(previousSibling);
        previousSibling = previousSibling.previousSibling;
      }
      while (stack.length > 0) {
        let node = stack.pop();
        added.push(node);
        morphedNode.parentElement.insertBefore(node, morphedNode);
      }
      added.push(morphedNode);
      while (nextSibling != null) {
        stack.push(nextSibling);
        added.push(nextSibling);
        nextSibling = nextSibling.nextSibling;
      }
      while (stack.length > 0) {
        morphedNode.parentElement.insertBefore(stack.pop(), morphedNode.nextSibling);
      }
      return added;
    }
    __name(insertSiblings, "insertSiblings");
    function findBestNodeMatch(newContent, oldNode, ctx) {
      let currentElement;
      currentElement = newContent.firstChild;
      let bestElement = currentElement;
      let score = 0;
      while (currentElement) {
        let newScore = scoreElement(currentElement, oldNode, ctx);
        if (newScore > score) {
          bestElement = currentElement;
          score = newScore;
        }
        currentElement = currentElement.nextSibling;
      }
      return bestElement;
    }
    __name(findBestNodeMatch, "findBestNodeMatch");
    function scoreElement(node1, node2, ctx) {
      if (isSoftMatch(node1, node2)) {
        return 0.5 + getIdIntersectionCount(ctx, node1, node2);
      }
      return 0;
    }
    __name(scoreElement, "scoreElement");
    function removeNode(tempNode, ctx) {
      removeIdsFromConsideration(ctx, tempNode);
      if (ctx.callbacks.beforeNodeRemoved(tempNode) === false)
        return;
      tempNode.remove();
      ctx.callbacks.afterNodeRemoved(tempNode);
    }
    __name(removeNode, "removeNode");
    function isIdInConsideration(ctx, id) {
      return !ctx.deadIds.has(id);
    }
    __name(isIdInConsideration, "isIdInConsideration");
    function idIsWithinNode(ctx, id, targetNode) {
      let idSet = ctx.idMap.get(targetNode) || EMPTY_SET;
      return idSet.has(id);
    }
    __name(idIsWithinNode, "idIsWithinNode");
    function removeIdsFromConsideration(ctx, node) {
      let idSet = ctx.idMap.get(node) || EMPTY_SET;
      for (const id of idSet) {
        ctx.deadIds.add(id);
      }
    }
    __name(removeIdsFromConsideration, "removeIdsFromConsideration");
    function getIdIntersectionCount(ctx, node1, node2) {
      let sourceSet = ctx.idMap.get(node1) || EMPTY_SET;
      let matchCount = 0;
      for (const id of sourceSet) {
        if (isIdInConsideration(ctx, id) && idIsWithinNode(ctx, id, node2)) {
          ++matchCount;
        }
      }
      return matchCount;
    }
    __name(getIdIntersectionCount, "getIdIntersectionCount");
    function populateIdMapForNode(node, idMap) {
      let nodeParent = node.parentElement;
      let idElements = node.querySelectorAll("[id]");
      for (const elt of idElements) {
        let current = elt;
        while (current !== nodeParent && current != null) {
          let idSet = idMap.get(current);
          if (idSet == null) {
            idSet = /* @__PURE__ */ new Set();
            idMap.set(current, idSet);
          }
          idSet.add(elt.id);
          current = current.parentElement;
        }
      }
    }
    __name(populateIdMapForNode, "populateIdMapForNode");
    function createIdMap(oldContent, newContent) {
      let idMap = /* @__PURE__ */ new Map();
      populateIdMapForNode(oldContent, idMap);
      populateIdMapForNode(newContent, idMap);
      return idMap;
    }
    __name(createIdMap, "createIdMap");
    return {
      morph,
      defaults: defaults2
    };
  }();
  var PageRenderer = class extends Renderer {
    static {
      __name(this, "PageRenderer");
    }
    static renderElement(currentElement, newElement) {
      if (document.body && newElement instanceof HTMLBodyElement) {
        document.body.replaceWith(newElement);
      } else {
        document.documentElement.appendChild(newElement);
      }
    }
    get shouldRender() {
      return this.newSnapshot.isVisitable && this.trackedElementsAreIdentical;
    }
    get reloadReason() {
      if (!this.newSnapshot.isVisitable) {
        return {
          reason: "turbo_visit_control_is_reload"
        };
      }
      if (!this.trackedElementsAreIdentical) {
        return {
          reason: "tracked_element_mismatch"
        };
      }
    }
    async prepareToRender() {
      this.#setLanguage();
      await this.mergeHead();
    }
    async render() {
      if (this.willRender) {
        await this.replaceBody();
      }
    }
    finishRendering() {
      super.finishRendering();
      if (!this.isPreview) {
        this.focusFirstAutofocusableElement();
      }
    }
    get currentHeadSnapshot() {
      return this.currentSnapshot.headSnapshot;
    }
    get newHeadSnapshot() {
      return this.newSnapshot.headSnapshot;
    }
    get newElement() {
      return this.newSnapshot.element;
    }
    #setLanguage() {
      const { documentElement } = this.currentSnapshot;
      const { lang } = this.newSnapshot;
      if (lang) {
        documentElement.setAttribute("lang", lang);
      } else {
        documentElement.removeAttribute("lang");
      }
    }
    async mergeHead() {
      const mergedHeadElements = this.mergeProvisionalElements();
      const newStylesheetElements = this.copyNewHeadStylesheetElements();
      this.copyNewHeadScriptElements();
      await mergedHeadElements;
      await newStylesheetElements;
      if (this.willRender) {
        this.removeUnusedDynamicStylesheetElements();
      }
    }
    async replaceBody() {
      await this.preservingPermanentElements(async () => {
        this.activateNewBody();
        await this.assignNewBody();
      });
    }
    get trackedElementsAreIdentical() {
      return this.currentHeadSnapshot.trackedElementSignature == this.newHeadSnapshot.trackedElementSignature;
    }
    async copyNewHeadStylesheetElements() {
      const loadingElements = [];
      for (const element of this.newHeadStylesheetElements) {
        loadingElements.push(waitForLoad(element));
        document.head.appendChild(element);
      }
      await Promise.all(loadingElements);
    }
    copyNewHeadScriptElements() {
      for (const element of this.newHeadScriptElements) {
        document.head.appendChild(activateScriptElement(element));
      }
    }
    removeUnusedDynamicStylesheetElements() {
      for (const element of this.unusedDynamicStylesheetElements) {
        document.head.removeChild(element);
      }
    }
    async mergeProvisionalElements() {
      const newHeadElements = [...this.newHeadProvisionalElements];
      for (const element of this.currentHeadProvisionalElements) {
        if (!this.isCurrentElementInElementList(element, newHeadElements)) {
          document.head.removeChild(element);
        }
      }
      for (const element of newHeadElements) {
        document.head.appendChild(element);
      }
    }
    isCurrentElementInElementList(element, elementList) {
      for (const [index, newElement] of elementList.entries()) {
        if (element.tagName == "TITLE") {
          if (newElement.tagName != "TITLE") {
            continue;
          }
          if (element.innerHTML == newElement.innerHTML) {
            elementList.splice(index, 1);
            return true;
          }
        }
        if (newElement.isEqualNode(element)) {
          elementList.splice(index, 1);
          return true;
        }
      }
      return false;
    }
    removeCurrentHeadProvisionalElements() {
      for (const element of this.currentHeadProvisionalElements) {
        document.head.removeChild(element);
      }
    }
    copyNewHeadProvisionalElements() {
      for (const element of this.newHeadProvisionalElements) {
        document.head.appendChild(element);
      }
    }
    activateNewBody() {
      document.adoptNode(this.newElement);
      this.activateNewBodyScriptElements();
    }
    activateNewBodyScriptElements() {
      for (const inertScriptElement of this.newBodyScriptElements) {
        const activatedScriptElement = activateScriptElement(inertScriptElement);
        inertScriptElement.replaceWith(activatedScriptElement);
      }
    }
    async assignNewBody() {
      await this.renderElement(this.currentElement, this.newElement);
    }
    get unusedDynamicStylesheetElements() {
      return this.oldHeadStylesheetElements.filter((element) => {
        return element.getAttribute("data-turbo-track") === "dynamic";
      });
    }
    get oldHeadStylesheetElements() {
      return this.currentHeadSnapshot.getStylesheetElementsNotInSnapshot(this.newHeadSnapshot);
    }
    get newHeadStylesheetElements() {
      return this.newHeadSnapshot.getStylesheetElementsNotInSnapshot(this.currentHeadSnapshot);
    }
    get newHeadScriptElements() {
      return this.newHeadSnapshot.getScriptElementsNotInSnapshot(this.currentHeadSnapshot);
    }
    get currentHeadProvisionalElements() {
      return this.currentHeadSnapshot.provisionalElements;
    }
    get newHeadProvisionalElements() {
      return this.newHeadSnapshot.provisionalElements;
    }
    get newBodyScriptElements() {
      return this.newElement.querySelectorAll("script");
    }
  };
  var MorphRenderer = class extends PageRenderer {
    static {
      __name(this, "MorphRenderer");
    }
    async render() {
      if (this.willRender)
        await this.#morphBody();
    }
    get renderMethod() {
      return "morph";
    }
    // Private
    async #morphBody() {
      this.#morphElements(this.currentElement, this.newElement);
      this.#reloadRemoteFrames();
      dispatch("turbo:morph", {
        detail: {
          currentElement: this.currentElement,
          newElement: this.newElement
        }
      });
    }
    #morphElements(currentElement, newElement, morphStyle = "outerHTML") {
      this.isMorphingTurboFrame = this.#isFrameReloadedWithMorph(currentElement);
      Idiomorph.morph(currentElement, newElement, {
        morphStyle,
        callbacks: {
          beforeNodeAdded: this.#shouldAddElement,
          beforeNodeMorphed: this.#shouldMorphElement,
          beforeAttributeUpdated: this.#shouldUpdateAttribute,
          beforeNodeRemoved: this.#shouldRemoveElement,
          afterNodeMorphed: this.#didMorphElement
        }
      });
    }
    #shouldAddElement = (node) => {
      return !(node.id && node.hasAttribute("data-turbo-permanent") && document.getElementById(node.id));
    };
    #shouldMorphElement = (oldNode, newNode) => {
      if (oldNode instanceof HTMLElement) {
        if (!oldNode.hasAttribute("data-turbo-permanent") && (this.isMorphingTurboFrame || !this.#isFrameReloadedWithMorph(oldNode))) {
          const event = dispatch("turbo:before-morph-element", {
            cancelable: true,
            target: oldNode,
            detail: {
              newElement: newNode
            }
          });
          return !event.defaultPrevented;
        } else {
          return false;
        }
      }
    };
    #shouldUpdateAttribute = (attributeName, target, mutationType) => {
      const event = dispatch("turbo:before-morph-attribute", { cancelable: true, target, detail: { attributeName, mutationType } });
      return !event.defaultPrevented;
    };
    #didMorphElement = (oldNode, newNode) => {
      if (newNode instanceof HTMLElement) {
        dispatch("turbo:morph-element", {
          target: oldNode,
          detail: {
            newElement: newNode
          }
        });
      }
    };
    #shouldRemoveElement = (node) => {
      return this.#shouldMorphElement(node);
    };
    #reloadRemoteFrames() {
      this.#remoteFrames().forEach((frame) => {
        if (this.#isFrameReloadedWithMorph(frame)) {
          this.#renderFrameWithMorph(frame);
          frame.reload();
        }
      });
    }
    #renderFrameWithMorph(frame) {
      frame.addEventListener("turbo:before-frame-render", (event) => {
        event.detail.render = this.#morphFrameUpdate;
      }, { once: true });
    }
    #morphFrameUpdate = (currentElement, newElement) => {
      dispatch("turbo:before-frame-morph", {
        target: currentElement,
        detail: { currentElement, newElement }
      });
      this.#morphElements(currentElement, newElement.children, "innerHTML");
    };
    #isFrameReloadedWithMorph(element) {
      return element.src && element.refresh === "morph";
    }
    #remoteFrames() {
      return Array.from(document.querySelectorAll("turbo-frame[src]")).filter((frame) => {
        return !frame.closest("[data-turbo-permanent]");
      });
    }
  };
  var SnapshotCache = class {
    static {
      __name(this, "SnapshotCache");
    }
    keys = [];
    snapshots = {};
    constructor(size) {
      this.size = size;
    }
    has(location2) {
      return toCacheKey(location2) in this.snapshots;
    }
    get(location2) {
      if (this.has(location2)) {
        const snapshot = this.read(location2);
        this.touch(location2);
        return snapshot;
      }
    }
    put(location2, snapshot) {
      this.write(location2, snapshot);
      this.touch(location2);
      return snapshot;
    }
    clear() {
      this.snapshots = {};
    }
    // Private
    read(location2) {
      return this.snapshots[toCacheKey(location2)];
    }
    write(location2, snapshot) {
      this.snapshots[toCacheKey(location2)] = snapshot;
    }
    touch(location2) {
      const key = toCacheKey(location2);
      const index = this.keys.indexOf(key);
      if (index > -1)
        this.keys.splice(index, 1);
      this.keys.unshift(key);
      this.trim();
    }
    trim() {
      for (const key of this.keys.splice(this.size)) {
        delete this.snapshots[key];
      }
    }
  };
  var PageView = class extends View {
    static {
      __name(this, "PageView");
    }
    snapshotCache = new SnapshotCache(10);
    lastRenderedLocation = new URL(location.href);
    forceReloaded = false;
    shouldTransitionTo(newSnapshot) {
      return this.snapshot.prefersViewTransitions && newSnapshot.prefersViewTransitions;
    }
    renderPage(snapshot, isPreview = false, willRender = true, visit2) {
      const shouldMorphPage = this.isPageRefresh(visit2) && this.snapshot.shouldMorphPage;
      const rendererClass = shouldMorphPage ? MorphRenderer : PageRenderer;
      const renderer = new rendererClass(this.snapshot, snapshot, PageRenderer.renderElement, isPreview, willRender);
      if (!renderer.shouldRender) {
        this.forceReloaded = true;
      } else {
        visit2?.changeHistory();
      }
      return this.render(renderer);
    }
    renderError(snapshot, visit2) {
      visit2?.changeHistory();
      const renderer = new ErrorRenderer(this.snapshot, snapshot, ErrorRenderer.renderElement, false);
      return this.render(renderer);
    }
    clearSnapshotCache() {
      this.snapshotCache.clear();
    }
    async cacheSnapshot(snapshot = this.snapshot) {
      if (snapshot.isCacheable) {
        this.delegate.viewWillCacheSnapshot();
        const { lastRenderedLocation: location2 } = this;
        await nextEventLoopTick();
        const cachedSnapshot = snapshot.clone();
        this.snapshotCache.put(location2, cachedSnapshot);
        return cachedSnapshot;
      }
    }
    getCachedSnapshotForLocation(location2) {
      return this.snapshotCache.get(location2);
    }
    isPageRefresh(visit2) {
      return !visit2 || this.lastRenderedLocation.pathname === visit2.location.pathname && visit2.action === "replace";
    }
    shouldPreserveScrollPosition(visit2) {
      return this.isPageRefresh(visit2) && this.snapshot.shouldPreserveScrollPosition;
    }
    get snapshot() {
      return PageSnapshot.fromElement(this.element);
    }
  };
  var Preloader = class {
    static {
      __name(this, "Preloader");
    }
    selector = "a[data-turbo-preload]";
    constructor(delegate, snapshotCache) {
      this.delegate = delegate;
      this.snapshotCache = snapshotCache;
    }
    start() {
      if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", this.#preloadAll);
      } else {
        this.preloadOnLoadLinksForView(document.body);
      }
    }
    stop() {
      document.removeEventListener("DOMContentLoaded", this.#preloadAll);
    }
    preloadOnLoadLinksForView(element) {
      for (const link of element.querySelectorAll(this.selector)) {
        if (this.delegate.shouldPreloadLink(link)) {
          this.preloadURL(link);
        }
      }
    }
    async preloadURL(link) {
      const location2 = new URL(link.href);
      if (this.snapshotCache.has(location2)) {
        return;
      }
      const fetchRequest = new FetchRequest(this, FetchMethod.get, location2, new URLSearchParams(), link);
      await fetchRequest.perform();
    }
    // Fetch request delegate
    prepareRequest(fetchRequest) {
      fetchRequest.headers["X-Sec-Purpose"] = "prefetch";
    }
    async requestSucceededWithResponse(fetchRequest, fetchResponse) {
      try {
        const responseHTML = await fetchResponse.responseHTML;
        const snapshot = PageSnapshot.fromHTMLString(responseHTML);
        this.snapshotCache.put(fetchRequest.url, snapshot);
      } catch (_2) {
      }
    }
    requestStarted(fetchRequest) {
    }
    requestErrored(fetchRequest) {
    }
    requestFinished(fetchRequest) {
    }
    requestPreventedHandlingResponse(fetchRequest, fetchResponse) {
    }
    requestFailedWithResponse(fetchRequest, fetchResponse) {
    }
    #preloadAll = () => {
      this.preloadOnLoadLinksForView(document.body);
    };
  };
  var Cache = class {
    static {
      __name(this, "Cache");
    }
    constructor(session2) {
      this.session = session2;
    }
    clear() {
      this.session.clearCache();
    }
    resetCacheControl() {
      this.#setCacheControl("");
    }
    exemptPageFromCache() {
      this.#setCacheControl("no-cache");
    }
    exemptPageFromPreview() {
      this.#setCacheControl("no-preview");
    }
    #setCacheControl(value) {
      setMetaContent("turbo-cache-control", value);
    }
  };
  var Session = class {
    static {
      __name(this, "Session");
    }
    navigator = new Navigator(this);
    history = new History(this);
    view = new PageView(this, document.documentElement);
    adapter = new BrowserAdapter(this);
    pageObserver = new PageObserver(this);
    cacheObserver = new CacheObserver();
    linkPrefetchObserver = new LinkPrefetchObserver(this, document);
    linkClickObserver = new LinkClickObserver(this, window);
    formSubmitObserver = new FormSubmitObserver(this, document);
    scrollObserver = new ScrollObserver(this);
    streamObserver = new StreamObserver(this);
    formLinkClickObserver = new FormLinkClickObserver(this, document.documentElement);
    frameRedirector = new FrameRedirector(this, document.documentElement);
    streamMessageRenderer = new StreamMessageRenderer();
    cache = new Cache(this);
    drive = true;
    enabled = true;
    progressBarDelay = 500;
    started = false;
    formMode = "on";
    #pageRefreshDebouncePeriod = 150;
    constructor(recentRequests2) {
      this.recentRequests = recentRequests2;
      this.preloader = new Preloader(this, this.view.snapshotCache);
      this.debouncedRefresh = this.refresh;
      this.pageRefreshDebouncePeriod = this.pageRefreshDebouncePeriod;
    }
    start() {
      if (!this.started) {
        this.pageObserver.start();
        this.cacheObserver.start();
        this.linkPrefetchObserver.start();
        this.formLinkClickObserver.start();
        this.linkClickObserver.start();
        this.formSubmitObserver.start();
        this.scrollObserver.start();
        this.streamObserver.start();
        this.frameRedirector.start();
        this.history.start();
        this.preloader.start();
        this.started = true;
        this.enabled = true;
      }
    }
    disable() {
      this.enabled = false;
    }
    stop() {
      if (this.started) {
        this.pageObserver.stop();
        this.cacheObserver.stop();
        this.linkPrefetchObserver.stop();
        this.formLinkClickObserver.stop();
        this.linkClickObserver.stop();
        this.formSubmitObserver.stop();
        this.scrollObserver.stop();
        this.streamObserver.stop();
        this.frameRedirector.stop();
        this.history.stop();
        this.preloader.stop();
        this.started = false;
      }
    }
    registerAdapter(adapter) {
      this.adapter = adapter;
    }
    visit(location2, options = {}) {
      const frameElement = options.frame ? document.getElementById(options.frame) : null;
      if (frameElement instanceof FrameElement) {
        const action = options.action || getVisitAction(frameElement);
        frameElement.delegate.proposeVisitIfNavigatedWithAction(frameElement, action);
        frameElement.src = location2.toString();
      } else {
        this.navigator.proposeVisit(expandURL(location2), options);
      }
    }
    refresh(url, requestId) {
      const isRecentRequest = requestId && this.recentRequests.has(requestId);
      if (!isRecentRequest) {
        this.visit(url, { action: "replace", shouldCacheSnapshot: false });
      }
    }
    connectStreamSource(source) {
      this.streamObserver.connectStreamSource(source);
    }
    disconnectStreamSource(source) {
      this.streamObserver.disconnectStreamSource(source);
    }
    renderStreamMessage(message) {
      this.streamMessageRenderer.render(StreamMessage.wrap(message));
    }
    clearCache() {
      this.view.clearSnapshotCache();
    }
    setProgressBarDelay(delay) {
      this.progressBarDelay = delay;
    }
    setFormMode(mode) {
      this.formMode = mode;
    }
    get location() {
      return this.history.location;
    }
    get restorationIdentifier() {
      return this.history.restorationIdentifier;
    }
    get pageRefreshDebouncePeriod() {
      return this.#pageRefreshDebouncePeriod;
    }
    set pageRefreshDebouncePeriod(value) {
      this.refresh = debounce(this.debouncedRefresh.bind(this), value);
      this.#pageRefreshDebouncePeriod = value;
    }
    // Preloader delegate
    shouldPreloadLink(element) {
      const isUnsafe = element.hasAttribute("data-turbo-method");
      const isStream = element.hasAttribute("data-turbo-stream");
      const frameTarget = element.getAttribute("data-turbo-frame");
      const frame = frameTarget == "_top" ? null : document.getElementById(frameTarget) || findClosestRecursively(element, "turbo-frame:not([disabled])");
      if (isUnsafe || isStream || frame instanceof FrameElement) {
        return false;
      } else {
        const location2 = new URL(element.href);
        return this.elementIsNavigatable(element) && locationIsVisitable(location2, this.snapshot.rootLocation);
      }
    }
    // History delegate
    historyPoppedToLocationWithRestorationIdentifierAndDirection(location2, restorationIdentifier, direction) {
      if (this.enabled) {
        this.navigator.startVisit(location2, restorationIdentifier, {
          action: "restore",
          historyChanged: true,
          direction
        });
      } else {
        this.adapter.pageInvalidated({
          reason: "turbo_disabled"
        });
      }
    }
    // Scroll observer delegate
    scrollPositionChanged(position) {
      this.history.updateRestorationData({ scrollPosition: position });
    }
    // Form click observer delegate
    willSubmitFormLinkToLocation(link, location2) {
      return this.elementIsNavigatable(link) && locationIsVisitable(location2, this.snapshot.rootLocation);
    }
    submittedFormLinkToLocation() {
    }
    // Link hover observer delegate
    canPrefetchRequestToLocation(link, location2) {
      return this.elementIsNavigatable(link) && locationIsVisitable(location2, this.snapshot.rootLocation);
    }
    // Link click observer delegate
    willFollowLinkToLocation(link, location2, event) {
      return this.elementIsNavigatable(link) && locationIsVisitable(location2, this.snapshot.rootLocation) && this.applicationAllowsFollowingLinkToLocation(link, location2, event);
    }
    followedLinkToLocation(link, location2) {
      const action = this.getActionForLink(link);
      const acceptsStreamResponse = link.hasAttribute("data-turbo-stream");
      this.visit(location2.href, { action, acceptsStreamResponse });
    }
    // Navigator delegate
    allowsVisitingLocationWithAction(location2, action) {
      return this.locationWithActionIsSamePage(location2, action) || this.applicationAllowsVisitingLocation(location2);
    }
    visitProposedToLocation(location2, options) {
      extendURLWithDeprecatedProperties(location2);
      this.adapter.visitProposedToLocation(location2, options);
    }
    // Visit delegate
    visitStarted(visit2) {
      if (!visit2.acceptsStreamResponse) {
        markAsBusy(document.documentElement);
        this.view.markVisitDirection(visit2.direction);
      }
      extendURLWithDeprecatedProperties(visit2.location);
      if (!visit2.silent) {
        this.notifyApplicationAfterVisitingLocation(visit2.location, visit2.action);
      }
    }
    visitCompleted(visit2) {
      this.view.unmarkVisitDirection();
      clearBusyState(document.documentElement);
      this.notifyApplicationAfterPageLoad(visit2.getTimingMetrics());
    }
    locationWithActionIsSamePage(location2, action) {
      return this.navigator.locationWithActionIsSamePage(location2, action);
    }
    visitScrolledToSamePageLocation(oldURL, newURL) {
      this.notifyApplicationAfterVisitingSamePageLocation(oldURL, newURL);
    }
    // Form submit observer delegate
    willSubmitForm(form, submitter) {
      const action = getAction$1(form, submitter);
      return this.submissionIsNavigatable(form, submitter) && locationIsVisitable(expandURL(action), this.snapshot.rootLocation);
    }
    formSubmitted(form, submitter) {
      this.navigator.submitForm(form, submitter);
    }
    // Page observer delegate
    pageBecameInteractive() {
      this.view.lastRenderedLocation = this.location;
      this.notifyApplicationAfterPageLoad();
    }
    pageLoaded() {
      this.history.assumeControlOfScrollRestoration();
    }
    pageWillUnload() {
      this.history.relinquishControlOfScrollRestoration();
    }
    // Stream observer delegate
    receivedMessageFromStream(message) {
      this.renderStreamMessage(message);
    }
    // Page view delegate
    viewWillCacheSnapshot() {
      if (!this.navigator.currentVisit?.silent) {
        this.notifyApplicationBeforeCachingSnapshot();
      }
    }
    allowsImmediateRender({ element }, options) {
      const event = this.notifyApplicationBeforeRender(element, options);
      const {
        defaultPrevented,
        detail: { render }
      } = event;
      if (this.view.renderer && render) {
        this.view.renderer.renderElement = render;
      }
      return !defaultPrevented;
    }
    viewRenderedSnapshot(_snapshot, _isPreview, renderMethod) {
      this.view.lastRenderedLocation = this.history.location;
      this.notifyApplicationAfterRender(renderMethod);
    }
    preloadOnLoadLinksForView(element) {
      this.preloader.preloadOnLoadLinksForView(element);
    }
    viewInvalidated(reason) {
      this.adapter.pageInvalidated(reason);
    }
    // Frame element
    frameLoaded(frame) {
      this.notifyApplicationAfterFrameLoad(frame);
    }
    frameRendered(fetchResponse, frame) {
      this.notifyApplicationAfterFrameRender(fetchResponse, frame);
    }
    // Application events
    applicationAllowsFollowingLinkToLocation(link, location2, ev) {
      const event = this.notifyApplicationAfterClickingLinkToLocation(link, location2, ev);
      return !event.defaultPrevented;
    }
    applicationAllowsVisitingLocation(location2) {
      const event = this.notifyApplicationBeforeVisitingLocation(location2);
      return !event.defaultPrevented;
    }
    notifyApplicationAfterClickingLinkToLocation(link, location2, event) {
      return dispatch("turbo:click", {
        target: link,
        detail: { url: location2.href, originalEvent: event },
        cancelable: true
      });
    }
    notifyApplicationBeforeVisitingLocation(location2) {
      return dispatch("turbo:before-visit", {
        detail: { url: location2.href },
        cancelable: true
      });
    }
    notifyApplicationAfterVisitingLocation(location2, action) {
      return dispatch("turbo:visit", { detail: { url: location2.href, action } });
    }
    notifyApplicationBeforeCachingSnapshot() {
      return dispatch("turbo:before-cache");
    }
    notifyApplicationBeforeRender(newBody, options) {
      return dispatch("turbo:before-render", {
        detail: { newBody, ...options },
        cancelable: true
      });
    }
    notifyApplicationAfterRender(renderMethod) {
      return dispatch("turbo:render", { detail: { renderMethod } });
    }
    notifyApplicationAfterPageLoad(timing = {}) {
      return dispatch("turbo:load", {
        detail: { url: this.location.href, timing }
      });
    }
    notifyApplicationAfterVisitingSamePageLocation(oldURL, newURL) {
      dispatchEvent(
        new HashChangeEvent("hashchange", {
          oldURL: oldURL.toString(),
          newURL: newURL.toString()
        })
      );
    }
    notifyApplicationAfterFrameLoad(frame) {
      return dispatch("turbo:frame-load", { target: frame });
    }
    notifyApplicationAfterFrameRender(fetchResponse, frame) {
      return dispatch("turbo:frame-render", {
        detail: { fetchResponse },
        target: frame,
        cancelable: true
      });
    }
    // Helpers
    submissionIsNavigatable(form, submitter) {
      if (this.formMode == "off") {
        return false;
      } else {
        const submitterIsNavigatable = submitter ? this.elementIsNavigatable(submitter) : true;
        if (this.formMode == "optin") {
          return submitterIsNavigatable && form.closest('[data-turbo="true"]') != null;
        } else {
          return submitterIsNavigatable && this.elementIsNavigatable(form);
        }
      }
    }
    elementIsNavigatable(element) {
      const container = findClosestRecursively(element, "[data-turbo]");
      const withinFrame = findClosestRecursively(element, "turbo-frame");
      if (this.drive || withinFrame) {
        if (container) {
          return container.getAttribute("data-turbo") != "false";
        } else {
          return true;
        }
      } else {
        if (container) {
          return container.getAttribute("data-turbo") == "true";
        } else {
          return false;
        }
      }
    }
    // Private
    getActionForLink(link) {
      return getVisitAction(link) || "advance";
    }
    get snapshot() {
      return this.view.snapshot;
    }
  };
  function extendURLWithDeprecatedProperties(url) {
    Object.defineProperties(url, deprecatedLocationPropertyDescriptors);
  }
  __name(extendURLWithDeprecatedProperties, "extendURLWithDeprecatedProperties");
  var deprecatedLocationPropertyDescriptors = {
    absoluteURL: {
      get() {
        return this.toString();
      }
    }
  };
  var session = new Session(recentRequests);
  var { cache, navigator: navigator$1 } = session;
  function start() {
    session.start();
  }
  __name(start, "start");
  function registerAdapter(adapter) {
    session.registerAdapter(adapter);
  }
  __name(registerAdapter, "registerAdapter");
  function visit(location2, options) {
    session.visit(location2, options);
  }
  __name(visit, "visit");
  function connectStreamSource(source) {
    session.connectStreamSource(source);
  }
  __name(connectStreamSource, "connectStreamSource");
  function disconnectStreamSource(source) {
    session.disconnectStreamSource(source);
  }
  __name(disconnectStreamSource, "disconnectStreamSource");
  function renderStreamMessage(message) {
    session.renderStreamMessage(message);
  }
  __name(renderStreamMessage, "renderStreamMessage");
  function clearCache() {
    console.warn(
      "Please replace `Turbo.clearCache()` with `Turbo.cache.clear()`. The top-level function is deprecated and will be removed in a future version of Turbo.`"
    );
    session.clearCache();
  }
  __name(clearCache, "clearCache");
  function setProgressBarDelay(delay) {
    session.setProgressBarDelay(delay);
  }
  __name(setProgressBarDelay, "setProgressBarDelay");
  function setConfirmMethod(confirmMethod) {
    FormSubmission.confirmMethod = confirmMethod;
  }
  __name(setConfirmMethod, "setConfirmMethod");
  function setFormMode(mode) {
    session.setFormMode(mode);
  }
  __name(setFormMode, "setFormMode");
  var Turbo = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    navigator: navigator$1,
    session,
    cache,
    PageRenderer,
    PageSnapshot,
    FrameRenderer,
    fetch: fetchWithTurboHeaders,
    start,
    registerAdapter,
    visit,
    connectStreamSource,
    disconnectStreamSource,
    renderStreamMessage,
    clearCache,
    setProgressBarDelay,
    setConfirmMethod,
    setFormMode
  });
  var TurboFrameMissingError = class extends Error {
    static {
      __name(this, "TurboFrameMissingError");
    }
  };
  var FrameController = class {
    static {
      __name(this, "FrameController");
    }
    fetchResponseLoaded = (_fetchResponse) => Promise.resolve();
    #currentFetchRequest = null;
    #resolveVisitPromise = () => {
    };
    #connected = false;
    #hasBeenLoaded = false;
    #ignoredAttributes = /* @__PURE__ */ new Set();
    action = null;
    constructor(element) {
      this.element = element;
      this.view = new FrameView(this, this.element);
      this.appearanceObserver = new AppearanceObserver(this, this.element);
      this.formLinkClickObserver = new FormLinkClickObserver(this, this.element);
      this.linkInterceptor = new LinkInterceptor(this, this.element);
      this.restorationIdentifier = uuid();
      this.formSubmitObserver = new FormSubmitObserver(this, this.element);
    }
    // Frame delegate
    connect() {
      if (!this.#connected) {
        this.#connected = true;
        if (this.loadingStyle == FrameLoadingStyle.lazy) {
          this.appearanceObserver.start();
        } else {
          this.#loadSourceURL();
        }
        this.formLinkClickObserver.start();
        this.linkInterceptor.start();
        this.formSubmitObserver.start();
      }
    }
    disconnect() {
      if (this.#connected) {
        this.#connected = false;
        this.appearanceObserver.stop();
        this.formLinkClickObserver.stop();
        this.linkInterceptor.stop();
        this.formSubmitObserver.stop();
      }
    }
    disabledChanged() {
      if (this.loadingStyle == FrameLoadingStyle.eager) {
        this.#loadSourceURL();
      }
    }
    sourceURLChanged() {
      if (this.#isIgnoringChangesTo("src"))
        return;
      if (this.element.isConnected) {
        this.complete = false;
      }
      if (this.loadingStyle == FrameLoadingStyle.eager || this.#hasBeenLoaded) {
        this.#loadSourceURL();
      }
    }
    sourceURLReloaded() {
      const { src } = this.element;
      this.element.removeAttribute("complete");
      this.element.src = null;
      this.element.src = src;
      return this.element.loaded;
    }
    loadingStyleChanged() {
      if (this.loadingStyle == FrameLoadingStyle.lazy) {
        this.appearanceObserver.start();
      } else {
        this.appearanceObserver.stop();
        this.#loadSourceURL();
      }
    }
    async #loadSourceURL() {
      if (this.enabled && this.isActive && !this.complete && this.sourceURL) {
        this.element.loaded = this.#visit(expandURL(this.sourceURL));
        this.appearanceObserver.stop();
        await this.element.loaded;
        this.#hasBeenLoaded = true;
      }
    }
    async loadResponse(fetchResponse) {
      if (fetchResponse.redirected || fetchResponse.succeeded && fetchResponse.isHTML) {
        this.sourceURL = fetchResponse.response.url;
      }
      try {
        const html = await fetchResponse.responseHTML;
        if (html) {
          const document2 = parseHTMLDocument(html);
          const pageSnapshot = PageSnapshot.fromDocument(document2);
          if (pageSnapshot.isVisitable) {
            await this.#loadFrameResponse(fetchResponse, document2);
          } else {
            await this.#handleUnvisitableFrameResponse(fetchResponse);
          }
        }
      } finally {
        this.fetchResponseLoaded = () => Promise.resolve();
      }
    }
    // Appearance observer delegate
    elementAppearedInViewport(element) {
      this.proposeVisitIfNavigatedWithAction(element, getVisitAction(element));
      this.#loadSourceURL();
    }
    // Form link click observer delegate
    willSubmitFormLinkToLocation(link) {
      return this.#shouldInterceptNavigation(link);
    }
    submittedFormLinkToLocation(link, _location, form) {
      const frame = this.#findFrameElement(link);
      if (frame)
        form.setAttribute("data-turbo-frame", frame.id);
    }
    // Link interceptor delegate
    shouldInterceptLinkClick(element, _location, _event) {
      return this.#shouldInterceptNavigation(element);
    }
    linkClickIntercepted(element, location2) {
      this.#navigateFrame(element, location2);
    }
    // Form submit observer delegate
    willSubmitForm(element, submitter) {
      return element.closest("turbo-frame") == this.element && this.#shouldInterceptNavigation(element, submitter);
    }
    formSubmitted(element, submitter) {
      if (this.formSubmission) {
        this.formSubmission.stop();
      }
      this.formSubmission = new FormSubmission(this, element, submitter);
      const { fetchRequest } = this.formSubmission;
      this.prepareRequest(fetchRequest);
      this.formSubmission.start();
    }
    // Fetch request delegate
    prepareRequest(request) {
      request.headers["Turbo-Frame"] = this.id;
      if (this.currentNavigationElement?.hasAttribute("data-turbo-stream")) {
        request.acceptResponseType(StreamMessage.contentType);
      }
    }
    requestStarted(_request) {
      markAsBusy(this.element);
    }
    requestPreventedHandlingResponse(_request, _response) {
      this.#resolveVisitPromise();
    }
    async requestSucceededWithResponse(request, response) {
      await this.loadResponse(response);
      this.#resolveVisitPromise();
    }
    async requestFailedWithResponse(request, response) {
      await this.loadResponse(response);
      this.#resolveVisitPromise();
    }
    requestErrored(request, error) {
      console.error(error);
      this.#resolveVisitPromise();
    }
    requestFinished(_request) {
      clearBusyState(this.element);
    }
    // Form submission delegate
    formSubmissionStarted({ formElement }) {
      markAsBusy(formElement, this.#findFrameElement(formElement));
    }
    formSubmissionSucceededWithResponse(formSubmission, response) {
      const frame = this.#findFrameElement(formSubmission.formElement, formSubmission.submitter);
      frame.delegate.proposeVisitIfNavigatedWithAction(frame, getVisitAction(formSubmission.submitter, formSubmission.formElement, frame));
      frame.delegate.loadResponse(response);
      if (!formSubmission.isSafe) {
        session.clearCache();
      }
    }
    formSubmissionFailedWithResponse(formSubmission, fetchResponse) {
      this.element.delegate.loadResponse(fetchResponse);
      session.clearCache();
    }
    formSubmissionErrored(formSubmission, error) {
      console.error(error);
    }
    formSubmissionFinished({ formElement }) {
      clearBusyState(formElement, this.#findFrameElement(formElement));
    }
    // View delegate
    allowsImmediateRender({ element: newFrame }, options) {
      const event = dispatch("turbo:before-frame-render", {
        target: this.element,
        detail: { newFrame, ...options },
        cancelable: true
      });
      const {
        defaultPrevented,
        detail: { render }
      } = event;
      if (this.view.renderer && render) {
        this.view.renderer.renderElement = render;
      }
      return !defaultPrevented;
    }
    viewRenderedSnapshot(_snapshot, _isPreview, _renderMethod) {
    }
    preloadOnLoadLinksForView(element) {
      session.preloadOnLoadLinksForView(element);
    }
    viewInvalidated() {
    }
    // Frame renderer delegate
    willRenderFrame(currentElement, _newElement) {
      this.previousFrameElement = currentElement.cloneNode(true);
    }
    visitCachedSnapshot = ({ element }) => {
      const frame = element.querySelector("#" + this.element.id);
      if (frame && this.previousFrameElement) {
        frame.replaceChildren(...this.previousFrameElement.children);
      }
      delete this.previousFrameElement;
    };
    // Private
    async #loadFrameResponse(fetchResponse, document2) {
      const newFrameElement = await this.extractForeignFrameElement(document2.body);
      if (newFrameElement) {
        const snapshot = new Snapshot(newFrameElement);
        const renderer = new FrameRenderer(this, this.view.snapshot, snapshot, FrameRenderer.renderElement, false, false);
        if (this.view.renderPromise)
          await this.view.renderPromise;
        this.changeHistory();
        await this.view.render(renderer);
        this.complete = true;
        session.frameRendered(fetchResponse, this.element);
        session.frameLoaded(this.element);
        await this.fetchResponseLoaded(fetchResponse);
      } else if (this.#willHandleFrameMissingFromResponse(fetchResponse)) {
        this.#handleFrameMissingFromResponse(fetchResponse);
      }
    }
    async #visit(url) {
      const request = new FetchRequest(this, FetchMethod.get, url, new URLSearchParams(), this.element);
      this.#currentFetchRequest?.cancel();
      this.#currentFetchRequest = request;
      return new Promise((resolve) => {
        this.#resolveVisitPromise = () => {
          this.#resolveVisitPromise = () => {
          };
          this.#currentFetchRequest = null;
          resolve();
        };
        request.perform();
      });
    }
    #navigateFrame(element, url, submitter) {
      const frame = this.#findFrameElement(element, submitter);
      frame.delegate.proposeVisitIfNavigatedWithAction(frame, getVisitAction(submitter, element, frame));
      this.#withCurrentNavigationElement(element, () => {
        frame.src = url;
      });
    }
    proposeVisitIfNavigatedWithAction(frame, action = null) {
      this.action = action;
      if (this.action) {
        const pageSnapshot = PageSnapshot.fromElement(frame).clone();
        const { visitCachedSnapshot } = frame.delegate;
        frame.delegate.fetchResponseLoaded = async (fetchResponse) => {
          if (frame.src) {
            const { statusCode, redirected } = fetchResponse;
            const responseHTML = await fetchResponse.responseHTML;
            const response = { statusCode, redirected, responseHTML };
            const options = {
              response,
              visitCachedSnapshot,
              willRender: false,
              updateHistory: false,
              restorationIdentifier: this.restorationIdentifier,
              snapshot: pageSnapshot
            };
            if (this.action)
              options.action = this.action;
            session.visit(frame.src, options);
          }
        };
      }
    }
    changeHistory() {
      if (this.action) {
        const method = getHistoryMethodForAction(this.action);
        session.history.update(method, expandURL(this.element.src || ""), this.restorationIdentifier);
      }
    }
    async #handleUnvisitableFrameResponse(fetchResponse) {
      console.warn(
        `The response (${fetchResponse.statusCode}) from <turbo-frame id="${this.element.id}"> is performing a full page visit due to turbo-visit-control.`
      );
      await this.#visitResponse(fetchResponse.response);
    }
    #willHandleFrameMissingFromResponse(fetchResponse) {
      this.element.setAttribute("complete", "");
      const response = fetchResponse.response;
      const visit2 = /* @__PURE__ */ __name(async (url, options) => {
        if (url instanceof Response) {
          this.#visitResponse(url);
        } else {
          session.visit(url, options);
        }
      }, "visit");
      const event = dispatch("turbo:frame-missing", {
        target: this.element,
        detail: { response, visit: visit2 },
        cancelable: true
      });
      return !event.defaultPrevented;
    }
    #handleFrameMissingFromResponse(fetchResponse) {
      this.view.missing();
      this.#throwFrameMissingError(fetchResponse);
    }
    #throwFrameMissingError(fetchResponse) {
      const message = `The response (${fetchResponse.statusCode}) did not contain the expected <turbo-frame id="${this.element.id}"> and will be ignored. To perform a full page visit instead, set turbo-visit-control to reload.`;
      throw new TurboFrameMissingError(message);
    }
    async #visitResponse(response) {
      const wrapped = new FetchResponse(response);
      const responseHTML = await wrapped.responseHTML;
      const { location: location2, redirected, statusCode } = wrapped;
      return session.visit(location2, { response: { redirected, statusCode, responseHTML } });
    }
    #findFrameElement(element, submitter) {
      const id = getAttribute("data-turbo-frame", submitter, element) || this.element.getAttribute("target");
      return getFrameElementById(id) ?? this.element;
    }
    async extractForeignFrameElement(container) {
      let element;
      const id = CSS.escape(this.id);
      try {
        element = activateElement(container.querySelector(`turbo-frame#${id}`), this.sourceURL);
        if (element) {
          return element;
        }
        element = activateElement(container.querySelector(`turbo-frame[src][recurse~=${id}]`), this.sourceURL);
        if (element) {
          await element.loaded;
          return await this.extractForeignFrameElement(element);
        }
      } catch (error) {
        console.error(error);
        return new FrameElement();
      }
      return null;
    }
    #formActionIsVisitable(form, submitter) {
      const action = getAction$1(form, submitter);
      return locationIsVisitable(expandURL(action), this.rootLocation);
    }
    #shouldInterceptNavigation(element, submitter) {
      const id = getAttribute("data-turbo-frame", submitter, element) || this.element.getAttribute("target");
      if (element instanceof HTMLFormElement && !this.#formActionIsVisitable(element, submitter)) {
        return false;
      }
      if (!this.enabled || id == "_top") {
        return false;
      }
      if (id) {
        const frameElement = getFrameElementById(id);
        if (frameElement) {
          return !frameElement.disabled;
        }
      }
      if (!session.elementIsNavigatable(element)) {
        return false;
      }
      if (submitter && !session.elementIsNavigatable(submitter)) {
        return false;
      }
      return true;
    }
    // Computed properties
    get id() {
      return this.element.id;
    }
    get enabled() {
      return !this.element.disabled;
    }
    get sourceURL() {
      if (this.element.src) {
        return this.element.src;
      }
    }
    set sourceURL(sourceURL) {
      this.#ignoringChangesToAttribute("src", () => {
        this.element.src = sourceURL ?? null;
      });
    }
    get loadingStyle() {
      return this.element.loading;
    }
    get isLoading() {
      return this.formSubmission !== void 0 || this.#resolveVisitPromise() !== void 0;
    }
    get complete() {
      return this.element.hasAttribute("complete");
    }
    set complete(value) {
      if (value) {
        this.element.setAttribute("complete", "");
      } else {
        this.element.removeAttribute("complete");
      }
    }
    get isActive() {
      return this.element.isActive && this.#connected;
    }
    get rootLocation() {
      const meta = this.element.ownerDocument.querySelector(`meta[name="turbo-root"]`);
      const root2 = meta?.content ?? "/";
      return expandURL(root2);
    }
    #isIgnoringChangesTo(attributeName) {
      return this.#ignoredAttributes.has(attributeName);
    }
    #ignoringChangesToAttribute(attributeName, callback) {
      this.#ignoredAttributes.add(attributeName);
      callback();
      this.#ignoredAttributes.delete(attributeName);
    }
    #withCurrentNavigationElement(element, callback) {
      this.currentNavigationElement = element;
      callback();
      delete this.currentNavigationElement;
    }
  };
  function getFrameElementById(id) {
    if (id != null) {
      const element = document.getElementById(id);
      if (element instanceof FrameElement) {
        return element;
      }
    }
  }
  __name(getFrameElementById, "getFrameElementById");
  function activateElement(element, currentURL) {
    if (element) {
      const src = element.getAttribute("src");
      if (src != null && currentURL != null && urlsAreEqual(src, currentURL)) {
        throw new Error(`Matching <turbo-frame id="${element.id}"> element has a source URL which references itself`);
      }
      if (element.ownerDocument !== document) {
        element = document.importNode(element, true);
      }
      if (element instanceof FrameElement) {
        element.connectedCallback();
        element.disconnectedCallback();
        return element;
      }
    }
  }
  __name(activateElement, "activateElement");
  var StreamActions = {
    after() {
      this.targetElements.forEach((e2) => e2.parentElement?.insertBefore(this.templateContent, e2.nextSibling));
    },
    append() {
      this.removeDuplicateTargetChildren();
      this.targetElements.forEach((e2) => e2.append(this.templateContent));
    },
    before() {
      this.targetElements.forEach((e2) => e2.parentElement?.insertBefore(this.templateContent, e2));
    },
    prepend() {
      this.removeDuplicateTargetChildren();
      this.targetElements.forEach((e2) => e2.prepend(this.templateContent));
    },
    remove() {
      this.targetElements.forEach((e2) => e2.remove());
    },
    replace() {
      this.targetElements.forEach((e2) => e2.replaceWith(this.templateContent));
    },
    update() {
      this.targetElements.forEach((targetElement) => {
        targetElement.innerHTML = "";
        targetElement.append(this.templateContent);
      });
    },
    refresh() {
      session.refresh(this.baseURI, this.requestId);
    }
  };
  var StreamElement = class _StreamElement extends HTMLElement {
    static {
      __name(this, "StreamElement");
    }
    static async renderElement(newElement) {
      await newElement.performAction();
    }
    async connectedCallback() {
      try {
        await this.render();
      } catch (error) {
        console.error(error);
      } finally {
        this.disconnect();
      }
    }
    async render() {
      return this.renderPromise ??= (async () => {
        const event = this.beforeRenderEvent;
        if (this.dispatchEvent(event)) {
          await nextRepaint();
          await event.detail.render(this);
        }
      })();
    }
    disconnect() {
      try {
        this.remove();
      } catch {
      }
    }
    /**
     * Removes duplicate children (by ID)
     */
    removeDuplicateTargetChildren() {
      this.duplicateChildren.forEach((c2) => c2.remove());
    }
    /**
     * Gets the list of duplicate children (i.e. those with the same ID)
     */
    get duplicateChildren() {
      const existingChildren = this.targetElements.flatMap((e2) => [...e2.children]).filter((c2) => !!c2.id);
      const newChildrenIds = [...this.templateContent?.children || []].filter((c2) => !!c2.id).map((c2) => c2.id);
      return existingChildren.filter((c2) => newChildrenIds.includes(c2.id));
    }
    /**
     * Gets the action function to be performed.
     */
    get performAction() {
      if (this.action) {
        const actionFunction = StreamActions[this.action];
        if (actionFunction) {
          return actionFunction;
        }
        this.#raise("unknown action");
      }
      this.#raise("action attribute is missing");
    }
    /**
     * Gets the target elements which the template will be rendered to.
     */
    get targetElements() {
      if (this.target) {
        return this.targetElementsById;
      } else if (this.targets) {
        return this.targetElementsByQuery;
      } else {
        this.#raise("target or targets attribute is missing");
      }
    }
    /**
     * Gets the contents of the main `<template>`.
     */
    get templateContent() {
      return this.templateElement.content.cloneNode(true);
    }
    /**
     * Gets the main `<template>` used for rendering
     */
    get templateElement() {
      if (this.firstElementChild === null) {
        const template = this.ownerDocument.createElement("template");
        this.appendChild(template);
        return template;
      } else if (this.firstElementChild instanceof HTMLTemplateElement) {
        return this.firstElementChild;
      }
      this.#raise("first child element must be a <template> element");
    }
    /**
     * Gets the current action.
     */
    get action() {
      return this.getAttribute("action");
    }
    /**
     * Gets the current target (an element ID) to which the result will
     * be rendered.
     */
    get target() {
      return this.getAttribute("target");
    }
    /**
     * Gets the current "targets" selector (a CSS selector)
     */
    get targets() {
      return this.getAttribute("targets");
    }
    /**
     * Reads the request-id attribute
     */
    get requestId() {
      return this.getAttribute("request-id");
    }
    #raise(message) {
      throw new Error(`${this.description}: ${message}`);
    }
    get description() {
      return (this.outerHTML.match(/<[^>]+>/) ?? [])[0] ?? "<turbo-stream>";
    }
    get beforeRenderEvent() {
      return new CustomEvent("turbo:before-stream-render", {
        bubbles: true,
        cancelable: true,
        detail: { newStream: this, render: _StreamElement.renderElement }
      });
    }
    get targetElementsById() {
      const element = this.ownerDocument?.getElementById(this.target);
      if (element !== null) {
        return [element];
      } else {
        return [];
      }
    }
    get targetElementsByQuery() {
      const elements = this.ownerDocument?.querySelectorAll(this.targets);
      if (elements.length !== 0) {
        return Array.prototype.slice.call(elements);
      } else {
        return [];
      }
    }
  };
  var StreamSourceElement = class extends HTMLElement {
    static {
      __name(this, "StreamSourceElement");
    }
    streamSource = null;
    connectedCallback() {
      this.streamSource = this.src.match(/^ws{1,2}:/) ? new WebSocket(this.src) : new EventSource(this.src);
      connectStreamSource(this.streamSource);
    }
    disconnectedCallback() {
      if (this.streamSource) {
        this.streamSource.close();
        disconnectStreamSource(this.streamSource);
      }
    }
    get src() {
      return this.getAttribute("src") || "";
    }
  };
  FrameElement.delegateConstructor = FrameController;
  if (customElements.get("turbo-frame") === void 0) {
    customElements.define("turbo-frame", FrameElement);
  }
  if (customElements.get("turbo-stream") === void 0) {
    customElements.define("turbo-stream", StreamElement);
  }
  if (customElements.get("turbo-stream-source") === void 0) {
    customElements.define("turbo-stream-source", StreamSourceElement);
  }
  (() => {
    let element = document.currentScript;
    if (!element)
      return;
    if (element.hasAttribute("data-turbo-suppress-warning"))
      return;
    element = element.parentElement;
    while (element) {
      if (element == document.body) {
        return console.warn(
          unindent`
        You are loading Turbo from a <script> element inside the <body> element. This is probably not what you meant to do!

        Load your applications JavaScript bundle inside the <head> element instead. <script> elements in <body> are evaluated with each page change.

        For more information, see: https://turbo.hotwired.dev/handbook/building#working-with-script-elements

        
        Suppress this warning by adding a "data-turbo-suppress-warning" attribute to: %s
      `,
          element.outerHTML
        );
      }
      element = element.parentElement;
    }
  })();
  window.Turbo = { ...Turbo, StreamActions };
  start();

  // node_modules/@hotwired/turbo-rails/app/javascript/turbo/cable.js
  var consumer;
  async function getConsumer() {
    return consumer || setConsumer(createConsumer2().then(setConsumer));
  }
  __name(getConsumer, "getConsumer");
  function setConsumer(newConsumer) {
    return consumer = newConsumer;
  }
  __name(setConsumer, "setConsumer");
  async function createConsumer2() {
    const { createConsumer: createConsumer3 } = await Promise.resolve().then(() => (init_src(), src_exports));
    return createConsumer3();
  }
  __name(createConsumer2, "createConsumer");
  async function subscribeTo(channel, mixin) {
    const { subscriptions } = await getConsumer();
    return subscriptions.create(channel, mixin);
  }
  __name(subscribeTo, "subscribeTo");

  // node_modules/@hotwired/turbo-rails/app/javascript/turbo/snakeize.js
  function walk(obj) {
    if (!obj || typeof obj !== "object")
      return obj;
    if (obj instanceof Date || obj instanceof RegExp)
      return obj;
    if (Array.isArray(obj))
      return obj.map(walk);
    return Object.keys(obj).reduce(function(acc, key) {
      var camel = key[0].toLowerCase() + key.slice(1).replace(/([A-Z]+)/g, function(m2, x2) {
        return "_" + x2.toLowerCase();
      });
      acc[camel] = walk(obj[key]);
      return acc;
    }, {});
  }
  __name(walk, "walk");

  // node_modules/@hotwired/turbo-rails/app/javascript/turbo/cable_stream_source_element.js
  var TurboCableStreamSourceElement = class extends HTMLElement {
    static {
      __name(this, "TurboCableStreamSourceElement");
    }
    async connectedCallback() {
      connectStreamSource(this);
      this.subscription = await subscribeTo(this.channel, {
        received: this.dispatchMessageEvent.bind(this),
        connected: this.subscriptionConnected.bind(this),
        disconnected: this.subscriptionDisconnected.bind(this)
      });
    }
    disconnectedCallback() {
      disconnectStreamSource(this);
      if (this.subscription)
        this.subscription.unsubscribe();
    }
    dispatchMessageEvent(data) {
      const event = new MessageEvent("message", { data });
      return this.dispatchEvent(event);
    }
    subscriptionConnected() {
      this.setAttribute("connected", "");
    }
    subscriptionDisconnected() {
      this.removeAttribute("connected");
    }
    get channel() {
      const channel = this.getAttribute("channel");
      const signed_stream_name = this.getAttribute("signed-stream-name");
      return { channel, signed_stream_name, ...walk({ ...this.dataset }) };
    }
  };
  if (customElements.get("turbo-cable-stream-source") === void 0) {
    customElements.define("turbo-cable-stream-source", TurboCableStreamSourceElement);
  }

  // node_modules/@hotwired/turbo-rails/app/javascript/turbo/fetch_requests.js
  function encodeMethodIntoRequestBody(event) {
    if (event.target instanceof HTMLFormElement) {
      const { target: form, detail: { fetchOptions } } = event;
      form.addEventListener("turbo:submit-start", ({ detail: { formSubmission: { submitter } } }) => {
        const body = isBodyInit(fetchOptions.body) ? fetchOptions.body : new URLSearchParams();
        const method = determineFetchMethod(submitter, body, form);
        if (!/get/i.test(method)) {
          if (/post/i.test(method)) {
            body.delete("_method");
          } else {
            body.set("_method", method);
          }
          fetchOptions.method = "post";
        }
      }, { once: true });
    }
  }
  __name(encodeMethodIntoRequestBody, "encodeMethodIntoRequestBody");
  function determineFetchMethod(submitter, body, form) {
    const formMethod = determineFormMethod(submitter);
    const overrideMethod = body.get("_method");
    const method = form.getAttribute("method") || "get";
    if (typeof formMethod == "string") {
      return formMethod;
    } else if (typeof overrideMethod == "string") {
      return overrideMethod;
    } else {
      return method;
    }
  }
  __name(determineFetchMethod, "determineFetchMethod");
  function determineFormMethod(submitter) {
    if (submitter instanceof HTMLButtonElement || submitter instanceof HTMLInputElement) {
      if (submitter.name === "_method") {
        return submitter.value;
      } else if (submitter.hasAttribute("formmethod")) {
        return submitter.formMethod;
      } else {
        return null;
      }
    } else {
      return null;
    }
  }
  __name(determineFormMethod, "determineFormMethod");
  function isBodyInit(body) {
    return body instanceof FormData || body instanceof URLSearchParams;
  }
  __name(isBodyInit, "isBodyInit");

  // node_modules/@hotwired/turbo-rails/app/javascript/turbo/index.js
  window.Turbo = turbo_es2017_esm_exports;
  addEventListener("turbo:before-fetch-request", encodeMethodIntoRequestBody);

  // node_modules/@johanhalse/musculus/dist/musculus.js
  var mixins_default = {
    camelize: function(value) {
      return value.replace(
        /(?:[_-])([a-z0-9])/g,
        (_2, char) => char.toUpperCase()
      );
    },
    dasherize: function(value) {
      const dash = value.replace(
        /([A-Z])/g,
        (_2, char) => `-${char.toLowerCase()}`
      );
      return dash.startsWith("-") ? dash.substr(1) : dash;
    }
  };
  var Application = class {
    static {
      __name(this, "Application");
    }
    constructor() {
      this.controllers = {};
    }
    start(dom) {
      this.window = window;
      this.document = document;
      this.connect();
    }
    connect() {
      for (let key in this.controllers) {
        this.window.customElements.define(key, this.controllers[key]);
      }
    }
    register(controller) {
      let controllerName = this.dasherize(controller.name.replace("Default", ""));
      this.controllers[controllerName] = controller;
    }
  };
  Object.assign(Application.prototype, mixins_default);
  var application = new Application();
  var Controller = class extends window.HTMLElement {
    static {
      __name(this, "Controller");
    }
    constructor() {
      super();
      this.element = this;
      this.descriptorPattern = /^(?:(.+?)(?:\.(.+?))?(?:@(window|document))?->)?(.+?)(?:#([^:]+?))(?::(.+))?$/;
    }
    bindAction(action) {
      if (action.identifier != this.name) {
        return;
      }
      action.boundFn = this[action.methodName].bind(this);
      action.listener = action.eventTarget.addEventListener(
        action.eventName || this.defaultEventName(action.eventTarget),
        action.boundFn,
        false
      );
    }
    parseAction(el) {
      const actions = el.dataset.action.split(" ");
      return actions.map(this.parseActionDescriptorString(el).bind(this));
    }
    parseActionDescriptorString(el) {
      return function(descriptorString) {
        const source = descriptorString.trim();
        const matches = source.match(this.descriptorPattern) || [];
        let eventName = matches[1];
        let keyFilter = matches[2];
        if (keyFilter && !["keydown", "keyup", "keypress"].includes(eventName)) {
          eventName += `.${keyFilter}`;
          keyFilter = "";
        }
        return {
          eventTarget: this.parseEventTarget(matches[3]) || el,
          eventName,
          eventOptions: matches[6] ? this.parseEventOptions(matches[6]) : {},
          identifier: matches[4],
          methodName: matches[5],
          keyFilter
        };
      };
    }
    parseEventTarget(eventTargetName) {
      if (eventTargetName == "window") {
        return window;
      }
      if (eventTargetName == "document") {
        return document;
      }
    }
    parseEventOptions(eventOptions) {
      return eventOptions.split(":").reduce(
        (options, token) => Object.assign(options, {
          [token.replace(/^!/, "")]: !/^!/.test(token)
        }),
        {}
      );
    }
    defineTargets() {
      if (this.constructor.targets == void 0) {
        return;
      }
      this.constructor.targets.forEach(this.mapTargets.bind(this));
    }
    mapTargets(targetName) {
      const targets = this.querySelectorAll(
        `[data-${this.name}-target="${targetName}"]`
      );
      this[targetName + "Targets"] = Array.from(targets);
      this[targetName + "Target"] = targets[0];
    }
    defineValues() {
      if (this.constructor.values == void 0) {
        return;
      }
      const keys2 = Object.keys(this.constructor.values);
      keys2.forEach(this.mapValues(this.constructor.values).bind(this));
    }
    mapValues(values) {
      return function(key) {
        this[key + "Value"] = this.parseValue(key, values[key]);
      };
    }
    parseValue(key, keyType) {
      const dataKey = this.camelize(`${this.name}-${key}-value`);
      const val = this.dataset[dataKey];
      if (val == void 0) {
        return void 0;
      }
      switch (keyType) {
        case Array:
          return JSON.parse(val);
        case Boolean:
          return !(val == "0" || val == "false");
        case Number:
          return Number(val);
        case Object:
          return JSON.parse(val);
        default:
          return val;
      }
    }
    attachActions() {
      const actionElements = Array.from(
        this.querySelectorAll("[data-action]")
      );
      if (this.dataset.action) {
        actionElements.push(this);
      }
      this.actions = actionElements.flatMap(this.parseAction.bind(this));
      this.actions.forEach(this.bindAction.bind(this));
    }
    connectedCallback() {
      this.name = this.dasherize(this.constructor.name).replace("-controller-default", "").replace("-controller", "");
      this.attachActions();
      this.defineValues();
      this.defineTargets();
      this.connect && this.connect();
    }
    disconnectedCallback() {
      this.disconnect && this.disconnect();
    }
    dasherize(value) {
      const dash = value.replace(
        /([A-Z])/g,
        (_2, char) => `-${char.toLowerCase()}`
      );
      return dash.startsWith("-") ? dash.substr(1) : dash;
    }
    defaultEventName(el) {
      switch (el.nodeName) {
        case "DETAILS":
          return "toggle";
        case "FORM":
          return "submit";
        case "INPUT":
          if (el.type.toLowerCase() == "submit") {
            return "click";
          }
          return "input";
        case "SELECT":
          return "change";
        case "TEXTAREA":
          return "change";
        default:
          return "click";
      }
    }
  };
  Object.assign(Controller.prototype, mixins_default);

  // app/javascript/controllers/admin_tab_controller.js
  var AdminTabController = class extends Controller {
    static {
      __name(this, "AdminTabController");
    }
    connect() {
      document.querySelectorAll("admin-tab-controller label").forEach(this.setCurrent.bind(this));
    }
    mark(e2) {
      document.querySelectorAll("admin-tab-controller label").forEach(this.unselect);
      this.select(e2.target);
    }
    setCurrent(target) {
      const checkbox = document.getElementById(target.getAttribute("for"));
      if (checkbox.checked) {
        this.select(target);
      } else {
        this.unselect(target);
      }
    }
    unselect(target) {
      target.classList.add("bg-neutral-200", "hover:bg-neutral-300");
      target.classList.remove("bg-cyan-200");
    }
    select(target) {
      target.classList.remove("bg-neutral-200", "hover:bg-neutral-300");
      target.classList.add("bg-cyan-200");
    }
  };

  // app/javascript/controllers/admin_cleave_controller.js
  var AdminCleaveController = class extends Controller {
    static {
      __name(this, "AdminCleaveController");
    }
    connect() {
      const input = this.querySelector("input");
      if (input.autocomplete == "cc-number") {
        this.cc({ target: input });
      } else {
        this.cleave({ target: input });
      }
    }
    cleave(e2) {
      const amount = parseInt(e2.target.value.replaceAll(" ", ""));
      if (isNaN(amount)) {
        return;
      }
      e2.target.value = parseInt(amount).toLocaleString("en").replaceAll(",", " ");
    }
    cc(e2) {
      const amount = e2.target.value.replaceAll(" ", "");
      const result = [];
      for (let i2 = 0; i2 < amount.length; i2 += 4) {
        result.push(amount.slice(i2, i2 + 4));
      }
      e2.target.value = result.join(" ");
    }
  };

  // node_modules/js-cookie/dist/js.cookie.mjs
  function assign(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        target[key] = source[key];
      }
    }
    return target;
  }
  __name(assign, "assign");
  var defaultConverter = {
    read: function(value) {
      if (value[0] === '"') {
        value = value.slice(1, -1);
      }
      return value.replace(/(%[\dA-F]{2})+/gi, decodeURIComponent);
    },
    write: function(value) {
      return encodeURIComponent(value).replace(
        /%(2[346BF]|3[AC-F]|40|5[BDE]|60|7[BCD])/g,
        decodeURIComponent
      );
    }
  };
  function init(converter, defaultAttributes) {
    function set(name, value, attributes) {
      if (typeof document === "undefined") {
        return;
      }
      attributes = assign({}, defaultAttributes, attributes);
      if (typeof attributes.expires === "number") {
        attributes.expires = new Date(Date.now() + attributes.expires * 864e5);
      }
      if (attributes.expires) {
        attributes.expires = attributes.expires.toUTCString();
      }
      name = encodeURIComponent(name).replace(/%(2[346B]|5E|60|7C)/g, decodeURIComponent).replace(/[()]/g, escape);
      var stringifiedAttributes = "";
      for (var attributeName in attributes) {
        if (!attributes[attributeName]) {
          continue;
        }
        stringifiedAttributes += "; " + attributeName;
        if (attributes[attributeName] === true) {
          continue;
        }
        stringifiedAttributes += "=" + attributes[attributeName].split(";")[0];
      }
      return document.cookie = name + "=" + converter.write(value, name) + stringifiedAttributes;
    }
    __name(set, "set");
    function get(name) {
      if (typeof document === "undefined" || arguments.length && !name) {
        return;
      }
      var cookies = document.cookie ? document.cookie.split("; ") : [];
      var jar = {};
      for (var i2 = 0; i2 < cookies.length; i2++) {
        var parts = cookies[i2].split("=");
        var value = parts.slice(1).join("=");
        try {
          var found = decodeURIComponent(parts[0]);
          jar[found] = converter.read(value, found);
          if (name === found) {
            break;
          }
        } catch (e2) {
        }
      }
      return name ? jar[name] : jar;
    }
    __name(get, "get");
    return Object.create(
      {
        set,
        get,
        remove: function(name, attributes) {
          set(
            name,
            "",
            assign({}, attributes, {
              expires: -1
            })
          );
        },
        withAttributes: function(attributes) {
          return init(this.converter, assign({}, this.attributes, attributes));
        },
        withConverter: function(converter2) {
          return init(assign({}, this.converter, converter2), this.attributes);
        }
      },
      {
        attributes: { value: Object.freeze(defaultAttributes) },
        converter: { value: Object.freeze(converter) }
      }
    );
  }
  __name(init, "init");
  var api = init(defaultConverter, { path: "/" });

  // app/javascript/controllers/back_to_scope_controller.js
  var BackToScopeController = class extends Controller {
    static {
      __name(this, "BackToScopeController");
    }
    click(e2) {
      const resource = this.dataset["resource"];
      const url = api.get(`return_to_${resource}_tab`);
      if (url) {
        e2.preventDefault();
        window.Turbo.visit(e2.target.href + "?scope=" + url);
      }
    }
  };

  // app/javascript/controllers/batch_action_controller.js
  var BatchActionController = class extends Controller {
    static {
      __name(this, "BatchActionController");
    }
    static targets = ["actionbar", "all", "checkbox"];
    checkbox(e2) {
      if (this.checkboxTargets.some(this.isChecked)) {
        this.showActions();
      } else {
        this.hideActions();
      }
    }
    isChecked(checkbox) {
      return checkbox.checked;
    }
    showActions() {
      this.actionbarTarget.classList.remove("hidden");
      this.allTarget.checked = true;
    }
    hideActions() {
      this.actionbarTarget.classList.add("hidden");
      this.allTarget.checked = false;
    }
  };

  // app/javascript/controllers/clickable_row_controller.js
  var ClickableRowController = class extends Controller {
    static {
      __name(this, "ClickableRowController");
    }
    connect() {
      this.querySelectorAll("[data-link]").forEach(this.addHoverClasses);
    }
    addHoverClasses(tr) {
      tr.classList.add("cursor-pointer", "hover:bg-neutral-200");
    }
    click(e2) {
      if (e2.target.tagName == "A" || e2.target.tagName == "INPUT") {
        return true;
      }
      const link = e2.target.closest("tr").dataset["link"];
      if (e2.which == 2 || e2.which == 4 || e2.metaKey || e2.ctrlKey) {
        window.open(link, "_blank");
      } else {
        e2.preventDefault();
        window.Turbo.visit(link);
      }
    }
  };

  // app/javascript/controllers/hamburger_menu_controller.js
  var HamburgerMenuController = class extends Controller {
    static {
      __name(this, "HamburgerMenuController");
    }
    connect() {
      this.classList.add("cursor-pointer");
    }
    toggle(e2) {
      document.getElementById("left-menu").classList.toggle("-translate-x-full");
      document.getElementById("main").classList.toggle("blur-sm");
    }
  };

  // app/javascript/controllers/geo_search_controller.js
  var import_debounce = __toESM(require_debounce());
  var GeoSearchController = class extends Controller {
    static {
      __name(this, "GeoSearchController");
    }
    static targets = ["lat", "lng", "visibleField", "results"];
    static values = { model: String };
    connect() {
      this.debouncedFetchData = (0, import_debounce.default)(this.fetchData.bind(this), 500);
    }
    change(e2) {
      this.debouncedFetchData(e2.target.value);
    }
    fetchData(text, update) {
      fetch("https://nominatim.openstreetmap.org/search?" + new URLSearchParams({ q: text, format: "jsonv2" })).then((response) => response.json()).then((response) => this.display(response));
    }
    buildMarkup(response) {
      return response.map(function(location2) {
        return `
        <div>
          <span
            class="block p-2 cursor-pointer hover:bg-neutral-100"
            data-info='${JSON.stringify(location2)}'
            data-action="click->geo-search#select"
          >${location2.display_name}</span>
        </div>`;
      }).join("");
    }
    display(response) {
      this.resultsTarget.innerHTML = this.buildMarkup(response);
      this.bindNewActions(this.resultsTarget);
    }
    bindNewActions(el) {
      const actionElements = Array.from(el.querySelectorAll("[data-action]"));
      const actions = actionElements.flatMap(this.parseAction.bind(this));
      actions.forEach(this.bindAction.bind(this));
    }
    select(e2) {
      const item = JSON.parse(e2.currentTarget.dataset["info"]);
      this.visibleFieldTarget.value = item.name || item.display_name;
      this.latTarget.value = item.lat;
      this.lngTarget.value = item.lon;
      this.resultsTarget.innerHTML = "";
    }
  };

  // node_modules/flatpickr/dist/esm/types/options.js
  var HOOKS = [
    "onChange",
    "onClose",
    "onDayCreate",
    "onDestroy",
    "onKeyDown",
    "onMonthChange",
    "onOpen",
    "onParseConfig",
    "onReady",
    "onValueUpdate",
    "onYearChange",
    "onPreCalendarPosition"
  ];
  var defaults = {
    _disable: [],
    allowInput: false,
    allowInvalidPreload: false,
    altFormat: "F j, Y",
    altInput: false,
    altInputClass: "form-control input",
    animate: typeof window === "object" && window.navigator.userAgent.indexOf("MSIE") === -1,
    ariaDateFormat: "F j, Y",
    autoFillDefaultTime: true,
    clickOpens: true,
    closeOnSelect: true,
    conjunction: ", ",
    dateFormat: "Y-m-d",
    defaultHour: 12,
    defaultMinute: 0,
    defaultSeconds: 0,
    disable: [],
    disableMobile: false,
    enableSeconds: false,
    enableTime: false,
    errorHandler: function(err) {
      return typeof console !== "undefined" && console.warn(err);
    },
    getWeek: function(givenDate) {
      var date = new Date(givenDate.getTime());
      date.setHours(0, 0, 0, 0);
      date.setDate(date.getDate() + 3 - (date.getDay() + 6) % 7);
      var week1 = new Date(date.getFullYear(), 0, 4);
      return 1 + Math.round(((date.getTime() - week1.getTime()) / 864e5 - 3 + (week1.getDay() + 6) % 7) / 7);
    },
    hourIncrement: 1,
    ignoredFocusElements: [],
    inline: false,
    locale: "default",
    minuteIncrement: 5,
    mode: "single",
    monthSelectorType: "dropdown",
    nextArrow: "<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 17 17'><g></g><path d='M13.207 8.472l-7.854 7.854-0.707-0.707 7.146-7.146-7.146-7.148 0.707-0.707 7.854 7.854z' /></svg>",
    noCalendar: false,
    now: /* @__PURE__ */ new Date(),
    onChange: [],
    onClose: [],
    onDayCreate: [],
    onDestroy: [],
    onKeyDown: [],
    onMonthChange: [],
    onOpen: [],
    onParseConfig: [],
    onReady: [],
    onValueUpdate: [],
    onYearChange: [],
    onPreCalendarPosition: [],
    plugins: [],
    position: "auto",
    positionElement: void 0,
    prevArrow: "<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 17 17'><g></g><path d='M5.207 8.471l7.146 7.147-0.707 0.707-7.853-7.854 7.854-7.853 0.707 0.707-7.147 7.146z' /></svg>",
    shorthandCurrentMonth: false,
    showMonths: 1,
    static: false,
    time_24hr: false,
    weekNumbers: false,
    wrap: false
  };

  // node_modules/flatpickr/dist/esm/l10n/default.js
  var english = {
    weekdays: {
      shorthand: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
      longhand: [
        "Sunday",
        "Monday",
        "Tuesday",
        "Wednesday",
        "Thursday",
        "Friday",
        "Saturday"
      ]
    },
    months: {
      shorthand: [
        "Jan",
        "Feb",
        "Mar",
        "Apr",
        "May",
        "Jun",
        "Jul",
        "Aug",
        "Sep",
        "Oct",
        "Nov",
        "Dec"
      ],
      longhand: [
        "January",
        "February",
        "March",
        "April",
        "May",
        "June",
        "July",
        "August",
        "September",
        "October",
        "November",
        "December"
      ]
    },
    daysInMonth: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
    firstDayOfWeek: 0,
    ordinal: function(nth) {
      var s2 = nth % 100;
      if (s2 > 3 && s2 < 21)
        return "th";
      switch (s2 % 10) {
        case 1:
          return "st";
        case 2:
          return "nd";
        case 3:
          return "rd";
        default:
          return "th";
      }
    },
    rangeSeparator: " to ",
    weekAbbreviation: "Wk",
    scrollTitle: "Scroll to increment",
    toggleTitle: "Click to toggle",
    amPM: ["AM", "PM"],
    yearAriaLabel: "Year",
    monthAriaLabel: "Month",
    hourAriaLabel: "Hour",
    minuteAriaLabel: "Minute",
    time_24hr: false
  };
  var default_default = english;

  // node_modules/flatpickr/dist/esm/utils/index.js
  var pad = /* @__PURE__ */ __name(function(number, length) {
    if (length === void 0) {
      length = 2;
    }
    return ("000" + number).slice(length * -1);
  }, "pad");
  var int = /* @__PURE__ */ __name(function(bool) {
    return bool === true ? 1 : 0;
  }, "int");
  function debounce3(fn, wait) {
    var t2;
    return function() {
      var _this = this;
      var args = arguments;
      clearTimeout(t2);
      t2 = setTimeout(function() {
        return fn.apply(_this, args);
      }, wait);
    };
  }
  __name(debounce3, "debounce");
  var arrayify = /* @__PURE__ */ __name(function(obj) {
    return obj instanceof Array ? obj : [obj];
  }, "arrayify");

  // node_modules/flatpickr/dist/esm/utils/dom.js
  function toggleClass(elem, className, bool) {
    if (bool === true)
      return elem.classList.add(className);
    elem.classList.remove(className);
  }
  __name(toggleClass, "toggleClass");
  function createElement(tag, className, content) {
    var e2 = window.document.createElement(tag);
    className = className || "";
    content = content || "";
    e2.className = className;
    if (content !== void 0)
      e2.textContent = content;
    return e2;
  }
  __name(createElement, "createElement");
  function clearNode(node) {
    while (node.firstChild)
      node.removeChild(node.firstChild);
  }
  __name(clearNode, "clearNode");
  function findParent(node, condition) {
    if (condition(node))
      return node;
    else if (node.parentNode)
      return findParent(node.parentNode, condition);
    return void 0;
  }
  __name(findParent, "findParent");
  function createNumberInput(inputClassName, opts) {
    var wrapper = createElement("div", "numInputWrapper"), numInput = createElement("input", "numInput " + inputClassName), arrowUp = createElement("span", "arrowUp"), arrowDown = createElement("span", "arrowDown");
    if (navigator.userAgent.indexOf("MSIE 9.0") === -1) {
      numInput.type = "number";
    } else {
      numInput.type = "text";
      numInput.pattern = "\\d*";
    }
    if (opts !== void 0)
      for (var key in opts)
        numInput.setAttribute(key, opts[key]);
    wrapper.appendChild(numInput);
    wrapper.appendChild(arrowUp);
    wrapper.appendChild(arrowDown);
    return wrapper;
  }
  __name(createNumberInput, "createNumberInput");
  function getEventTarget(event) {
    try {
      if (typeof event.composedPath === "function") {
        var path = event.composedPath();
        return path[0];
      }
      return event.target;
    } catch (error) {
      return event.target;
    }
  }
  __name(getEventTarget, "getEventTarget");

  // node_modules/flatpickr/dist/esm/utils/formatting.js
  var doNothing = /* @__PURE__ */ __name(function() {
    return void 0;
  }, "doNothing");
  var monthToStr = /* @__PURE__ */ __name(function(monthNumber, shorthand, locale) {
    return locale.months[shorthand ? "shorthand" : "longhand"][monthNumber];
  }, "monthToStr");
  var revFormat = {
    D: doNothing,
    F: function(dateObj, monthName, locale) {
      dateObj.setMonth(locale.months.longhand.indexOf(monthName));
    },
    G: function(dateObj, hour) {
      dateObj.setHours((dateObj.getHours() >= 12 ? 12 : 0) + parseFloat(hour));
    },
    H: function(dateObj, hour) {
      dateObj.setHours(parseFloat(hour));
    },
    J: function(dateObj, day) {
      dateObj.setDate(parseFloat(day));
    },
    K: function(dateObj, amPM, locale) {
      dateObj.setHours(dateObj.getHours() % 12 + 12 * int(new RegExp(locale.amPM[1], "i").test(amPM)));
    },
    M: function(dateObj, shortMonth, locale) {
      dateObj.setMonth(locale.months.shorthand.indexOf(shortMonth));
    },
    S: function(dateObj, seconds) {
      dateObj.setSeconds(parseFloat(seconds));
    },
    U: function(_2, unixSeconds) {
      return new Date(parseFloat(unixSeconds) * 1e3);
    },
    W: function(dateObj, weekNum, locale) {
      var weekNumber = parseInt(weekNum);
      var date = new Date(dateObj.getFullYear(), 0, 2 + (weekNumber - 1) * 7, 0, 0, 0, 0);
      date.setDate(date.getDate() - date.getDay() + locale.firstDayOfWeek);
      return date;
    },
    Y: function(dateObj, year) {
      dateObj.setFullYear(parseFloat(year));
    },
    Z: function(_2, ISODate) {
      return new Date(ISODate);
    },
    d: function(dateObj, day) {
      dateObj.setDate(parseFloat(day));
    },
    h: function(dateObj, hour) {
      dateObj.setHours((dateObj.getHours() >= 12 ? 12 : 0) + parseFloat(hour));
    },
    i: function(dateObj, minutes) {
      dateObj.setMinutes(parseFloat(minutes));
    },
    j: function(dateObj, day) {
      dateObj.setDate(parseFloat(day));
    },
    l: doNothing,
    m: function(dateObj, month) {
      dateObj.setMonth(parseFloat(month) - 1);
    },
    n: function(dateObj, month) {
      dateObj.setMonth(parseFloat(month) - 1);
    },
    s: function(dateObj, seconds) {
      dateObj.setSeconds(parseFloat(seconds));
    },
    u: function(_2, unixMillSeconds) {
      return new Date(parseFloat(unixMillSeconds));
    },
    w: doNothing,
    y: function(dateObj, year) {
      dateObj.setFullYear(2e3 + parseFloat(year));
    }
  };
  var tokenRegex = {
    D: "",
    F: "",
    G: "(\\d\\d|\\d)",
    H: "(\\d\\d|\\d)",
    J: "(\\d\\d|\\d)\\w+",
    K: "",
    M: "",
    S: "(\\d\\d|\\d)",
    U: "(.+)",
    W: "(\\d\\d|\\d)",
    Y: "(\\d{4})",
    Z: "(.+)",
    d: "(\\d\\d|\\d)",
    h: "(\\d\\d|\\d)",
    i: "(\\d\\d|\\d)",
    j: "(\\d\\d|\\d)",
    l: "",
    m: "(\\d\\d|\\d)",
    n: "(\\d\\d|\\d)",
    s: "(\\d\\d|\\d)",
    u: "(.+)",
    w: "(\\d\\d|\\d)",
    y: "(\\d{2})"
  };
  var formats = {
    Z: function(date) {
      return date.toISOString();
    },
    D: function(date, locale, options) {
      return locale.weekdays.shorthand[formats.w(date, locale, options)];
    },
    F: function(date, locale, options) {
      return monthToStr(formats.n(date, locale, options) - 1, false, locale);
    },
    G: function(date, locale, options) {
      return pad(formats.h(date, locale, options));
    },
    H: function(date) {
      return pad(date.getHours());
    },
    J: function(date, locale) {
      return locale.ordinal !== void 0 ? date.getDate() + locale.ordinal(date.getDate()) : date.getDate();
    },
    K: function(date, locale) {
      return locale.amPM[int(date.getHours() > 11)];
    },
    M: function(date, locale) {
      return monthToStr(date.getMonth(), true, locale);
    },
    S: function(date) {
      return pad(date.getSeconds());
    },
    U: function(date) {
      return date.getTime() / 1e3;
    },
    W: function(date, _2, options) {
      return options.getWeek(date);
    },
    Y: function(date) {
      return pad(date.getFullYear(), 4);
    },
    d: function(date) {
      return pad(date.getDate());
    },
    h: function(date) {
      return date.getHours() % 12 ? date.getHours() % 12 : 12;
    },
    i: function(date) {
      return pad(date.getMinutes());
    },
    j: function(date) {
      return date.getDate();
    },
    l: function(date, locale) {
      return locale.weekdays.longhand[date.getDay()];
    },
    m: function(date) {
      return pad(date.getMonth() + 1);
    },
    n: function(date) {
      return date.getMonth() + 1;
    },
    s: function(date) {
      return date.getSeconds();
    },
    u: function(date) {
      return date.getTime();
    },
    w: function(date) {
      return date.getDay();
    },
    y: function(date) {
      return String(date.getFullYear()).substring(2);
    }
  };

  // node_modules/flatpickr/dist/esm/utils/dates.js
  var createDateFormatter = /* @__PURE__ */ __name(function(_a) {
    var _b = _a.config, config4 = _b === void 0 ? defaults : _b, _c = _a.l10n, l10n = _c === void 0 ? english : _c, _d = _a.isMobile, isMobile = _d === void 0 ? false : _d;
    return function(dateObj, frmt, overrideLocale) {
      var locale = overrideLocale || l10n;
      if (config4.formatDate !== void 0 && !isMobile) {
        return config4.formatDate(dateObj, frmt, locale);
      }
      return frmt.split("").map(function(c2, i2, arr) {
        return formats[c2] && arr[i2 - 1] !== "\\" ? formats[c2](dateObj, locale, config4) : c2 !== "\\" ? c2 : "";
      }).join("");
    };
  }, "createDateFormatter");
  var createDateParser = /* @__PURE__ */ __name(function(_a) {
    var _b = _a.config, config4 = _b === void 0 ? defaults : _b, _c = _a.l10n, l10n = _c === void 0 ? english : _c;
    return function(date, givenFormat, timeless, customLocale) {
      if (date !== 0 && !date)
        return void 0;
      var locale = customLocale || l10n;
      var parsedDate;
      var dateOrig = date;
      if (date instanceof Date)
        parsedDate = new Date(date.getTime());
      else if (typeof date !== "string" && date.toFixed !== void 0)
        parsedDate = new Date(date);
      else if (typeof date === "string") {
        var format = givenFormat || (config4 || defaults).dateFormat;
        var datestr = String(date).trim();
        if (datestr === "today") {
          parsedDate = /* @__PURE__ */ new Date();
          timeless = true;
        } else if (config4 && config4.parseDate) {
          parsedDate = config4.parseDate(date, format);
        } else if (/Z$/.test(datestr) || /GMT$/.test(datestr)) {
          parsedDate = new Date(date);
        } else {
          var matched = void 0, ops = [];
          for (var i2 = 0, matchIndex = 0, regexStr = ""; i2 < format.length; i2++) {
            var token = format[i2];
            var isBackSlash = token === "\\";
            var escaped = format[i2 - 1] === "\\" || isBackSlash;
            if (tokenRegex[token] && !escaped) {
              regexStr += tokenRegex[token];
              var match2 = new RegExp(regexStr).exec(date);
              if (match2 && (matched = true)) {
                ops[token !== "Y" ? "push" : "unshift"]({
                  fn: revFormat[token],
                  val: match2[++matchIndex]
                });
              }
            } else if (!isBackSlash)
              regexStr += ".";
          }
          parsedDate = !config4 || !config4.noCalendar ? new Date((/* @__PURE__ */ new Date()).getFullYear(), 0, 1, 0, 0, 0, 0) : new Date((/* @__PURE__ */ new Date()).setHours(0, 0, 0, 0));
          ops.forEach(function(_a2) {
            var fn = _a2.fn, val = _a2.val;
            return parsedDate = fn(parsedDate, val, locale) || parsedDate;
          });
          parsedDate = matched ? parsedDate : void 0;
        }
      }
      if (!(parsedDate instanceof Date && !isNaN(parsedDate.getTime()))) {
        config4.errorHandler(new Error("Invalid date provided: " + dateOrig));
        return void 0;
      }
      if (timeless === true)
        parsedDate.setHours(0, 0, 0, 0);
      return parsedDate;
    };
  }, "createDateParser");
  function compareDates(date1, date2, timeless) {
    if (timeless === void 0) {
      timeless = true;
    }
    if (timeless !== false) {
      return new Date(date1.getTime()).setHours(0, 0, 0, 0) - new Date(date2.getTime()).setHours(0, 0, 0, 0);
    }
    return date1.getTime() - date2.getTime();
  }
  __name(compareDates, "compareDates");
  var isBetween = /* @__PURE__ */ __name(function(ts, ts1, ts2) {
    return ts > Math.min(ts1, ts2) && ts < Math.max(ts1, ts2);
  }, "isBetween");
  var calculateSecondsSinceMidnight = /* @__PURE__ */ __name(function(hours, minutes, seconds) {
    return hours * 3600 + minutes * 60 + seconds;
  }, "calculateSecondsSinceMidnight");
  var parseSeconds = /* @__PURE__ */ __name(function(secondsSinceMidnight) {
    var hours = Math.floor(secondsSinceMidnight / 3600), minutes = (secondsSinceMidnight - hours * 3600) / 60;
    return [hours, minutes, secondsSinceMidnight - hours * 3600 - minutes * 60];
  }, "parseSeconds");
  var duration = {
    DAY: 864e5
  };
  function getDefaultHours(config4) {
    var hours = config4.defaultHour;
    var minutes = config4.defaultMinute;
    var seconds = config4.defaultSeconds;
    if (config4.minDate !== void 0) {
      var minHour = config4.minDate.getHours();
      var minMinutes = config4.minDate.getMinutes();
      var minSeconds = config4.minDate.getSeconds();
      if (hours < minHour) {
        hours = minHour;
      }
      if (hours === minHour && minutes < minMinutes) {
        minutes = minMinutes;
      }
      if (hours === minHour && minutes === minMinutes && seconds < minSeconds)
        seconds = config4.minDate.getSeconds();
    }
    if (config4.maxDate !== void 0) {
      var maxHr = config4.maxDate.getHours();
      var maxMinutes = config4.maxDate.getMinutes();
      hours = Math.min(hours, maxHr);
      if (hours === maxHr)
        minutes = Math.min(maxMinutes, minutes);
      if (hours === maxHr && minutes === maxMinutes)
        seconds = config4.maxDate.getSeconds();
    }
    return { hours, minutes, seconds };
  }
  __name(getDefaultHours, "getDefaultHours");

  // node_modules/flatpickr/dist/esm/utils/polyfills.js
  if (typeof Object.assign !== "function") {
    Object.assign = function(target) {
      var args = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
      }
      if (!target) {
        throw TypeError("Cannot convert undefined or null to object");
      }
      var _loop_1 = /* @__PURE__ */ __name(function(source2) {
        if (source2) {
          Object.keys(source2).forEach(function(key) {
            return target[key] = source2[key];
          });
        }
      }, "_loop_1");
      for (var _a = 0, args_1 = args; _a < args_1.length; _a++) {
        var source = args_1[_a];
        _loop_1(source);
      }
      return target;
    };
  }

  // node_modules/flatpickr/dist/esm/index.js
  var __assign = function() {
    __assign = Object.assign || function(t2) {
      for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
        s2 = arguments[i2];
        for (var p2 in s2)
          if (Object.prototype.hasOwnProperty.call(s2, p2))
            t2[p2] = s2[p2];
      }
      return t2;
    };
    return __assign.apply(this, arguments);
  };
  var __spreadArrays = function() {
    for (var s2 = 0, i2 = 0, il = arguments.length; i2 < il; i2++)
      s2 += arguments[i2].length;
    for (var r2 = Array(s2), k2 = 0, i2 = 0; i2 < il; i2++)
      for (var a2 = arguments[i2], j2 = 0, jl = a2.length; j2 < jl; j2++, k2++)
        r2[k2] = a2[j2];
    return r2;
  };
  var DEBOUNCED_CHANGE_MS = 300;
  function FlatpickrInstance(element, instanceConfig) {
    var self2 = {
      config: __assign(__assign({}, defaults), flatpickr.defaultConfig),
      l10n: default_default
    };
    self2.parseDate = createDateParser({ config: self2.config, l10n: self2.l10n });
    self2._handlers = [];
    self2.pluginElements = [];
    self2.loadedPlugins = [];
    self2._bind = bind;
    self2._setHoursFromDate = setHoursFromDate;
    self2._positionCalendar = positionCalendar;
    self2.changeMonth = changeMonth;
    self2.changeYear = changeYear;
    self2.clear = clear;
    self2.close = close;
    self2.onMouseOver = onMouseOver;
    self2._createElement = createElement;
    self2.createDay = createDay;
    self2.destroy = destroy;
    self2.isEnabled = isEnabled;
    self2.jumpToDate = jumpToDate;
    self2.updateValue = updateValue;
    self2.open = open;
    self2.redraw = redraw;
    self2.set = set;
    self2.setDate = setDate;
    self2.toggle = toggle;
    function setupHelperFunctions() {
      self2.utils = {
        getDaysInMonth: function(month, yr) {
          if (month === void 0) {
            month = self2.currentMonth;
          }
          if (yr === void 0) {
            yr = self2.currentYear;
          }
          if (month === 1 && (yr % 4 === 0 && yr % 100 !== 0 || yr % 400 === 0))
            return 29;
          return self2.l10n.daysInMonth[month];
        }
      };
    }
    __name(setupHelperFunctions, "setupHelperFunctions");
    function init2() {
      self2.element = self2.input = element;
      self2.isOpen = false;
      parseConfig();
      setupLocale();
      setupInputs();
      setupDates();
      setupHelperFunctions();
      if (!self2.isMobile)
        build();
      bindEvents();
      if (self2.selectedDates.length || self2.config.noCalendar) {
        if (self2.config.enableTime) {
          setHoursFromDate(self2.config.noCalendar ? self2.latestSelectedDateObj : void 0);
        }
        updateValue(false);
      }
      setCalendarWidth();
      var isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
      if (!self2.isMobile && isSafari) {
        positionCalendar();
      }
      triggerEvent("onReady");
    }
    __name(init2, "init");
    function getClosestActiveElement() {
      var _a;
      return ((_a = self2.calendarContainer) === null || _a === void 0 ? void 0 : _a.getRootNode()).activeElement || document.activeElement;
    }
    __name(getClosestActiveElement, "getClosestActiveElement");
    function bindToInstance(fn) {
      return fn.bind(self2);
    }
    __name(bindToInstance, "bindToInstance");
    function setCalendarWidth() {
      var config4 = self2.config;
      if (config4.weekNumbers === false && config4.showMonths === 1) {
        return;
      } else if (config4.noCalendar !== true) {
        window.requestAnimationFrame(function() {
          if (self2.calendarContainer !== void 0) {
            self2.calendarContainer.style.visibility = "hidden";
            self2.calendarContainer.style.display = "block";
          }
          if (self2.daysContainer !== void 0) {
            var daysWidth = (self2.days.offsetWidth + 1) * config4.showMonths;
            self2.daysContainer.style.width = daysWidth + "px";
            self2.calendarContainer.style.width = daysWidth + (self2.weekWrapper !== void 0 ? self2.weekWrapper.offsetWidth : 0) + "px";
            self2.calendarContainer.style.removeProperty("visibility");
            self2.calendarContainer.style.removeProperty("display");
          }
        });
      }
    }
    __name(setCalendarWidth, "setCalendarWidth");
    function updateTime(e2) {
      if (self2.selectedDates.length === 0) {
        var defaultDate = self2.config.minDate === void 0 || compareDates(/* @__PURE__ */ new Date(), self2.config.minDate) >= 0 ? /* @__PURE__ */ new Date() : new Date(self2.config.minDate.getTime());
        var defaults2 = getDefaultHours(self2.config);
        defaultDate.setHours(defaults2.hours, defaults2.minutes, defaults2.seconds, defaultDate.getMilliseconds());
        self2.selectedDates = [defaultDate];
        self2.latestSelectedDateObj = defaultDate;
      }
      if (e2 !== void 0 && e2.type !== "blur") {
        timeWrapper(e2);
      }
      var prevValue = self2._input.value;
      setHoursFromInputs();
      updateValue();
      if (self2._input.value !== prevValue) {
        self2._debouncedChange();
      }
    }
    __name(updateTime, "updateTime");
    function ampm2military(hour, amPM) {
      return hour % 12 + 12 * int(amPM === self2.l10n.amPM[1]);
    }
    __name(ampm2military, "ampm2military");
    function military2ampm(hour) {
      switch (hour % 24) {
        case 0:
        case 12:
          return 12;
        default:
          return hour % 12;
      }
    }
    __name(military2ampm, "military2ampm");
    function setHoursFromInputs() {
      if (self2.hourElement === void 0 || self2.minuteElement === void 0)
        return;
      var hours = (parseInt(self2.hourElement.value.slice(-2), 10) || 0) % 24, minutes = (parseInt(self2.minuteElement.value, 10) || 0) % 60, seconds = self2.secondElement !== void 0 ? (parseInt(self2.secondElement.value, 10) || 0) % 60 : 0;
      if (self2.amPM !== void 0) {
        hours = ampm2military(hours, self2.amPM.textContent);
      }
      var limitMinHours = self2.config.minTime !== void 0 || self2.config.minDate && self2.minDateHasTime && self2.latestSelectedDateObj && compareDates(self2.latestSelectedDateObj, self2.config.minDate, true) === 0;
      var limitMaxHours = self2.config.maxTime !== void 0 || self2.config.maxDate && self2.maxDateHasTime && self2.latestSelectedDateObj && compareDates(self2.latestSelectedDateObj, self2.config.maxDate, true) === 0;
      if (self2.config.maxTime !== void 0 && self2.config.minTime !== void 0 && self2.config.minTime > self2.config.maxTime) {
        var minBound = calculateSecondsSinceMidnight(self2.config.minTime.getHours(), self2.config.minTime.getMinutes(), self2.config.minTime.getSeconds());
        var maxBound = calculateSecondsSinceMidnight(self2.config.maxTime.getHours(), self2.config.maxTime.getMinutes(), self2.config.maxTime.getSeconds());
        var currentTime = calculateSecondsSinceMidnight(hours, minutes, seconds);
        if (currentTime > maxBound && currentTime < minBound) {
          var result = parseSeconds(minBound);
          hours = result[0];
          minutes = result[1];
          seconds = result[2];
        }
      } else {
        if (limitMaxHours) {
          var maxTime = self2.config.maxTime !== void 0 ? self2.config.maxTime : self2.config.maxDate;
          hours = Math.min(hours, maxTime.getHours());
          if (hours === maxTime.getHours())
            minutes = Math.min(minutes, maxTime.getMinutes());
          if (minutes === maxTime.getMinutes())
            seconds = Math.min(seconds, maxTime.getSeconds());
        }
        if (limitMinHours) {
          var minTime = self2.config.minTime !== void 0 ? self2.config.minTime : self2.config.minDate;
          hours = Math.max(hours, minTime.getHours());
          if (hours === minTime.getHours() && minutes < minTime.getMinutes())
            minutes = minTime.getMinutes();
          if (minutes === minTime.getMinutes())
            seconds = Math.max(seconds, minTime.getSeconds());
        }
      }
      setHours(hours, minutes, seconds);
    }
    __name(setHoursFromInputs, "setHoursFromInputs");
    function setHoursFromDate(dateObj) {
      var date = dateObj || self2.latestSelectedDateObj;
      if (date && date instanceof Date) {
        setHours(date.getHours(), date.getMinutes(), date.getSeconds());
      }
    }
    __name(setHoursFromDate, "setHoursFromDate");
    function setHours(hours, minutes, seconds) {
      if (self2.latestSelectedDateObj !== void 0) {
        self2.latestSelectedDateObj.setHours(hours % 24, minutes, seconds || 0, 0);
      }
      if (!self2.hourElement || !self2.minuteElement || self2.isMobile)
        return;
      self2.hourElement.value = pad(!self2.config.time_24hr ? (12 + hours) % 12 + 12 * int(hours % 12 === 0) : hours);
      self2.minuteElement.value = pad(minutes);
      if (self2.amPM !== void 0)
        self2.amPM.textContent = self2.l10n.amPM[int(hours >= 12)];
      if (self2.secondElement !== void 0)
        self2.secondElement.value = pad(seconds);
    }
    __name(setHours, "setHours");
    function onYearInput(event) {
      var eventTarget = getEventTarget(event);
      var year = parseInt(eventTarget.value) + (event.delta || 0);
      if (year / 1e3 > 1 || event.key === "Enter" && !/[^\d]/.test(year.toString())) {
        changeYear(year);
      }
    }
    __name(onYearInput, "onYearInput");
    function bind(element2, event, handler, options) {
      if (event instanceof Array)
        return event.forEach(function(ev) {
          return bind(element2, ev, handler, options);
        });
      if (element2 instanceof Array)
        return element2.forEach(function(el) {
          return bind(el, event, handler, options);
        });
      element2.addEventListener(event, handler, options);
      self2._handlers.push({
        remove: function() {
          return element2.removeEventListener(event, handler, options);
        }
      });
    }
    __name(bind, "bind");
    function triggerChange() {
      triggerEvent("onChange");
    }
    __name(triggerChange, "triggerChange");
    function bindEvents() {
      if (self2.config.wrap) {
        ["open", "close", "toggle", "clear"].forEach(function(evt) {
          Array.prototype.forEach.call(self2.element.querySelectorAll("[data-" + evt + "]"), function(el) {
            return bind(el, "click", self2[evt]);
          });
        });
      }
      if (self2.isMobile) {
        setupMobile();
        return;
      }
      var debouncedResize = debounce3(onResize, 50);
      self2._debouncedChange = debounce3(triggerChange, DEBOUNCED_CHANGE_MS);
      if (self2.daysContainer && !/iPhone|iPad|iPod/i.test(navigator.userAgent))
        bind(self2.daysContainer, "mouseover", function(e2) {
          if (self2.config.mode === "range")
            onMouseOver(getEventTarget(e2));
        });
      bind(self2._input, "keydown", onKeyDown);
      if (self2.calendarContainer !== void 0) {
        bind(self2.calendarContainer, "keydown", onKeyDown);
      }
      if (!self2.config.inline && !self2.config.static)
        bind(window, "resize", debouncedResize);
      if (window.ontouchstart !== void 0)
        bind(window.document, "touchstart", documentClick);
      else
        bind(window.document, "mousedown", documentClick);
      bind(window.document, "focus", documentClick, { capture: true });
      if (self2.config.clickOpens === true) {
        bind(self2._input, "focus", self2.open);
        bind(self2._input, "click", self2.open);
      }
      if (self2.daysContainer !== void 0) {
        bind(self2.monthNav, "click", onMonthNavClick);
        bind(self2.monthNav, ["keyup", "increment"], onYearInput);
        bind(self2.daysContainer, "click", selectDate);
      }
      if (self2.timeContainer !== void 0 && self2.minuteElement !== void 0 && self2.hourElement !== void 0) {
        var selText = /* @__PURE__ */ __name(function(e2) {
          return getEventTarget(e2).select();
        }, "selText");
        bind(self2.timeContainer, ["increment"], updateTime);
        bind(self2.timeContainer, "blur", updateTime, { capture: true });
        bind(self2.timeContainer, "click", timeIncrement);
        bind([self2.hourElement, self2.minuteElement], ["focus", "click"], selText);
        if (self2.secondElement !== void 0)
          bind(self2.secondElement, "focus", function() {
            return self2.secondElement && self2.secondElement.select();
          });
        if (self2.amPM !== void 0) {
          bind(self2.amPM, "click", function(e2) {
            updateTime(e2);
          });
        }
      }
      if (self2.config.allowInput) {
        bind(self2._input, "blur", onBlur);
      }
    }
    __name(bindEvents, "bindEvents");
    function jumpToDate(jumpDate, triggerChange2) {
      var jumpTo = jumpDate !== void 0 ? self2.parseDate(jumpDate) : self2.latestSelectedDateObj || (self2.config.minDate && self2.config.minDate > self2.now ? self2.config.minDate : self2.config.maxDate && self2.config.maxDate < self2.now ? self2.config.maxDate : self2.now);
      var oldYear = self2.currentYear;
      var oldMonth = self2.currentMonth;
      try {
        if (jumpTo !== void 0) {
          self2.currentYear = jumpTo.getFullYear();
          self2.currentMonth = jumpTo.getMonth();
        }
      } catch (e2) {
        e2.message = "Invalid date supplied: " + jumpTo;
        self2.config.errorHandler(e2);
      }
      if (triggerChange2 && self2.currentYear !== oldYear) {
        triggerEvent("onYearChange");
        buildMonthSwitch();
      }
      if (triggerChange2 && (self2.currentYear !== oldYear || self2.currentMonth !== oldMonth)) {
        triggerEvent("onMonthChange");
      }
      self2.redraw();
    }
    __name(jumpToDate, "jumpToDate");
    function timeIncrement(e2) {
      var eventTarget = getEventTarget(e2);
      if (~eventTarget.className.indexOf("arrow"))
        incrementNumInput(e2, eventTarget.classList.contains("arrowUp") ? 1 : -1);
    }
    __name(timeIncrement, "timeIncrement");
    function incrementNumInput(e2, delta, inputElem) {
      var target = e2 && getEventTarget(e2);
      var input = inputElem || target && target.parentNode && target.parentNode.firstChild;
      var event = createEvent("increment");
      event.delta = delta;
      input && input.dispatchEvent(event);
    }
    __name(incrementNumInput, "incrementNumInput");
    function build() {
      var fragment = window.document.createDocumentFragment();
      self2.calendarContainer = createElement("div", "flatpickr-calendar");
      self2.calendarContainer.tabIndex = -1;
      if (!self2.config.noCalendar) {
        fragment.appendChild(buildMonthNav());
        self2.innerContainer = createElement("div", "flatpickr-innerContainer");
        if (self2.config.weekNumbers) {
          var _a = buildWeeks(), weekWrapper = _a.weekWrapper, weekNumbers = _a.weekNumbers;
          self2.innerContainer.appendChild(weekWrapper);
          self2.weekNumbers = weekNumbers;
          self2.weekWrapper = weekWrapper;
        }
        self2.rContainer = createElement("div", "flatpickr-rContainer");
        self2.rContainer.appendChild(buildWeekdays());
        if (!self2.daysContainer) {
          self2.daysContainer = createElement("div", "flatpickr-days");
          self2.daysContainer.tabIndex = -1;
        }
        buildDays();
        self2.rContainer.appendChild(self2.daysContainer);
        self2.innerContainer.appendChild(self2.rContainer);
        fragment.appendChild(self2.innerContainer);
      }
      if (self2.config.enableTime) {
        fragment.appendChild(buildTime());
      }
      toggleClass(self2.calendarContainer, "rangeMode", self2.config.mode === "range");
      toggleClass(self2.calendarContainer, "animate", self2.config.animate === true);
      toggleClass(self2.calendarContainer, "multiMonth", self2.config.showMonths > 1);
      self2.calendarContainer.appendChild(fragment);
      var customAppend = self2.config.appendTo !== void 0 && self2.config.appendTo.nodeType !== void 0;
      if (self2.config.inline || self2.config.static) {
        self2.calendarContainer.classList.add(self2.config.inline ? "inline" : "static");
        if (self2.config.inline) {
          if (!customAppend && self2.element.parentNode)
            self2.element.parentNode.insertBefore(self2.calendarContainer, self2._input.nextSibling);
          else if (self2.config.appendTo !== void 0)
            self2.config.appendTo.appendChild(self2.calendarContainer);
        }
        if (self2.config.static) {
          var wrapper = createElement("div", "flatpickr-wrapper");
          if (self2.element.parentNode)
            self2.element.parentNode.insertBefore(wrapper, self2.element);
          wrapper.appendChild(self2.element);
          if (self2.altInput)
            wrapper.appendChild(self2.altInput);
          wrapper.appendChild(self2.calendarContainer);
        }
      }
      if (!self2.config.static && !self2.config.inline)
        (self2.config.appendTo !== void 0 ? self2.config.appendTo : window.document.body).appendChild(self2.calendarContainer);
    }
    __name(build, "build");
    function createDay(className, date, _dayNumber, i2) {
      var dateIsEnabled = isEnabled(date, true), dayElement = createElement("span", className, date.getDate().toString());
      dayElement.dateObj = date;
      dayElement.$i = i2;
      dayElement.setAttribute("aria-label", self2.formatDate(date, self2.config.ariaDateFormat));
      if (className.indexOf("hidden") === -1 && compareDates(date, self2.now) === 0) {
        self2.todayDateElem = dayElement;
        dayElement.classList.add("today");
        dayElement.setAttribute("aria-current", "date");
      }
      if (dateIsEnabled) {
        dayElement.tabIndex = -1;
        if (isDateSelected(date)) {
          dayElement.classList.add("selected");
          self2.selectedDateElem = dayElement;
          if (self2.config.mode === "range") {
            toggleClass(dayElement, "startRange", self2.selectedDates[0] && compareDates(date, self2.selectedDates[0], true) === 0);
            toggleClass(dayElement, "endRange", self2.selectedDates[1] && compareDates(date, self2.selectedDates[1], true) === 0);
            if (className === "nextMonthDay")
              dayElement.classList.add("inRange");
          }
        }
      } else {
        dayElement.classList.add("flatpickr-disabled");
      }
      if (self2.config.mode === "range") {
        if (isDateInRange(date) && !isDateSelected(date))
          dayElement.classList.add("inRange");
      }
      if (self2.weekNumbers && self2.config.showMonths === 1 && className !== "prevMonthDay" && i2 % 7 === 6) {
        self2.weekNumbers.insertAdjacentHTML("beforeend", "<span class='flatpickr-day'>" + self2.config.getWeek(date) + "</span>");
      }
      triggerEvent("onDayCreate", dayElement);
      return dayElement;
    }
    __name(createDay, "createDay");
    function focusOnDayElem(targetNode) {
      targetNode.focus();
      if (self2.config.mode === "range")
        onMouseOver(targetNode);
    }
    __name(focusOnDayElem, "focusOnDayElem");
    function getFirstAvailableDay(delta) {
      var startMonth = delta > 0 ? 0 : self2.config.showMonths - 1;
      var endMonth = delta > 0 ? self2.config.showMonths : -1;
      for (var m2 = startMonth; m2 != endMonth; m2 += delta) {
        var month = self2.daysContainer.children[m2];
        var startIndex = delta > 0 ? 0 : month.children.length - 1;
        var endIndex = delta > 0 ? month.children.length : -1;
        for (var i2 = startIndex; i2 != endIndex; i2 += delta) {
          var c2 = month.children[i2];
          if (c2.className.indexOf("hidden") === -1 && isEnabled(c2.dateObj))
            return c2;
        }
      }
      return void 0;
    }
    __name(getFirstAvailableDay, "getFirstAvailableDay");
    function getNextAvailableDay(current, delta) {
      var givenMonth = current.className.indexOf("Month") === -1 ? current.dateObj.getMonth() : self2.currentMonth;
      var endMonth = delta > 0 ? self2.config.showMonths : -1;
      var loopDelta = delta > 0 ? 1 : -1;
      for (var m2 = givenMonth - self2.currentMonth; m2 != endMonth; m2 += loopDelta) {
        var month = self2.daysContainer.children[m2];
        var startIndex = givenMonth - self2.currentMonth === m2 ? current.$i + delta : delta < 0 ? month.children.length - 1 : 0;
        var numMonthDays = month.children.length;
        for (var i2 = startIndex; i2 >= 0 && i2 < numMonthDays && i2 != (delta > 0 ? numMonthDays : -1); i2 += loopDelta) {
          var c2 = month.children[i2];
          if (c2.className.indexOf("hidden") === -1 && isEnabled(c2.dateObj) && Math.abs(current.$i - i2) >= Math.abs(delta))
            return focusOnDayElem(c2);
        }
      }
      self2.changeMonth(loopDelta);
      focusOnDay(getFirstAvailableDay(loopDelta), 0);
      return void 0;
    }
    __name(getNextAvailableDay, "getNextAvailableDay");
    function focusOnDay(current, offset) {
      var activeElement = getClosestActiveElement();
      var dayFocused = isInView(activeElement || document.body);
      var startElem = current !== void 0 ? current : dayFocused ? activeElement : self2.selectedDateElem !== void 0 && isInView(self2.selectedDateElem) ? self2.selectedDateElem : self2.todayDateElem !== void 0 && isInView(self2.todayDateElem) ? self2.todayDateElem : getFirstAvailableDay(offset > 0 ? 1 : -1);
      if (startElem === void 0) {
        self2._input.focus();
      } else if (!dayFocused) {
        focusOnDayElem(startElem);
      } else {
        getNextAvailableDay(startElem, offset);
      }
    }
    __name(focusOnDay, "focusOnDay");
    function buildMonthDays(year, month) {
      var firstOfMonth = (new Date(year, month, 1).getDay() - self2.l10n.firstDayOfWeek + 7) % 7;
      var prevMonthDays = self2.utils.getDaysInMonth((month - 1 + 12) % 12, year);
      var daysInMonth = self2.utils.getDaysInMonth(month, year), days = window.document.createDocumentFragment(), isMultiMonth = self2.config.showMonths > 1, prevMonthDayClass = isMultiMonth ? "prevMonthDay hidden" : "prevMonthDay", nextMonthDayClass = isMultiMonth ? "nextMonthDay hidden" : "nextMonthDay";
      var dayNumber = prevMonthDays + 1 - firstOfMonth, dayIndex = 0;
      for (; dayNumber <= prevMonthDays; dayNumber++, dayIndex++) {
        days.appendChild(createDay("flatpickr-day " + prevMonthDayClass, new Date(year, month - 1, dayNumber), dayNumber, dayIndex));
      }
      for (dayNumber = 1; dayNumber <= daysInMonth; dayNumber++, dayIndex++) {
        days.appendChild(createDay("flatpickr-day", new Date(year, month, dayNumber), dayNumber, dayIndex));
      }
      for (var dayNum = daysInMonth + 1; dayNum <= 42 - firstOfMonth && (self2.config.showMonths === 1 || dayIndex % 7 !== 0); dayNum++, dayIndex++) {
        days.appendChild(createDay("flatpickr-day " + nextMonthDayClass, new Date(year, month + 1, dayNum % daysInMonth), dayNum, dayIndex));
      }
      var dayContainer = createElement("div", "dayContainer");
      dayContainer.appendChild(days);
      return dayContainer;
    }
    __name(buildMonthDays, "buildMonthDays");
    function buildDays() {
      if (self2.daysContainer === void 0) {
        return;
      }
      clearNode(self2.daysContainer);
      if (self2.weekNumbers)
        clearNode(self2.weekNumbers);
      var frag = document.createDocumentFragment();
      for (var i2 = 0; i2 < self2.config.showMonths; i2++) {
        var d2 = new Date(self2.currentYear, self2.currentMonth, 1);
        d2.setMonth(self2.currentMonth + i2);
        frag.appendChild(buildMonthDays(d2.getFullYear(), d2.getMonth()));
      }
      self2.daysContainer.appendChild(frag);
      self2.days = self2.daysContainer.firstChild;
      if (self2.config.mode === "range" && self2.selectedDates.length === 1) {
        onMouseOver();
      }
    }
    __name(buildDays, "buildDays");
    function buildMonthSwitch() {
      if (self2.config.showMonths > 1 || self2.config.monthSelectorType !== "dropdown")
        return;
      var shouldBuildMonth = /* @__PURE__ */ __name(function(month2) {
        if (self2.config.minDate !== void 0 && self2.currentYear === self2.config.minDate.getFullYear() && month2 < self2.config.minDate.getMonth()) {
          return false;
        }
        return !(self2.config.maxDate !== void 0 && self2.currentYear === self2.config.maxDate.getFullYear() && month2 > self2.config.maxDate.getMonth());
      }, "shouldBuildMonth");
      self2.monthsDropdownContainer.tabIndex = -1;
      self2.monthsDropdownContainer.innerHTML = "";
      for (var i2 = 0; i2 < 12; i2++) {
        if (!shouldBuildMonth(i2))
          continue;
        var month = createElement("option", "flatpickr-monthDropdown-month");
        month.value = new Date(self2.currentYear, i2).getMonth().toString();
        month.textContent = monthToStr(i2, self2.config.shorthandCurrentMonth, self2.l10n);
        month.tabIndex = -1;
        if (self2.currentMonth === i2) {
          month.selected = true;
        }
        self2.monthsDropdownContainer.appendChild(month);
      }
    }
    __name(buildMonthSwitch, "buildMonthSwitch");
    function buildMonth() {
      var container = createElement("div", "flatpickr-month");
      var monthNavFragment = window.document.createDocumentFragment();
      var monthElement;
      if (self2.config.showMonths > 1 || self2.config.monthSelectorType === "static") {
        monthElement = createElement("span", "cur-month");
      } else {
        self2.monthsDropdownContainer = createElement("select", "flatpickr-monthDropdown-months");
        self2.monthsDropdownContainer.setAttribute("aria-label", self2.l10n.monthAriaLabel);
        bind(self2.monthsDropdownContainer, "change", function(e2) {
          var target = getEventTarget(e2);
          var selectedMonth = parseInt(target.value, 10);
          self2.changeMonth(selectedMonth - self2.currentMonth);
          triggerEvent("onMonthChange");
        });
        buildMonthSwitch();
        monthElement = self2.monthsDropdownContainer;
      }
      var yearInput = createNumberInput("cur-year", { tabindex: "-1" });
      var yearElement = yearInput.getElementsByTagName("input")[0];
      yearElement.setAttribute("aria-label", self2.l10n.yearAriaLabel);
      if (self2.config.minDate) {
        yearElement.setAttribute("min", self2.config.minDate.getFullYear().toString());
      }
      if (self2.config.maxDate) {
        yearElement.setAttribute("max", self2.config.maxDate.getFullYear().toString());
        yearElement.disabled = !!self2.config.minDate && self2.config.minDate.getFullYear() === self2.config.maxDate.getFullYear();
      }
      var currentMonth = createElement("div", "flatpickr-current-month");
      currentMonth.appendChild(monthElement);
      currentMonth.appendChild(yearInput);
      monthNavFragment.appendChild(currentMonth);
      container.appendChild(monthNavFragment);
      return {
        container,
        yearElement,
        monthElement
      };
    }
    __name(buildMonth, "buildMonth");
    function buildMonths() {
      clearNode(self2.monthNav);
      self2.monthNav.appendChild(self2.prevMonthNav);
      if (self2.config.showMonths) {
        self2.yearElements = [];
        self2.monthElements = [];
      }
      for (var m2 = self2.config.showMonths; m2--; ) {
        var month = buildMonth();
        self2.yearElements.push(month.yearElement);
        self2.monthElements.push(month.monthElement);
        self2.monthNav.appendChild(month.container);
      }
      self2.monthNav.appendChild(self2.nextMonthNav);
    }
    __name(buildMonths, "buildMonths");
    function buildMonthNav() {
      self2.monthNav = createElement("div", "flatpickr-months");
      self2.yearElements = [];
      self2.monthElements = [];
      self2.prevMonthNav = createElement("span", "flatpickr-prev-month");
      self2.prevMonthNav.innerHTML = self2.config.prevArrow;
      self2.nextMonthNav = createElement("span", "flatpickr-next-month");
      self2.nextMonthNav.innerHTML = self2.config.nextArrow;
      buildMonths();
      Object.defineProperty(self2, "_hidePrevMonthArrow", {
        get: function() {
          return self2.__hidePrevMonthArrow;
        },
        set: function(bool) {
          if (self2.__hidePrevMonthArrow !== bool) {
            toggleClass(self2.prevMonthNav, "flatpickr-disabled", bool);
            self2.__hidePrevMonthArrow = bool;
          }
        }
      });
      Object.defineProperty(self2, "_hideNextMonthArrow", {
        get: function() {
          return self2.__hideNextMonthArrow;
        },
        set: function(bool) {
          if (self2.__hideNextMonthArrow !== bool) {
            toggleClass(self2.nextMonthNav, "flatpickr-disabled", bool);
            self2.__hideNextMonthArrow = bool;
          }
        }
      });
      self2.currentYearElement = self2.yearElements[0];
      updateNavigationCurrentMonth();
      return self2.monthNav;
    }
    __name(buildMonthNav, "buildMonthNav");
    function buildTime() {
      self2.calendarContainer.classList.add("hasTime");
      if (self2.config.noCalendar)
        self2.calendarContainer.classList.add("noCalendar");
      var defaults2 = getDefaultHours(self2.config);
      self2.timeContainer = createElement("div", "flatpickr-time");
      self2.timeContainer.tabIndex = -1;
      var separator = createElement("span", "flatpickr-time-separator", ":");
      var hourInput = createNumberInput("flatpickr-hour", {
        "aria-label": self2.l10n.hourAriaLabel
      });
      self2.hourElement = hourInput.getElementsByTagName("input")[0];
      var minuteInput = createNumberInput("flatpickr-minute", {
        "aria-label": self2.l10n.minuteAriaLabel
      });
      self2.minuteElement = minuteInput.getElementsByTagName("input")[0];
      self2.hourElement.tabIndex = self2.minuteElement.tabIndex = -1;
      self2.hourElement.value = pad(self2.latestSelectedDateObj ? self2.latestSelectedDateObj.getHours() : self2.config.time_24hr ? defaults2.hours : military2ampm(defaults2.hours));
      self2.minuteElement.value = pad(self2.latestSelectedDateObj ? self2.latestSelectedDateObj.getMinutes() : defaults2.minutes);
      self2.hourElement.setAttribute("step", self2.config.hourIncrement.toString());
      self2.minuteElement.setAttribute("step", self2.config.minuteIncrement.toString());
      self2.hourElement.setAttribute("min", self2.config.time_24hr ? "0" : "1");
      self2.hourElement.setAttribute("max", self2.config.time_24hr ? "23" : "12");
      self2.hourElement.setAttribute("maxlength", "2");
      self2.minuteElement.setAttribute("min", "0");
      self2.minuteElement.setAttribute("max", "59");
      self2.minuteElement.setAttribute("maxlength", "2");
      self2.timeContainer.appendChild(hourInput);
      self2.timeContainer.appendChild(separator);
      self2.timeContainer.appendChild(minuteInput);
      if (self2.config.time_24hr)
        self2.timeContainer.classList.add("time24hr");
      if (self2.config.enableSeconds) {
        self2.timeContainer.classList.add("hasSeconds");
        var secondInput = createNumberInput("flatpickr-second");
        self2.secondElement = secondInput.getElementsByTagName("input")[0];
        self2.secondElement.value = pad(self2.latestSelectedDateObj ? self2.latestSelectedDateObj.getSeconds() : defaults2.seconds);
        self2.secondElement.setAttribute("step", self2.minuteElement.getAttribute("step"));
        self2.secondElement.setAttribute("min", "0");
        self2.secondElement.setAttribute("max", "59");
        self2.secondElement.setAttribute("maxlength", "2");
        self2.timeContainer.appendChild(createElement("span", "flatpickr-time-separator", ":"));
        self2.timeContainer.appendChild(secondInput);
      }
      if (!self2.config.time_24hr) {
        self2.amPM = createElement("span", "flatpickr-am-pm", self2.l10n.amPM[int((self2.latestSelectedDateObj ? self2.hourElement.value : self2.config.defaultHour) > 11)]);
        self2.amPM.title = self2.l10n.toggleTitle;
        self2.amPM.tabIndex = -1;
        self2.timeContainer.appendChild(self2.amPM);
      }
      return self2.timeContainer;
    }
    __name(buildTime, "buildTime");
    function buildWeekdays() {
      if (!self2.weekdayContainer)
        self2.weekdayContainer = createElement("div", "flatpickr-weekdays");
      else
        clearNode(self2.weekdayContainer);
      for (var i2 = self2.config.showMonths; i2--; ) {
        var container = createElement("div", "flatpickr-weekdaycontainer");
        self2.weekdayContainer.appendChild(container);
      }
      updateWeekdays();
      return self2.weekdayContainer;
    }
    __name(buildWeekdays, "buildWeekdays");
    function updateWeekdays() {
      if (!self2.weekdayContainer) {
        return;
      }
      var firstDayOfWeek = self2.l10n.firstDayOfWeek;
      var weekdays = __spreadArrays(self2.l10n.weekdays.shorthand);
      if (firstDayOfWeek > 0 && firstDayOfWeek < weekdays.length) {
        weekdays = __spreadArrays(weekdays.splice(firstDayOfWeek, weekdays.length), weekdays.splice(0, firstDayOfWeek));
      }
      for (var i2 = self2.config.showMonths; i2--; ) {
        self2.weekdayContainer.children[i2].innerHTML = "\n      <span class='flatpickr-weekday'>\n        " + weekdays.join("</span><span class='flatpickr-weekday'>") + "\n      </span>\n      ";
      }
    }
    __name(updateWeekdays, "updateWeekdays");
    function buildWeeks() {
      self2.calendarContainer.classList.add("hasWeeks");
      var weekWrapper = createElement("div", "flatpickr-weekwrapper");
      weekWrapper.appendChild(createElement("span", "flatpickr-weekday", self2.l10n.weekAbbreviation));
      var weekNumbers = createElement("div", "flatpickr-weeks");
      weekWrapper.appendChild(weekNumbers);
      return {
        weekWrapper,
        weekNumbers
      };
    }
    __name(buildWeeks, "buildWeeks");
    function changeMonth(value, isOffset) {
      if (isOffset === void 0) {
        isOffset = true;
      }
      var delta = isOffset ? value : value - self2.currentMonth;
      if (delta < 0 && self2._hidePrevMonthArrow === true || delta > 0 && self2._hideNextMonthArrow === true)
        return;
      self2.currentMonth += delta;
      if (self2.currentMonth < 0 || self2.currentMonth > 11) {
        self2.currentYear += self2.currentMonth > 11 ? 1 : -1;
        self2.currentMonth = (self2.currentMonth + 12) % 12;
        triggerEvent("onYearChange");
        buildMonthSwitch();
      }
      buildDays();
      triggerEvent("onMonthChange");
      updateNavigationCurrentMonth();
    }
    __name(changeMonth, "changeMonth");
    function clear(triggerChangeEvent, toInitial) {
      if (triggerChangeEvent === void 0) {
        triggerChangeEvent = true;
      }
      if (toInitial === void 0) {
        toInitial = true;
      }
      self2.input.value = "";
      if (self2.altInput !== void 0)
        self2.altInput.value = "";
      if (self2.mobileInput !== void 0)
        self2.mobileInput.value = "";
      self2.selectedDates = [];
      self2.latestSelectedDateObj = void 0;
      if (toInitial === true) {
        self2.currentYear = self2._initialDate.getFullYear();
        self2.currentMonth = self2._initialDate.getMonth();
      }
      if (self2.config.enableTime === true) {
        var _a = getDefaultHours(self2.config), hours = _a.hours, minutes = _a.minutes, seconds = _a.seconds;
        setHours(hours, minutes, seconds);
      }
      self2.redraw();
      if (triggerChangeEvent)
        triggerEvent("onChange");
    }
    __name(clear, "clear");
    function close() {
      self2.isOpen = false;
      if (!self2.isMobile) {
        if (self2.calendarContainer !== void 0) {
          self2.calendarContainer.classList.remove("open");
        }
        if (self2._input !== void 0) {
          self2._input.classList.remove("active");
        }
      }
      triggerEvent("onClose");
    }
    __name(close, "close");
    function destroy() {
      if (self2.config !== void 0)
        triggerEvent("onDestroy");
      for (var i2 = self2._handlers.length; i2--; ) {
        self2._handlers[i2].remove();
      }
      self2._handlers = [];
      if (self2.mobileInput) {
        if (self2.mobileInput.parentNode)
          self2.mobileInput.parentNode.removeChild(self2.mobileInput);
        self2.mobileInput = void 0;
      } else if (self2.calendarContainer && self2.calendarContainer.parentNode) {
        if (self2.config.static && self2.calendarContainer.parentNode) {
          var wrapper = self2.calendarContainer.parentNode;
          wrapper.lastChild && wrapper.removeChild(wrapper.lastChild);
          if (wrapper.parentNode) {
            while (wrapper.firstChild)
              wrapper.parentNode.insertBefore(wrapper.firstChild, wrapper);
            wrapper.parentNode.removeChild(wrapper);
          }
        } else
          self2.calendarContainer.parentNode.removeChild(self2.calendarContainer);
      }
      if (self2.altInput) {
        self2.input.type = "text";
        if (self2.altInput.parentNode)
          self2.altInput.parentNode.removeChild(self2.altInput);
        delete self2.altInput;
      }
      if (self2.input) {
        self2.input.type = self2.input._type;
        self2.input.classList.remove("flatpickr-input");
        self2.input.removeAttribute("readonly");
      }
      [
        "_showTimeInput",
        "latestSelectedDateObj",
        "_hideNextMonthArrow",
        "_hidePrevMonthArrow",
        "__hideNextMonthArrow",
        "__hidePrevMonthArrow",
        "isMobile",
        "isOpen",
        "selectedDateElem",
        "minDateHasTime",
        "maxDateHasTime",
        "days",
        "daysContainer",
        "_input",
        "_positionElement",
        "innerContainer",
        "rContainer",
        "monthNav",
        "todayDateElem",
        "calendarContainer",
        "weekdayContainer",
        "prevMonthNav",
        "nextMonthNav",
        "monthsDropdownContainer",
        "currentMonthElement",
        "currentYearElement",
        "navigationCurrentMonth",
        "selectedDateElem",
        "config"
      ].forEach(function(k2) {
        try {
          delete self2[k2];
        } catch (_2) {
        }
      });
    }
    __name(destroy, "destroy");
    function isCalendarElem(elem) {
      return self2.calendarContainer.contains(elem);
    }
    __name(isCalendarElem, "isCalendarElem");
    function documentClick(e2) {
      if (self2.isOpen && !self2.config.inline) {
        var eventTarget_1 = getEventTarget(e2);
        var isCalendarElement = isCalendarElem(eventTarget_1);
        var isInput = eventTarget_1 === self2.input || eventTarget_1 === self2.altInput || self2.element.contains(eventTarget_1) || e2.path && e2.path.indexOf && (~e2.path.indexOf(self2.input) || ~e2.path.indexOf(self2.altInput));
        var lostFocus = !isInput && !isCalendarElement && !isCalendarElem(e2.relatedTarget);
        var isIgnored = !self2.config.ignoredFocusElements.some(function(elem) {
          return elem.contains(eventTarget_1);
        });
        if (lostFocus && isIgnored) {
          if (self2.config.allowInput) {
            self2.setDate(self2._input.value, false, self2.config.altInput ? self2.config.altFormat : self2.config.dateFormat);
          }
          if (self2.timeContainer !== void 0 && self2.minuteElement !== void 0 && self2.hourElement !== void 0 && self2.input.value !== "" && self2.input.value !== void 0) {
            updateTime();
          }
          self2.close();
          if (self2.config && self2.config.mode === "range" && self2.selectedDates.length === 1)
            self2.clear(false);
        }
      }
    }
    __name(documentClick, "documentClick");
    function changeYear(newYear) {
      if (!newYear || self2.config.minDate && newYear < self2.config.minDate.getFullYear() || self2.config.maxDate && newYear > self2.config.maxDate.getFullYear())
        return;
      var newYearNum = newYear, isNewYear = self2.currentYear !== newYearNum;
      self2.currentYear = newYearNum || self2.currentYear;
      if (self2.config.maxDate && self2.currentYear === self2.config.maxDate.getFullYear()) {
        self2.currentMonth = Math.min(self2.config.maxDate.getMonth(), self2.currentMonth);
      } else if (self2.config.minDate && self2.currentYear === self2.config.minDate.getFullYear()) {
        self2.currentMonth = Math.max(self2.config.minDate.getMonth(), self2.currentMonth);
      }
      if (isNewYear) {
        self2.redraw();
        triggerEvent("onYearChange");
        buildMonthSwitch();
      }
    }
    __name(changeYear, "changeYear");
    function isEnabled(date, timeless) {
      var _a;
      if (timeless === void 0) {
        timeless = true;
      }
      var dateToCheck = self2.parseDate(date, void 0, timeless);
      if (self2.config.minDate && dateToCheck && compareDates(dateToCheck, self2.config.minDate, timeless !== void 0 ? timeless : !self2.minDateHasTime) < 0 || self2.config.maxDate && dateToCheck && compareDates(dateToCheck, self2.config.maxDate, timeless !== void 0 ? timeless : !self2.maxDateHasTime) > 0)
        return false;
      if (!self2.config.enable && self2.config.disable.length === 0)
        return true;
      if (dateToCheck === void 0)
        return false;
      var bool = !!self2.config.enable, array = (_a = self2.config.enable) !== null && _a !== void 0 ? _a : self2.config.disable;
      for (var i2 = 0, d2 = void 0; i2 < array.length; i2++) {
        d2 = array[i2];
        if (typeof d2 === "function" && d2(dateToCheck))
          return bool;
        else if (d2 instanceof Date && dateToCheck !== void 0 && d2.getTime() === dateToCheck.getTime())
          return bool;
        else if (typeof d2 === "string") {
          var parsed = self2.parseDate(d2, void 0, true);
          return parsed && parsed.getTime() === dateToCheck.getTime() ? bool : !bool;
        } else if (typeof d2 === "object" && dateToCheck !== void 0 && d2.from && d2.to && dateToCheck.getTime() >= d2.from.getTime() && dateToCheck.getTime() <= d2.to.getTime())
          return bool;
      }
      return !bool;
    }
    __name(isEnabled, "isEnabled");
    function isInView(elem) {
      if (self2.daysContainer !== void 0)
        return elem.className.indexOf("hidden") === -1 && elem.className.indexOf("flatpickr-disabled") === -1 && self2.daysContainer.contains(elem);
      return false;
    }
    __name(isInView, "isInView");
    function onBlur(e2) {
      var isInput = e2.target === self2._input;
      var valueChanged = self2._input.value.trimEnd() !== getDateStr();
      if (isInput && valueChanged && !(e2.relatedTarget && isCalendarElem(e2.relatedTarget))) {
        self2.setDate(self2._input.value, true, e2.target === self2.altInput ? self2.config.altFormat : self2.config.dateFormat);
      }
    }
    __name(onBlur, "onBlur");
    function onKeyDown(e2) {
      var eventTarget = getEventTarget(e2);
      var isInput = self2.config.wrap ? element.contains(eventTarget) : eventTarget === self2._input;
      var allowInput = self2.config.allowInput;
      var allowKeydown = self2.isOpen && (!allowInput || !isInput);
      var allowInlineKeydown = self2.config.inline && isInput && !allowInput;
      if (e2.keyCode === 13 && isInput) {
        if (allowInput) {
          self2.setDate(self2._input.value, true, eventTarget === self2.altInput ? self2.config.altFormat : self2.config.dateFormat);
          self2.close();
          return eventTarget.blur();
        } else {
          self2.open();
        }
      } else if (isCalendarElem(eventTarget) || allowKeydown || allowInlineKeydown) {
        var isTimeObj = !!self2.timeContainer && self2.timeContainer.contains(eventTarget);
        switch (e2.keyCode) {
          case 13:
            if (isTimeObj) {
              e2.preventDefault();
              updateTime();
              focusAndClose();
            } else
              selectDate(e2);
            break;
          case 27:
            e2.preventDefault();
            focusAndClose();
            break;
          case 8:
          case 46:
            if (isInput && !self2.config.allowInput) {
              e2.preventDefault();
              self2.clear();
            }
            break;
          case 37:
          case 39:
            if (!isTimeObj && !isInput) {
              e2.preventDefault();
              var activeElement = getClosestActiveElement();
              if (self2.daysContainer !== void 0 && (allowInput === false || activeElement && isInView(activeElement))) {
                var delta_1 = e2.keyCode === 39 ? 1 : -1;
                if (!e2.ctrlKey)
                  focusOnDay(void 0, delta_1);
                else {
                  e2.stopPropagation();
                  changeMonth(delta_1);
                  focusOnDay(getFirstAvailableDay(1), 0);
                }
              }
            } else if (self2.hourElement)
              self2.hourElement.focus();
            break;
          case 38:
          case 40:
            e2.preventDefault();
            var delta = e2.keyCode === 40 ? 1 : -1;
            if (self2.daysContainer && eventTarget.$i !== void 0 || eventTarget === self2.input || eventTarget === self2.altInput) {
              if (e2.ctrlKey) {
                e2.stopPropagation();
                changeYear(self2.currentYear - delta);
                focusOnDay(getFirstAvailableDay(1), 0);
              } else if (!isTimeObj)
                focusOnDay(void 0, delta * 7);
            } else if (eventTarget === self2.currentYearElement) {
              changeYear(self2.currentYear - delta);
            } else if (self2.config.enableTime) {
              if (!isTimeObj && self2.hourElement)
                self2.hourElement.focus();
              updateTime(e2);
              self2._debouncedChange();
            }
            break;
          case 9:
            if (isTimeObj) {
              var elems = [
                self2.hourElement,
                self2.minuteElement,
                self2.secondElement,
                self2.amPM
              ].concat(self2.pluginElements).filter(function(x2) {
                return x2;
              });
              var i2 = elems.indexOf(eventTarget);
              if (i2 !== -1) {
                var target = elems[i2 + (e2.shiftKey ? -1 : 1)];
                e2.preventDefault();
                (target || self2._input).focus();
              }
            } else if (!self2.config.noCalendar && self2.daysContainer && self2.daysContainer.contains(eventTarget) && e2.shiftKey) {
              e2.preventDefault();
              self2._input.focus();
            }
            break;
          default:
            break;
        }
      }
      if (self2.amPM !== void 0 && eventTarget === self2.amPM) {
        switch (e2.key) {
          case self2.l10n.amPM[0].charAt(0):
          case self2.l10n.amPM[0].charAt(0).toLowerCase():
            self2.amPM.textContent = self2.l10n.amPM[0];
            setHoursFromInputs();
            updateValue();
            break;
          case self2.l10n.amPM[1].charAt(0):
          case self2.l10n.amPM[1].charAt(0).toLowerCase():
            self2.amPM.textContent = self2.l10n.amPM[1];
            setHoursFromInputs();
            updateValue();
            break;
        }
      }
      if (isInput || isCalendarElem(eventTarget)) {
        triggerEvent("onKeyDown", e2);
      }
    }
    __name(onKeyDown, "onKeyDown");
    function onMouseOver(elem, cellClass) {
      if (cellClass === void 0) {
        cellClass = "flatpickr-day";
      }
      if (self2.selectedDates.length !== 1 || elem && (!elem.classList.contains(cellClass) || elem.classList.contains("flatpickr-disabled")))
        return;
      var hoverDate = elem ? elem.dateObj.getTime() : self2.days.firstElementChild.dateObj.getTime(), initialDate = self2.parseDate(self2.selectedDates[0], void 0, true).getTime(), rangeStartDate = Math.min(hoverDate, self2.selectedDates[0].getTime()), rangeEndDate = Math.max(hoverDate, self2.selectedDates[0].getTime());
      var containsDisabled = false;
      var minRange = 0, maxRange = 0;
      for (var t2 = rangeStartDate; t2 < rangeEndDate; t2 += duration.DAY) {
        if (!isEnabled(new Date(t2), true)) {
          containsDisabled = containsDisabled || t2 > rangeStartDate && t2 < rangeEndDate;
          if (t2 < initialDate && (!minRange || t2 > minRange))
            minRange = t2;
          else if (t2 > initialDate && (!maxRange || t2 < maxRange))
            maxRange = t2;
        }
      }
      var hoverableCells = Array.from(self2.rContainer.querySelectorAll("*:nth-child(-n+" + self2.config.showMonths + ") > ." + cellClass));
      hoverableCells.forEach(function(dayElem) {
        var date = dayElem.dateObj;
        var timestamp = date.getTime();
        var outOfRange = minRange > 0 && timestamp < minRange || maxRange > 0 && timestamp > maxRange;
        if (outOfRange) {
          dayElem.classList.add("notAllowed");
          ["inRange", "startRange", "endRange"].forEach(function(c2) {
            dayElem.classList.remove(c2);
          });
          return;
        } else if (containsDisabled && !outOfRange)
          return;
        ["startRange", "inRange", "endRange", "notAllowed"].forEach(function(c2) {
          dayElem.classList.remove(c2);
        });
        if (elem !== void 0) {
          elem.classList.add(hoverDate <= self2.selectedDates[0].getTime() ? "startRange" : "endRange");
          if (initialDate < hoverDate && timestamp === initialDate)
            dayElem.classList.add("startRange");
          else if (initialDate > hoverDate && timestamp === initialDate)
            dayElem.classList.add("endRange");
          if (timestamp >= minRange && (maxRange === 0 || timestamp <= maxRange) && isBetween(timestamp, initialDate, hoverDate))
            dayElem.classList.add("inRange");
        }
      });
    }
    __name(onMouseOver, "onMouseOver");
    function onResize() {
      if (self2.isOpen && !self2.config.static && !self2.config.inline)
        positionCalendar();
    }
    __name(onResize, "onResize");
    function open(e2, positionElement) {
      if (positionElement === void 0) {
        positionElement = self2._positionElement;
      }
      if (self2.isMobile === true) {
        if (e2) {
          e2.preventDefault();
          var eventTarget = getEventTarget(e2);
          if (eventTarget) {
            eventTarget.blur();
          }
        }
        if (self2.mobileInput !== void 0) {
          self2.mobileInput.focus();
          self2.mobileInput.click();
        }
        triggerEvent("onOpen");
        return;
      } else if (self2._input.disabled || self2.config.inline) {
        return;
      }
      var wasOpen = self2.isOpen;
      self2.isOpen = true;
      if (!wasOpen) {
        self2.calendarContainer.classList.add("open");
        self2._input.classList.add("active");
        triggerEvent("onOpen");
        positionCalendar(positionElement);
      }
      if (self2.config.enableTime === true && self2.config.noCalendar === true) {
        if (self2.config.allowInput === false && (e2 === void 0 || !self2.timeContainer.contains(e2.relatedTarget))) {
          setTimeout(function() {
            return self2.hourElement.select();
          }, 50);
        }
      }
    }
    __name(open, "open");
    function minMaxDateSetter(type) {
      return function(date) {
        var dateObj = self2.config["_" + type + "Date"] = self2.parseDate(date, self2.config.dateFormat);
        var inverseDateObj = self2.config["_" + (type === "min" ? "max" : "min") + "Date"];
        if (dateObj !== void 0) {
          self2[type === "min" ? "minDateHasTime" : "maxDateHasTime"] = dateObj.getHours() > 0 || dateObj.getMinutes() > 0 || dateObj.getSeconds() > 0;
        }
        if (self2.selectedDates) {
          self2.selectedDates = self2.selectedDates.filter(function(d2) {
            return isEnabled(d2);
          });
          if (!self2.selectedDates.length && type === "min")
            setHoursFromDate(dateObj);
          updateValue();
        }
        if (self2.daysContainer) {
          redraw();
          if (dateObj !== void 0)
            self2.currentYearElement[type] = dateObj.getFullYear().toString();
          else
            self2.currentYearElement.removeAttribute(type);
          self2.currentYearElement.disabled = !!inverseDateObj && dateObj !== void 0 && inverseDateObj.getFullYear() === dateObj.getFullYear();
        }
      };
    }
    __name(minMaxDateSetter, "minMaxDateSetter");
    function parseConfig() {
      var boolOpts = [
        "wrap",
        "weekNumbers",
        "allowInput",
        "allowInvalidPreload",
        "clickOpens",
        "time_24hr",
        "enableTime",
        "noCalendar",
        "altInput",
        "shorthandCurrentMonth",
        "inline",
        "static",
        "enableSeconds",
        "disableMobile"
      ];
      var userConfig = __assign(__assign({}, JSON.parse(JSON.stringify(element.dataset || {}))), instanceConfig);
      var formats2 = {};
      self2.config.parseDate = userConfig.parseDate;
      self2.config.formatDate = userConfig.formatDate;
      Object.defineProperty(self2.config, "enable", {
        get: function() {
          return self2.config._enable;
        },
        set: function(dates) {
          self2.config._enable = parseDateRules(dates);
        }
      });
      Object.defineProperty(self2.config, "disable", {
        get: function() {
          return self2.config._disable;
        },
        set: function(dates) {
          self2.config._disable = parseDateRules(dates);
        }
      });
      var timeMode = userConfig.mode === "time";
      if (!userConfig.dateFormat && (userConfig.enableTime || timeMode)) {
        var defaultDateFormat = flatpickr.defaultConfig.dateFormat || defaults.dateFormat;
        formats2.dateFormat = userConfig.noCalendar || timeMode ? "H:i" + (userConfig.enableSeconds ? ":S" : "") : defaultDateFormat + " H:i" + (userConfig.enableSeconds ? ":S" : "");
      }
      if (userConfig.altInput && (userConfig.enableTime || timeMode) && !userConfig.altFormat) {
        var defaultAltFormat = flatpickr.defaultConfig.altFormat || defaults.altFormat;
        formats2.altFormat = userConfig.noCalendar || timeMode ? "h:i" + (userConfig.enableSeconds ? ":S K" : " K") : defaultAltFormat + (" h:i" + (userConfig.enableSeconds ? ":S" : "") + " K");
      }
      Object.defineProperty(self2.config, "minDate", {
        get: function() {
          return self2.config._minDate;
        },
        set: minMaxDateSetter("min")
      });
      Object.defineProperty(self2.config, "maxDate", {
        get: function() {
          return self2.config._maxDate;
        },
        set: minMaxDateSetter("max")
      });
      var minMaxTimeSetter = /* @__PURE__ */ __name(function(type) {
        return function(val) {
          self2.config[type === "min" ? "_minTime" : "_maxTime"] = self2.parseDate(val, "H:i:S");
        };
      }, "minMaxTimeSetter");
      Object.defineProperty(self2.config, "minTime", {
        get: function() {
          return self2.config._minTime;
        },
        set: minMaxTimeSetter("min")
      });
      Object.defineProperty(self2.config, "maxTime", {
        get: function() {
          return self2.config._maxTime;
        },
        set: minMaxTimeSetter("max")
      });
      if (userConfig.mode === "time") {
        self2.config.noCalendar = true;
        self2.config.enableTime = true;
      }
      Object.assign(self2.config, formats2, userConfig);
      for (var i2 = 0; i2 < boolOpts.length; i2++)
        self2.config[boolOpts[i2]] = self2.config[boolOpts[i2]] === true || self2.config[boolOpts[i2]] === "true";
      HOOKS.filter(function(hook) {
        return self2.config[hook] !== void 0;
      }).forEach(function(hook) {
        self2.config[hook] = arrayify(self2.config[hook] || []).map(bindToInstance);
      });
      self2.isMobile = !self2.config.disableMobile && !self2.config.inline && self2.config.mode === "single" && !self2.config.disable.length && !self2.config.enable && !self2.config.weekNumbers && /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
      for (var i2 = 0; i2 < self2.config.plugins.length; i2++) {
        var pluginConf = self2.config.plugins[i2](self2) || {};
        for (var key in pluginConf) {
          if (HOOKS.indexOf(key) > -1) {
            self2.config[key] = arrayify(pluginConf[key]).map(bindToInstance).concat(self2.config[key]);
          } else if (typeof userConfig[key] === "undefined")
            self2.config[key] = pluginConf[key];
        }
      }
      if (!userConfig.altInputClass) {
        self2.config.altInputClass = getInputElem().className + " " + self2.config.altInputClass;
      }
      triggerEvent("onParseConfig");
    }
    __name(parseConfig, "parseConfig");
    function getInputElem() {
      return self2.config.wrap ? element.querySelector("[data-input]") : element;
    }
    __name(getInputElem, "getInputElem");
    function setupLocale() {
      if (typeof self2.config.locale !== "object" && typeof flatpickr.l10ns[self2.config.locale] === "undefined")
        self2.config.errorHandler(new Error("flatpickr: invalid locale " + self2.config.locale));
      self2.l10n = __assign(__assign({}, flatpickr.l10ns.default), typeof self2.config.locale === "object" ? self2.config.locale : self2.config.locale !== "default" ? flatpickr.l10ns[self2.config.locale] : void 0);
      tokenRegex.D = "(" + self2.l10n.weekdays.shorthand.join("|") + ")";
      tokenRegex.l = "(" + self2.l10n.weekdays.longhand.join("|") + ")";
      tokenRegex.M = "(" + self2.l10n.months.shorthand.join("|") + ")";
      tokenRegex.F = "(" + self2.l10n.months.longhand.join("|") + ")";
      tokenRegex.K = "(" + self2.l10n.amPM[0] + "|" + self2.l10n.amPM[1] + "|" + self2.l10n.amPM[0].toLowerCase() + "|" + self2.l10n.amPM[1].toLowerCase() + ")";
      var userConfig = __assign(__assign({}, instanceConfig), JSON.parse(JSON.stringify(element.dataset || {})));
      if (userConfig.time_24hr === void 0 && flatpickr.defaultConfig.time_24hr === void 0) {
        self2.config.time_24hr = self2.l10n.time_24hr;
      }
      self2.formatDate = createDateFormatter(self2);
      self2.parseDate = createDateParser({ config: self2.config, l10n: self2.l10n });
    }
    __name(setupLocale, "setupLocale");
    function positionCalendar(customPositionElement) {
      if (typeof self2.config.position === "function") {
        return void self2.config.position(self2, customPositionElement);
      }
      if (self2.calendarContainer === void 0)
        return;
      triggerEvent("onPreCalendarPosition");
      var positionElement = customPositionElement || self2._positionElement;
      var calendarHeight = Array.prototype.reduce.call(self2.calendarContainer.children, function(acc, child) {
        return acc + child.offsetHeight;
      }, 0), calendarWidth = self2.calendarContainer.offsetWidth, configPos = self2.config.position.split(" "), configPosVertical = configPos[0], configPosHorizontal = configPos.length > 1 ? configPos[1] : null, inputBounds = positionElement.getBoundingClientRect(), distanceFromBottom = window.innerHeight - inputBounds.bottom, showOnTop = configPosVertical === "above" || configPosVertical !== "below" && distanceFromBottom < calendarHeight && inputBounds.top > calendarHeight;
      var top = window.pageYOffset + inputBounds.top + (!showOnTop ? positionElement.offsetHeight + 2 : -calendarHeight - 2);
      toggleClass(self2.calendarContainer, "arrowTop", !showOnTop);
      toggleClass(self2.calendarContainer, "arrowBottom", showOnTop);
      if (self2.config.inline)
        return;
      var left = window.pageXOffset + inputBounds.left;
      var isCenter = false;
      var isRight = false;
      if (configPosHorizontal === "center") {
        left -= (calendarWidth - inputBounds.width) / 2;
        isCenter = true;
      } else if (configPosHorizontal === "right") {
        left -= calendarWidth - inputBounds.width;
        isRight = true;
      }
      toggleClass(self2.calendarContainer, "arrowLeft", !isCenter && !isRight);
      toggleClass(self2.calendarContainer, "arrowCenter", isCenter);
      toggleClass(self2.calendarContainer, "arrowRight", isRight);
      var right = window.document.body.offsetWidth - (window.pageXOffset + inputBounds.right);
      var rightMost = left + calendarWidth > window.document.body.offsetWidth;
      var centerMost = right + calendarWidth > window.document.body.offsetWidth;
      toggleClass(self2.calendarContainer, "rightMost", rightMost);
      if (self2.config.static)
        return;
      self2.calendarContainer.style.top = top + "px";
      if (!rightMost) {
        self2.calendarContainer.style.left = left + "px";
        self2.calendarContainer.style.right = "auto";
      } else if (!centerMost) {
        self2.calendarContainer.style.left = "auto";
        self2.calendarContainer.style.right = right + "px";
      } else {
        var doc = getDocumentStyleSheet();
        if (doc === void 0)
          return;
        var bodyWidth = window.document.body.offsetWidth;
        var centerLeft = Math.max(0, bodyWidth / 2 - calendarWidth / 2);
        var centerBefore = ".flatpickr-calendar.centerMost:before";
        var centerAfter = ".flatpickr-calendar.centerMost:after";
        var centerIndex = doc.cssRules.length;
        var centerStyle = "{left:" + inputBounds.left + "px;right:auto;}";
        toggleClass(self2.calendarContainer, "rightMost", false);
        toggleClass(self2.calendarContainer, "centerMost", true);
        doc.insertRule(centerBefore + "," + centerAfter + centerStyle, centerIndex);
        self2.calendarContainer.style.left = centerLeft + "px";
        self2.calendarContainer.style.right = "auto";
      }
    }
    __name(positionCalendar, "positionCalendar");
    function getDocumentStyleSheet() {
      var editableSheet = null;
      for (var i2 = 0; i2 < document.styleSheets.length; i2++) {
        var sheet = document.styleSheets[i2];
        if (!sheet.cssRules)
          continue;
        try {
          sheet.cssRules;
        } catch (err) {
          continue;
        }
        editableSheet = sheet;
        break;
      }
      return editableSheet != null ? editableSheet : createStyleSheet();
    }
    __name(getDocumentStyleSheet, "getDocumentStyleSheet");
    function createStyleSheet() {
      var style = document.createElement("style");
      document.head.appendChild(style);
      return style.sheet;
    }
    __name(createStyleSheet, "createStyleSheet");
    function redraw() {
      if (self2.config.noCalendar || self2.isMobile)
        return;
      buildMonthSwitch();
      updateNavigationCurrentMonth();
      buildDays();
    }
    __name(redraw, "redraw");
    function focusAndClose() {
      self2._input.focus();
      if (window.navigator.userAgent.indexOf("MSIE") !== -1 || navigator.msMaxTouchPoints !== void 0) {
        setTimeout(self2.close, 0);
      } else {
        self2.close();
      }
    }
    __name(focusAndClose, "focusAndClose");
    function selectDate(e2) {
      e2.preventDefault();
      e2.stopPropagation();
      var isSelectable = /* @__PURE__ */ __name(function(day) {
        return day.classList && day.classList.contains("flatpickr-day") && !day.classList.contains("flatpickr-disabled") && !day.classList.contains("notAllowed");
      }, "isSelectable");
      var t2 = findParent(getEventTarget(e2), isSelectable);
      if (t2 === void 0)
        return;
      var target = t2;
      var selectedDate = self2.latestSelectedDateObj = new Date(target.dateObj.getTime());
      var shouldChangeMonth = (selectedDate.getMonth() < self2.currentMonth || selectedDate.getMonth() > self2.currentMonth + self2.config.showMonths - 1) && self2.config.mode !== "range";
      self2.selectedDateElem = target;
      if (self2.config.mode === "single")
        self2.selectedDates = [selectedDate];
      else if (self2.config.mode === "multiple") {
        var selectedIndex = isDateSelected(selectedDate);
        if (selectedIndex)
          self2.selectedDates.splice(parseInt(selectedIndex), 1);
        else
          self2.selectedDates.push(selectedDate);
      } else if (self2.config.mode === "range") {
        if (self2.selectedDates.length === 2) {
          self2.clear(false, false);
        }
        self2.latestSelectedDateObj = selectedDate;
        self2.selectedDates.push(selectedDate);
        if (compareDates(selectedDate, self2.selectedDates[0], true) !== 0)
          self2.selectedDates.sort(function(a2, b2) {
            return a2.getTime() - b2.getTime();
          });
      }
      setHoursFromInputs();
      if (shouldChangeMonth) {
        var isNewYear = self2.currentYear !== selectedDate.getFullYear();
        self2.currentYear = selectedDate.getFullYear();
        self2.currentMonth = selectedDate.getMonth();
        if (isNewYear) {
          triggerEvent("onYearChange");
          buildMonthSwitch();
        }
        triggerEvent("onMonthChange");
      }
      updateNavigationCurrentMonth();
      buildDays();
      updateValue();
      if (!shouldChangeMonth && self2.config.mode !== "range" && self2.config.showMonths === 1)
        focusOnDayElem(target);
      else if (self2.selectedDateElem !== void 0 && self2.hourElement === void 0) {
        self2.selectedDateElem && self2.selectedDateElem.focus();
      }
      if (self2.hourElement !== void 0)
        self2.hourElement !== void 0 && self2.hourElement.focus();
      if (self2.config.closeOnSelect) {
        var single = self2.config.mode === "single" && !self2.config.enableTime;
        var range = self2.config.mode === "range" && self2.selectedDates.length === 2 && !self2.config.enableTime;
        if (single || range) {
          focusAndClose();
        }
      }
      triggerChange();
    }
    __name(selectDate, "selectDate");
    var CALLBACKS = {
      locale: [setupLocale, updateWeekdays],
      showMonths: [buildMonths, setCalendarWidth, buildWeekdays],
      minDate: [jumpToDate],
      maxDate: [jumpToDate],
      positionElement: [updatePositionElement],
      clickOpens: [
        function() {
          if (self2.config.clickOpens === true) {
            bind(self2._input, "focus", self2.open);
            bind(self2._input, "click", self2.open);
          } else {
            self2._input.removeEventListener("focus", self2.open);
            self2._input.removeEventListener("click", self2.open);
          }
        }
      ]
    };
    function set(option, value) {
      if (option !== null && typeof option === "object") {
        Object.assign(self2.config, option);
        for (var key in option) {
          if (CALLBACKS[key] !== void 0)
            CALLBACKS[key].forEach(function(x2) {
              return x2();
            });
        }
      } else {
        self2.config[option] = value;
        if (CALLBACKS[option] !== void 0)
          CALLBACKS[option].forEach(function(x2) {
            return x2();
          });
        else if (HOOKS.indexOf(option) > -1)
          self2.config[option] = arrayify(value);
      }
      self2.redraw();
      updateValue(true);
    }
    __name(set, "set");
    function setSelectedDate(inputDate, format) {
      var dates = [];
      if (inputDate instanceof Array)
        dates = inputDate.map(function(d2) {
          return self2.parseDate(d2, format);
        });
      else if (inputDate instanceof Date || typeof inputDate === "number")
        dates = [self2.parseDate(inputDate, format)];
      else if (typeof inputDate === "string") {
        switch (self2.config.mode) {
          case "single":
          case "time":
            dates = [self2.parseDate(inputDate, format)];
            break;
          case "multiple":
            dates = inputDate.split(self2.config.conjunction).map(function(date) {
              return self2.parseDate(date, format);
            });
            break;
          case "range":
            dates = inputDate.split(self2.l10n.rangeSeparator).map(function(date) {
              return self2.parseDate(date, format);
            });
            break;
          default:
            break;
        }
      } else
        self2.config.errorHandler(new Error("Invalid date supplied: " + JSON.stringify(inputDate)));
      self2.selectedDates = self2.config.allowInvalidPreload ? dates : dates.filter(function(d2) {
        return d2 instanceof Date && isEnabled(d2, false);
      });
      if (self2.config.mode === "range")
        self2.selectedDates.sort(function(a2, b2) {
          return a2.getTime() - b2.getTime();
        });
    }
    __name(setSelectedDate, "setSelectedDate");
    function setDate(date, triggerChange2, format) {
      if (triggerChange2 === void 0) {
        triggerChange2 = false;
      }
      if (format === void 0) {
        format = self2.config.dateFormat;
      }
      if (date !== 0 && !date || date instanceof Array && date.length === 0)
        return self2.clear(triggerChange2);
      setSelectedDate(date, format);
      self2.latestSelectedDateObj = self2.selectedDates[self2.selectedDates.length - 1];
      self2.redraw();
      jumpToDate(void 0, triggerChange2);
      setHoursFromDate();
      if (self2.selectedDates.length === 0) {
        self2.clear(false);
      }
      updateValue(triggerChange2);
      if (triggerChange2)
        triggerEvent("onChange");
    }
    __name(setDate, "setDate");
    function parseDateRules(arr) {
      return arr.slice().map(function(rule) {
        if (typeof rule === "string" || typeof rule === "number" || rule instanceof Date) {
          return self2.parseDate(rule, void 0, true);
        } else if (rule && typeof rule === "object" && rule.from && rule.to)
          return {
            from: self2.parseDate(rule.from, void 0),
            to: self2.parseDate(rule.to, void 0)
          };
        return rule;
      }).filter(function(x2) {
        return x2;
      });
    }
    __name(parseDateRules, "parseDateRules");
    function setupDates() {
      self2.selectedDates = [];
      self2.now = self2.parseDate(self2.config.now) || /* @__PURE__ */ new Date();
      var preloadedDate = self2.config.defaultDate || ((self2.input.nodeName === "INPUT" || self2.input.nodeName === "TEXTAREA") && self2.input.placeholder && self2.input.value === self2.input.placeholder ? null : self2.input.value);
      if (preloadedDate)
        setSelectedDate(preloadedDate, self2.config.dateFormat);
      self2._initialDate = self2.selectedDates.length > 0 ? self2.selectedDates[0] : self2.config.minDate && self2.config.minDate.getTime() > self2.now.getTime() ? self2.config.minDate : self2.config.maxDate && self2.config.maxDate.getTime() < self2.now.getTime() ? self2.config.maxDate : self2.now;
      self2.currentYear = self2._initialDate.getFullYear();
      self2.currentMonth = self2._initialDate.getMonth();
      if (self2.selectedDates.length > 0)
        self2.latestSelectedDateObj = self2.selectedDates[0];
      if (self2.config.minTime !== void 0)
        self2.config.minTime = self2.parseDate(self2.config.minTime, "H:i");
      if (self2.config.maxTime !== void 0)
        self2.config.maxTime = self2.parseDate(self2.config.maxTime, "H:i");
      self2.minDateHasTime = !!self2.config.minDate && (self2.config.minDate.getHours() > 0 || self2.config.minDate.getMinutes() > 0 || self2.config.minDate.getSeconds() > 0);
      self2.maxDateHasTime = !!self2.config.maxDate && (self2.config.maxDate.getHours() > 0 || self2.config.maxDate.getMinutes() > 0 || self2.config.maxDate.getSeconds() > 0);
    }
    __name(setupDates, "setupDates");
    function setupInputs() {
      self2.input = getInputElem();
      if (!self2.input) {
        self2.config.errorHandler(new Error("Invalid input element specified"));
        return;
      }
      self2.input._type = self2.input.type;
      self2.input.type = "text";
      self2.input.classList.add("flatpickr-input");
      self2._input = self2.input;
      if (self2.config.altInput) {
        self2.altInput = createElement(self2.input.nodeName, self2.config.altInputClass);
        self2._input = self2.altInput;
        self2.altInput.placeholder = self2.input.placeholder;
        self2.altInput.disabled = self2.input.disabled;
        self2.altInput.required = self2.input.required;
        self2.altInput.tabIndex = self2.input.tabIndex;
        self2.altInput.type = "text";
        self2.input.setAttribute("type", "hidden");
        if (!self2.config.static && self2.input.parentNode)
          self2.input.parentNode.insertBefore(self2.altInput, self2.input.nextSibling);
      }
      if (!self2.config.allowInput)
        self2._input.setAttribute("readonly", "readonly");
      updatePositionElement();
    }
    __name(setupInputs, "setupInputs");
    function updatePositionElement() {
      self2._positionElement = self2.config.positionElement || self2._input;
    }
    __name(updatePositionElement, "updatePositionElement");
    function setupMobile() {
      var inputType = self2.config.enableTime ? self2.config.noCalendar ? "time" : "datetime-local" : "date";
      self2.mobileInput = createElement("input", self2.input.className + " flatpickr-mobile");
      self2.mobileInput.tabIndex = 1;
      self2.mobileInput.type = inputType;
      self2.mobileInput.disabled = self2.input.disabled;
      self2.mobileInput.required = self2.input.required;
      self2.mobileInput.placeholder = self2.input.placeholder;
      self2.mobileFormatStr = inputType === "datetime-local" ? "Y-m-d\\TH:i:S" : inputType === "date" ? "Y-m-d" : "H:i:S";
      if (self2.selectedDates.length > 0) {
        self2.mobileInput.defaultValue = self2.mobileInput.value = self2.formatDate(self2.selectedDates[0], self2.mobileFormatStr);
      }
      if (self2.config.minDate)
        self2.mobileInput.min = self2.formatDate(self2.config.minDate, "Y-m-d");
      if (self2.config.maxDate)
        self2.mobileInput.max = self2.formatDate(self2.config.maxDate, "Y-m-d");
      if (self2.input.getAttribute("step"))
        self2.mobileInput.step = String(self2.input.getAttribute("step"));
      self2.input.type = "hidden";
      if (self2.altInput !== void 0)
        self2.altInput.type = "hidden";
      try {
        if (self2.input.parentNode)
          self2.input.parentNode.insertBefore(self2.mobileInput, self2.input.nextSibling);
      } catch (_a) {
      }
      bind(self2.mobileInput, "change", function(e2) {
        self2.setDate(getEventTarget(e2).value, false, self2.mobileFormatStr);
        triggerEvent("onChange");
        triggerEvent("onClose");
      });
    }
    __name(setupMobile, "setupMobile");
    function toggle(e2) {
      if (self2.isOpen === true)
        return self2.close();
      self2.open(e2);
    }
    __name(toggle, "toggle");
    function triggerEvent(event, data) {
      if (self2.config === void 0)
        return;
      var hooks = self2.config[event];
      if (hooks !== void 0 && hooks.length > 0) {
        for (var i2 = 0; hooks[i2] && i2 < hooks.length; i2++)
          hooks[i2](self2.selectedDates, self2.input.value, self2, data);
      }
      if (event === "onChange") {
        self2.input.dispatchEvent(createEvent("change"));
        self2.input.dispatchEvent(createEvent("input"));
      }
    }
    __name(triggerEvent, "triggerEvent");
    function createEvent(name) {
      var e2 = document.createEvent("Event");
      e2.initEvent(name, true, true);
      return e2;
    }
    __name(createEvent, "createEvent");
    function isDateSelected(date) {
      for (var i2 = 0; i2 < self2.selectedDates.length; i2++) {
        var selectedDate = self2.selectedDates[i2];
        if (selectedDate instanceof Date && compareDates(selectedDate, date) === 0)
          return "" + i2;
      }
      return false;
    }
    __name(isDateSelected, "isDateSelected");
    function isDateInRange(date) {
      if (self2.config.mode !== "range" || self2.selectedDates.length < 2)
        return false;
      return compareDates(date, self2.selectedDates[0]) >= 0 && compareDates(date, self2.selectedDates[1]) <= 0;
    }
    __name(isDateInRange, "isDateInRange");
    function updateNavigationCurrentMonth() {
      if (self2.config.noCalendar || self2.isMobile || !self2.monthNav)
        return;
      self2.yearElements.forEach(function(yearElement, i2) {
        var d2 = new Date(self2.currentYear, self2.currentMonth, 1);
        d2.setMonth(self2.currentMonth + i2);
        if (self2.config.showMonths > 1 || self2.config.monthSelectorType === "static") {
          self2.monthElements[i2].textContent = monthToStr(d2.getMonth(), self2.config.shorthandCurrentMonth, self2.l10n) + " ";
        } else {
          self2.monthsDropdownContainer.value = d2.getMonth().toString();
        }
        yearElement.value = d2.getFullYear().toString();
      });
      self2._hidePrevMonthArrow = self2.config.minDate !== void 0 && (self2.currentYear === self2.config.minDate.getFullYear() ? self2.currentMonth <= self2.config.minDate.getMonth() : self2.currentYear < self2.config.minDate.getFullYear());
      self2._hideNextMonthArrow = self2.config.maxDate !== void 0 && (self2.currentYear === self2.config.maxDate.getFullYear() ? self2.currentMonth + 1 > self2.config.maxDate.getMonth() : self2.currentYear > self2.config.maxDate.getFullYear());
    }
    __name(updateNavigationCurrentMonth, "updateNavigationCurrentMonth");
    function getDateStr(specificFormat) {
      var format = specificFormat || (self2.config.altInput ? self2.config.altFormat : self2.config.dateFormat);
      return self2.selectedDates.map(function(dObj) {
        return self2.formatDate(dObj, format);
      }).filter(function(d2, i2, arr) {
        return self2.config.mode !== "range" || self2.config.enableTime || arr.indexOf(d2) === i2;
      }).join(self2.config.mode !== "range" ? self2.config.conjunction : self2.l10n.rangeSeparator);
    }
    __name(getDateStr, "getDateStr");
    function updateValue(triggerChange2) {
      if (triggerChange2 === void 0) {
        triggerChange2 = true;
      }
      if (self2.mobileInput !== void 0 && self2.mobileFormatStr) {
        self2.mobileInput.value = self2.latestSelectedDateObj !== void 0 ? self2.formatDate(self2.latestSelectedDateObj, self2.mobileFormatStr) : "";
      }
      self2.input.value = getDateStr(self2.config.dateFormat);
      if (self2.altInput !== void 0) {
        self2.altInput.value = getDateStr(self2.config.altFormat);
      }
      if (triggerChange2 !== false)
        triggerEvent("onValueUpdate");
    }
    __name(updateValue, "updateValue");
    function onMonthNavClick(e2) {
      var eventTarget = getEventTarget(e2);
      var isPrevMonth = self2.prevMonthNav.contains(eventTarget);
      var isNextMonth = self2.nextMonthNav.contains(eventTarget);
      if (isPrevMonth || isNextMonth) {
        changeMonth(isPrevMonth ? -1 : 1);
      } else if (self2.yearElements.indexOf(eventTarget) >= 0) {
        eventTarget.select();
      } else if (eventTarget.classList.contains("arrowUp")) {
        self2.changeYear(self2.currentYear + 1);
      } else if (eventTarget.classList.contains("arrowDown")) {
        self2.changeYear(self2.currentYear - 1);
      }
    }
    __name(onMonthNavClick, "onMonthNavClick");
    function timeWrapper(e2) {
      e2.preventDefault();
      var isKeyDown = e2.type === "keydown", eventTarget = getEventTarget(e2), input = eventTarget;
      if (self2.amPM !== void 0 && eventTarget === self2.amPM) {
        self2.amPM.textContent = self2.l10n.amPM[int(self2.amPM.textContent === self2.l10n.amPM[0])];
      }
      var min = parseFloat(input.getAttribute("min")), max = parseFloat(input.getAttribute("max")), step = parseFloat(input.getAttribute("step")), curValue = parseInt(input.value, 10), delta = e2.delta || (isKeyDown ? e2.which === 38 ? 1 : -1 : 0);
      var newValue = curValue + step * delta;
      if (typeof input.value !== "undefined" && input.value.length === 2) {
        var isHourElem = input === self2.hourElement, isMinuteElem = input === self2.minuteElement;
        if (newValue < min) {
          newValue = max + newValue + int(!isHourElem) + (int(isHourElem) && int(!self2.amPM));
          if (isMinuteElem)
            incrementNumInput(void 0, -1, self2.hourElement);
        } else if (newValue > max) {
          newValue = input === self2.hourElement ? newValue - max - int(!self2.amPM) : min;
          if (isMinuteElem)
            incrementNumInput(void 0, 1, self2.hourElement);
        }
        if (self2.amPM && isHourElem && (step === 1 ? newValue + curValue === 23 : Math.abs(newValue - curValue) > step)) {
          self2.amPM.textContent = self2.l10n.amPM[int(self2.amPM.textContent === self2.l10n.amPM[0])];
        }
        input.value = pad(newValue);
      }
    }
    __name(timeWrapper, "timeWrapper");
    init2();
    return self2;
  }
  __name(FlatpickrInstance, "FlatpickrInstance");
  function _flatpickr(nodeList, config4) {
    var nodes = Array.prototype.slice.call(nodeList).filter(function(x2) {
      return x2 instanceof HTMLElement;
    });
    var instances = [];
    for (var i2 = 0; i2 < nodes.length; i2++) {
      var node = nodes[i2];
      try {
        if (node.getAttribute("data-fp-omit") !== null)
          continue;
        if (node._flatpickr !== void 0) {
          node._flatpickr.destroy();
          node._flatpickr = void 0;
        }
        node._flatpickr = FlatpickrInstance(node, config4 || {});
        instances.push(node._flatpickr);
      } catch (e2) {
        console.error(e2);
      }
    }
    return instances.length === 1 ? instances[0] : instances;
  }
  __name(_flatpickr, "_flatpickr");
  if (typeof HTMLElement !== "undefined" && typeof HTMLCollection !== "undefined" && typeof NodeList !== "undefined") {
    HTMLCollection.prototype.flatpickr = NodeList.prototype.flatpickr = function(config4) {
      return _flatpickr(this, config4);
    };
    HTMLElement.prototype.flatpickr = function(config4) {
      return _flatpickr([this], config4);
    };
  }
  var flatpickr = /* @__PURE__ */ __name(function(selector, config4) {
    if (typeof selector === "string") {
      return _flatpickr(window.document.querySelectorAll(selector), config4);
    } else if (selector instanceof Node) {
      return _flatpickr([selector], config4);
    } else {
      return _flatpickr(selector, config4);
    }
  }, "flatpickr");
  flatpickr.defaultConfig = {};
  flatpickr.l10ns = {
    en: __assign({}, default_default),
    default: __assign({}, default_default)
  };
  flatpickr.localize = function(l10n) {
    flatpickr.l10ns.default = __assign(__assign({}, flatpickr.l10ns.default), l10n);
  };
  flatpickr.setDefaults = function(config4) {
    flatpickr.defaultConfig = __assign(__assign({}, flatpickr.defaultConfig), config4);
  };
  flatpickr.parseDate = createDateParser({});
  flatpickr.formatDate = createDateFormatter({});
  flatpickr.compareDates = compareDates;
  if (typeof jQuery !== "undefined" && typeof jQuery.fn !== "undefined") {
    jQuery.fn.flatpickr = function(config4) {
      return _flatpickr(this, config4);
    };
  }
  Date.prototype.fp_incr = function(days) {
    return new Date(this.getFullYear(), this.getMonth(), this.getDate() + (typeof days === "string" ? parseInt(days, 10) : days));
  };
  if (typeof window !== "undefined") {
    window.flatpickr = flatpickr;
  }
  var esm_default = flatpickr;

  // app/javascript/controllers/datetime_select_controller.js
  var DatetimeSelectController = class extends Controller {
    static {
      __name(this, "DatetimeSelectController");
    }
    connect() {
      const defaults2 = { enableTime: true, time_24hr: true, defaultMinute: 0 };
      const tmp = esm_default(this.querySelector("input"), Object.assign(defaults2, this.appendage()));
    }
    appendage() {
      return this.dataset["inline"] ? { inline: true } : {};
    }
  };

  // app/javascript/controllers/image_preview_controller.js
  var ImagePreviewController = class extends Controller {
    static {
      __name(this, "ImagePreviewController");
    }
    static targets = ["container"];
    preview(e2) {
      const file = e2.currentTarget.files[0];
      if (!file.type.startsWith("image/")) {
        return;
      }
      const img = this.imageElement(file);
      this.containerTarget.innerHTML = "";
      this.containerTarget.appendChild(img);
      this.generatePreview(file, img);
    }
    generatePreview(file, img) {
      const reader = new FileReader();
      reader.onload = /* @__PURE__ */ function(aImg) {
        return function(e2) {
          aImg.src = e2.target.result;
        };
      }(img);
      reader.readAsDataURL(file);
    }
    imageElement(file) {
      const img = document.createElement("img");
      img.file = file;
      return img;
    }
  };

  // app/javascript/controllers/relation_search_controller.js
  var import_debounce2 = __toESM(require_debounce());
  var RelationSearchController = class extends Controller {
    static {
      __name(this, "RelationSearchController");
    }
    static targets = ["field", "visibleField", "results"];
    static values = { model: String };
    connect() {
      this.debouncedFetchData = (0, import_debounce2.default)(this.fetchData.bind(this), 500);
    }
    change(e2) {
      this.debouncedFetchData(e2.target.value);
    }
    fetchData(text, update) {
      fetch("/admin/relations?" + new URLSearchParams({ m: this.modelValue, q: text })).then((response) => response.text()).then((response) => this.display(response));
    }
    display(response) {
      this.resultsTarget.innerHTML = response;
      this.bindNewActions(this.resultsTarget);
    }
    bindNewActions(el) {
      const actionElements = Array.from(el.querySelectorAll("[data-action]"));
      const actions = actionElements.flatMap(this.parseAction.bind(this));
      actions.forEach(this.bindAction.bind(this));
    }
    select(e2) {
      const item = e2.currentTarget;
      this.visibleFieldTarget.value = item.getAttribute("name");
      this.fieldTarget.value = item.id;
      this.resultsTarget.innerHTML = "";
    }
  };

  // node_modules/lodash-es/_freeGlobal.js
  var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
  var freeGlobal_default = freeGlobal;

  // node_modules/lodash-es/_root.js
  var freeSelf = typeof self == "object" && self && self.Object === Object && self;
  var root = freeGlobal_default || freeSelf || Function("return this")();
  var root_default = root;

  // node_modules/lodash-es/_Symbol.js
  var Symbol2 = root_default.Symbol;
  var Symbol_default = Symbol2;

  // node_modules/lodash-es/_getRawTag.js
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var nativeObjectToString = objectProto.toString;
  var symToStringTag = Symbol_default ? Symbol_default.toStringTag : void 0;
  function getRawTag(value) {
    var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
    try {
      value[symToStringTag] = void 0;
      var unmasked = true;
    } catch (e2) {
    }
    var result = nativeObjectToString.call(value);
    if (unmasked) {
      if (isOwn) {
        value[symToStringTag] = tag;
      } else {
        delete value[symToStringTag];
      }
    }
    return result;
  }
  __name(getRawTag, "getRawTag");
  var getRawTag_default = getRawTag;

  // node_modules/lodash-es/_objectToString.js
  var objectProto2 = Object.prototype;
  var nativeObjectToString2 = objectProto2.toString;
  function objectToString(value) {
    return nativeObjectToString2.call(value);
  }
  __name(objectToString, "objectToString");
  var objectToString_default = objectToString;

  // node_modules/lodash-es/_baseGetTag.js
  var nullTag = "[object Null]";
  var undefinedTag = "[object Undefined]";
  var symToStringTag2 = Symbol_default ? Symbol_default.toStringTag : void 0;
  function baseGetTag(value) {
    if (value == null) {
      return value === void 0 ? undefinedTag : nullTag;
    }
    return symToStringTag2 && symToStringTag2 in Object(value) ? getRawTag_default(value) : objectToString_default(value);
  }
  __name(baseGetTag, "baseGetTag");
  var baseGetTag_default = baseGetTag;

  // node_modules/lodash-es/isObjectLike.js
  function isObjectLike(value) {
    return value != null && typeof value == "object";
  }
  __name(isObjectLike, "isObjectLike");
  var isObjectLike_default = isObjectLike;

  // node_modules/lodash-es/isArray.js
  var isArray = Array.isArray;
  var isArray_default = isArray;

  // node_modules/lodash-es/isObject.js
  function isObject(value) {
    var type = typeof value;
    return value != null && (type == "object" || type == "function");
  }
  __name(isObject, "isObject");
  var isObject_default = isObject;

  // node_modules/lodash-es/identity.js
  function identity(value) {
    return value;
  }
  __name(identity, "identity");
  var identity_default = identity;

  // node_modules/lodash-es/isFunction.js
  var asyncTag = "[object AsyncFunction]";
  var funcTag = "[object Function]";
  var genTag = "[object GeneratorFunction]";
  var proxyTag = "[object Proxy]";
  function isFunction(value) {
    if (!isObject_default(value)) {
      return false;
    }
    var tag = baseGetTag_default(value);
    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
  }
  __name(isFunction, "isFunction");
  var isFunction_default = isFunction;

  // node_modules/lodash-es/_coreJsData.js
  var coreJsData = root_default["__core-js_shared__"];
  var coreJsData_default = coreJsData;

  // node_modules/lodash-es/_isMasked.js
  var maskSrcKey = function() {
    var uid = /[^.]+$/.exec(coreJsData_default && coreJsData_default.keys && coreJsData_default.keys.IE_PROTO || "");
    return uid ? "Symbol(src)_1." + uid : "";
  }();
  function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
  }
  __name(isMasked, "isMasked");
  var isMasked_default = isMasked;

  // node_modules/lodash-es/_toSource.js
  var funcProto = Function.prototype;
  var funcToString = funcProto.toString;
  function toSource(func) {
    if (func != null) {
      try {
        return funcToString.call(func);
      } catch (e2) {
      }
      try {
        return func + "";
      } catch (e2) {
      }
    }
    return "";
  }
  __name(toSource, "toSource");
  var toSource_default = toSource;

  // node_modules/lodash-es/_baseIsNative.js
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
  var reIsHostCtor = /^\[object .+?Constructor\]$/;
  var funcProto2 = Function.prototype;
  var objectProto3 = Object.prototype;
  var funcToString2 = funcProto2.toString;
  var hasOwnProperty2 = objectProto3.hasOwnProperty;
  var reIsNative = RegExp(
    "^" + funcToString2.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  );
  function baseIsNative(value) {
    if (!isObject_default(value) || isMasked_default(value)) {
      return false;
    }
    var pattern = isFunction_default(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource_default(value));
  }
  __name(baseIsNative, "baseIsNative");
  var baseIsNative_default = baseIsNative;

  // node_modules/lodash-es/_getValue.js
  function getValue(object, key) {
    return object == null ? void 0 : object[key];
  }
  __name(getValue, "getValue");
  var getValue_default = getValue;

  // node_modules/lodash-es/_getNative.js
  function getNative(object, key) {
    var value = getValue_default(object, key);
    return baseIsNative_default(value) ? value : void 0;
  }
  __name(getNative, "getNative");
  var getNative_default = getNative;

  // node_modules/lodash-es/_WeakMap.js
  var WeakMap2 = getNative_default(root_default, "WeakMap");
  var WeakMap_default = WeakMap2;

  // node_modules/lodash-es/_baseCreate.js
  var objectCreate = Object.create;
  var baseCreate = /* @__PURE__ */ function() {
    function object() {
    }
    __name(object, "object");
    return function(proto) {
      if (!isObject_default(proto)) {
        return {};
      }
      if (objectCreate) {
        return objectCreate(proto);
      }
      object.prototype = proto;
      var result = new object();
      object.prototype = void 0;
      return result;
    };
  }();
  var baseCreate_default = baseCreate;

  // node_modules/lodash-es/_apply.js
  function apply(func, thisArg, args) {
    switch (args.length) {
      case 0:
        return func.call(thisArg);
      case 1:
        return func.call(thisArg, args[0]);
      case 2:
        return func.call(thisArg, args[0], args[1]);
      case 3:
        return func.call(thisArg, args[0], args[1], args[2]);
    }
    return func.apply(thisArg, args);
  }
  __name(apply, "apply");
  var apply_default = apply;

  // node_modules/lodash-es/_copyArray.js
  function copyArray(source, array) {
    var index = -1, length = source.length;
    array || (array = Array(length));
    while (++index < length) {
      array[index] = source[index];
    }
    return array;
  }
  __name(copyArray, "copyArray");
  var copyArray_default = copyArray;

  // node_modules/lodash-es/_shortOut.js
  var HOT_COUNT = 800;
  var HOT_SPAN = 16;
  var nativeNow = Date.now;
  function shortOut(func) {
    var count = 0, lastCalled = 0;
    return function() {
      var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
      lastCalled = stamp;
      if (remaining > 0) {
        if (++count >= HOT_COUNT) {
          return arguments[0];
        }
      } else {
        count = 0;
      }
      return func.apply(void 0, arguments);
    };
  }
  __name(shortOut, "shortOut");
  var shortOut_default = shortOut;

  // node_modules/lodash-es/constant.js
  function constant(value) {
    return function() {
      return value;
    };
  }
  __name(constant, "constant");
  var constant_default = constant;

  // node_modules/lodash-es/_defineProperty.js
  var defineProperty = function() {
    try {
      var func = getNative_default(Object, "defineProperty");
      func({}, "", {});
      return func;
    } catch (e2) {
    }
  }();
  var defineProperty_default = defineProperty;

  // node_modules/lodash-es/_baseSetToString.js
  var baseSetToString = !defineProperty_default ? identity_default : function(func, string) {
    return defineProperty_default(func, "toString", {
      "configurable": true,
      "enumerable": false,
      "value": constant_default(string),
      "writable": true
    });
  };
  var baseSetToString_default = baseSetToString;

  // node_modules/lodash-es/_setToString.js
  var setToString = shortOut_default(baseSetToString_default);
  var setToString_default = setToString;

  // node_modules/lodash-es/_arrayEach.js
  function arrayEach(array, iteratee) {
    var index = -1, length = array == null ? 0 : array.length;
    while (++index < length) {
      if (iteratee(array[index], index, array) === false) {
        break;
      }
    }
    return array;
  }
  __name(arrayEach, "arrayEach");
  var arrayEach_default = arrayEach;

  // node_modules/lodash-es/_isIndex.js
  var MAX_SAFE_INTEGER = 9007199254740991;
  var reIsUint = /^(?:0|[1-9]\d*)$/;
  function isIndex(value, length) {
    var type = typeof value;
    length = length == null ? MAX_SAFE_INTEGER : length;
    return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
  }
  __name(isIndex, "isIndex");
  var isIndex_default = isIndex;

  // node_modules/lodash-es/_baseAssignValue.js
  function baseAssignValue(object, key, value) {
    if (key == "__proto__" && defineProperty_default) {
      defineProperty_default(object, key, {
        "configurable": true,
        "enumerable": true,
        "value": value,
        "writable": true
      });
    } else {
      object[key] = value;
    }
  }
  __name(baseAssignValue, "baseAssignValue");
  var baseAssignValue_default = baseAssignValue;

  // node_modules/lodash-es/eq.js
  function eq(value, other) {
    return value === other || value !== value && other !== other;
  }
  __name(eq, "eq");
  var eq_default = eq;

  // node_modules/lodash-es/_assignValue.js
  var objectProto4 = Object.prototype;
  var hasOwnProperty3 = objectProto4.hasOwnProperty;
  function assignValue(object, key, value) {
    var objValue = object[key];
    if (!(hasOwnProperty3.call(object, key) && eq_default(objValue, value)) || value === void 0 && !(key in object)) {
      baseAssignValue_default(object, key, value);
    }
  }
  __name(assignValue, "assignValue");
  var assignValue_default = assignValue;

  // node_modules/lodash-es/_copyObject.js
  function copyObject(source, props, object, customizer) {
    var isNew = !object;
    object || (object = {});
    var index = -1, length = props.length;
    while (++index < length) {
      var key = props[index];
      var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
      if (newValue === void 0) {
        newValue = source[key];
      }
      if (isNew) {
        baseAssignValue_default(object, key, newValue);
      } else {
        assignValue_default(object, key, newValue);
      }
    }
    return object;
  }
  __name(copyObject, "copyObject");
  var copyObject_default = copyObject;

  // node_modules/lodash-es/_overRest.js
  var nativeMax = Math.max;
  function overRest(func, start2, transform) {
    start2 = nativeMax(start2 === void 0 ? func.length - 1 : start2, 0);
    return function() {
      var args = arguments, index = -1, length = nativeMax(args.length - start2, 0), array = Array(length);
      while (++index < length) {
        array[index] = args[start2 + index];
      }
      index = -1;
      var otherArgs = Array(start2 + 1);
      while (++index < start2) {
        otherArgs[index] = args[index];
      }
      otherArgs[start2] = transform(array);
      return apply_default(func, this, otherArgs);
    };
  }
  __name(overRest, "overRest");
  var overRest_default = overRest;

  // node_modules/lodash-es/_baseRest.js
  function baseRest(func, start2) {
    return setToString_default(overRest_default(func, start2, identity_default), func + "");
  }
  __name(baseRest, "baseRest");
  var baseRest_default = baseRest;

  // node_modules/lodash-es/isLength.js
  var MAX_SAFE_INTEGER2 = 9007199254740991;
  function isLength(value) {
    return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER2;
  }
  __name(isLength, "isLength");
  var isLength_default = isLength;

  // node_modules/lodash-es/isArrayLike.js
  function isArrayLike(value) {
    return value != null && isLength_default(value.length) && !isFunction_default(value);
  }
  __name(isArrayLike, "isArrayLike");
  var isArrayLike_default = isArrayLike;

  // node_modules/lodash-es/_isIterateeCall.js
  function isIterateeCall(value, index, object) {
    if (!isObject_default(object)) {
      return false;
    }
    var type = typeof index;
    if (type == "number" ? isArrayLike_default(object) && isIndex_default(index, object.length) : type == "string" && index in object) {
      return eq_default(object[index], value);
    }
    return false;
  }
  __name(isIterateeCall, "isIterateeCall");
  var isIterateeCall_default = isIterateeCall;

  // node_modules/lodash-es/_createAssigner.js
  function createAssigner(assigner) {
    return baseRest_default(function(object, sources) {
      var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
      customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
      if (guard && isIterateeCall_default(sources[0], sources[1], guard)) {
        customizer = length < 3 ? void 0 : customizer;
        length = 1;
      }
      object = Object(object);
      while (++index < length) {
        var source = sources[index];
        if (source) {
          assigner(object, source, index, customizer);
        }
      }
      return object;
    });
  }
  __name(createAssigner, "createAssigner");
  var createAssigner_default = createAssigner;

  // node_modules/lodash-es/_isPrototype.js
  var objectProto5 = Object.prototype;
  function isPrototype(value) {
    var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto5;
    return value === proto;
  }
  __name(isPrototype, "isPrototype");
  var isPrototype_default = isPrototype;

  // node_modules/lodash-es/_baseTimes.js
  function baseTimes(n2, iteratee) {
    var index = -1, result = Array(n2);
    while (++index < n2) {
      result[index] = iteratee(index);
    }
    return result;
  }
  __name(baseTimes, "baseTimes");
  var baseTimes_default = baseTimes;

  // node_modules/lodash-es/_baseIsArguments.js
  var argsTag = "[object Arguments]";
  function baseIsArguments(value) {
    return isObjectLike_default(value) && baseGetTag_default(value) == argsTag;
  }
  __name(baseIsArguments, "baseIsArguments");
  var baseIsArguments_default = baseIsArguments;

  // node_modules/lodash-es/isArguments.js
  var objectProto6 = Object.prototype;
  var hasOwnProperty4 = objectProto6.hasOwnProperty;
  var propertyIsEnumerable = objectProto6.propertyIsEnumerable;
  var isArguments = baseIsArguments_default(/* @__PURE__ */ function() {
    return arguments;
  }()) ? baseIsArguments_default : function(value) {
    return isObjectLike_default(value) && hasOwnProperty4.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
  };
  var isArguments_default = isArguments;

  // node_modules/lodash-es/stubFalse.js
  function stubFalse() {
    return false;
  }
  __name(stubFalse, "stubFalse");
  var stubFalse_default = stubFalse;

  // node_modules/lodash-es/isBuffer.js
  var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
  var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var Buffer2 = moduleExports ? root_default.Buffer : void 0;
  var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
  var isBuffer = nativeIsBuffer || stubFalse_default;
  var isBuffer_default = isBuffer;

  // node_modules/lodash-es/_baseIsTypedArray.js
  var argsTag2 = "[object Arguments]";
  var arrayTag = "[object Array]";
  var boolTag = "[object Boolean]";
  var dateTag = "[object Date]";
  var errorTag = "[object Error]";
  var funcTag2 = "[object Function]";
  var mapTag = "[object Map]";
  var numberTag = "[object Number]";
  var objectTag = "[object Object]";
  var regexpTag = "[object RegExp]";
  var setTag = "[object Set]";
  var stringTag = "[object String]";
  var weakMapTag = "[object WeakMap]";
  var arrayBufferTag = "[object ArrayBuffer]";
  var dataViewTag = "[object DataView]";
  var float32Tag = "[object Float32Array]";
  var float64Tag = "[object Float64Array]";
  var int8Tag = "[object Int8Array]";
  var int16Tag = "[object Int16Array]";
  var int32Tag = "[object Int32Array]";
  var uint8Tag = "[object Uint8Array]";
  var uint8ClampedTag = "[object Uint8ClampedArray]";
  var uint16Tag = "[object Uint16Array]";
  var uint32Tag = "[object Uint32Array]";
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag2] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag2] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
  function baseIsTypedArray(value) {
    return isObjectLike_default(value) && isLength_default(value.length) && !!typedArrayTags[baseGetTag_default(value)];
  }
  __name(baseIsTypedArray, "baseIsTypedArray");
  var baseIsTypedArray_default = baseIsTypedArray;

  // node_modules/lodash-es/_baseUnary.js
  function baseUnary(func) {
    return function(value) {
      return func(value);
    };
  }
  __name(baseUnary, "baseUnary");
  var baseUnary_default = baseUnary;

  // node_modules/lodash-es/_nodeUtil.js
  var freeExports2 = typeof exports == "object" && exports && !exports.nodeType && exports;
  var freeModule2 = freeExports2 && typeof module == "object" && module && !module.nodeType && module;
  var moduleExports2 = freeModule2 && freeModule2.exports === freeExports2;
  var freeProcess = moduleExports2 && freeGlobal_default.process;
  var nodeUtil = function() {
    try {
      var types = freeModule2 && freeModule2.require && freeModule2.require("util").types;
      if (types) {
        return types;
      }
      return freeProcess && freeProcess.binding && freeProcess.binding("util");
    } catch (e2) {
    }
  }();
  var nodeUtil_default = nodeUtil;

  // node_modules/lodash-es/isTypedArray.js
  var nodeIsTypedArray = nodeUtil_default && nodeUtil_default.isTypedArray;
  var isTypedArray = nodeIsTypedArray ? baseUnary_default(nodeIsTypedArray) : baseIsTypedArray_default;
  var isTypedArray_default = isTypedArray;

  // node_modules/lodash-es/_arrayLikeKeys.js
  var objectProto7 = Object.prototype;
  var hasOwnProperty5 = objectProto7.hasOwnProperty;
  function arrayLikeKeys(value, inherited) {
    var isArr = isArray_default(value), isArg = !isArr && isArguments_default(value), isBuff = !isArr && !isArg && isBuffer_default(value), isType = !isArr && !isArg && !isBuff && isTypedArray_default(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes_default(value.length, String) : [], length = result.length;
    for (var key in value) {
      if ((inherited || hasOwnProperty5.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
      (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
      isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
      isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
      isIndex_default(key, length)))) {
        result.push(key);
      }
    }
    return result;
  }
  __name(arrayLikeKeys, "arrayLikeKeys");
  var arrayLikeKeys_default = arrayLikeKeys;

  // node_modules/lodash-es/_overArg.js
  function overArg(func, transform) {
    return function(arg) {
      return func(transform(arg));
    };
  }
  __name(overArg, "overArg");
  var overArg_default = overArg;

  // node_modules/lodash-es/_nativeKeys.js
  var nativeKeys = overArg_default(Object.keys, Object);
  var nativeKeys_default = nativeKeys;

  // node_modules/lodash-es/_baseKeys.js
  var objectProto8 = Object.prototype;
  var hasOwnProperty6 = objectProto8.hasOwnProperty;
  function baseKeys(object) {
    if (!isPrototype_default(object)) {
      return nativeKeys_default(object);
    }
    var result = [];
    for (var key in Object(object)) {
      if (hasOwnProperty6.call(object, key) && key != "constructor") {
        result.push(key);
      }
    }
    return result;
  }
  __name(baseKeys, "baseKeys");
  var baseKeys_default = baseKeys;

  // node_modules/lodash-es/keys.js
  function keys(object) {
    return isArrayLike_default(object) ? arrayLikeKeys_default(object) : baseKeys_default(object);
  }
  __name(keys, "keys");
  var keys_default = keys;

  // node_modules/lodash-es/_nativeKeysIn.js
  function nativeKeysIn(object) {
    var result = [];
    if (object != null) {
      for (var key in Object(object)) {
        result.push(key);
      }
    }
    return result;
  }
  __name(nativeKeysIn, "nativeKeysIn");
  var nativeKeysIn_default = nativeKeysIn;

  // node_modules/lodash-es/_baseKeysIn.js
  var objectProto9 = Object.prototype;
  var hasOwnProperty7 = objectProto9.hasOwnProperty;
  function baseKeysIn(object) {
    if (!isObject_default(object)) {
      return nativeKeysIn_default(object);
    }
    var isProto = isPrototype_default(object), result = [];
    for (var key in object) {
      if (!(key == "constructor" && (isProto || !hasOwnProperty7.call(object, key)))) {
        result.push(key);
      }
    }
    return result;
  }
  __name(baseKeysIn, "baseKeysIn");
  var baseKeysIn_default = baseKeysIn;

  // node_modules/lodash-es/keysIn.js
  function keysIn(object) {
    return isArrayLike_default(object) ? arrayLikeKeys_default(object, true) : baseKeysIn_default(object);
  }
  __name(keysIn, "keysIn");
  var keysIn_default = keysIn;

  // node_modules/lodash-es/_nativeCreate.js
  var nativeCreate = getNative_default(Object, "create");
  var nativeCreate_default = nativeCreate;

  // node_modules/lodash-es/_hashClear.js
  function hashClear() {
    this.__data__ = nativeCreate_default ? nativeCreate_default(null) : {};
    this.size = 0;
  }
  __name(hashClear, "hashClear");
  var hashClear_default = hashClear;

  // node_modules/lodash-es/_hashDelete.js
  function hashDelete(key) {
    var result = this.has(key) && delete this.__data__[key];
    this.size -= result ? 1 : 0;
    return result;
  }
  __name(hashDelete, "hashDelete");
  var hashDelete_default = hashDelete;

  // node_modules/lodash-es/_hashGet.js
  var HASH_UNDEFINED = "__lodash_hash_undefined__";
  var objectProto10 = Object.prototype;
  var hasOwnProperty8 = objectProto10.hasOwnProperty;
  function hashGet(key) {
    var data = this.__data__;
    if (nativeCreate_default) {
      var result = data[key];
      return result === HASH_UNDEFINED ? void 0 : result;
    }
    return hasOwnProperty8.call(data, key) ? data[key] : void 0;
  }
  __name(hashGet, "hashGet");
  var hashGet_default = hashGet;

  // node_modules/lodash-es/_hashHas.js
  var objectProto11 = Object.prototype;
  var hasOwnProperty9 = objectProto11.hasOwnProperty;
  function hashHas(key) {
    var data = this.__data__;
    return nativeCreate_default ? data[key] !== void 0 : hasOwnProperty9.call(data, key);
  }
  __name(hashHas, "hashHas");
  var hashHas_default = hashHas;

  // node_modules/lodash-es/_hashSet.js
  var HASH_UNDEFINED2 = "__lodash_hash_undefined__";
  function hashSet(key, value) {
    var data = this.__data__;
    this.size += this.has(key) ? 0 : 1;
    data[key] = nativeCreate_default && value === void 0 ? HASH_UNDEFINED2 : value;
    return this;
  }
  __name(hashSet, "hashSet");
  var hashSet_default = hashSet;

  // node_modules/lodash-es/_Hash.js
  function Hash(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  __name(Hash, "Hash");
  Hash.prototype.clear = hashClear_default;
  Hash.prototype["delete"] = hashDelete_default;
  Hash.prototype.get = hashGet_default;
  Hash.prototype.has = hashHas_default;
  Hash.prototype.set = hashSet_default;
  var Hash_default = Hash;

  // node_modules/lodash-es/_listCacheClear.js
  function listCacheClear() {
    this.__data__ = [];
    this.size = 0;
  }
  __name(listCacheClear, "listCacheClear");
  var listCacheClear_default = listCacheClear;

  // node_modules/lodash-es/_assocIndexOf.js
  function assocIndexOf(array, key) {
    var length = array.length;
    while (length--) {
      if (eq_default(array[length][0], key)) {
        return length;
      }
    }
    return -1;
  }
  __name(assocIndexOf, "assocIndexOf");
  var assocIndexOf_default = assocIndexOf;

  // node_modules/lodash-es/_listCacheDelete.js
  var arrayProto = Array.prototype;
  var splice = arrayProto.splice;
  function listCacheDelete(key) {
    var data = this.__data__, index = assocIndexOf_default(data, key);
    if (index < 0) {
      return false;
    }
    var lastIndex = data.length - 1;
    if (index == lastIndex) {
      data.pop();
    } else {
      splice.call(data, index, 1);
    }
    --this.size;
    return true;
  }
  __name(listCacheDelete, "listCacheDelete");
  var listCacheDelete_default = listCacheDelete;

  // node_modules/lodash-es/_listCacheGet.js
  function listCacheGet(key) {
    var data = this.__data__, index = assocIndexOf_default(data, key);
    return index < 0 ? void 0 : data[index][1];
  }
  __name(listCacheGet, "listCacheGet");
  var listCacheGet_default = listCacheGet;

  // node_modules/lodash-es/_listCacheHas.js
  function listCacheHas(key) {
    return assocIndexOf_default(this.__data__, key) > -1;
  }
  __name(listCacheHas, "listCacheHas");
  var listCacheHas_default = listCacheHas;

  // node_modules/lodash-es/_listCacheSet.js
  function listCacheSet(key, value) {
    var data = this.__data__, index = assocIndexOf_default(data, key);
    if (index < 0) {
      ++this.size;
      data.push([key, value]);
    } else {
      data[index][1] = value;
    }
    return this;
  }
  __name(listCacheSet, "listCacheSet");
  var listCacheSet_default = listCacheSet;

  // node_modules/lodash-es/_ListCache.js
  function ListCache(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  __name(ListCache, "ListCache");
  ListCache.prototype.clear = listCacheClear_default;
  ListCache.prototype["delete"] = listCacheDelete_default;
  ListCache.prototype.get = listCacheGet_default;
  ListCache.prototype.has = listCacheHas_default;
  ListCache.prototype.set = listCacheSet_default;
  var ListCache_default = ListCache;

  // node_modules/lodash-es/_Map.js
  var Map2 = getNative_default(root_default, "Map");
  var Map_default = Map2;

  // node_modules/lodash-es/_mapCacheClear.js
  function mapCacheClear() {
    this.size = 0;
    this.__data__ = {
      "hash": new Hash_default(),
      "map": new (Map_default || ListCache_default)(),
      "string": new Hash_default()
    };
  }
  __name(mapCacheClear, "mapCacheClear");
  var mapCacheClear_default = mapCacheClear;

  // node_modules/lodash-es/_isKeyable.js
  function isKeyable(value) {
    var type = typeof value;
    return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
  }
  __name(isKeyable, "isKeyable");
  var isKeyable_default = isKeyable;

  // node_modules/lodash-es/_getMapData.js
  function getMapData(map, key) {
    var data = map.__data__;
    return isKeyable_default(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
  }
  __name(getMapData, "getMapData");
  var getMapData_default = getMapData;

  // node_modules/lodash-es/_mapCacheDelete.js
  function mapCacheDelete(key) {
    var result = getMapData_default(this, key)["delete"](key);
    this.size -= result ? 1 : 0;
    return result;
  }
  __name(mapCacheDelete, "mapCacheDelete");
  var mapCacheDelete_default = mapCacheDelete;

  // node_modules/lodash-es/_mapCacheGet.js
  function mapCacheGet(key) {
    return getMapData_default(this, key).get(key);
  }
  __name(mapCacheGet, "mapCacheGet");
  var mapCacheGet_default = mapCacheGet;

  // node_modules/lodash-es/_mapCacheHas.js
  function mapCacheHas(key) {
    return getMapData_default(this, key).has(key);
  }
  __name(mapCacheHas, "mapCacheHas");
  var mapCacheHas_default = mapCacheHas;

  // node_modules/lodash-es/_mapCacheSet.js
  function mapCacheSet(key, value) {
    var data = getMapData_default(this, key), size = data.size;
    data.set(key, value);
    this.size += data.size == size ? 0 : 1;
    return this;
  }
  __name(mapCacheSet, "mapCacheSet");
  var mapCacheSet_default = mapCacheSet;

  // node_modules/lodash-es/_MapCache.js
  function MapCache(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  __name(MapCache, "MapCache");
  MapCache.prototype.clear = mapCacheClear_default;
  MapCache.prototype["delete"] = mapCacheDelete_default;
  MapCache.prototype.get = mapCacheGet_default;
  MapCache.prototype.has = mapCacheHas_default;
  MapCache.prototype.set = mapCacheSet_default;
  var MapCache_default = MapCache;

  // node_modules/lodash-es/_arrayPush.js
  function arrayPush(array, values) {
    var index = -1, length = values.length, offset = array.length;
    while (++index < length) {
      array[offset + index] = values[index];
    }
    return array;
  }
  __name(arrayPush, "arrayPush");
  var arrayPush_default = arrayPush;

  // node_modules/lodash-es/_getPrototype.js
  var getPrototype = overArg_default(Object.getPrototypeOf, Object);
  var getPrototype_default = getPrototype;

  // node_modules/lodash-es/isPlainObject.js
  var objectTag2 = "[object Object]";
  var funcProto3 = Function.prototype;
  var objectProto12 = Object.prototype;
  var funcToString3 = funcProto3.toString;
  var hasOwnProperty10 = objectProto12.hasOwnProperty;
  var objectCtorString = funcToString3.call(Object);
  function isPlainObject(value) {
    if (!isObjectLike_default(value) || baseGetTag_default(value) != objectTag2) {
      return false;
    }
    var proto = getPrototype_default(value);
    if (proto === null) {
      return true;
    }
    var Ctor = hasOwnProperty10.call(proto, "constructor") && proto.constructor;
    return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString3.call(Ctor) == objectCtorString;
  }
  __name(isPlainObject, "isPlainObject");
  var isPlainObject_default = isPlainObject;

  // node_modules/lodash-es/_stackClear.js
  function stackClear() {
    this.__data__ = new ListCache_default();
    this.size = 0;
  }
  __name(stackClear, "stackClear");
  var stackClear_default = stackClear;

  // node_modules/lodash-es/_stackDelete.js
  function stackDelete(key) {
    var data = this.__data__, result = data["delete"](key);
    this.size = data.size;
    return result;
  }
  __name(stackDelete, "stackDelete");
  var stackDelete_default = stackDelete;

  // node_modules/lodash-es/_stackGet.js
  function stackGet(key) {
    return this.__data__.get(key);
  }
  __name(stackGet, "stackGet");
  var stackGet_default = stackGet;

  // node_modules/lodash-es/_stackHas.js
  function stackHas(key) {
    return this.__data__.has(key);
  }
  __name(stackHas, "stackHas");
  var stackHas_default = stackHas;

  // node_modules/lodash-es/_stackSet.js
  var LARGE_ARRAY_SIZE = 200;
  function stackSet(key, value) {
    var data = this.__data__;
    if (data instanceof ListCache_default) {
      var pairs = data.__data__;
      if (!Map_default || pairs.length < LARGE_ARRAY_SIZE - 1) {
        pairs.push([key, value]);
        this.size = ++data.size;
        return this;
      }
      data = this.__data__ = new MapCache_default(pairs);
    }
    data.set(key, value);
    this.size = data.size;
    return this;
  }
  __name(stackSet, "stackSet");
  var stackSet_default = stackSet;

  // node_modules/lodash-es/_Stack.js
  function Stack(entries) {
    var data = this.__data__ = new ListCache_default(entries);
    this.size = data.size;
  }
  __name(Stack, "Stack");
  Stack.prototype.clear = stackClear_default;
  Stack.prototype["delete"] = stackDelete_default;
  Stack.prototype.get = stackGet_default;
  Stack.prototype.has = stackHas_default;
  Stack.prototype.set = stackSet_default;
  var Stack_default = Stack;

  // node_modules/lodash-es/_baseAssign.js
  function baseAssign(object, source) {
    return object && copyObject_default(source, keys_default(source), object);
  }
  __name(baseAssign, "baseAssign");
  var baseAssign_default = baseAssign;

  // node_modules/lodash-es/_baseAssignIn.js
  function baseAssignIn(object, source) {
    return object && copyObject_default(source, keysIn_default(source), object);
  }
  __name(baseAssignIn, "baseAssignIn");
  var baseAssignIn_default = baseAssignIn;

  // node_modules/lodash-es/_cloneBuffer.js
  var freeExports3 = typeof exports == "object" && exports && !exports.nodeType && exports;
  var freeModule3 = freeExports3 && typeof module == "object" && module && !module.nodeType && module;
  var moduleExports3 = freeModule3 && freeModule3.exports === freeExports3;
  var Buffer3 = moduleExports3 ? root_default.Buffer : void 0;
  var allocUnsafe = Buffer3 ? Buffer3.allocUnsafe : void 0;
  function cloneBuffer(buffer, isDeep) {
    if (isDeep) {
      return buffer.slice();
    }
    var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
    buffer.copy(result);
    return result;
  }
  __name(cloneBuffer, "cloneBuffer");
  var cloneBuffer_default = cloneBuffer;

  // node_modules/lodash-es/_arrayFilter.js
  function arrayFilter(array, predicate) {
    var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
    while (++index < length) {
      var value = array[index];
      if (predicate(value, index, array)) {
        result[resIndex++] = value;
      }
    }
    return result;
  }
  __name(arrayFilter, "arrayFilter");
  var arrayFilter_default = arrayFilter;

  // node_modules/lodash-es/stubArray.js
  function stubArray() {
    return [];
  }
  __name(stubArray, "stubArray");
  var stubArray_default = stubArray;

  // node_modules/lodash-es/_getSymbols.js
  var objectProto13 = Object.prototype;
  var propertyIsEnumerable2 = objectProto13.propertyIsEnumerable;
  var nativeGetSymbols = Object.getOwnPropertySymbols;
  var getSymbols = !nativeGetSymbols ? stubArray_default : function(object) {
    if (object == null) {
      return [];
    }
    object = Object(object);
    return arrayFilter_default(nativeGetSymbols(object), function(symbol) {
      return propertyIsEnumerable2.call(object, symbol);
    });
  };
  var getSymbols_default = getSymbols;

  // node_modules/lodash-es/_copySymbols.js
  function copySymbols(source, object) {
    return copyObject_default(source, getSymbols_default(source), object);
  }
  __name(copySymbols, "copySymbols");
  var copySymbols_default = copySymbols;

  // node_modules/lodash-es/_getSymbolsIn.js
  var nativeGetSymbols2 = Object.getOwnPropertySymbols;
  var getSymbolsIn = !nativeGetSymbols2 ? stubArray_default : function(object) {
    var result = [];
    while (object) {
      arrayPush_default(result, getSymbols_default(object));
      object = getPrototype_default(object);
    }
    return result;
  };
  var getSymbolsIn_default = getSymbolsIn;

  // node_modules/lodash-es/_copySymbolsIn.js
  function copySymbolsIn(source, object) {
    return copyObject_default(source, getSymbolsIn_default(source), object);
  }
  __name(copySymbolsIn, "copySymbolsIn");
  var copySymbolsIn_default = copySymbolsIn;

  // node_modules/lodash-es/_baseGetAllKeys.js
  function baseGetAllKeys(object, keysFunc, symbolsFunc) {
    var result = keysFunc(object);
    return isArray_default(object) ? result : arrayPush_default(result, symbolsFunc(object));
  }
  __name(baseGetAllKeys, "baseGetAllKeys");
  var baseGetAllKeys_default = baseGetAllKeys;

  // node_modules/lodash-es/_getAllKeys.js
  function getAllKeys(object) {
    return baseGetAllKeys_default(object, keys_default, getSymbols_default);
  }
  __name(getAllKeys, "getAllKeys");
  var getAllKeys_default = getAllKeys;

  // node_modules/lodash-es/_getAllKeysIn.js
  function getAllKeysIn(object) {
    return baseGetAllKeys_default(object, keysIn_default, getSymbolsIn_default);
  }
  __name(getAllKeysIn, "getAllKeysIn");
  var getAllKeysIn_default = getAllKeysIn;

  // node_modules/lodash-es/_DataView.js
  var DataView = getNative_default(root_default, "DataView");
  var DataView_default = DataView;

  // node_modules/lodash-es/_Promise.js
  var Promise2 = getNative_default(root_default, "Promise");
  var Promise_default = Promise2;

  // node_modules/lodash-es/_Set.js
  var Set2 = getNative_default(root_default, "Set");
  var Set_default = Set2;

  // node_modules/lodash-es/_getTag.js
  var mapTag2 = "[object Map]";
  var objectTag3 = "[object Object]";
  var promiseTag = "[object Promise]";
  var setTag2 = "[object Set]";
  var weakMapTag2 = "[object WeakMap]";
  var dataViewTag2 = "[object DataView]";
  var dataViewCtorString = toSource_default(DataView_default);
  var mapCtorString = toSource_default(Map_default);
  var promiseCtorString = toSource_default(Promise_default);
  var setCtorString = toSource_default(Set_default);
  var weakMapCtorString = toSource_default(WeakMap_default);
  var getTag = baseGetTag_default;
  if (DataView_default && getTag(new DataView_default(new ArrayBuffer(1))) != dataViewTag2 || Map_default && getTag(new Map_default()) != mapTag2 || Promise_default && getTag(Promise_default.resolve()) != promiseTag || Set_default && getTag(new Set_default()) != setTag2 || WeakMap_default && getTag(new WeakMap_default()) != weakMapTag2) {
    getTag = /* @__PURE__ */ __name(function(value) {
      var result = baseGetTag_default(value), Ctor = result == objectTag3 ? value.constructor : void 0, ctorString = Ctor ? toSource_default(Ctor) : "";
      if (ctorString) {
        switch (ctorString) {
          case dataViewCtorString:
            return dataViewTag2;
          case mapCtorString:
            return mapTag2;
          case promiseCtorString:
            return promiseTag;
          case setCtorString:
            return setTag2;
          case weakMapCtorString:
            return weakMapTag2;
        }
      }
      return result;
    }, "getTag");
  }
  var getTag_default = getTag;

  // node_modules/lodash-es/_initCloneArray.js
  var objectProto14 = Object.prototype;
  var hasOwnProperty11 = objectProto14.hasOwnProperty;
  function initCloneArray(array) {
    var length = array.length, result = new array.constructor(length);
    if (length && typeof array[0] == "string" && hasOwnProperty11.call(array, "index")) {
      result.index = array.index;
      result.input = array.input;
    }
    return result;
  }
  __name(initCloneArray, "initCloneArray");
  var initCloneArray_default = initCloneArray;

  // node_modules/lodash-es/_Uint8Array.js
  var Uint8Array2 = root_default.Uint8Array;
  var Uint8Array_default = Uint8Array2;

  // node_modules/lodash-es/_cloneArrayBuffer.js
  function cloneArrayBuffer(arrayBuffer) {
    var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
    new Uint8Array_default(result).set(new Uint8Array_default(arrayBuffer));
    return result;
  }
  __name(cloneArrayBuffer, "cloneArrayBuffer");
  var cloneArrayBuffer_default = cloneArrayBuffer;

  // node_modules/lodash-es/_cloneDataView.js
  function cloneDataView(dataView, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer_default(dataView.buffer) : dataView.buffer;
    return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
  }
  __name(cloneDataView, "cloneDataView");
  var cloneDataView_default = cloneDataView;

  // node_modules/lodash-es/_cloneRegExp.js
  var reFlags = /\w*$/;
  function cloneRegExp(regexp) {
    var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
    result.lastIndex = regexp.lastIndex;
    return result;
  }
  __name(cloneRegExp, "cloneRegExp");
  var cloneRegExp_default = cloneRegExp;

  // node_modules/lodash-es/_cloneSymbol.js
  var symbolProto = Symbol_default ? Symbol_default.prototype : void 0;
  var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
  function cloneSymbol(symbol) {
    return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
  }
  __name(cloneSymbol, "cloneSymbol");
  var cloneSymbol_default = cloneSymbol;

  // node_modules/lodash-es/_cloneTypedArray.js
  function cloneTypedArray(typedArray, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer_default(typedArray.buffer) : typedArray.buffer;
    return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
  }
  __name(cloneTypedArray, "cloneTypedArray");
  var cloneTypedArray_default = cloneTypedArray;

  // node_modules/lodash-es/_initCloneByTag.js
  var boolTag2 = "[object Boolean]";
  var dateTag2 = "[object Date]";
  var mapTag3 = "[object Map]";
  var numberTag2 = "[object Number]";
  var regexpTag2 = "[object RegExp]";
  var setTag3 = "[object Set]";
  var stringTag2 = "[object String]";
  var symbolTag = "[object Symbol]";
  var arrayBufferTag2 = "[object ArrayBuffer]";
  var dataViewTag3 = "[object DataView]";
  var float32Tag2 = "[object Float32Array]";
  var float64Tag2 = "[object Float64Array]";
  var int8Tag2 = "[object Int8Array]";
  var int16Tag2 = "[object Int16Array]";
  var int32Tag2 = "[object Int32Array]";
  var uint8Tag2 = "[object Uint8Array]";
  var uint8ClampedTag2 = "[object Uint8ClampedArray]";
  var uint16Tag2 = "[object Uint16Array]";
  var uint32Tag2 = "[object Uint32Array]";
  function initCloneByTag(object, tag, isDeep) {
    var Ctor = object.constructor;
    switch (tag) {
      case arrayBufferTag2:
        return cloneArrayBuffer_default(object);
      case boolTag2:
      case dateTag2:
        return new Ctor(+object);
      case dataViewTag3:
        return cloneDataView_default(object, isDeep);
      case float32Tag2:
      case float64Tag2:
      case int8Tag2:
      case int16Tag2:
      case int32Tag2:
      case uint8Tag2:
      case uint8ClampedTag2:
      case uint16Tag2:
      case uint32Tag2:
        return cloneTypedArray_default(object, isDeep);
      case mapTag3:
        return new Ctor();
      case numberTag2:
      case stringTag2:
        return new Ctor(object);
      case regexpTag2:
        return cloneRegExp_default(object);
      case setTag3:
        return new Ctor();
      case symbolTag:
        return cloneSymbol_default(object);
    }
  }
  __name(initCloneByTag, "initCloneByTag");
  var initCloneByTag_default = initCloneByTag;

  // node_modules/lodash-es/_initCloneObject.js
  function initCloneObject(object) {
    return typeof object.constructor == "function" && !isPrototype_default(object) ? baseCreate_default(getPrototype_default(object)) : {};
  }
  __name(initCloneObject, "initCloneObject");
  var initCloneObject_default = initCloneObject;

  // node_modules/lodash-es/_baseIsMap.js
  var mapTag4 = "[object Map]";
  function baseIsMap(value) {
    return isObjectLike_default(value) && getTag_default(value) == mapTag4;
  }
  __name(baseIsMap, "baseIsMap");
  var baseIsMap_default = baseIsMap;

  // node_modules/lodash-es/isMap.js
  var nodeIsMap = nodeUtil_default && nodeUtil_default.isMap;
  var isMap = nodeIsMap ? baseUnary_default(nodeIsMap) : baseIsMap_default;
  var isMap_default = isMap;

  // node_modules/lodash-es/_baseIsSet.js
  var setTag4 = "[object Set]";
  function baseIsSet(value) {
    return isObjectLike_default(value) && getTag_default(value) == setTag4;
  }
  __name(baseIsSet, "baseIsSet");
  var baseIsSet_default = baseIsSet;

  // node_modules/lodash-es/isSet.js
  var nodeIsSet = nodeUtil_default && nodeUtil_default.isSet;
  var isSet = nodeIsSet ? baseUnary_default(nodeIsSet) : baseIsSet_default;
  var isSet_default = isSet;

  // node_modules/lodash-es/_baseClone.js
  var CLONE_DEEP_FLAG = 1;
  var CLONE_FLAT_FLAG = 2;
  var CLONE_SYMBOLS_FLAG = 4;
  var argsTag3 = "[object Arguments]";
  var arrayTag2 = "[object Array]";
  var boolTag3 = "[object Boolean]";
  var dateTag3 = "[object Date]";
  var errorTag2 = "[object Error]";
  var funcTag3 = "[object Function]";
  var genTag2 = "[object GeneratorFunction]";
  var mapTag5 = "[object Map]";
  var numberTag3 = "[object Number]";
  var objectTag4 = "[object Object]";
  var regexpTag3 = "[object RegExp]";
  var setTag5 = "[object Set]";
  var stringTag3 = "[object String]";
  var symbolTag2 = "[object Symbol]";
  var weakMapTag3 = "[object WeakMap]";
  var arrayBufferTag3 = "[object ArrayBuffer]";
  var dataViewTag4 = "[object DataView]";
  var float32Tag3 = "[object Float32Array]";
  var float64Tag3 = "[object Float64Array]";
  var int8Tag3 = "[object Int8Array]";
  var int16Tag3 = "[object Int16Array]";
  var int32Tag3 = "[object Int32Array]";
  var uint8Tag3 = "[object Uint8Array]";
  var uint8ClampedTag3 = "[object Uint8ClampedArray]";
  var uint16Tag3 = "[object Uint16Array]";
  var uint32Tag3 = "[object Uint32Array]";
  var cloneableTags = {};
  cloneableTags[argsTag3] = cloneableTags[arrayTag2] = cloneableTags[arrayBufferTag3] = cloneableTags[dataViewTag4] = cloneableTags[boolTag3] = cloneableTags[dateTag3] = cloneableTags[float32Tag3] = cloneableTags[float64Tag3] = cloneableTags[int8Tag3] = cloneableTags[int16Tag3] = cloneableTags[int32Tag3] = cloneableTags[mapTag5] = cloneableTags[numberTag3] = cloneableTags[objectTag4] = cloneableTags[regexpTag3] = cloneableTags[setTag5] = cloneableTags[stringTag3] = cloneableTags[symbolTag2] = cloneableTags[uint8Tag3] = cloneableTags[uint8ClampedTag3] = cloneableTags[uint16Tag3] = cloneableTags[uint32Tag3] = true;
  cloneableTags[errorTag2] = cloneableTags[funcTag3] = cloneableTags[weakMapTag3] = false;
  function baseClone(value, bitmask, customizer, key, object, stack) {
    var result, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
    if (customizer) {
      result = object ? customizer(value, key, object, stack) : customizer(value);
    }
    if (result !== void 0) {
      return result;
    }
    if (!isObject_default(value)) {
      return value;
    }
    var isArr = isArray_default(value);
    if (isArr) {
      result = initCloneArray_default(value);
      if (!isDeep) {
        return copyArray_default(value, result);
      }
    } else {
      var tag = getTag_default(value), isFunc = tag == funcTag3 || tag == genTag2;
      if (isBuffer_default(value)) {
        return cloneBuffer_default(value, isDeep);
      }
      if (tag == objectTag4 || tag == argsTag3 || isFunc && !object) {
        result = isFlat || isFunc ? {} : initCloneObject_default(value);
        if (!isDeep) {
          return isFlat ? copySymbolsIn_default(value, baseAssignIn_default(result, value)) : copySymbols_default(value, baseAssign_default(result, value));
        }
      } else {
        if (!cloneableTags[tag]) {
          return object ? value : {};
        }
        result = initCloneByTag_default(value, tag, isDeep);
      }
    }
    stack || (stack = new Stack_default());
    var stacked = stack.get(value);
    if (stacked) {
      return stacked;
    }
    stack.set(value, result);
    if (isSet_default(value)) {
      value.forEach(function(subValue) {
        result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
      });
    } else if (isMap_default(value)) {
      value.forEach(function(subValue, key2) {
        result.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
      });
    }
    var keysFunc = isFull ? isFlat ? getAllKeysIn_default : getAllKeys_default : isFlat ? keysIn_default : keys_default;
    var props = isArr ? void 0 : keysFunc(value);
    arrayEach_default(props || value, function(subValue, key2) {
      if (props) {
        key2 = subValue;
        subValue = value[key2];
      }
      assignValue_default(result, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
    });
    return result;
  }
  __name(baseClone, "baseClone");
  var baseClone_default = baseClone;

  // node_modules/lodash-es/cloneDeep.js
  var CLONE_DEEP_FLAG2 = 1;
  var CLONE_SYMBOLS_FLAG2 = 4;
  function cloneDeep(value) {
    return baseClone_default(value, CLONE_DEEP_FLAG2 | CLONE_SYMBOLS_FLAG2);
  }
  __name(cloneDeep, "cloneDeep");
  var cloneDeep_default = cloneDeep;

  // node_modules/lodash-es/_setCacheAdd.js
  var HASH_UNDEFINED3 = "__lodash_hash_undefined__";
  function setCacheAdd(value) {
    this.__data__.set(value, HASH_UNDEFINED3);
    return this;
  }
  __name(setCacheAdd, "setCacheAdd");
  var setCacheAdd_default = setCacheAdd;

  // node_modules/lodash-es/_setCacheHas.js
  function setCacheHas(value) {
    return this.__data__.has(value);
  }
  __name(setCacheHas, "setCacheHas");
  var setCacheHas_default = setCacheHas;

  // node_modules/lodash-es/_SetCache.js
  function SetCache(values) {
    var index = -1, length = values == null ? 0 : values.length;
    this.__data__ = new MapCache_default();
    while (++index < length) {
      this.add(values[index]);
    }
  }
  __name(SetCache, "SetCache");
  SetCache.prototype.add = SetCache.prototype.push = setCacheAdd_default;
  SetCache.prototype.has = setCacheHas_default;
  var SetCache_default = SetCache;

  // node_modules/lodash-es/_arraySome.js
  function arraySome(array, predicate) {
    var index = -1, length = array == null ? 0 : array.length;
    while (++index < length) {
      if (predicate(array[index], index, array)) {
        return true;
      }
    }
    return false;
  }
  __name(arraySome, "arraySome");
  var arraySome_default = arraySome;

  // node_modules/lodash-es/_cacheHas.js
  function cacheHas(cache2, key) {
    return cache2.has(key);
  }
  __name(cacheHas, "cacheHas");
  var cacheHas_default = cacheHas;

  // node_modules/lodash-es/_equalArrays.js
  var COMPARE_PARTIAL_FLAG = 1;
  var COMPARE_UNORDERED_FLAG = 2;
  function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
    if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
      return false;
    }
    var arrStacked = stack.get(array);
    var othStacked = stack.get(other);
    if (arrStacked && othStacked) {
      return arrStacked == other && othStacked == array;
    }
    var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache_default() : void 0;
    stack.set(array, other);
    stack.set(other, array);
    while (++index < arrLength) {
      var arrValue = array[index], othValue = other[index];
      if (customizer) {
        var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
      }
      if (compared !== void 0) {
        if (compared) {
          continue;
        }
        result = false;
        break;
      }
      if (seen) {
        if (!arraySome_default(other, function(othValue2, othIndex) {
          if (!cacheHas_default(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
            return seen.push(othIndex);
          }
        })) {
          result = false;
          break;
        }
      } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
        result = false;
        break;
      }
    }
    stack["delete"](array);
    stack["delete"](other);
    return result;
  }
  __name(equalArrays, "equalArrays");
  var equalArrays_default = equalArrays;

  // node_modules/lodash-es/_mapToArray.js
  function mapToArray(map) {
    var index = -1, result = Array(map.size);
    map.forEach(function(value, key) {
      result[++index] = [key, value];
    });
    return result;
  }
  __name(mapToArray, "mapToArray");
  var mapToArray_default = mapToArray;

  // node_modules/lodash-es/_setToArray.js
  function setToArray(set) {
    var index = -1, result = Array(set.size);
    set.forEach(function(value) {
      result[++index] = value;
    });
    return result;
  }
  __name(setToArray, "setToArray");
  var setToArray_default = setToArray;

  // node_modules/lodash-es/_equalByTag.js
  var COMPARE_PARTIAL_FLAG2 = 1;
  var COMPARE_UNORDERED_FLAG2 = 2;
  var boolTag4 = "[object Boolean]";
  var dateTag4 = "[object Date]";
  var errorTag3 = "[object Error]";
  var mapTag6 = "[object Map]";
  var numberTag4 = "[object Number]";
  var regexpTag4 = "[object RegExp]";
  var setTag6 = "[object Set]";
  var stringTag4 = "[object String]";
  var symbolTag3 = "[object Symbol]";
  var arrayBufferTag4 = "[object ArrayBuffer]";
  var dataViewTag5 = "[object DataView]";
  var symbolProto2 = Symbol_default ? Symbol_default.prototype : void 0;
  var symbolValueOf2 = symbolProto2 ? symbolProto2.valueOf : void 0;
  function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
    switch (tag) {
      case dataViewTag5:
        if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
          return false;
        }
        object = object.buffer;
        other = other.buffer;
      case arrayBufferTag4:
        if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array_default(object), new Uint8Array_default(other))) {
          return false;
        }
        return true;
      case boolTag4:
      case dateTag4:
      case numberTag4:
        return eq_default(+object, +other);
      case errorTag3:
        return object.name == other.name && object.message == other.message;
      case regexpTag4:
      case stringTag4:
        return object == other + "";
      case mapTag6:
        var convert = mapToArray_default;
      case setTag6:
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG2;
        convert || (convert = setToArray_default);
        if (object.size != other.size && !isPartial) {
          return false;
        }
        var stacked = stack.get(object);
        if (stacked) {
          return stacked == other;
        }
        bitmask |= COMPARE_UNORDERED_FLAG2;
        stack.set(object, other);
        var result = equalArrays_default(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
        stack["delete"](object);
        return result;
      case symbolTag3:
        if (symbolValueOf2) {
          return symbolValueOf2.call(object) == symbolValueOf2.call(other);
        }
    }
    return false;
  }
  __name(equalByTag, "equalByTag");
  var equalByTag_default = equalByTag;

  // node_modules/lodash-es/_equalObjects.js
  var COMPARE_PARTIAL_FLAG3 = 1;
  var objectProto15 = Object.prototype;
  var hasOwnProperty12 = objectProto15.hasOwnProperty;
  function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG3, objProps = getAllKeys_default(object), objLength = objProps.length, othProps = getAllKeys_default(other), othLength = othProps.length;
    if (objLength != othLength && !isPartial) {
      return false;
    }
    var index = objLength;
    while (index--) {
      var key = objProps[index];
      if (!(isPartial ? key in other : hasOwnProperty12.call(other, key))) {
        return false;
      }
    }
    var objStacked = stack.get(object);
    var othStacked = stack.get(other);
    if (objStacked && othStacked) {
      return objStacked == other && othStacked == object;
    }
    var result = true;
    stack.set(object, other);
    stack.set(other, object);
    var skipCtor = isPartial;
    while (++index < objLength) {
      key = objProps[index];
      var objValue = object[key], othValue = other[key];
      if (customizer) {
        var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
      }
      if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
        result = false;
        break;
      }
      skipCtor || (skipCtor = key == "constructor");
    }
    if (result && !skipCtor) {
      var objCtor = object.constructor, othCtor = other.constructor;
      if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
        result = false;
      }
    }
    stack["delete"](object);
    stack["delete"](other);
    return result;
  }
  __name(equalObjects, "equalObjects");
  var equalObjects_default = equalObjects;

  // node_modules/lodash-es/_baseIsEqualDeep.js
  var COMPARE_PARTIAL_FLAG4 = 1;
  var argsTag4 = "[object Arguments]";
  var arrayTag3 = "[object Array]";
  var objectTag5 = "[object Object]";
  var objectProto16 = Object.prototype;
  var hasOwnProperty13 = objectProto16.hasOwnProperty;
  function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
    var objIsArr = isArray_default(object), othIsArr = isArray_default(other), objTag = objIsArr ? arrayTag3 : getTag_default(object), othTag = othIsArr ? arrayTag3 : getTag_default(other);
    objTag = objTag == argsTag4 ? objectTag5 : objTag;
    othTag = othTag == argsTag4 ? objectTag5 : othTag;
    var objIsObj = objTag == objectTag5, othIsObj = othTag == objectTag5, isSameTag = objTag == othTag;
    if (isSameTag && isBuffer_default(object)) {
      if (!isBuffer_default(other)) {
        return false;
      }
      objIsArr = true;
      objIsObj = false;
    }
    if (isSameTag && !objIsObj) {
      stack || (stack = new Stack_default());
      return objIsArr || isTypedArray_default(object) ? equalArrays_default(object, other, bitmask, customizer, equalFunc, stack) : equalByTag_default(object, other, objTag, bitmask, customizer, equalFunc, stack);
    }
    if (!(bitmask & COMPARE_PARTIAL_FLAG4)) {
      var objIsWrapped = objIsObj && hasOwnProperty13.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty13.call(other, "__wrapped__");
      if (objIsWrapped || othIsWrapped) {
        var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
        stack || (stack = new Stack_default());
        return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
      }
    }
    if (!isSameTag) {
      return false;
    }
    stack || (stack = new Stack_default());
    return equalObjects_default(object, other, bitmask, customizer, equalFunc, stack);
  }
  __name(baseIsEqualDeep, "baseIsEqualDeep");
  var baseIsEqualDeep_default = baseIsEqualDeep;

  // node_modules/lodash-es/_baseIsEqual.js
  function baseIsEqual(value, other, bitmask, customizer, stack) {
    if (value === other) {
      return true;
    }
    if (value == null || other == null || !isObjectLike_default(value) && !isObjectLike_default(other)) {
      return value !== value && other !== other;
    }
    return baseIsEqualDeep_default(value, other, bitmask, customizer, baseIsEqual, stack);
  }
  __name(baseIsEqual, "baseIsEqual");
  var baseIsEqual_default = baseIsEqual;

  // node_modules/lodash-es/_createBaseFor.js
  function createBaseFor(fromRight) {
    return function(object, iteratee, keysFunc) {
      var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
      while (length--) {
        var key = props[fromRight ? length : ++index];
        if (iteratee(iterable[key], key, iterable) === false) {
          break;
        }
      }
      return object;
    };
  }
  __name(createBaseFor, "createBaseFor");
  var createBaseFor_default = createBaseFor;

  // node_modules/lodash-es/_baseFor.js
  var baseFor = createBaseFor_default();
  var baseFor_default = baseFor;

  // node_modules/lodash-es/_assignMergeValue.js
  function assignMergeValue(object, key, value) {
    if (value !== void 0 && !eq_default(object[key], value) || value === void 0 && !(key in object)) {
      baseAssignValue_default(object, key, value);
    }
  }
  __name(assignMergeValue, "assignMergeValue");
  var assignMergeValue_default = assignMergeValue;

  // node_modules/lodash-es/isArrayLikeObject.js
  function isArrayLikeObject(value) {
    return isObjectLike_default(value) && isArrayLike_default(value);
  }
  __name(isArrayLikeObject, "isArrayLikeObject");
  var isArrayLikeObject_default = isArrayLikeObject;

  // node_modules/lodash-es/_safeGet.js
  function safeGet(object, key) {
    if (key === "constructor" && typeof object[key] === "function") {
      return;
    }
    if (key == "__proto__") {
      return;
    }
    return object[key];
  }
  __name(safeGet, "safeGet");
  var safeGet_default = safeGet;

  // node_modules/lodash-es/toPlainObject.js
  function toPlainObject(value) {
    return copyObject_default(value, keysIn_default(value));
  }
  __name(toPlainObject, "toPlainObject");
  var toPlainObject_default = toPlainObject;

  // node_modules/lodash-es/_baseMergeDeep.js
  function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
    var objValue = safeGet_default(object, key), srcValue = safeGet_default(source, key), stacked = stack.get(srcValue);
    if (stacked) {
      assignMergeValue_default(object, key, stacked);
      return;
    }
    var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : void 0;
    var isCommon = newValue === void 0;
    if (isCommon) {
      var isArr = isArray_default(srcValue), isBuff = !isArr && isBuffer_default(srcValue), isTyped = !isArr && !isBuff && isTypedArray_default(srcValue);
      newValue = srcValue;
      if (isArr || isBuff || isTyped) {
        if (isArray_default(objValue)) {
          newValue = objValue;
        } else if (isArrayLikeObject_default(objValue)) {
          newValue = copyArray_default(objValue);
        } else if (isBuff) {
          isCommon = false;
          newValue = cloneBuffer_default(srcValue, true);
        } else if (isTyped) {
          isCommon = false;
          newValue = cloneTypedArray_default(srcValue, true);
        } else {
          newValue = [];
        }
      } else if (isPlainObject_default(srcValue) || isArguments_default(srcValue)) {
        newValue = objValue;
        if (isArguments_default(objValue)) {
          newValue = toPlainObject_default(objValue);
        } else if (!isObject_default(objValue) || isFunction_default(objValue)) {
          newValue = initCloneObject_default(srcValue);
        }
      } else {
        isCommon = false;
      }
    }
    if (isCommon) {
      stack.set(srcValue, newValue);
      mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
      stack["delete"](srcValue);
    }
    assignMergeValue_default(object, key, newValue);
  }
  __name(baseMergeDeep, "baseMergeDeep");
  var baseMergeDeep_default = baseMergeDeep;

  // node_modules/lodash-es/_baseMerge.js
  function baseMerge(object, source, srcIndex, customizer, stack) {
    if (object === source) {
      return;
    }
    baseFor_default(source, function(srcValue, key) {
      stack || (stack = new Stack_default());
      if (isObject_default(srcValue)) {
        baseMergeDeep_default(object, source, key, srcIndex, baseMerge, customizer, stack);
      } else {
        var newValue = customizer ? customizer(safeGet_default(object, key), srcValue, key + "", object, source, stack) : void 0;
        if (newValue === void 0) {
          newValue = srcValue;
        }
        assignMergeValue_default(object, key, newValue);
      }
    }, keysIn_default);
  }
  __name(baseMerge, "baseMerge");
  var baseMerge_default = baseMerge;

  // node_modules/lodash-es/isEqual.js
  function isEqual(value, other) {
    return baseIsEqual_default(value, other);
  }
  __name(isEqual, "isEqual");
  var isEqual_default = isEqual;

  // node_modules/lodash-es/merge.js
  var merge = createAssigner_default(function(object, source, srcIndex) {
    baseMerge_default(object, source, srcIndex);
  });
  var merge_default = merge;

  // node_modules/parchment/dist/parchment.js
  var parchment_exports = {};
  __export(parchment_exports, {
    Attributor: () => Attributor,
    AttributorStore: () => AttributorStore$1,
    BlockBlot: () => BlockBlot$1,
    ClassAttributor: () => ClassAttributor$1,
    ContainerBlot: () => ContainerBlot$1,
    EmbedBlot: () => EmbedBlot$1,
    InlineBlot: () => InlineBlot$1,
    LeafBlot: () => LeafBlot$1,
    ParentBlot: () => ParentBlot$1,
    Registry: () => Registry,
    Scope: () => Scope,
    ScrollBlot: () => ScrollBlot$1,
    StyleAttributor: () => StyleAttributor$1,
    TextBlot: () => TextBlot$1
  });
  var Scope = /* @__PURE__ */ ((Scope2) => (Scope2[Scope2.TYPE = 3] = "TYPE", Scope2[Scope2.LEVEL = 12] = "LEVEL", Scope2[Scope2.ATTRIBUTE = 13] = "ATTRIBUTE", Scope2[Scope2.BLOT = 14] = "BLOT", Scope2[Scope2.INLINE = 7] = "INLINE", Scope2[Scope2.BLOCK = 11] = "BLOCK", Scope2[Scope2.BLOCK_BLOT = 10] = "BLOCK_BLOT", Scope2[Scope2.INLINE_BLOT = 6] = "INLINE_BLOT", Scope2[Scope2.BLOCK_ATTRIBUTE = 9] = "BLOCK_ATTRIBUTE", Scope2[Scope2.INLINE_ATTRIBUTE = 5] = "INLINE_ATTRIBUTE", Scope2[Scope2.ANY = 15] = "ANY", Scope2))(Scope || {});
  var Attributor = class {
    static {
      __name(this, "Attributor");
    }
    constructor(attrName, keyName, options = {}) {
      this.attrName = attrName, this.keyName = keyName;
      const attributeBit = Scope.TYPE & Scope.ATTRIBUTE;
      this.scope = options.scope != null ? (
        // Ignore type bits, force attribute bit
        options.scope & Scope.LEVEL | attributeBit
      ) : Scope.ATTRIBUTE, options.whitelist != null && (this.whitelist = options.whitelist);
    }
    static keys(node) {
      return Array.from(node.attributes).map((item) => item.name);
    }
    add(node, value) {
      return this.canAdd(node, value) ? (node.setAttribute(this.keyName, value), true) : false;
    }
    canAdd(_node, value) {
      return this.whitelist == null ? true : typeof value == "string" ? this.whitelist.indexOf(value.replace(/["']/g, "")) > -1 : this.whitelist.indexOf(value) > -1;
    }
    remove(node) {
      node.removeAttribute(this.keyName);
    }
    value(node) {
      const value = node.getAttribute(this.keyName);
      return this.canAdd(node, value) && value ? value : "";
    }
  };
  var ParchmentError = class extends Error {
    static {
      __name(this, "ParchmentError");
    }
    constructor(message) {
      message = "[Parchment] " + message, super(message), this.message = message, this.name = this.constructor.name;
    }
  };
  var _Registry = class _Registry2 {
    static {
      __name(this, "_Registry");
    }
    constructor() {
      this.attributes = {}, this.classes = {}, this.tags = {}, this.types = {};
    }
    static find(node, bubble = false) {
      if (node == null)
        return null;
      if (this.blots.has(node))
        return this.blots.get(node) || null;
      if (bubble) {
        let parentNode = null;
        try {
          parentNode = node.parentNode;
        } catch {
          return null;
        }
        return this.find(parentNode, bubble);
      }
      return null;
    }
    create(scroll, input, value) {
      const match2 = this.query(input);
      if (match2 == null)
        throw new ParchmentError(`Unable to create ${input} blot`);
      const blotClass = match2, node = (
        // @ts-expect-error Fix me later
        input instanceof Node || input.nodeType === Node.TEXT_NODE ? input : blotClass.create(value)
      ), blot = new blotClass(scroll, node, value);
      return _Registry2.blots.set(blot.domNode, blot), blot;
    }
    find(node, bubble = false) {
      return _Registry2.find(node, bubble);
    }
    query(query, scope = Scope.ANY) {
      let match2;
      return typeof query == "string" ? match2 = this.types[query] || this.attributes[query] : query instanceof Text || query.nodeType === Node.TEXT_NODE ? match2 = this.types.text : typeof query == "number" ? query & Scope.LEVEL & Scope.BLOCK ? match2 = this.types.block : query & Scope.LEVEL & Scope.INLINE && (match2 = this.types.inline) : query instanceof Element && ((query.getAttribute("class") || "").split(/\s+/).some((name) => (match2 = this.classes[name], !!match2)), match2 = match2 || this.tags[query.tagName]), match2 == null ? null : "scope" in match2 && scope & Scope.LEVEL & match2.scope && scope & Scope.TYPE & match2.scope ? match2 : null;
    }
    register(...definitions) {
      return definitions.map((definition) => {
        const isBlot = "blotName" in definition, isAttr = "attrName" in definition;
        if (!isBlot && !isAttr)
          throw new ParchmentError("Invalid definition");
        if (isBlot && definition.blotName === "abstract")
          throw new ParchmentError("Cannot register abstract class");
        const key = isBlot ? definition.blotName : isAttr ? definition.attrName : void 0;
        return this.types[key] = definition, isAttr ? typeof definition.keyName == "string" && (this.attributes[definition.keyName] = definition) : isBlot && (definition.className && (this.classes[definition.className] = definition), definition.tagName && (Array.isArray(definition.tagName) ? definition.tagName = definition.tagName.map((tagName) => tagName.toUpperCase()) : definition.tagName = definition.tagName.toUpperCase(), (Array.isArray(definition.tagName) ? definition.tagName : [definition.tagName]).forEach((tag) => {
          (this.tags[tag] == null || definition.className == null) && (this.tags[tag] = definition);
        }))), definition;
      });
    }
  };
  _Registry.blots = /* @__PURE__ */ new WeakMap();
  var Registry = _Registry;
  function match(node, prefix) {
    return (node.getAttribute("class") || "").split(/\s+/).filter((name) => name.indexOf(`${prefix}-`) === 0);
  }
  __name(match, "match");
  var ClassAttributor = class extends Attributor {
    static {
      __name(this, "ClassAttributor");
    }
    static keys(node) {
      return (node.getAttribute("class") || "").split(/\s+/).map((name) => name.split("-").slice(0, -1).join("-"));
    }
    add(node, value) {
      return this.canAdd(node, value) ? (this.remove(node), node.classList.add(`${this.keyName}-${value}`), true) : false;
    }
    remove(node) {
      match(node, this.keyName).forEach((name) => {
        node.classList.remove(name);
      }), node.classList.length === 0 && node.removeAttribute("class");
    }
    value(node) {
      const value = (match(node, this.keyName)[0] || "").slice(this.keyName.length + 1);
      return this.canAdd(node, value) ? value : "";
    }
  };
  var ClassAttributor$1 = ClassAttributor;
  function camelize(name) {
    const parts = name.split("-"), rest = parts.slice(1).map((part) => part[0].toUpperCase() + part.slice(1)).join("");
    return parts[0] + rest;
  }
  __name(camelize, "camelize");
  var StyleAttributor = class extends Attributor {
    static {
      __name(this, "StyleAttributor");
    }
    static keys(node) {
      return (node.getAttribute("style") || "").split(";").map((value) => value.split(":")[0].trim());
    }
    add(node, value) {
      return this.canAdd(node, value) ? (node.style[camelize(this.keyName)] = value, true) : false;
    }
    remove(node) {
      node.style[camelize(this.keyName)] = "", node.getAttribute("style") || node.removeAttribute("style");
    }
    value(node) {
      const value = node.style[camelize(this.keyName)];
      return this.canAdd(node, value) ? value : "";
    }
  };
  var StyleAttributor$1 = StyleAttributor;
  var AttributorStore = class {
    static {
      __name(this, "AttributorStore");
    }
    constructor(domNode) {
      this.attributes = {}, this.domNode = domNode, this.build();
    }
    attribute(attribute, value) {
      value ? attribute.add(this.domNode, value) && (attribute.value(this.domNode) != null ? this.attributes[attribute.attrName] = attribute : delete this.attributes[attribute.attrName]) : (attribute.remove(this.domNode), delete this.attributes[attribute.attrName]);
    }
    build() {
      this.attributes = {};
      const blot = Registry.find(this.domNode);
      if (blot == null)
        return;
      const attributes = Attributor.keys(this.domNode), classes = ClassAttributor$1.keys(this.domNode), styles = StyleAttributor$1.keys(this.domNode);
      attributes.concat(classes).concat(styles).forEach((name) => {
        const attr = blot.scroll.query(name, Scope.ATTRIBUTE);
        attr instanceof Attributor && (this.attributes[attr.attrName] = attr);
      });
    }
    copy(target) {
      Object.keys(this.attributes).forEach((key) => {
        const value = this.attributes[key].value(this.domNode);
        target.format(key, value);
      });
    }
    move(target) {
      this.copy(target), Object.keys(this.attributes).forEach((key) => {
        this.attributes[key].remove(this.domNode);
      }), this.attributes = {};
    }
    values() {
      return Object.keys(this.attributes).reduce(
        (attributes, name) => (attributes[name] = this.attributes[name].value(this.domNode), attributes),
        {}
      );
    }
  };
  var AttributorStore$1 = AttributorStore;
  var _ShadowBlot = class _ShadowBlot2 {
    static {
      __name(this, "_ShadowBlot");
    }
    constructor(scroll, domNode) {
      this.scroll = scroll, this.domNode = domNode, Registry.blots.set(domNode, this), this.prev = null, this.next = null;
    }
    static create(rawValue) {
      if (this.tagName == null)
        throw new ParchmentError("Blot definition missing tagName");
      let node, value;
      return Array.isArray(this.tagName) ? (typeof rawValue == "string" ? (value = rawValue.toUpperCase(), parseInt(value, 10).toString() === value && (value = parseInt(value, 10))) : typeof rawValue == "number" && (value = rawValue), typeof value == "number" ? node = document.createElement(this.tagName[value - 1]) : value && this.tagName.indexOf(value) > -1 ? node = document.createElement(value) : node = document.createElement(this.tagName[0])) : node = document.createElement(this.tagName), this.className && node.classList.add(this.className), node;
    }
    // Hack for accessing inherited static methods
    get statics() {
      return this.constructor;
    }
    attach() {
    }
    clone() {
      const domNode = this.domNode.cloneNode(false);
      return this.scroll.create(domNode);
    }
    detach() {
      this.parent != null && this.parent.removeChild(this), Registry.blots.delete(this.domNode);
    }
    deleteAt(index, length) {
      this.isolate(index, length).remove();
    }
    formatAt(index, length, name, value) {
      const blot = this.isolate(index, length);
      if (this.scroll.query(name, Scope.BLOT) != null && value)
        blot.wrap(name, value);
      else if (this.scroll.query(name, Scope.ATTRIBUTE) != null) {
        const parent = this.scroll.create(this.statics.scope);
        blot.wrap(parent), parent.format(name, value);
      }
    }
    insertAt(index, value, def) {
      const blot = def == null ? this.scroll.create("text", value) : this.scroll.create(value, def), ref = this.split(index);
      this.parent.insertBefore(blot, ref || void 0);
    }
    isolate(index, length) {
      const target = this.split(index);
      if (target == null)
        throw new Error("Attempt to isolate at end");
      return target.split(length), target;
    }
    length() {
      return 1;
    }
    offset(root2 = this.parent) {
      return this.parent == null || this === root2 ? 0 : this.parent.children.offset(this) + this.parent.offset(root2);
    }
    optimize(_context) {
      this.statics.requiredContainer && !(this.parent instanceof this.statics.requiredContainer) && this.wrap(this.statics.requiredContainer.blotName);
    }
    remove() {
      this.domNode.parentNode != null && this.domNode.parentNode.removeChild(this.domNode), this.detach();
    }
    replaceWith(name, value) {
      const replacement = typeof name == "string" ? this.scroll.create(name, value) : name;
      return this.parent != null && (this.parent.insertBefore(replacement, this.next || void 0), this.remove()), replacement;
    }
    split(index, _force) {
      return index === 0 ? this : this.next;
    }
    update(_mutations, _context) {
    }
    wrap(name, value) {
      const wrapper = typeof name == "string" ? this.scroll.create(name, value) : name;
      if (this.parent != null && this.parent.insertBefore(wrapper, this.next || void 0), typeof wrapper.appendChild != "function")
        throw new ParchmentError(`Cannot wrap ${name}`);
      return wrapper.appendChild(this), wrapper;
    }
  };
  _ShadowBlot.blotName = "abstract";
  var ShadowBlot = _ShadowBlot;
  var _LeafBlot = class _LeafBlot2 extends ShadowBlot {
    static {
      __name(this, "_LeafBlot");
    }
    /**
     * Returns the value represented by domNode if it is this Blot's type
     * No checking that domNode can represent this Blot type is required so
     * applications needing it should check externally before calling.
     */
    static value(_domNode) {
      return true;
    }
    /**
     * Given location represented by node and offset from DOM Selection Range,
     * return index to that location.
     */
    index(node, offset) {
      return this.domNode === node || this.domNode.compareDocumentPosition(node) & Node.DOCUMENT_POSITION_CONTAINED_BY ? Math.min(offset, 1) : -1;
    }
    /**
     * Given index to location within blot, return node and offset representing
     * that location, consumable by DOM Selection Range
     */
    position(index, _inclusive) {
      let offset = Array.from(this.parent.domNode.childNodes).indexOf(this.domNode);
      return index > 0 && (offset += 1), [this.parent.domNode, offset];
    }
    /**
     * Return value represented by this blot
     * Should not change without interaction from API or
     * user change detectable by update()
     */
    value() {
      return {
        [this.statics.blotName]: this.statics.value(this.domNode) || true
      };
    }
  };
  _LeafBlot.scope = Scope.INLINE_BLOT;
  var LeafBlot = _LeafBlot;
  var LeafBlot$1 = LeafBlot;
  var LinkedList = class {
    static {
      __name(this, "LinkedList");
    }
    constructor() {
      this.head = null, this.tail = null, this.length = 0;
    }
    append(...nodes) {
      if (this.insertBefore(nodes[0], null), nodes.length > 1) {
        const rest = nodes.slice(1);
        this.append(...rest);
      }
    }
    at(index) {
      const next = this.iterator();
      let cur = next();
      for (; cur && index > 0; )
        index -= 1, cur = next();
      return cur;
    }
    contains(node) {
      const next = this.iterator();
      let cur = next();
      for (; cur; ) {
        if (cur === node)
          return true;
        cur = next();
      }
      return false;
    }
    indexOf(node) {
      const next = this.iterator();
      let cur = next(), index = 0;
      for (; cur; ) {
        if (cur === node)
          return index;
        index += 1, cur = next();
      }
      return -1;
    }
    insertBefore(node, refNode) {
      node != null && (this.remove(node), node.next = refNode, refNode != null ? (node.prev = refNode.prev, refNode.prev != null && (refNode.prev.next = node), refNode.prev = node, refNode === this.head && (this.head = node)) : this.tail != null ? (this.tail.next = node, node.prev = this.tail, this.tail = node) : (node.prev = null, this.head = this.tail = node), this.length += 1);
    }
    offset(target) {
      let index = 0, cur = this.head;
      for (; cur != null; ) {
        if (cur === target)
          return index;
        index += cur.length(), cur = cur.next;
      }
      return -1;
    }
    remove(node) {
      this.contains(node) && (node.prev != null && (node.prev.next = node.next), node.next != null && (node.next.prev = node.prev), node === this.head && (this.head = node.next), node === this.tail && (this.tail = node.prev), this.length -= 1);
    }
    iterator(curNode = this.head) {
      return () => {
        const ret = curNode;
        return curNode != null && (curNode = curNode.next), ret;
      };
    }
    find(index, inclusive = false) {
      const next = this.iterator();
      let cur = next();
      for (; cur; ) {
        const length = cur.length();
        if (index < length || inclusive && index === length && (cur.next == null || cur.next.length() !== 0))
          return [cur, index];
        index -= length, cur = next();
      }
      return [null, 0];
    }
    forEach(callback) {
      const next = this.iterator();
      let cur = next();
      for (; cur; )
        callback(cur), cur = next();
    }
    forEachAt(index, length, callback) {
      if (length <= 0)
        return;
      const [startNode, offset] = this.find(index);
      let curIndex = index - offset;
      const next = this.iterator(startNode);
      let cur = next();
      for (; cur && curIndex < index + length; ) {
        const curLength = cur.length();
        index > curIndex ? callback(
          cur,
          index - curIndex,
          Math.min(length, curIndex + curLength - index)
        ) : callback(cur, 0, Math.min(curLength, index + length - curIndex)), curIndex += curLength, cur = next();
      }
    }
    map(callback) {
      return this.reduce((memo, cur) => (memo.push(callback(cur)), memo), []);
    }
    reduce(callback, memo) {
      const next = this.iterator();
      let cur = next();
      for (; cur; )
        memo = callback(memo, cur), cur = next();
      return memo;
    }
  };
  function makeAttachedBlot(node, scroll) {
    const found = scroll.find(node);
    if (found)
      return found;
    try {
      return scroll.create(node);
    } catch {
      const blot = scroll.create(Scope.INLINE);
      return Array.from(node.childNodes).forEach((child) => {
        blot.domNode.appendChild(child);
      }), node.parentNode && node.parentNode.replaceChild(blot.domNode, node), blot.attach(), blot;
    }
  }
  __name(makeAttachedBlot, "makeAttachedBlot");
  var _ParentBlot = class _ParentBlot2 extends ShadowBlot {
    static {
      __name(this, "_ParentBlot");
    }
    constructor(scroll, domNode) {
      super(scroll, domNode), this.uiNode = null, this.build();
    }
    appendChild(other) {
      this.insertBefore(other);
    }
    attach() {
      super.attach(), this.children.forEach((child) => {
        child.attach();
      });
    }
    attachUI(node) {
      this.uiNode != null && this.uiNode.remove(), this.uiNode = node, _ParentBlot2.uiClass && this.uiNode.classList.add(_ParentBlot2.uiClass), this.uiNode.setAttribute("contenteditable", "false"), this.domNode.insertBefore(this.uiNode, this.domNode.firstChild);
    }
    /**
     * Called during construction, should fill its own children LinkedList.
     */
    build() {
      this.children = new LinkedList(), Array.from(this.domNode.childNodes).filter((node) => node !== this.uiNode).reverse().forEach((node) => {
        try {
          const child = makeAttachedBlot(node, this.scroll);
          this.insertBefore(child, this.children.head || void 0);
        } catch (err) {
          if (err instanceof ParchmentError)
            return;
          throw err;
        }
      });
    }
    deleteAt(index, length) {
      if (index === 0 && length === this.length())
        return this.remove();
      this.children.forEachAt(index, length, (child, offset, childLength) => {
        child.deleteAt(offset, childLength);
      });
    }
    descendant(criteria, index = 0) {
      const [child, offset] = this.children.find(index);
      return criteria.blotName == null && criteria(child) || criteria.blotName != null && child instanceof criteria ? [child, offset] : child instanceof _ParentBlot2 ? child.descendant(criteria, offset) : [null, -1];
    }
    descendants(criteria, index = 0, length = Number.MAX_VALUE) {
      let descendants = [], lengthLeft = length;
      return this.children.forEachAt(
        index,
        length,
        (child, childIndex, childLength) => {
          (criteria.blotName == null && criteria(child) || criteria.blotName != null && child instanceof criteria) && descendants.push(child), child instanceof _ParentBlot2 && (descendants = descendants.concat(
            child.descendants(criteria, childIndex, lengthLeft)
          )), lengthLeft -= childLength;
        }
      ), descendants;
    }
    detach() {
      this.children.forEach((child) => {
        child.detach();
      }), super.detach();
    }
    enforceAllowedChildren() {
      let done = false;
      this.children.forEach((child) => {
        done || this.statics.allowedChildren.some(
          (def) => child instanceof def
        ) || (child.statics.scope === Scope.BLOCK_BLOT ? (child.next != null && this.splitAfter(child), child.prev != null && this.splitAfter(child.prev), child.parent.unwrap(), done = true) : child instanceof _ParentBlot2 ? child.unwrap() : child.remove());
      });
    }
    formatAt(index, length, name, value) {
      this.children.forEachAt(index, length, (child, offset, childLength) => {
        child.formatAt(offset, childLength, name, value);
      });
    }
    insertAt(index, value, def) {
      const [child, offset] = this.children.find(index);
      if (child)
        child.insertAt(offset, value, def);
      else {
        const blot = def == null ? this.scroll.create("text", value) : this.scroll.create(value, def);
        this.appendChild(blot);
      }
    }
    insertBefore(childBlot, refBlot) {
      childBlot.parent != null && childBlot.parent.children.remove(childBlot);
      let refDomNode = null;
      this.children.insertBefore(childBlot, refBlot || null), childBlot.parent = this, refBlot != null && (refDomNode = refBlot.domNode), (this.domNode.parentNode !== childBlot.domNode || this.domNode.nextSibling !== refDomNode) && this.domNode.insertBefore(childBlot.domNode, refDomNode), childBlot.attach();
    }
    length() {
      return this.children.reduce((memo, child) => memo + child.length(), 0);
    }
    moveChildren(targetParent, refNode) {
      this.children.forEach((child) => {
        targetParent.insertBefore(child, refNode);
      });
    }
    optimize(context) {
      if (super.optimize(context), this.enforceAllowedChildren(), this.uiNode != null && this.uiNode !== this.domNode.firstChild && this.domNode.insertBefore(this.uiNode, this.domNode.firstChild), this.children.length === 0)
        if (this.statics.defaultChild != null) {
          const child = this.scroll.create(this.statics.defaultChild.blotName);
          this.appendChild(child);
        } else
          this.remove();
    }
    path(index, inclusive = false) {
      const [child, offset] = this.children.find(index, inclusive), position = [[this, index]];
      return child instanceof _ParentBlot2 ? position.concat(child.path(offset, inclusive)) : (child != null && position.push([child, offset]), position);
    }
    removeChild(child) {
      this.children.remove(child);
    }
    replaceWith(name, value) {
      const replacement = typeof name == "string" ? this.scroll.create(name, value) : name;
      return replacement instanceof _ParentBlot2 && this.moveChildren(replacement), super.replaceWith(replacement);
    }
    split(index, force = false) {
      if (!force) {
        if (index === 0)
          return this;
        if (index === this.length())
          return this.next;
      }
      const after = this.clone();
      return this.parent && this.parent.insertBefore(after, this.next || void 0), this.children.forEachAt(index, this.length(), (child, offset, _length) => {
        const split = child.split(offset, force);
        split != null && after.appendChild(split);
      }), after;
    }
    splitAfter(child) {
      const after = this.clone();
      for (; child.next != null; )
        after.appendChild(child.next);
      return this.parent && this.parent.insertBefore(after, this.next || void 0), after;
    }
    unwrap() {
      this.parent && this.moveChildren(this.parent, this.next || void 0), this.remove();
    }
    update(mutations, _context) {
      const addedNodes = [], removedNodes = [];
      mutations.forEach((mutation) => {
        mutation.target === this.domNode && mutation.type === "childList" && (addedNodes.push(...mutation.addedNodes), removedNodes.push(...mutation.removedNodes));
      }), removedNodes.forEach((node) => {
        if (node.parentNode != null && // @ts-expect-error Fix me later
        node.tagName !== "IFRAME" && document.body.compareDocumentPosition(node) & Node.DOCUMENT_POSITION_CONTAINED_BY)
          return;
        const blot = this.scroll.find(node);
        blot != null && (blot.domNode.parentNode == null || blot.domNode.parentNode === this.domNode) && blot.detach();
      }), addedNodes.filter((node) => node.parentNode === this.domNode && node !== this.uiNode).sort((a2, b2) => a2 === b2 ? 0 : a2.compareDocumentPosition(b2) & Node.DOCUMENT_POSITION_FOLLOWING ? 1 : -1).forEach((node) => {
        let refBlot = null;
        node.nextSibling != null && (refBlot = this.scroll.find(node.nextSibling));
        const blot = makeAttachedBlot(node, this.scroll);
        (blot.next !== refBlot || blot.next == null) && (blot.parent != null && blot.parent.removeChild(this), this.insertBefore(blot, refBlot || void 0));
      }), this.enforceAllowedChildren();
    }
  };
  _ParentBlot.uiClass = "";
  var ParentBlot = _ParentBlot;
  var ParentBlot$1 = ParentBlot;
  function isEqual2(obj1, obj2) {
    if (Object.keys(obj1).length !== Object.keys(obj2).length)
      return false;
    for (const prop in obj1)
      if (obj1[prop] !== obj2[prop])
        return false;
    return true;
  }
  __name(isEqual2, "isEqual");
  var _InlineBlot = class _InlineBlot2 extends ParentBlot$1 {
    static {
      __name(this, "_InlineBlot");
    }
    static create(value) {
      return super.create(value);
    }
    static formats(domNode, scroll) {
      const match2 = scroll.query(_InlineBlot2.blotName);
      if (!(match2 != null && domNode.tagName === match2.tagName)) {
        if (typeof this.tagName == "string")
          return true;
        if (Array.isArray(this.tagName))
          return domNode.tagName.toLowerCase();
      }
    }
    constructor(scroll, domNode) {
      super(scroll, domNode), this.attributes = new AttributorStore$1(this.domNode);
    }
    format(name, value) {
      if (name === this.statics.blotName && !value)
        this.children.forEach((child) => {
          child instanceof _InlineBlot2 || (child = child.wrap(_InlineBlot2.blotName, true)), this.attributes.copy(child);
        }), this.unwrap();
      else {
        const format = this.scroll.query(name, Scope.INLINE);
        if (format == null)
          return;
        format instanceof Attributor ? this.attributes.attribute(format, value) : value && (name !== this.statics.blotName || this.formats()[name] !== value) && this.replaceWith(name, value);
      }
    }
    formats() {
      const formats2 = this.attributes.values(), format = this.statics.formats(this.domNode, this.scroll);
      return format != null && (formats2[this.statics.blotName] = format), formats2;
    }
    formatAt(index, length, name, value) {
      this.formats()[name] != null || this.scroll.query(name, Scope.ATTRIBUTE) ? this.isolate(index, length).format(name, value) : super.formatAt(index, length, name, value);
    }
    optimize(context) {
      super.optimize(context);
      const formats2 = this.formats();
      if (Object.keys(formats2).length === 0)
        return this.unwrap();
      const next = this.next;
      next instanceof _InlineBlot2 && next.prev === this && isEqual2(formats2, next.formats()) && (next.moveChildren(this), next.remove());
    }
    replaceWith(name, value) {
      const replacement = super.replaceWith(name, value);
      return this.attributes.copy(replacement), replacement;
    }
    update(mutations, context) {
      super.update(mutations, context), mutations.some(
        (mutation) => mutation.target === this.domNode && mutation.type === "attributes"
      ) && this.attributes.build();
    }
    wrap(name, value) {
      const wrapper = super.wrap(name, value);
      return wrapper instanceof _InlineBlot2 && this.attributes.move(wrapper), wrapper;
    }
  };
  _InlineBlot.allowedChildren = [_InlineBlot, LeafBlot$1], _InlineBlot.blotName = "inline", _InlineBlot.scope = Scope.INLINE_BLOT, _InlineBlot.tagName = "SPAN";
  var InlineBlot = _InlineBlot;
  var InlineBlot$1 = InlineBlot;
  var _BlockBlot = class _BlockBlot2 extends ParentBlot$1 {
    static {
      __name(this, "_BlockBlot");
    }
    static create(value) {
      return super.create(value);
    }
    static formats(domNode, scroll) {
      const match2 = scroll.query(_BlockBlot2.blotName);
      if (!(match2 != null && domNode.tagName === match2.tagName)) {
        if (typeof this.tagName == "string")
          return true;
        if (Array.isArray(this.tagName))
          return domNode.tagName.toLowerCase();
      }
    }
    constructor(scroll, domNode) {
      super(scroll, domNode), this.attributes = new AttributorStore$1(this.domNode);
    }
    format(name, value) {
      const format = this.scroll.query(name, Scope.BLOCK);
      format != null && (format instanceof Attributor ? this.attributes.attribute(format, value) : name === this.statics.blotName && !value ? this.replaceWith(_BlockBlot2.blotName) : value && (name !== this.statics.blotName || this.formats()[name] !== value) && this.replaceWith(name, value));
    }
    formats() {
      const formats2 = this.attributes.values(), format = this.statics.formats(this.domNode, this.scroll);
      return format != null && (formats2[this.statics.blotName] = format), formats2;
    }
    formatAt(index, length, name, value) {
      this.scroll.query(name, Scope.BLOCK) != null ? this.format(name, value) : super.formatAt(index, length, name, value);
    }
    insertAt(index, value, def) {
      if (def == null || this.scroll.query(value, Scope.INLINE) != null)
        super.insertAt(index, value, def);
      else {
        const after = this.split(index);
        if (after != null) {
          const blot = this.scroll.create(value, def);
          after.parent.insertBefore(blot, after);
        } else
          throw new Error("Attempt to insertAt after block boundaries");
      }
    }
    replaceWith(name, value) {
      const replacement = super.replaceWith(name, value);
      return this.attributes.copy(replacement), replacement;
    }
    update(mutations, context) {
      super.update(mutations, context), mutations.some(
        (mutation) => mutation.target === this.domNode && mutation.type === "attributes"
      ) && this.attributes.build();
    }
  };
  _BlockBlot.blotName = "block", _BlockBlot.scope = Scope.BLOCK_BLOT, _BlockBlot.tagName = "P", _BlockBlot.allowedChildren = [
    InlineBlot$1,
    _BlockBlot,
    LeafBlot$1
  ];
  var BlockBlot = _BlockBlot;
  var BlockBlot$1 = BlockBlot;
  var _ContainerBlot = class _ContainerBlot2 extends ParentBlot$1 {
    static {
      __name(this, "_ContainerBlot");
    }
    checkMerge() {
      return this.next !== null && this.next.statics.blotName === this.statics.blotName;
    }
    deleteAt(index, length) {
      super.deleteAt(index, length), this.enforceAllowedChildren();
    }
    formatAt(index, length, name, value) {
      super.formatAt(index, length, name, value), this.enforceAllowedChildren();
    }
    insertAt(index, value, def) {
      super.insertAt(index, value, def), this.enforceAllowedChildren();
    }
    optimize(context) {
      super.optimize(context), this.children.length > 0 && this.next != null && this.checkMerge() && (this.next.moveChildren(this), this.next.remove());
    }
  };
  _ContainerBlot.blotName = "container", _ContainerBlot.scope = Scope.BLOCK_BLOT;
  var ContainerBlot = _ContainerBlot;
  var ContainerBlot$1 = ContainerBlot;
  var EmbedBlot = class extends LeafBlot$1 {
    static {
      __name(this, "EmbedBlot");
    }
    static formats(_domNode, _scroll) {
    }
    format(name, value) {
      super.formatAt(0, this.length(), name, value);
    }
    formatAt(index, length, name, value) {
      index === 0 && length === this.length() ? this.format(name, value) : super.formatAt(index, length, name, value);
    }
    formats() {
      return this.statics.formats(this.domNode, this.scroll);
    }
  };
  var EmbedBlot$1 = EmbedBlot;
  var OBSERVER_CONFIG = {
    attributes: true,
    characterData: true,
    characterDataOldValue: true,
    childList: true,
    subtree: true
  };
  var MAX_OPTIMIZE_ITERATIONS = 100;
  var _ScrollBlot = class _ScrollBlot2 extends ParentBlot$1 {
    static {
      __name(this, "_ScrollBlot");
    }
    constructor(registry, node) {
      super(null, node), this.registry = registry, this.scroll = this, this.build(), this.observer = new MutationObserver((mutations) => {
        this.update(mutations);
      }), this.observer.observe(this.domNode, OBSERVER_CONFIG), this.attach();
    }
    create(input, value) {
      return this.registry.create(this, input, value);
    }
    find(node, bubble = false) {
      const blot = this.registry.find(node, bubble);
      return blot ? blot.scroll === this ? blot : bubble ? this.find(blot.scroll.domNode.parentNode, true) : null : null;
    }
    query(query, scope = Scope.ANY) {
      return this.registry.query(query, scope);
    }
    register(...definitions) {
      return this.registry.register(...definitions);
    }
    build() {
      this.scroll != null && super.build();
    }
    detach() {
      super.detach(), this.observer.disconnect();
    }
    deleteAt(index, length) {
      this.update(), index === 0 && length === this.length() ? this.children.forEach((child) => {
        child.remove();
      }) : super.deleteAt(index, length);
    }
    formatAt(index, length, name, value) {
      this.update(), super.formatAt(index, length, name, value);
    }
    insertAt(index, value, def) {
      this.update(), super.insertAt(index, value, def);
    }
    optimize(mutations = [], context = {}) {
      super.optimize(context);
      const mutationsMap = context.mutationsMap || /* @__PURE__ */ new WeakMap();
      let records = Array.from(this.observer.takeRecords());
      for (; records.length > 0; )
        mutations.push(records.pop());
      const mark = /* @__PURE__ */ __name((blot, markParent = true) => {
        blot == null || blot === this || blot.domNode.parentNode != null && (mutationsMap.has(blot.domNode) || mutationsMap.set(blot.domNode, []), markParent && mark(blot.parent));
      }, "mark"), optimize = /* @__PURE__ */ __name((blot) => {
        mutationsMap.has(blot.domNode) && (blot instanceof ParentBlot$1 && blot.children.forEach(optimize), mutationsMap.delete(blot.domNode), blot.optimize(context));
      }, "optimize");
      let remaining = mutations;
      for (let i2 = 0; remaining.length > 0; i2 += 1) {
        if (i2 >= MAX_OPTIMIZE_ITERATIONS)
          throw new Error("[Parchment] Maximum optimize iterations reached");
        for (remaining.forEach((mutation) => {
          const blot = this.find(mutation.target, true);
          blot != null && (blot.domNode === mutation.target && (mutation.type === "childList" ? (mark(this.find(mutation.previousSibling, false)), Array.from(mutation.addedNodes).forEach((node) => {
            const child = this.find(node, false);
            mark(child, false), child instanceof ParentBlot$1 && child.children.forEach((grandChild) => {
              mark(grandChild, false);
            });
          })) : mutation.type === "attributes" && mark(blot.prev)), mark(blot));
        }), this.children.forEach(optimize), remaining = Array.from(this.observer.takeRecords()), records = remaining.slice(); records.length > 0; )
          mutations.push(records.pop());
      }
    }
    update(mutations, context = {}) {
      mutations = mutations || this.observer.takeRecords();
      const mutationsMap = /* @__PURE__ */ new WeakMap();
      mutations.map((mutation) => {
        const blot = this.find(mutation.target, true);
        return blot == null ? null : mutationsMap.has(blot.domNode) ? (mutationsMap.get(blot.domNode).push(mutation), null) : (mutationsMap.set(blot.domNode, [mutation]), blot);
      }).forEach((blot) => {
        blot != null && blot !== this && mutationsMap.has(blot.domNode) && blot.update(mutationsMap.get(blot.domNode) || [], context);
      }), context.mutationsMap = mutationsMap, mutationsMap.has(this.domNode) && super.update(mutationsMap.get(this.domNode), context), this.optimize(mutations, context);
    }
  };
  _ScrollBlot.blotName = "scroll", _ScrollBlot.defaultChild = BlockBlot$1, _ScrollBlot.allowedChildren = [BlockBlot$1, ContainerBlot$1], _ScrollBlot.scope = Scope.BLOCK_BLOT, _ScrollBlot.tagName = "DIV";
  var ScrollBlot = _ScrollBlot;
  var ScrollBlot$1 = ScrollBlot;
  var _TextBlot = class _TextBlot2 extends LeafBlot$1 {
    static {
      __name(this, "_TextBlot");
    }
    static create(value) {
      return document.createTextNode(value);
    }
    static value(domNode) {
      return domNode.data;
    }
    constructor(scroll, node) {
      super(scroll, node), this.text = this.statics.value(this.domNode);
    }
    deleteAt(index, length) {
      this.domNode.data = this.text = this.text.slice(0, index) + this.text.slice(index + length);
    }
    index(node, offset) {
      return this.domNode === node ? offset : -1;
    }
    insertAt(index, value, def) {
      def == null ? (this.text = this.text.slice(0, index) + value + this.text.slice(index), this.domNode.data = this.text) : super.insertAt(index, value, def);
    }
    length() {
      return this.text.length;
    }
    optimize(context) {
      super.optimize(context), this.text = this.statics.value(this.domNode), this.text.length === 0 ? this.remove() : this.next instanceof _TextBlot2 && this.next.prev === this && (this.insertAt(this.length(), this.next.value()), this.next.remove());
    }
    position(index, _inclusive = false) {
      return [this.domNode, index];
    }
    split(index, force = false) {
      if (!force) {
        if (index === 0)
          return this;
        if (index === this.length())
          return this.next;
      }
      const after = this.scroll.create(this.domNode.splitText(index));
      return this.parent.insertBefore(after, this.next || void 0), this.text = this.statics.value(this.domNode), after;
    }
    update(mutations, _context) {
      mutations.some((mutation) => mutation.type === "characterData" && mutation.target === this.domNode) && (this.text = this.statics.value(this.domNode));
    }
    value() {
      return this.text;
    }
  };
  _TextBlot.blotName = "text", _TextBlot.scope = Scope.INLINE_BLOT;
  var TextBlot = _TextBlot;
  var TextBlot$1 = TextBlot;

  // node_modules/quill/core/quill.js
  var import_quill_delta3 = __toESM(require_Delta(), 1);

  // node_modules/quill/core/editor.js
  var import_quill_delta2 = __toESM(require_Delta(), 1);

  // node_modules/quill/blots/block.js
  var import_quill_delta = __toESM(require_Delta(), 1);

  // node_modules/quill/blots/break.js
  var Break = class extends EmbedBlot$1 {
    static {
      __name(this, "Break");
    }
    static value() {
      return void 0;
    }
    optimize() {
      if (this.prev || this.next) {
        this.remove();
      }
    }
    length() {
      return 0;
    }
    value() {
      return "";
    }
  };
  Break.blotName = "break";
  Break.tagName = "BR";
  var break_default = Break;

  // node_modules/quill/blots/text.js
  var Text2 = class extends TextBlot$1 {
    static {
      __name(this, "Text");
    }
  };
  function escapeText(text) {
    return text.replace(/[&<>"']/g, (s2) => {
      const entityMap = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;"
      };
      return entityMap[s2];
    });
  }
  __name(escapeText, "escapeText");

  // node_modules/quill/blots/inline.js
  var Inline = class _Inline extends InlineBlot$1 {
    static {
      __name(this, "Inline");
    }
    static allowedChildren = [_Inline, break_default, EmbedBlot$1, Text2];
    // Lower index means deeper in the DOM tree, since not found (-1) is for embeds
    static order = [
      "cursor",
      "inline",
      // Must be lower
      "link",
      // Chrome wants <a> to be lower
      "underline",
      "strike",
      "italic",
      "bold",
      "script",
      "code"
      // Must be higher
    ];
    static compare(self2, other) {
      const selfIndex = _Inline.order.indexOf(self2);
      const otherIndex = _Inline.order.indexOf(other);
      if (selfIndex >= 0 || otherIndex >= 0) {
        return selfIndex - otherIndex;
      }
      if (self2 === other) {
        return 0;
      }
      if (self2 < other) {
        return -1;
      }
      return 1;
    }
    formatAt(index, length, name, value) {
      if (_Inline.compare(this.statics.blotName, name) < 0 && this.scroll.query(name, Scope.BLOT)) {
        const blot = this.isolate(index, length);
        if (value) {
          blot.wrap(name, value);
        }
      } else {
        super.formatAt(index, length, name, value);
      }
    }
    optimize(context) {
      super.optimize(context);
      if (this.parent instanceof _Inline && _Inline.compare(this.statics.blotName, this.parent.statics.blotName) > 0) {
        const parent = this.parent.isolate(this.offset(), this.length());
        this.moveChildren(parent);
        parent.wrap(this);
      }
    }
  };
  var inline_default = Inline;

  // node_modules/quill/blots/block.js
  var NEWLINE_LENGTH = 1;
  var Block = class extends BlockBlot$1 {
    static {
      __name(this, "Block");
    }
    cache = {};
    delta() {
      if (this.cache.delta == null) {
        this.cache.delta = blockDelta(this);
      }
      return this.cache.delta;
    }
    deleteAt(index, length) {
      super.deleteAt(index, length);
      this.cache = {};
    }
    formatAt(index, length, name, value) {
      if (length <= 0)
        return;
      if (this.scroll.query(name, Scope.BLOCK)) {
        if (index + length === this.length()) {
          this.format(name, value);
        }
      } else {
        super.formatAt(index, Math.min(length, this.length() - index - 1), name, value);
      }
      this.cache = {};
    }
    insertAt(index, value, def) {
      if (def != null) {
        super.insertAt(index, value, def);
        this.cache = {};
        return;
      }
      if (value.length === 0)
        return;
      const lines = value.split("\n");
      const text = lines.shift();
      if (text.length > 0) {
        if (index < this.length() - 1 || this.children.tail == null) {
          super.insertAt(Math.min(index, this.length() - 1), text);
        } else {
          this.children.tail.insertAt(this.children.tail.length(), text);
        }
        this.cache = {};
      }
      let block = this;
      lines.reduce((lineIndex, line) => {
        block = block.split(lineIndex, true);
        block.insertAt(0, line);
        return line.length;
      }, index + text.length);
    }
    insertBefore(blot, ref) {
      const {
        head
      } = this.children;
      super.insertBefore(blot, ref);
      if (head instanceof break_default) {
        head.remove();
      }
      this.cache = {};
    }
    length() {
      if (this.cache.length == null) {
        this.cache.length = super.length() + NEWLINE_LENGTH;
      }
      return this.cache.length;
    }
    moveChildren(target, ref) {
      super.moveChildren(target, ref);
      this.cache = {};
    }
    optimize(context) {
      super.optimize(context);
      this.cache = {};
    }
    path(index) {
      return super.path(index, true);
    }
    removeChild(child) {
      super.removeChild(child);
      this.cache = {};
    }
    split(index) {
      let force = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      if (force && (index === 0 || index >= this.length() - NEWLINE_LENGTH)) {
        const clone = this.clone();
        if (index === 0) {
          this.parent.insertBefore(clone, this);
          return this;
        }
        this.parent.insertBefore(clone, this.next);
        return clone;
      }
      const next = super.split(index, force);
      this.cache = {};
      return next;
    }
  };
  Block.blotName = "block";
  Block.tagName = "P";
  Block.defaultChild = break_default;
  Block.allowedChildren = [break_default, inline_default, EmbedBlot$1, Text2];
  var BlockEmbed = class extends EmbedBlot$1 {
    static {
      __name(this, "BlockEmbed");
    }
    attach() {
      super.attach();
      this.attributes = new AttributorStore$1(this.domNode);
    }
    delta() {
      return new import_quill_delta.default().insert(this.value(), {
        ...this.formats(),
        ...this.attributes.values()
      });
    }
    format(name, value) {
      const attribute = this.scroll.query(name, Scope.BLOCK_ATTRIBUTE);
      if (attribute != null) {
        this.attributes.attribute(attribute, value);
      }
    }
    formatAt(index, length, name, value) {
      this.format(name, value);
    }
    insertAt(index, value, def) {
      if (def != null) {
        super.insertAt(index, value, def);
        return;
      }
      const lines = value.split("\n");
      const text = lines.pop();
      const blocks = lines.map((line) => {
        const block = this.scroll.create(Block.blotName);
        block.insertAt(0, line);
        return block;
      });
      const ref = this.split(index);
      blocks.forEach((block) => {
        this.parent.insertBefore(block, ref);
      });
      if (text) {
        this.parent.insertBefore(this.scroll.create("text", text), ref);
      }
    }
  };
  BlockEmbed.scope = Scope.BLOCK_BLOT;
  function blockDelta(blot) {
    let filter = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
    return blot.descendants(LeafBlot$1).reduce((delta, leaf) => {
      if (leaf.length() === 0) {
        return delta;
      }
      return delta.insert(leaf.value(), bubbleFormats(leaf, {}, filter));
    }, new import_quill_delta.default()).insert("\n", bubbleFormats(blot));
  }
  __name(blockDelta, "blockDelta");
  function bubbleFormats(blot) {
    let formats2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    let filter = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
    if (blot == null)
      return formats2;
    if ("formats" in blot && typeof blot.formats === "function") {
      formats2 = {
        ...formats2,
        ...blot.formats()
      };
      if (filter) {
        delete formats2["code-token"];
      }
    }
    if (blot.parent == null || blot.parent.statics.blotName === "scroll" || blot.parent.statics.scope !== blot.statics.scope) {
      return formats2;
    }
    return bubbleFormats(blot.parent, formats2, filter);
  }
  __name(bubbleFormats, "bubbleFormats");

  // node_modules/quill/blots/cursor.js
  var Cursor = class _Cursor extends EmbedBlot$1 {
    static {
      __name(this, "Cursor");
    }
    static blotName = "cursor";
    static className = "ql-cursor";
    static tagName = "span";
    static CONTENTS = "\uFEFF";
    // Zero width no break space
    static value() {
      return void 0;
    }
    constructor(scroll, domNode, selection) {
      super(scroll, domNode);
      this.selection = selection;
      this.textNode = document.createTextNode(_Cursor.CONTENTS);
      this.domNode.appendChild(this.textNode);
      this.savedLength = 0;
    }
    detach() {
      if (this.parent != null)
        this.parent.removeChild(this);
    }
    format(name, value) {
      if (this.savedLength !== 0) {
        super.format(name, value);
        return;
      }
      let target = this;
      let index = 0;
      while (target != null && target.statics.scope !== Scope.BLOCK_BLOT) {
        index += target.offset(target.parent);
        target = target.parent;
      }
      if (target != null) {
        this.savedLength = _Cursor.CONTENTS.length;
        target.optimize();
        target.formatAt(index, _Cursor.CONTENTS.length, name, value);
        this.savedLength = 0;
      }
    }
    index(node, offset) {
      if (node === this.textNode)
        return 0;
      return super.index(node, offset);
    }
    length() {
      return this.savedLength;
    }
    position() {
      return [this.textNode, this.textNode.data.length];
    }
    remove() {
      super.remove();
      this.parent = null;
    }
    restore() {
      if (this.selection.composing || this.parent == null)
        return null;
      const range = this.selection.getNativeRange();
      while (this.domNode.lastChild != null && this.domNode.lastChild !== this.textNode) {
        this.domNode.parentNode.insertBefore(this.domNode.lastChild, this.domNode);
      }
      const prevTextBlot = this.prev instanceof Text2 ? this.prev : null;
      const prevTextLength = prevTextBlot ? prevTextBlot.length() : 0;
      const nextTextBlot = this.next instanceof Text2 ? this.next : null;
      const nextText = nextTextBlot ? nextTextBlot.text : "";
      const {
        textNode
      } = this;
      const newText = textNode.data.split(_Cursor.CONTENTS).join("");
      textNode.data = _Cursor.CONTENTS;
      let mergedTextBlot;
      if (prevTextBlot) {
        mergedTextBlot = prevTextBlot;
        if (newText || nextTextBlot) {
          prevTextBlot.insertAt(prevTextBlot.length(), newText + nextText);
          if (nextTextBlot) {
            nextTextBlot.remove();
          }
        }
      } else if (nextTextBlot) {
        mergedTextBlot = nextTextBlot;
        nextTextBlot.insertAt(0, newText);
      } else {
        const newTextNode = document.createTextNode(newText);
        mergedTextBlot = this.scroll.create(newTextNode);
        this.parent.insertBefore(mergedTextBlot, this);
      }
      this.remove();
      if (range) {
        const remapOffset = /* @__PURE__ */ __name((node, offset) => {
          if (prevTextBlot && node === prevTextBlot.domNode) {
            return offset;
          }
          if (node === textNode) {
            return prevTextLength + offset - 1;
          }
          if (nextTextBlot && node === nextTextBlot.domNode) {
            return prevTextLength + newText.length + offset;
          }
          return null;
        }, "remapOffset");
        const start2 = remapOffset(range.start.node, range.start.offset);
        const end = remapOffset(range.end.node, range.end.offset);
        if (start2 !== null && end !== null) {
          return {
            startNode: mergedTextBlot.domNode,
            startOffset: start2,
            endNode: mergedTextBlot.domNode,
            endOffset: end
          };
        }
      }
      return null;
    }
    update(mutations, context) {
      if (mutations.some((mutation) => {
        return mutation.type === "characterData" && mutation.target === this.textNode;
      })) {
        const range = this.restore();
        if (range)
          context.range = range;
      }
    }
    // Avoid .ql-cursor being a descendant of `<a/>`.
    // The reason is Safari pushes down `<a/>` on text insertion.
    // That will cause DOM nodes not sync with the model.
    //
    // For example ({I} is the caret), given the markup:
    //    <a><span class="ql-cursor">\uFEFF{I}</span></a>
    // When typing a char "x", `<a/>` will be pushed down inside the `<span>` first:
    //    <span class="ql-cursor"><a>\uFEFF{I}</a></span>
    // And then "x" will be inserted after `<a/>`:
    //    <span class="ql-cursor"><a>\uFEFF</a>d{I}</span>
    optimize(context) {
      super.optimize(context);
      let {
        parent
      } = this;
      while (parent) {
        if (parent.domNode.tagName === "A") {
          this.savedLength = _Cursor.CONTENTS.length;
          parent.isolate(this.offset(parent), this.length()).unwrap();
          this.savedLength = 0;
          break;
        }
        parent = parent.parent;
      }
    }
    value() {
      return "";
    }
  };
  var cursor_default = Cursor;

  // node_modules/eventemitter3/index.mjs
  var import_index = __toESM(require_eventemitter3(), 1);

  // node_modules/quill/core/instances.js
  var instances_default = /* @__PURE__ */ new WeakMap();

  // node_modules/quill/core/logger.js
  var levels = ["error", "warn", "log", "info"];
  var level = "warn";
  function debug(method) {
    if (level) {
      if (levels.indexOf(method) <= levels.indexOf(level)) {
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }
        console[method](...args);
      }
    }
  }
  __name(debug, "debug");
  function namespace(ns) {
    return levels.reduce((logger, method) => {
      logger[method] = debug.bind(console, method, ns);
      return logger;
    }, {});
  }
  __name(namespace, "namespace");
  namespace.level = (newLevel) => {
    level = newLevel;
  };
  debug.level = namespace.level;
  var logger_default2 = namespace;

  // node_modules/quill/core/emitter.js
  var debug2 = logger_default2("quill:events");
  var EVENTS = ["selectionchange", "mousedown", "mouseup", "click"];
  EVENTS.forEach((eventName) => {
    document.addEventListener(eventName, function() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      Array.from(document.querySelectorAll(".ql-container")).forEach((node) => {
        const quill = instances_default.get(node);
        if (quill && quill.emitter) {
          quill.emitter.handleDOM(...args);
        }
      });
    });
  });
  var Emitter = class extends import_index.default {
    static {
      __name(this, "Emitter");
    }
    static events = {
      EDITOR_CHANGE: "editor-change",
      SCROLL_BEFORE_UPDATE: "scroll-before-update",
      SCROLL_BLOT_MOUNT: "scroll-blot-mount",
      SCROLL_BLOT_UNMOUNT: "scroll-blot-unmount",
      SCROLL_OPTIMIZE: "scroll-optimize",
      SCROLL_UPDATE: "scroll-update",
      SCROLL_EMBED_UPDATE: "scroll-embed-update",
      SELECTION_CHANGE: "selection-change",
      TEXT_CHANGE: "text-change",
      COMPOSITION_BEFORE_START: "composition-before-start",
      COMPOSITION_START: "composition-start",
      COMPOSITION_BEFORE_END: "composition-before-end",
      COMPOSITION_END: "composition-end"
    };
    static sources = {
      API: "api",
      SILENT: "silent",
      USER: "user"
    };
    constructor() {
      super();
      this.domListeners = {};
      this.on("error", debug2.error);
    }
    emit() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      debug2.log.call(debug2, ...args);
      return super.emit(...args);
    }
    handleDOM(event) {
      for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
        args[_key3 - 1] = arguments[_key3];
      }
      (this.domListeners[event.type] || []).forEach((_ref) => {
        let {
          node,
          handler
        } = _ref;
        if (event.target === node || node.contains(event.target)) {
          handler(event, ...args);
        }
      });
    }
    listenDOM(eventName, node, handler) {
      if (!this.domListeners[eventName]) {
        this.domListeners[eventName] = [];
      }
      this.domListeners[eventName].push({
        node,
        handler
      });
    }
  };
  var emitter_default = Emitter;

  // node_modules/quill/core/selection.js
  var debug3 = logger_default2("quill:selection");
  var Range = class {
    static {
      __name(this, "Range");
    }
    constructor(index) {
      let length = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      this.index = index;
      this.length = length;
    }
  };
  var Selection = class {
    static {
      __name(this, "Selection");
    }
    constructor(scroll, emitter) {
      this.emitter = emitter;
      this.scroll = scroll;
      this.composing = false;
      this.mouseDown = false;
      this.root = this.scroll.domNode;
      this.cursor = this.scroll.create("cursor", this);
      this.savedRange = new Range(0, 0);
      this.lastRange = this.savedRange;
      this.lastNative = null;
      this.handleComposition();
      this.handleDragging();
      this.emitter.listenDOM("selectionchange", document, () => {
        if (!this.mouseDown && !this.composing) {
          setTimeout(this.update.bind(this, emitter_default.sources.USER), 1);
        }
      });
      this.emitter.on(emitter_default.events.SCROLL_BEFORE_UPDATE, () => {
        if (!this.hasFocus())
          return;
        const native = this.getNativeRange();
        if (native == null)
          return;
        if (native.start.node === this.cursor.textNode)
          return;
        this.emitter.once(emitter_default.events.SCROLL_UPDATE, (source, mutations) => {
          try {
            if (this.root.contains(native.start.node) && this.root.contains(native.end.node)) {
              this.setNativeRange(native.start.node, native.start.offset, native.end.node, native.end.offset);
            }
            const triggeredByTyping = mutations.some((mutation) => mutation.type === "characterData" || mutation.type === "childList" || mutation.type === "attributes" && mutation.target === this.root);
            this.update(triggeredByTyping ? emitter_default.sources.SILENT : source);
          } catch (ignored) {
          }
        });
      });
      this.emitter.on(emitter_default.events.SCROLL_OPTIMIZE, (mutations, context) => {
        if (context.range) {
          const {
            startNode,
            startOffset,
            endNode,
            endOffset
          } = context.range;
          this.setNativeRange(startNode, startOffset, endNode, endOffset);
          this.update(emitter_default.sources.SILENT);
        }
      });
      this.update(emitter_default.sources.SILENT);
    }
    handleComposition() {
      this.emitter.on(emitter_default.events.COMPOSITION_BEFORE_START, () => {
        this.composing = true;
      });
      this.emitter.on(emitter_default.events.COMPOSITION_END, () => {
        this.composing = false;
        if (this.cursor.parent) {
          const range = this.cursor.restore();
          if (!range)
            return;
          setTimeout(() => {
            this.setNativeRange(range.startNode, range.startOffset, range.endNode, range.endOffset);
          }, 1);
        }
      });
    }
    handleDragging() {
      this.emitter.listenDOM("mousedown", document.body, () => {
        this.mouseDown = true;
      });
      this.emitter.listenDOM("mouseup", document.body, () => {
        this.mouseDown = false;
        this.update(emitter_default.sources.USER);
      });
    }
    focus() {
      if (this.hasFocus())
        return;
      this.root.focus({
        preventScroll: true
      });
      this.setRange(this.savedRange);
    }
    format(format, value) {
      this.scroll.update();
      const nativeRange = this.getNativeRange();
      if (nativeRange == null || !nativeRange.native.collapsed || this.scroll.query(format, Scope.BLOCK))
        return;
      if (nativeRange.start.node !== this.cursor.textNode) {
        const blot = this.scroll.find(nativeRange.start.node, false);
        if (blot == null)
          return;
        if (blot instanceof LeafBlot$1) {
          const after = blot.split(nativeRange.start.offset);
          blot.parent.insertBefore(this.cursor, after);
        } else {
          blot.insertBefore(this.cursor, nativeRange.start.node);
        }
        this.cursor.attach();
      }
      this.cursor.format(format, value);
      this.scroll.optimize();
      this.setNativeRange(this.cursor.textNode, this.cursor.textNode.data.length);
      this.update();
    }
    getBounds(index) {
      let length = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      const scrollLength = this.scroll.length();
      index = Math.min(index, scrollLength - 1);
      length = Math.min(index + length, scrollLength - 1) - index;
      let node;
      let [leaf, offset] = this.scroll.leaf(index);
      if (leaf == null)
        return null;
      if (length > 0 && offset === leaf.length()) {
        const [next] = this.scroll.leaf(index + 1);
        if (next) {
          const [line] = this.scroll.line(index);
          const [nextLine] = this.scroll.line(index + 1);
          if (line === nextLine) {
            leaf = next;
            offset = 0;
          }
        }
      }
      [node, offset] = leaf.position(offset, true);
      const range = document.createRange();
      if (length > 0) {
        range.setStart(node, offset);
        [leaf, offset] = this.scroll.leaf(index + length);
        if (leaf == null)
          return null;
        [node, offset] = leaf.position(offset, true);
        range.setEnd(node, offset);
        return range.getBoundingClientRect();
      }
      let side = "left";
      let rect;
      if (node instanceof Text) {
        if (!node.data.length) {
          return null;
        }
        if (offset < node.data.length) {
          range.setStart(node, offset);
          range.setEnd(node, offset + 1);
        } else {
          range.setStart(node, offset - 1);
          range.setEnd(node, offset);
          side = "right";
        }
        rect = range.getBoundingClientRect();
      } else {
        if (!(leaf.domNode instanceof Element))
          return null;
        rect = leaf.domNode.getBoundingClientRect();
        if (offset > 0)
          side = "right";
      }
      return {
        bottom: rect.top + rect.height,
        height: rect.height,
        left: rect[side],
        right: rect[side],
        top: rect.top,
        width: 0
      };
    }
    getNativeRange() {
      const selection = document.getSelection();
      if (selection == null || selection.rangeCount <= 0)
        return null;
      const nativeRange = selection.getRangeAt(0);
      if (nativeRange == null)
        return null;
      const range = this.normalizeNative(nativeRange);
      debug3.info("getNativeRange", range);
      return range;
    }
    getRange() {
      const root2 = this.scroll.domNode;
      if ("isConnected" in root2 && !root2.isConnected) {
        return [null, null];
      }
      const normalized = this.getNativeRange();
      if (normalized == null)
        return [null, null];
      const range = this.normalizedToRange(normalized);
      return [range, normalized];
    }
    hasFocus() {
      return document.activeElement === this.root || document.activeElement != null && contains(this.root, document.activeElement);
    }
    normalizedToRange(range) {
      const positions = [[range.start.node, range.start.offset]];
      if (!range.native.collapsed) {
        positions.push([range.end.node, range.end.offset]);
      }
      const indexes = positions.map((position) => {
        const [node, offset] = position;
        const blot = this.scroll.find(node, true);
        const index = blot.offset(this.scroll);
        if (offset === 0) {
          return index;
        }
        if (blot instanceof LeafBlot$1) {
          return index + blot.index(node, offset);
        }
        return index + blot.length();
      });
      const end = Math.min(Math.max(...indexes), this.scroll.length() - 1);
      const start2 = Math.min(end, ...indexes);
      return new Range(start2, end - start2);
    }
    normalizeNative(nativeRange) {
      if (!contains(this.root, nativeRange.startContainer) || !nativeRange.collapsed && !contains(this.root, nativeRange.endContainer)) {
        return null;
      }
      const range = {
        start: {
          node: nativeRange.startContainer,
          offset: nativeRange.startOffset
        },
        end: {
          node: nativeRange.endContainer,
          offset: nativeRange.endOffset
        },
        native: nativeRange
      };
      [range.start, range.end].forEach((position) => {
        let {
          node,
          offset
        } = position;
        while (!(node instanceof Text) && node.childNodes.length > 0) {
          if (node.childNodes.length > offset) {
            node = node.childNodes[offset];
            offset = 0;
          } else if (node.childNodes.length === offset) {
            node = node.lastChild;
            if (node instanceof Text) {
              offset = node.data.length;
            } else if (node.childNodes.length > 0) {
              offset = node.childNodes.length;
            } else {
              offset = node.childNodes.length + 1;
            }
          } else {
            break;
          }
        }
        position.node = node;
        position.offset = offset;
      });
      return range;
    }
    rangeToNative(range) {
      const scrollLength = this.scroll.length();
      const getPosition = /* @__PURE__ */ __name((index, inclusive) => {
        index = Math.min(scrollLength - 1, index);
        const [leaf, leafOffset] = this.scroll.leaf(index);
        return leaf ? leaf.position(leafOffset, inclusive) : [null, -1];
      }, "getPosition");
      return [...getPosition(range.index, false), ...getPosition(range.index + range.length, true)];
    }
    setNativeRange(startNode, startOffset) {
      let endNode = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : startNode;
      let endOffset = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : startOffset;
      let force = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;
      debug3.info("setNativeRange", startNode, startOffset, endNode, endOffset);
      if (startNode != null && (this.root.parentNode == null || startNode.parentNode == null || // @ts-expect-error Fix me later
      endNode.parentNode == null)) {
        return;
      }
      const selection = document.getSelection();
      if (selection == null)
        return;
      if (startNode != null) {
        if (!this.hasFocus())
          this.root.focus({
            preventScroll: true
          });
        const {
          native
        } = this.getNativeRange() || {};
        if (native == null || force || startNode !== native.startContainer || startOffset !== native.startOffset || endNode !== native.endContainer || endOffset !== native.endOffset) {
          if (startNode instanceof Element && startNode.tagName === "BR") {
            startOffset = Array.from(startNode.parentNode.childNodes).indexOf(startNode);
            startNode = startNode.parentNode;
          }
          if (endNode instanceof Element && endNode.tagName === "BR") {
            endOffset = Array.from(endNode.parentNode.childNodes).indexOf(endNode);
            endNode = endNode.parentNode;
          }
          const range = document.createRange();
          range.setStart(startNode, startOffset);
          range.setEnd(endNode, endOffset);
          selection.removeAllRanges();
          selection.addRange(range);
        }
      } else {
        selection.removeAllRanges();
        this.root.blur();
      }
    }
    setRange(range) {
      let force = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      let source = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : emitter_default.sources.API;
      if (typeof force === "string") {
        source = force;
        force = false;
      }
      debug3.info("setRange", range);
      if (range != null) {
        const args = this.rangeToNative(range);
        this.setNativeRange(...args, force);
      } else {
        this.setNativeRange(null);
      }
      this.update(source);
    }
    update() {
      let source = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : emitter_default.sources.USER;
      const oldRange = this.lastRange;
      const [lastRange, nativeRange] = this.getRange();
      this.lastRange = lastRange;
      this.lastNative = nativeRange;
      if (this.lastRange != null) {
        this.savedRange = this.lastRange;
      }
      if (!isEqual_default(oldRange, this.lastRange)) {
        if (!this.composing && nativeRange != null && nativeRange.native.collapsed && nativeRange.start.node !== this.cursor.textNode) {
          const range = this.cursor.restore();
          if (range) {
            this.setNativeRange(range.startNode, range.startOffset, range.endNode, range.endOffset);
          }
        }
        const args = [emitter_default.events.SELECTION_CHANGE, cloneDeep_default(this.lastRange), cloneDeep_default(oldRange), source];
        this.emitter.emit(emitter_default.events.EDITOR_CHANGE, ...args);
        if (source !== emitter_default.sources.SILENT) {
          this.emitter.emit(...args);
        }
      }
    }
  };
  function contains(parent, descendant) {
    try {
      descendant.parentNode;
    } catch (e2) {
      return false;
    }
    return parent.contains(descendant);
  }
  __name(contains, "contains");
  var selection_default = Selection;

  // node_modules/quill/core/editor.js
  var ASCII = /^[ -~]*$/;
  var Editor = class {
    static {
      __name(this, "Editor");
    }
    constructor(scroll) {
      this.scroll = scroll;
      this.delta = this.getDelta();
    }
    applyDelta(delta) {
      this.scroll.update();
      let scrollLength = this.scroll.length();
      this.scroll.batchStart();
      const normalizedDelta = normalizeDelta(delta);
      const deleteDelta = new import_quill_delta2.default();
      const normalizedOps = splitOpLines(normalizedDelta.ops.slice());
      normalizedOps.reduce((index, op) => {
        const length = import_quill_delta2.Op.length(op);
        let attributes = op.attributes || {};
        let isImplicitNewlinePrepended = false;
        let isImplicitNewlineAppended = false;
        if (op.insert != null) {
          deleteDelta.retain(length);
          if (typeof op.insert === "string") {
            const text = op.insert;
            isImplicitNewlineAppended = !text.endsWith("\n") && (scrollLength <= index || !!this.scroll.descendant(BlockEmbed, index)[0]);
            this.scroll.insertAt(index, text);
            const [line, offset] = this.scroll.line(index);
            let formats2 = merge_default({}, bubbleFormats(line));
            if (line instanceof Block) {
              const [leaf] = line.descendant(LeafBlot$1, offset);
              if (leaf) {
                formats2 = merge_default(formats2, bubbleFormats(leaf));
              }
            }
            attributes = import_quill_delta2.AttributeMap.diff(formats2, attributes) || {};
          } else if (typeof op.insert === "object") {
            const key = Object.keys(op.insert)[0];
            if (key == null)
              return index;
            const isInlineEmbed = this.scroll.query(key, Scope.INLINE) != null;
            if (isInlineEmbed) {
              if (scrollLength <= index || !!this.scroll.descendant(BlockEmbed, index)[0]) {
                isImplicitNewlineAppended = true;
              }
            } else if (index > 0) {
              const [leaf, offset] = this.scroll.descendant(LeafBlot$1, index - 1);
              if (leaf instanceof Text2) {
                const text = leaf.value();
                if (text[offset] !== "\n") {
                  isImplicitNewlinePrepended = true;
                }
              } else if (leaf instanceof EmbedBlot$1 && leaf.statics.scope === Scope.INLINE_BLOT) {
                isImplicitNewlinePrepended = true;
              }
            }
            this.scroll.insertAt(index, key, op.insert[key]);
            if (isInlineEmbed) {
              const [leaf] = this.scroll.descendant(LeafBlot$1, index);
              if (leaf) {
                const formats2 = merge_default({}, bubbleFormats(leaf));
                attributes = import_quill_delta2.AttributeMap.diff(formats2, attributes) || {};
              }
            }
          }
          scrollLength += length;
        } else {
          deleteDelta.push(op);
          if (op.retain !== null && typeof op.retain === "object") {
            const key = Object.keys(op.retain)[0];
            if (key == null)
              return index;
            this.scroll.updateEmbedAt(index, key, op.retain[key]);
          }
        }
        Object.keys(attributes).forEach((name) => {
          this.scroll.formatAt(index, length, name, attributes[name]);
        });
        const prependedLength = isImplicitNewlinePrepended ? 1 : 0;
        const addedLength = isImplicitNewlineAppended ? 1 : 0;
        scrollLength += prependedLength + addedLength;
        deleteDelta.retain(prependedLength);
        deleteDelta.delete(addedLength);
        return index + length + prependedLength + addedLength;
      }, 0);
      deleteDelta.reduce((index, op) => {
        if (typeof op.delete === "number") {
          this.scroll.deleteAt(index, op.delete);
          return index;
        }
        return index + import_quill_delta2.Op.length(op);
      }, 0);
      this.scroll.batchEnd();
      this.scroll.optimize();
      return this.update(normalizedDelta);
    }
    deleteText(index, length) {
      this.scroll.deleteAt(index, length);
      return this.update(new import_quill_delta2.default().retain(index).delete(length));
    }
    formatLine(index, length) {
      let formats2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      this.scroll.update();
      Object.keys(formats2).forEach((format) => {
        this.scroll.lines(index, Math.max(length, 1)).forEach((line) => {
          line.format(format, formats2[format]);
        });
      });
      this.scroll.optimize();
      const delta = new import_quill_delta2.default().retain(index).retain(length, cloneDeep_default(formats2));
      return this.update(delta);
    }
    formatText(index, length) {
      let formats2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      Object.keys(formats2).forEach((format) => {
        this.scroll.formatAt(index, length, format, formats2[format]);
      });
      const delta = new import_quill_delta2.default().retain(index).retain(length, cloneDeep_default(formats2));
      return this.update(delta);
    }
    getContents(index, length) {
      return this.delta.slice(index, index + length);
    }
    getDelta() {
      return this.scroll.lines().reduce((delta, line) => {
        return delta.concat(line.delta());
      }, new import_quill_delta2.default());
    }
    getFormat(index) {
      let length = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      let lines = [];
      let leaves = [];
      if (length === 0) {
        this.scroll.path(index).forEach((path) => {
          const [blot] = path;
          if (blot instanceof Block) {
            lines.push(blot);
          } else if (blot instanceof LeafBlot$1) {
            leaves.push(blot);
          }
        });
      } else {
        lines = this.scroll.lines(index, length);
        leaves = this.scroll.descendants(LeafBlot$1, index, length);
      }
      const [lineFormats, leafFormats] = [lines, leaves].map((blots) => {
        const blot = blots.shift();
        if (blot == null)
          return {};
        let formats2 = bubbleFormats(blot);
        while (Object.keys(formats2).length > 0) {
          const blot2 = blots.shift();
          if (blot2 == null)
            return formats2;
          formats2 = combineFormats(bubbleFormats(blot2), formats2);
        }
        return formats2;
      });
      return {
        ...lineFormats,
        ...leafFormats
      };
    }
    getHTML(index, length) {
      const [line, lineOffset] = this.scroll.line(index);
      if (line) {
        const lineLength = line.length();
        const isWithinLine = line.length() >= lineOffset + length;
        if (isWithinLine && !(lineOffset === 0 && length === lineLength)) {
          return convertHTML(line, lineOffset, length, true);
        }
        return convertHTML(this.scroll, index, length, true);
      }
      return "";
    }
    getText(index, length) {
      return this.getContents(index, length).filter((op) => typeof op.insert === "string").map((op) => op.insert).join("");
    }
    insertContents(index, contents) {
      const normalizedDelta = normalizeDelta(contents);
      const change = new import_quill_delta2.default().retain(index).concat(normalizedDelta);
      this.scroll.insertContents(index, normalizedDelta);
      return this.update(change);
    }
    insertEmbed(index, embed, value) {
      this.scroll.insertAt(index, embed, value);
      return this.update(new import_quill_delta2.default().retain(index).insert({
        [embed]: value
      }));
    }
    insertText(index, text) {
      let formats2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      text = text.replace(/\r\n/g, "\n").replace(/\r/g, "\n");
      this.scroll.insertAt(index, text);
      Object.keys(formats2).forEach((format) => {
        this.scroll.formatAt(index, text.length, format, formats2[format]);
      });
      return this.update(new import_quill_delta2.default().retain(index).insert(text, cloneDeep_default(formats2)));
    }
    isBlank() {
      if (this.scroll.children.length === 0)
        return true;
      if (this.scroll.children.length > 1)
        return false;
      const blot = this.scroll.children.head;
      if (blot?.statics.blotName !== Block.blotName)
        return false;
      const block = blot;
      if (block.children.length > 1)
        return false;
      return block.children.head instanceof break_default;
    }
    removeFormat(index, length) {
      const text = this.getText(index, length);
      const [line, offset] = this.scroll.line(index + length);
      let suffixLength = 0;
      let suffix = new import_quill_delta2.default();
      if (line != null) {
        suffixLength = line.length() - offset;
        suffix = line.delta().slice(offset, offset + suffixLength - 1).insert("\n");
      }
      const contents = this.getContents(index, length + suffixLength);
      const diff = contents.diff(new import_quill_delta2.default().insert(text).concat(suffix));
      const delta = new import_quill_delta2.default().retain(index).concat(diff);
      return this.applyDelta(delta);
    }
    update(change) {
      let mutations = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
      let selectionInfo = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : void 0;
      const oldDelta = this.delta;
      if (mutations.length === 1 && mutations[0].type === "characterData" && // @ts-expect-error Fix me later
      mutations[0].target.data.match(ASCII) && this.scroll.find(mutations[0].target)) {
        const textBlot = this.scroll.find(mutations[0].target);
        const formats2 = bubbleFormats(textBlot);
        const index = textBlot.offset(this.scroll);
        const oldValue = mutations[0].oldValue.replace(cursor_default.CONTENTS, "");
        const oldText = new import_quill_delta2.default().insert(oldValue);
        const newText = new import_quill_delta2.default().insert(textBlot.value());
        const relativeSelectionInfo = selectionInfo && {
          oldRange: shiftRange(selectionInfo.oldRange, -index),
          newRange: shiftRange(selectionInfo.newRange, -index)
        };
        const diffDelta = new import_quill_delta2.default().retain(index).concat(oldText.diff(newText, relativeSelectionInfo));
        change = diffDelta.reduce((delta, op) => {
          if (op.insert) {
            return delta.insert(op.insert, formats2);
          }
          return delta.push(op);
        }, new import_quill_delta2.default());
        this.delta = oldDelta.compose(change);
      } else {
        this.delta = this.getDelta();
        if (!change || !isEqual_default(oldDelta.compose(change), this.delta)) {
          change = oldDelta.diff(this.delta, selectionInfo);
        }
      }
      return change;
    }
  };
  function convertListHTML(items, lastIndent, types) {
    if (items.length === 0) {
      const [endTag2] = getListType(types.pop());
      if (lastIndent <= 0) {
        return `</li></${endTag2}>`;
      }
      return `</li></${endTag2}>${convertListHTML([], lastIndent - 1, types)}`;
    }
    const [{
      child,
      offset,
      length,
      indent,
      type
    }, ...rest] = items;
    const [tag, attribute] = getListType(type);
    if (indent > lastIndent) {
      types.push(type);
      if (indent === lastIndent + 1) {
        return `<${tag}><li${attribute}>${convertHTML(child, offset, length)}${convertListHTML(rest, indent, types)}`;
      }
      return `<${tag}><li>${convertListHTML(items, lastIndent + 1, types)}`;
    }
    const previousType = types[types.length - 1];
    if (indent === lastIndent && type === previousType) {
      return `</li><li${attribute}>${convertHTML(child, offset, length)}${convertListHTML(rest, indent, types)}`;
    }
    const [endTag] = getListType(types.pop());
    return `</li></${endTag}>${convertListHTML(items, lastIndent - 1, types)}`;
  }
  __name(convertListHTML, "convertListHTML");
  function convertHTML(blot, index, length) {
    let isRoot = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
    if ("html" in blot && typeof blot.html === "function") {
      return blot.html(index, length);
    }
    if (blot instanceof Text2) {
      return escapeText(blot.value().slice(index, index + length));
    }
    if (blot instanceof ParentBlot$1) {
      if (blot.statics.blotName === "list-container") {
        const items = [];
        blot.children.forEachAt(index, length, (child, offset, childLength) => {
          const formats2 = "formats" in child && typeof child.formats === "function" ? child.formats() : {};
          items.push({
            child,
            offset,
            length: childLength,
            indent: formats2.indent || 0,
            type: formats2.list
          });
        });
        return convertListHTML(items, -1, []);
      }
      const parts = [];
      blot.children.forEachAt(index, length, (child, offset, childLength) => {
        parts.push(convertHTML(child, offset, childLength));
      });
      if (isRoot || blot.statics.blotName === "list") {
        return parts.join("");
      }
      const {
        outerHTML,
        innerHTML
      } = blot.domNode;
      const [start2, end] = outerHTML.split(`>${innerHTML}<`);
      if (start2 === "<table") {
        return `<table style="border: 1px solid #000;">${parts.join("")}<${end}`;
      }
      return `${start2}>${parts.join("")}<${end}`;
    }
    return blot.domNode instanceof Element ? blot.domNode.outerHTML : "";
  }
  __name(convertHTML, "convertHTML");
  function combineFormats(formats2, combined) {
    return Object.keys(combined).reduce((merged, name) => {
      if (formats2[name] == null)
        return merged;
      const combinedValue = combined[name];
      if (combinedValue === formats2[name]) {
        merged[name] = combinedValue;
      } else if (Array.isArray(combinedValue)) {
        if (combinedValue.indexOf(formats2[name]) < 0) {
          merged[name] = combinedValue.concat([formats2[name]]);
        } else {
          merged[name] = combinedValue;
        }
      } else {
        merged[name] = [combinedValue, formats2[name]];
      }
      return merged;
    }, {});
  }
  __name(combineFormats, "combineFormats");
  function getListType(type) {
    const tag = type === "ordered" ? "ol" : "ul";
    switch (type) {
      case "checked":
        return [tag, ' data-list="checked"'];
      case "unchecked":
        return [tag, ' data-list="unchecked"'];
      default:
        return [tag, ""];
    }
  }
  __name(getListType, "getListType");
  function normalizeDelta(delta) {
    return delta.reduce((normalizedDelta, op) => {
      if (typeof op.insert === "string") {
        const text = op.insert.replace(/\r\n/g, "\n").replace(/\r/g, "\n");
        return normalizedDelta.insert(text, op.attributes);
      }
      return normalizedDelta.push(op);
    }, new import_quill_delta2.default());
  }
  __name(normalizeDelta, "normalizeDelta");
  function shiftRange(_ref, amount) {
    let {
      index,
      length
    } = _ref;
    return new Range(index + amount, length);
  }
  __name(shiftRange, "shiftRange");
  function splitOpLines(ops) {
    const split = [];
    ops.forEach((op) => {
      if (typeof op.insert === "string") {
        const lines = op.insert.split("\n");
        lines.forEach((line, index) => {
          if (index)
            split.push({
              insert: "\n",
              attributes: op.attributes
            });
          if (line)
            split.push({
              insert: line,
              attributes: op.attributes
            });
        });
      } else {
        split.push(op);
      }
    });
    return split;
  }
  __name(splitOpLines, "splitOpLines");
  var editor_default = Editor;

  // node_modules/quill/core/module.js
  var Module = class {
    static {
      __name(this, "Module");
    }
    static DEFAULTS = {};
    constructor(quill) {
      let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      this.quill = quill;
      this.options = options;
    }
  };
  var module_default = Module;

  // node_modules/quill/blots/embed.js
  var GUARD_TEXT = "\uFEFF";
  var Embed = class extends EmbedBlot$1 {
    static {
      __name(this, "Embed");
    }
    constructor(scroll, node) {
      super(scroll, node);
      this.contentNode = document.createElement("span");
      this.contentNode.setAttribute("contenteditable", "false");
      Array.from(this.domNode.childNodes).forEach((childNode) => {
        this.contentNode.appendChild(childNode);
      });
      this.leftGuard = document.createTextNode(GUARD_TEXT);
      this.rightGuard = document.createTextNode(GUARD_TEXT);
      this.domNode.appendChild(this.leftGuard);
      this.domNode.appendChild(this.contentNode);
      this.domNode.appendChild(this.rightGuard);
    }
    index(node, offset) {
      if (node === this.leftGuard)
        return 0;
      if (node === this.rightGuard)
        return 1;
      return super.index(node, offset);
    }
    restore(node) {
      let range = null;
      let textNode;
      const text = node.data.split(GUARD_TEXT).join("");
      if (node === this.leftGuard) {
        if (this.prev instanceof Text2) {
          const prevLength = this.prev.length();
          this.prev.insertAt(prevLength, text);
          range = {
            startNode: this.prev.domNode,
            startOffset: prevLength + text.length
          };
        } else {
          textNode = document.createTextNode(text);
          this.parent.insertBefore(this.scroll.create(textNode), this);
          range = {
            startNode: textNode,
            startOffset: text.length
          };
        }
      } else if (node === this.rightGuard) {
        if (this.next instanceof Text2) {
          this.next.insertAt(0, text);
          range = {
            startNode: this.next.domNode,
            startOffset: text.length
          };
        } else {
          textNode = document.createTextNode(text);
          this.parent.insertBefore(this.scroll.create(textNode), this.next);
          range = {
            startNode: textNode,
            startOffset: text.length
          };
        }
      }
      node.data = GUARD_TEXT;
      return range;
    }
    update(mutations, context) {
      mutations.forEach((mutation) => {
        if (mutation.type === "characterData" && (mutation.target === this.leftGuard || mutation.target === this.rightGuard)) {
          const range = this.restore(mutation.target);
          if (range)
            context.range = range;
        }
      });
    }
  };
  var embed_default = Embed;

  // node_modules/quill/core/composition.js
  var Composition = class {
    static {
      __name(this, "Composition");
    }
    isComposing = false;
    constructor(scroll, emitter) {
      this.scroll = scroll;
      this.emitter = emitter;
      this.setupListeners();
    }
    setupListeners() {
      this.scroll.domNode.addEventListener("compositionstart", (event) => {
        if (!this.isComposing) {
          this.handleCompositionStart(event);
        }
      });
      this.scroll.domNode.addEventListener("compositionend", (event) => {
        if (this.isComposing) {
          queueMicrotask(() => {
            this.handleCompositionEnd(event);
          });
        }
      });
    }
    handleCompositionStart(event) {
      const blot = event.target instanceof Node ? this.scroll.find(event.target, true) : null;
      if (blot && !(blot instanceof embed_default)) {
        this.emitter.emit(emitter_default.events.COMPOSITION_BEFORE_START, event);
        this.scroll.batchStart();
        this.emitter.emit(emitter_default.events.COMPOSITION_START, event);
        this.isComposing = true;
      }
    }
    handleCompositionEnd(event) {
      this.emitter.emit(emitter_default.events.COMPOSITION_BEFORE_END, event);
      this.scroll.batchEnd();
      this.emitter.emit(emitter_default.events.COMPOSITION_END, event);
      this.isComposing = false;
    }
  };
  var composition_default = Composition;

  // node_modules/quill/core/theme.js
  var Theme = class _Theme {
    static {
      __name(this, "Theme");
    }
    static DEFAULTS = {
      modules: {}
    };
    static themes = {
      default: _Theme
    };
    modules = {};
    constructor(quill, options) {
      this.quill = quill;
      this.options = options;
    }
    init() {
      Object.keys(this.options.modules).forEach((name) => {
        if (this.modules[name] == null) {
          this.addModule(name);
        }
      });
    }
    addModule(name) {
      const ModuleClass = this.quill.constructor.import(`modules/${name}`);
      this.modules[name] = new ModuleClass(this.quill, this.options.modules[name] || {});
      return this.modules[name];
    }
  };
  var theme_default = Theme;

  // node_modules/quill/core/utils/scrollRectIntoView.js
  var getParentElement = /* @__PURE__ */ __name((element) => element.parentElement || element.getRootNode().host || null, "getParentElement");
  var getElementRect = /* @__PURE__ */ __name((element) => {
    const rect = element.getBoundingClientRect();
    const scaleX = "offsetWidth" in element && Math.abs(rect.width) / element.offsetWidth || 1;
    const scaleY = "offsetHeight" in element && Math.abs(rect.height) / element.offsetHeight || 1;
    return {
      top: rect.top,
      right: rect.left + element.clientWidth * scaleX,
      bottom: rect.top + element.clientHeight * scaleY,
      left: rect.left
    };
  }, "getElementRect");
  var paddingValueToInt = /* @__PURE__ */ __name((value) => {
    const number = parseInt(value, 10);
    return Number.isNaN(number) ? 0 : number;
  }, "paddingValueToInt");
  var getScrollDistance = /* @__PURE__ */ __name((targetStart, targetEnd, scrollStart, scrollEnd, scrollPaddingStart, scrollPaddingEnd) => {
    if (targetStart < scrollStart && targetEnd > scrollEnd) {
      return 0;
    }
    if (targetStart < scrollStart) {
      return -(scrollStart - targetStart + scrollPaddingStart);
    }
    if (targetEnd > scrollEnd) {
      return targetEnd - targetStart > scrollEnd - scrollStart ? targetStart + scrollPaddingStart - scrollStart : targetEnd - scrollEnd + scrollPaddingEnd;
    }
    return 0;
  }, "getScrollDistance");
  var scrollRectIntoView = /* @__PURE__ */ __name((root2, targetRect) => {
    const document2 = root2.ownerDocument;
    let rect = targetRect;
    let current = root2;
    while (current) {
      const isDocumentBody = current === document2.body;
      const bounding = isDocumentBody ? {
        top: 0,
        right: window.visualViewport?.width ?? document2.documentElement.clientWidth,
        bottom: window.visualViewport?.height ?? document2.documentElement.clientHeight,
        left: 0
      } : getElementRect(current);
      const style = getComputedStyle(current);
      const scrollDistanceX = getScrollDistance(rect.left, rect.right, bounding.left, bounding.right, paddingValueToInt(style.scrollPaddingLeft), paddingValueToInt(style.scrollPaddingRight));
      const scrollDistanceY = getScrollDistance(rect.top, rect.bottom, bounding.top, bounding.bottom, paddingValueToInt(style.scrollPaddingTop), paddingValueToInt(style.scrollPaddingBottom));
      if (scrollDistanceX || scrollDistanceY) {
        if (isDocumentBody) {
          document2.defaultView?.scrollBy(scrollDistanceX, scrollDistanceY);
        } else {
          const {
            scrollLeft,
            scrollTop
          } = current;
          if (scrollDistanceY) {
            current.scrollTop += scrollDistanceY;
          }
          if (scrollDistanceX) {
            current.scrollLeft += scrollDistanceX;
          }
          const scrolledLeft = current.scrollLeft - scrollLeft;
          const scrolledTop = current.scrollTop - scrollTop;
          rect = {
            left: rect.left - scrolledLeft,
            top: rect.top - scrolledTop,
            right: rect.right - scrolledLeft,
            bottom: rect.bottom - scrolledTop
          };
        }
      }
      current = isDocumentBody || style.position === "fixed" ? null : getParentElement(current);
    }
  }, "scrollRectIntoView");
  var scrollRectIntoView_default = scrollRectIntoView;

  // node_modules/quill/core/utils/createRegistryWithFormats.js
  var MAX_REGISTER_ITERATIONS = 100;
  var CORE_FORMATS = ["block", "break", "cursor", "inline", "scroll", "text"];
  var createRegistryWithFormats = /* @__PURE__ */ __name((formats2, sourceRegistry, debug8) => {
    const registry = new Registry();
    CORE_FORMATS.forEach((name) => {
      const coreBlot = sourceRegistry.query(name);
      if (coreBlot)
        registry.register(coreBlot);
    });
    formats2.forEach((name) => {
      let format = sourceRegistry.query(name);
      if (!format) {
        debug8.error(`Cannot register "${name}" specified in "formats" config. Are you sure it was registered?`);
      }
      let iterations = 0;
      while (format) {
        registry.register(format);
        format = "blotName" in format ? format.requiredContainer ?? null : null;
        iterations += 1;
        if (iterations > MAX_REGISTER_ITERATIONS) {
          debug8.error(`Cycle detected in registering blot requiredContainer: "${name}"`);
          break;
        }
      }
    });
    return registry;
  }, "createRegistryWithFormats");
  var createRegistryWithFormats_default = createRegistryWithFormats;

  // node_modules/quill/core/quill.js
  var debug4 = logger_default2("quill");
  var globalRegistry = new Registry();
  ParentBlot$1.uiClass = "ql-ui";
  var Quill = class _Quill {
    static {
      __name(this, "Quill");
    }
    static DEFAULTS = {
      bounds: null,
      modules: {
        clipboard: true,
        keyboard: true,
        history: true,
        uploader: true
      },
      placeholder: "",
      readOnly: false,
      registry: globalRegistry,
      theme: "default"
    };
    static events = emitter_default.events;
    static sources = emitter_default.sources;
    static version = false ? "dev" : "2.0.0";
    static imports = {
      delta: import_quill_delta3.default,
      parchment: parchment_exports,
      "core/module": module_default,
      "core/theme": theme_default
    };
    static debug(limit) {
      if (limit === true) {
        limit = "log";
      }
      logger_default2.level(limit);
    }
    static find(node) {
      let bubble = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      return instances_default.get(node) || globalRegistry.find(node, bubble);
    }
    static import(name) {
      if (this.imports[name] == null) {
        debug4.error(`Cannot import ${name}. Are you sure it was registered?`);
      }
      return this.imports[name];
    }
    static register(path, target) {
      let overwrite = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      if (typeof path !== "string") {
        const name = "attrName" in path ? path.attrName : path.blotName;
        if (typeof name === "string") {
          this.register(`formats/${name}`, path, target);
        } else {
          Object.keys(path).forEach((key) => {
            this.register(key, path[key], target);
          });
        }
      } else {
        if (this.imports[path] != null && !overwrite) {
          debug4.warn(`Overwriting ${path} with`, target);
        }
        this.imports[path] = target;
        if ((path.startsWith("blots/") || path.startsWith("formats/")) && target && typeof target !== "boolean" && // @ts-expect-error
        target.blotName !== "abstract") {
          globalRegistry.register(target);
        }
        if (typeof target.register === "function") {
          target.register(globalRegistry);
        }
      }
    }
    constructor(container) {
      let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      this.options = expandConfig(container, options);
      this.container = this.options.container;
      if (this.container == null) {
        debug4.error("Invalid Quill container", container);
        return;
      }
      if (this.options.debug) {
        _Quill.debug(this.options.debug);
      }
      const html = this.container.innerHTML.trim();
      this.container.classList.add("ql-container");
      this.container.innerHTML = "";
      instances_default.set(this.container, this);
      this.root = this.addContainer("ql-editor");
      this.root.classList.add("ql-blank");
      this.emitter = new emitter_default();
      const scrollBlotName = ScrollBlot$1.blotName;
      const ScrollBlot2 = this.options.registry.query(scrollBlotName);
      if (!ScrollBlot2 || !("blotName" in ScrollBlot2)) {
        throw new Error(`Cannot initialize Quill without "${scrollBlotName}" blot`);
      }
      this.scroll = new ScrollBlot2(this.options.registry, this.root, {
        emitter: this.emitter
      });
      this.editor = new editor_default(this.scroll);
      this.selection = new selection_default(this.scroll, this.emitter);
      this.composition = new composition_default(this.scroll, this.emitter);
      this.theme = new this.options.theme(this, this.options);
      this.keyboard = this.theme.addModule("keyboard");
      this.clipboard = this.theme.addModule("clipboard");
      this.history = this.theme.addModule("history");
      this.uploader = this.theme.addModule("uploader");
      this.theme.addModule("input");
      this.theme.addModule("uiNode");
      this.theme.init();
      this.emitter.on(emitter_default.events.EDITOR_CHANGE, (type) => {
        if (type === emitter_default.events.TEXT_CHANGE) {
          this.root.classList.toggle("ql-blank", this.editor.isBlank());
        }
      });
      this.emitter.on(emitter_default.events.SCROLL_UPDATE, (source, mutations) => {
        const oldRange = this.selection.lastRange;
        const [newRange] = this.selection.getRange();
        const selectionInfo = oldRange && newRange ? {
          oldRange,
          newRange
        } : void 0;
        modify.call(this, () => this.editor.update(null, mutations, selectionInfo), source);
      });
      this.emitter.on(emitter_default.events.SCROLL_EMBED_UPDATE, (blot, delta) => {
        const oldRange = this.selection.lastRange;
        const [newRange] = this.selection.getRange();
        const selectionInfo = oldRange && newRange ? {
          oldRange,
          newRange
        } : void 0;
        modify.call(this, () => {
          const change = new import_quill_delta3.default().retain(blot.offset(this)).retain({
            [blot.statics.blotName]: delta
          });
          return this.editor.update(change, [], selectionInfo);
        }, _Quill.sources.USER);
      });
      if (html) {
        const contents = this.clipboard.convert({
          html: `${html}<p><br></p>`,
          text: "\n"
        });
        this.setContents(contents);
      }
      this.history.clear();
      if (this.options.placeholder) {
        this.root.setAttribute("data-placeholder", this.options.placeholder);
      }
      if (this.options.readOnly) {
        this.disable();
      }
      this.allowReadOnlyEdits = false;
    }
    addContainer(container) {
      let refNode = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
      if (typeof container === "string") {
        const className = container;
        container = document.createElement("div");
        container.classList.add(className);
      }
      this.container.insertBefore(container, refNode);
      return container;
    }
    blur() {
      this.selection.setRange(null);
    }
    deleteText(index, length, source) {
      [index, length, , source] = overload(index, length, source);
      return modify.call(this, () => {
        return this.editor.deleteText(index, length);
      }, source, index, -1 * length);
    }
    disable() {
      this.enable(false);
    }
    editReadOnly(modifier) {
      this.allowReadOnlyEdits = true;
      const value = modifier();
      this.allowReadOnlyEdits = false;
      return value;
    }
    enable() {
      let enabled = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
      this.scroll.enable(enabled);
      this.container.classList.toggle("ql-disabled", !enabled);
    }
    focus() {
      let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      this.selection.focus();
      if (!options.preventScroll) {
        this.scrollSelectionIntoView();
      }
    }
    format(name, value) {
      let source = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : emitter_default.sources.API;
      return modify.call(this, () => {
        const range = this.getSelection(true);
        let change = new import_quill_delta3.default();
        if (range == null)
          return change;
        if (this.scroll.query(name, Scope.BLOCK)) {
          change = this.editor.formatLine(range.index, range.length, {
            [name]: value
          });
        } else if (range.length === 0) {
          this.selection.format(name, value);
          return change;
        } else {
          change = this.editor.formatText(range.index, range.length, {
            [name]: value
          });
        }
        this.setSelection(range, emitter_default.sources.SILENT);
        return change;
      }, source);
    }
    formatLine(index, length, name, value, source) {
      let formats2;
      [index, length, formats2, source] = overload(
        index,
        length,
        // @ts-expect-error
        name,
        value,
        source
      );
      return modify.call(this, () => {
        return this.editor.formatLine(index, length, formats2);
      }, source, index, 0);
    }
    formatText(index, length, name, value, source) {
      let formats2;
      [index, length, formats2, source] = overload(
        // @ts-expect-error
        index,
        length,
        name,
        value,
        source
      );
      return modify.call(this, () => {
        return this.editor.formatText(index, length, formats2);
      }, source, index, 0);
    }
    getBounds(index) {
      let length = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      let bounds = null;
      if (typeof index === "number") {
        bounds = this.selection.getBounds(index, length);
      } else {
        bounds = this.selection.getBounds(index.index, index.length);
      }
      if (!bounds)
        return null;
      const containerBounds = this.container.getBoundingClientRect();
      return {
        bottom: bounds.bottom - containerBounds.top,
        height: bounds.height,
        left: bounds.left - containerBounds.left,
        right: bounds.right - containerBounds.left,
        top: bounds.top - containerBounds.top,
        width: bounds.width
      };
    }
    getContents() {
      let index = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      let length = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.getLength() - index;
      [index, length] = overload(index, length);
      return this.editor.getContents(index, length);
    }
    getFormat() {
      let index = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.getSelection(true);
      let length = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      if (typeof index === "number") {
        return this.editor.getFormat(index, length);
      }
      return this.editor.getFormat(index.index, index.length);
    }
    getIndex(blot) {
      return blot.offset(this.scroll);
    }
    getLength() {
      return this.scroll.length();
    }
    getLeaf(index) {
      return this.scroll.leaf(index);
    }
    getLine(index) {
      return this.scroll.line(index);
    }
    getLines() {
      let index = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      let length = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Number.MAX_VALUE;
      if (typeof index !== "number") {
        return this.scroll.lines(index.index, index.length);
      }
      return this.scroll.lines(index, length);
    }
    getModule(name) {
      return this.theme.modules[name];
    }
    getSelection() {
      let focus = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
      if (focus)
        this.focus();
      this.update();
      return this.selection.getRange()[0];
    }
    getSemanticHTML() {
      let index = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      let length = arguments.length > 1 ? arguments[1] : void 0;
      if (typeof index === "number") {
        length = length ?? this.getLength() - index;
      }
      [index, length] = overload(index, length);
      return this.editor.getHTML(index, length);
    }
    getText() {
      let index = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      let length = arguments.length > 1 ? arguments[1] : void 0;
      if (typeof index === "number") {
        length = length ?? this.getLength() - index;
      }
      [index, length] = overload(index, length);
      return this.editor.getText(index, length);
    }
    hasFocus() {
      return this.selection.hasFocus();
    }
    insertEmbed(index, embed, value) {
      let source = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : _Quill.sources.API;
      return modify.call(this, () => {
        return this.editor.insertEmbed(index, embed, value);
      }, source, index);
    }
    insertText(index, text, name, value, source) {
      let formats2;
      [index, , formats2, source] = overload(index, 0, name, value, source);
      return modify.call(this, () => {
        return this.editor.insertText(index, text, formats2);
      }, source, index, text.length);
    }
    isEnabled() {
      return this.scroll.isEnabled();
    }
    off() {
      return this.emitter.off(...arguments);
    }
    on() {
      return this.emitter.on(...arguments);
    }
    once() {
      return this.emitter.once(...arguments);
    }
    removeFormat(index, length, source) {
      [index, length, , source] = overload(index, length, source);
      return modify.call(this, () => {
        return this.editor.removeFormat(index, length);
      }, source, index);
    }
    scrollRectIntoView(rect) {
      scrollRectIntoView_default(this.root, rect);
    }
    /**
     * @deprecated Use Quill#scrollSelectionIntoView() instead.
     */
    scrollIntoView() {
      console.warn("Quill#scrollIntoView() has been deprecated and will be removed in the near future. Please use Quill#scrollSelectionIntoView() instead.");
      this.scrollSelectionIntoView();
    }
    /**
     * Scroll the current selection into the visible area.
     * If the selection is already visible, no scrolling will occur.
     */
    scrollSelectionIntoView() {
      const range = this.selection.lastRange;
      const bounds = range && this.selection.getBounds(range.index, range.length);
      if (bounds) {
        this.scrollRectIntoView(bounds);
      }
    }
    setContents(delta) {
      let source = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : emitter_default.sources.API;
      return modify.call(this, () => {
        delta = new import_quill_delta3.default(delta);
        const length = this.getLength();
        const delete1 = this.editor.deleteText(0, length);
        const applied = this.editor.insertContents(0, delta);
        const delete2 = this.editor.deleteText(this.getLength() - 1, 1);
        return delete1.compose(applied).compose(delete2);
      }, source);
    }
    setSelection(index, length, source) {
      if (index == null) {
        this.selection.setRange(null, length || _Quill.sources.API);
      } else {
        [index, length, , source] = overload(index, length, source);
        this.selection.setRange(new Range(Math.max(0, index), length), source);
        if (source !== emitter_default.sources.SILENT) {
          this.scrollSelectionIntoView();
        }
      }
    }
    setText(text) {
      let source = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : emitter_default.sources.API;
      const delta = new import_quill_delta3.default().insert(text);
      return this.setContents(delta, source);
    }
    update() {
      let source = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : emitter_default.sources.USER;
      const change = this.scroll.update(source);
      this.selection.update(source);
      return change;
    }
    updateContents(delta) {
      let source = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : emitter_default.sources.API;
      return modify.call(this, () => {
        delta = new import_quill_delta3.default(delta);
        return this.editor.applyDelta(delta);
      }, source, true);
    }
  };
  function resolveSelector(selector) {
    return typeof selector === "string" ? document.querySelector(selector) : selector;
  }
  __name(resolveSelector, "resolveSelector");
  function expandModuleConfig(config4) {
    return Object.entries(config4 ?? {}).reduce((expanded, _ref) => {
      let [key, value] = _ref;
      return {
        ...expanded,
        [key]: value === true ? {} : value
      };
    }, {});
  }
  __name(expandModuleConfig, "expandModuleConfig");
  function omitUndefinedValuesFromOptions(obj) {
    return Object.fromEntries(Object.entries(obj).filter((entry) => entry[1] !== void 0));
  }
  __name(omitUndefinedValuesFromOptions, "omitUndefinedValuesFromOptions");
  function expandConfig(containerOrSelector, options) {
    const container = resolveSelector(containerOrSelector);
    if (!container) {
      throw new Error("Invalid Quill container");
    }
    const shouldUseDefaultTheme = !options.theme || options.theme === Quill.DEFAULTS.theme;
    const theme = shouldUseDefaultTheme ? theme_default : Quill.import(`themes/${options.theme}`);
    if (!theme) {
      throw new Error(`Invalid theme ${options.theme}. Did you register it?`);
    }
    const {
      modules: quillModuleDefaults,
      ...quillDefaults
    } = Quill.DEFAULTS;
    const {
      modules: themeModuleDefaults,
      ...themeDefaults
    } = theme.DEFAULTS;
    const modules = merge_default({}, expandModuleConfig(quillModuleDefaults), expandModuleConfig(themeModuleDefaults), expandModuleConfig(options.modules));
    if (modules != null && modules.toolbar && modules.toolbar.constructor !== Object) {
      modules.toolbar = {
        container: modules.toolbar
      };
    }
    const config4 = {
      ...quillDefaults,
      ...omitUndefinedValuesFromOptions(themeDefaults),
      ...omitUndefinedValuesFromOptions(options)
    };
    let registry = options.registry;
    if (registry) {
      if (options.formats) {
        debug4.warn('Ignoring "formats" option because "registry" is specified');
      }
    } else {
      registry = options.formats ? createRegistryWithFormats_default(options.formats, config4.registry, debug4) : config4.registry;
    }
    return {
      ...config4,
      registry,
      container,
      theme,
      modules: Object.entries(modules).reduce((modulesWithDefaults, _ref2) => {
        let [name, value] = _ref2;
        if (!value)
          return modulesWithDefaults;
        const moduleClass = Quill.import(`modules/${name}`);
        if (moduleClass == null) {
          debug4.error(`Cannot load ${name} module. Are you sure you registered it?`);
          return modulesWithDefaults;
        }
        return {
          ...modulesWithDefaults,
          // @ts-expect-error
          [name]: merge_default({}, moduleClass.DEFAULTS || {}, value)
        };
      }, {}),
      bounds: resolveSelector(config4.bounds)
    };
  }
  __name(expandConfig, "expandConfig");
  function modify(modifier, source, index, shift) {
    if (!this.isEnabled() && source === emitter_default.sources.USER && !this.allowReadOnlyEdits) {
      return new import_quill_delta3.default();
    }
    let range = index == null ? null : this.getSelection();
    const oldDelta = this.editor.delta;
    const change = modifier();
    if (range != null) {
      if (index === true) {
        index = range.index;
      }
      if (shift == null) {
        range = shiftRange2(range, change, source);
      } else if (shift !== 0) {
        range = shiftRange2(range, index, shift, source);
      }
      this.setSelection(range, emitter_default.sources.SILENT);
    }
    if (change.length() > 0) {
      const args = [emitter_default.events.TEXT_CHANGE, change, oldDelta, source];
      this.emitter.emit(emitter_default.events.EDITOR_CHANGE, ...args);
      if (source !== emitter_default.sources.SILENT) {
        this.emitter.emit(...args);
      }
    }
    return change;
  }
  __name(modify, "modify");
  function overload(index, length, name, value, source) {
    let formats2 = {};
    if (typeof index.index === "number" && typeof index.length === "number") {
      if (typeof length !== "number") {
        source = value;
        value = name;
        name = length;
        length = index.length;
        index = index.index;
      } else {
        length = index.length;
        index = index.index;
      }
    } else if (typeof length !== "number") {
      source = value;
      value = name;
      name = length;
      length = 0;
    }
    if (typeof name === "object") {
      formats2 = name;
      source = value;
    } else if (typeof name === "string") {
      if (value != null) {
        formats2[name] = value;
      } else {
        source = name;
      }
    }
    source = source || emitter_default.sources.API;
    return [index, length, formats2, source];
  }
  __name(overload, "overload");
  function shiftRange2(range, index, lengthOrSource, source) {
    const length = typeof lengthOrSource === "number" ? lengthOrSource : 0;
    if (range == null)
      return null;
    let start2;
    let end;
    if (index && typeof index.transformPosition === "function") {
      [start2, end] = [range.index, range.index + range.length].map((pos) => (
        // @ts-expect-error -- TODO: add a better type guard around `index`
        index.transformPosition(pos, source !== emitter_default.sources.USER)
      ));
    } else {
      [start2, end] = [range.index, range.index + range.length].map((pos) => {
        if (pos < index || pos === index && source === emitter_default.sources.USER)
          return pos;
        if (length >= 0) {
          return pos + length;
        }
        return Math.max(index, pos + length);
      });
    }
    return new Range(start2, end - start2);
  }
  __name(shiftRange2, "shiftRange");

  // node_modules/quill/blots/container.js
  var Container = class extends ContainerBlot$1 {
    static {
      __name(this, "Container");
    }
  };
  var container_default = Container;

  // node_modules/quill/blots/scroll.js
  var import_quill_delta4 = __toESM(require_Delta(), 1);
  function isLine(blot) {
    return blot instanceof Block || blot instanceof BlockEmbed;
  }
  __name(isLine, "isLine");
  function isUpdatable(blot) {
    return typeof blot.updateContent === "function";
  }
  __name(isUpdatable, "isUpdatable");
  var Scroll = class extends ScrollBlot$1 {
    static {
      __name(this, "Scroll");
    }
    static blotName = "scroll";
    static className = "ql-editor";
    static tagName = "DIV";
    static defaultChild = Block;
    static allowedChildren = [Block, BlockEmbed, container_default];
    constructor(registry, domNode, _ref) {
      let {
        emitter
      } = _ref;
      super(registry, domNode);
      this.emitter = emitter;
      this.batch = false;
      this.optimize();
      this.enable();
      this.domNode.addEventListener("dragstart", (e2) => this.handleDragStart(e2));
    }
    batchStart() {
      if (!Array.isArray(this.batch)) {
        this.batch = [];
      }
    }
    batchEnd() {
      if (!this.batch)
        return;
      const mutations = this.batch;
      this.batch = false;
      this.update(mutations);
    }
    emitMount(blot) {
      this.emitter.emit(emitter_default.events.SCROLL_BLOT_MOUNT, blot);
    }
    emitUnmount(blot) {
      this.emitter.emit(emitter_default.events.SCROLL_BLOT_UNMOUNT, blot);
    }
    emitEmbedUpdate(blot, change) {
      this.emitter.emit(emitter_default.events.SCROLL_EMBED_UPDATE, blot, change);
    }
    deleteAt(index, length) {
      const [first, offset] = this.line(index);
      const [last] = this.line(index + length);
      super.deleteAt(index, length);
      if (last != null && first !== last && offset > 0) {
        if (first instanceof BlockEmbed || last instanceof BlockEmbed) {
          this.optimize();
          return;
        }
        const ref = last.children.head instanceof break_default ? null : last.children.head;
        first.moveChildren(last, ref);
        first.remove();
      }
      this.optimize();
    }
    enable() {
      let enabled = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
      this.domNode.setAttribute("contenteditable", enabled ? "true" : "false");
    }
    formatAt(index, length, format, value) {
      super.formatAt(index, length, format, value);
      this.optimize();
    }
    insertAt(index, value, def) {
      if (index >= this.length()) {
        if (def == null || this.scroll.query(value, Scope.BLOCK) == null) {
          const blot = this.scroll.create(this.statics.defaultChild.blotName);
          this.appendChild(blot);
          if (def == null && value.endsWith("\n")) {
            blot.insertAt(0, value.slice(0, -1), def);
          } else {
            blot.insertAt(0, value, def);
          }
        } else {
          const embed = this.scroll.create(value, def);
          this.appendChild(embed);
        }
      } else {
        super.insertAt(index, value, def);
      }
      this.optimize();
    }
    insertBefore(blot, ref) {
      if (blot.statics.scope === Scope.INLINE_BLOT) {
        const wrapper = this.scroll.create(this.statics.defaultChild.blotName);
        wrapper.appendChild(blot);
        super.insertBefore(wrapper, ref);
      } else {
        super.insertBefore(blot, ref);
      }
    }
    insertContents(index, delta) {
      const renderBlocks = this.deltaToRenderBlocks(delta.concat(new import_quill_delta4.default().insert("\n")));
      const last = renderBlocks.pop();
      if (last == null)
        return;
      this.batchStart();
      const first = renderBlocks.shift();
      if (first) {
        const shouldInsertNewlineChar = first.type === "block" && (first.delta.length() === 0 || !this.descendant(BlockEmbed, index)[0] && index < this.length());
        const delta2 = first.type === "block" ? first.delta : new import_quill_delta4.default().insert({
          [first.key]: first.value
        });
        insertInlineContents(this, index, delta2);
        const newlineCharLength = first.type === "block" ? 1 : 0;
        const lineEndIndex = index + delta2.length() + newlineCharLength;
        if (shouldInsertNewlineChar) {
          this.insertAt(lineEndIndex - 1, "\n");
        }
        const formats2 = bubbleFormats(this.line(index)[0]);
        const attributes = import_quill_delta4.AttributeMap.diff(formats2, first.attributes) || {};
        Object.keys(attributes).forEach((name) => {
          this.formatAt(lineEndIndex - 1, 1, name, attributes[name]);
        });
        index = lineEndIndex;
      }
      let [refBlot, refBlotOffset] = this.children.find(index);
      if (renderBlocks.length) {
        if (refBlot) {
          refBlot = refBlot.split(refBlotOffset);
          refBlotOffset = 0;
        }
        renderBlocks.forEach((renderBlock) => {
          if (renderBlock.type === "block") {
            const block = this.createBlock(renderBlock.attributes, refBlot || void 0);
            insertInlineContents(block, 0, renderBlock.delta);
          } else {
            const blockEmbed = this.create(renderBlock.key, renderBlock.value);
            this.insertBefore(blockEmbed, refBlot || void 0);
            Object.keys(renderBlock.attributes).forEach((name) => {
              blockEmbed.format(name, renderBlock.attributes[name]);
            });
          }
        });
      }
      if (last.type === "block" && last.delta.length()) {
        const offset = refBlot ? refBlot.offset(refBlot.scroll) + refBlotOffset : this.length();
        insertInlineContents(this, offset, last.delta);
      }
      this.batchEnd();
      this.optimize();
    }
    isEnabled() {
      return this.domNode.getAttribute("contenteditable") === "true";
    }
    leaf(index) {
      const last = this.path(index).pop();
      if (!last) {
        return [null, -1];
      }
      const [blot, offset] = last;
      return blot instanceof LeafBlot$1 ? [blot, offset] : [null, -1];
    }
    line(index) {
      if (index === this.length()) {
        return this.line(index - 1);
      }
      return this.descendant(isLine, index);
    }
    lines() {
      let index = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      let length = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Number.MAX_VALUE;
      const getLines = /* @__PURE__ */ __name((blot, blotIndex, blotLength) => {
        let lines = [];
        let lengthLeft = blotLength;
        blot.children.forEachAt(blotIndex, blotLength, (child, childIndex, childLength) => {
          if (isLine(child)) {
            lines.push(child);
          } else if (child instanceof ContainerBlot$1) {
            lines = lines.concat(getLines(child, childIndex, lengthLeft));
          }
          lengthLeft -= childLength;
        });
        return lines;
      }, "getLines");
      return getLines(this, index, length);
    }
    optimize() {
      let mutations = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      let context = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (this.batch)
        return;
      super.optimize(mutations, context);
      if (mutations.length > 0) {
        this.emitter.emit(emitter_default.events.SCROLL_OPTIMIZE, mutations, context);
      }
    }
    path(index) {
      return super.path(index).slice(1);
    }
    remove() {
    }
    update(mutations) {
      if (this.batch) {
        if (Array.isArray(mutations)) {
          this.batch = this.batch.concat(mutations);
        }
        return;
      }
      let source = emitter_default.sources.USER;
      if (typeof mutations === "string") {
        source = mutations;
      }
      if (!Array.isArray(mutations)) {
        mutations = this.observer.takeRecords();
      }
      mutations = mutations.filter((_ref2) => {
        let {
          target
        } = _ref2;
        const blot = this.find(target, true);
        return blot && !isUpdatable(blot);
      });
      if (mutations.length > 0) {
        this.emitter.emit(emitter_default.events.SCROLL_BEFORE_UPDATE, source, mutations);
      }
      super.update(mutations.concat([]));
      if (mutations.length > 0) {
        this.emitter.emit(emitter_default.events.SCROLL_UPDATE, source, mutations);
      }
    }
    updateEmbedAt(index, key, change) {
      const [blot] = this.descendant((b2) => b2 instanceof BlockEmbed, index);
      if (blot && blot.statics.blotName === key && isUpdatable(blot)) {
        blot.updateContent(change);
      }
    }
    handleDragStart(event) {
      event.preventDefault();
    }
    deltaToRenderBlocks(delta) {
      const renderBlocks = [];
      let currentBlockDelta = new import_quill_delta4.default();
      delta.forEach((op) => {
        const insert = op?.insert;
        if (!insert)
          return;
        if (typeof insert === "string") {
          const splitted = insert.split("\n");
          splitted.slice(0, -1).forEach((text) => {
            currentBlockDelta.insert(text, op.attributes);
            renderBlocks.push({
              type: "block",
              delta: currentBlockDelta,
              attributes: op.attributes ?? {}
            });
            currentBlockDelta = new import_quill_delta4.default();
          });
          const last = splitted[splitted.length - 1];
          if (last) {
            currentBlockDelta.insert(last, op.attributes);
          }
        } else {
          const key = Object.keys(insert)[0];
          if (!key)
            return;
          if (this.query(key, Scope.INLINE)) {
            currentBlockDelta.push(op);
          } else {
            if (currentBlockDelta.length()) {
              renderBlocks.push({
                type: "block",
                delta: currentBlockDelta,
                attributes: {}
              });
            }
            currentBlockDelta = new import_quill_delta4.default();
            renderBlocks.push({
              type: "blockEmbed",
              key,
              value: insert[key],
              attributes: op.attributes ?? {}
            });
          }
        }
      });
      if (currentBlockDelta.length()) {
        renderBlocks.push({
          type: "block",
          delta: currentBlockDelta,
          attributes: {}
        });
      }
      return renderBlocks;
    }
    createBlock(attributes, refBlot) {
      let blotName;
      const formats2 = {};
      Object.entries(attributes).forEach((_ref3) => {
        let [key, value] = _ref3;
        const isBlockBlot = this.query(key, Scope.BLOCK & Scope.BLOT) != null;
        if (isBlockBlot) {
          blotName = key;
        } else {
          formats2[key] = value;
        }
      });
      const block = this.create(blotName || this.statics.defaultChild.blotName, blotName ? attributes[blotName] : void 0);
      this.insertBefore(block, refBlot || void 0);
      const length = block.length();
      Object.entries(formats2).forEach((_ref4) => {
        let [key, value] = _ref4;
        block.formatAt(0, length, key, value);
      });
      return block;
    }
  };
  function insertInlineContents(parent, index, inlineContents) {
    inlineContents.reduce((index2, op) => {
      const length = import_quill_delta4.Op.length(op);
      let attributes = op.attributes || {};
      if (op.insert != null) {
        if (typeof op.insert === "string") {
          const text = op.insert;
          parent.insertAt(index2, text);
          const [leaf] = parent.descendant(LeafBlot$1, index2);
          const formats2 = bubbleFormats(leaf);
          attributes = import_quill_delta4.AttributeMap.diff(formats2, attributes) || {};
        } else if (typeof op.insert === "object") {
          const key = Object.keys(op.insert)[0];
          if (key == null)
            return index2;
          parent.insertAt(index2, key, op.insert[key]);
          const isInlineEmbed = parent.scroll.query(key, Scope.INLINE) != null;
          if (isInlineEmbed) {
            const [leaf] = parent.descendant(LeafBlot$1, index2);
            const formats2 = bubbleFormats(leaf);
            attributes = import_quill_delta4.AttributeMap.diff(formats2, attributes) || {};
          }
        }
      }
      Object.keys(attributes).forEach((key) => {
        parent.formatAt(index2, length, key, attributes[key]);
      });
      return index2 + length;
    }, index);
  }
  __name(insertInlineContents, "insertInlineContents");
  var scroll_default = Scroll;

  // node_modules/quill/modules/clipboard.js
  var import_quill_delta6 = __toESM(require_Delta(), 1);

  // node_modules/quill/formats/align.js
  var config = {
    scope: Scope.BLOCK,
    whitelist: ["right", "center", "justify"]
  };
  var AlignAttribute = new Attributor("align", "align", config);
  var AlignClass = new ClassAttributor$1("align", "ql-align", config);
  var AlignStyle = new StyleAttributor$1("align", "text-align", config);

  // node_modules/quill/formats/color.js
  var ColorAttributor = class extends StyleAttributor$1 {
    static {
      __name(this, "ColorAttributor");
    }
    value(domNode) {
      let value = super.value(domNode);
      if (!value.startsWith("rgb("))
        return value;
      value = value.replace(/^[^\d]+/, "").replace(/[^\d]+$/, "");
      const hex = value.split(",").map((component) => `00${parseInt(component, 10).toString(16)}`.slice(-2)).join("");
      return `#${hex}`;
    }
  };
  var ColorClass = new ClassAttributor$1("color", "ql-color", {
    scope: Scope.INLINE
  });
  var ColorStyle = new ColorAttributor("color", "color", {
    scope: Scope.INLINE
  });

  // node_modules/quill/formats/background.js
  var BackgroundClass = new ClassAttributor$1("background", "ql-bg", {
    scope: Scope.INLINE
  });
  var BackgroundStyle = new ColorAttributor("background", "background-color", {
    scope: Scope.INLINE
  });

  // node_modules/quill/formats/code.js
  var CodeBlockContainer = class extends container_default {
    static {
      __name(this, "CodeBlockContainer");
    }
    static create(value) {
      const domNode = super.create(value);
      domNode.setAttribute("spellcheck", "false");
      return domNode;
    }
    code(index, length) {
      return this.children.map((child) => child.length() <= 1 ? "" : child.domNode.innerText).join("\n").slice(index, index + length);
    }
    html(index, length) {
      return `<pre>
${escapeText(this.code(index, length))}
</pre>`;
    }
  };
  var CodeBlock = class extends Block {
    static {
      __name(this, "CodeBlock");
    }
    static TAB = "  ";
    static register() {
      Quill.register(CodeBlockContainer);
    }
  };
  var Code = class extends inline_default {
    static {
      __name(this, "Code");
    }
  };
  Code.blotName = "code";
  Code.tagName = "CODE";
  CodeBlock.blotName = "code-block";
  CodeBlock.className = "ql-code-block";
  CodeBlock.tagName = "DIV";
  CodeBlockContainer.blotName = "code-block-container";
  CodeBlockContainer.className = "ql-code-block-container";
  CodeBlockContainer.tagName = "DIV";
  CodeBlockContainer.allowedChildren = [CodeBlock];
  CodeBlock.allowedChildren = [Text2, break_default, cursor_default];
  CodeBlock.requiredContainer = CodeBlockContainer;

  // node_modules/quill/formats/direction.js
  var config2 = {
    scope: Scope.BLOCK,
    whitelist: ["rtl"]
  };
  var DirectionAttribute = new Attributor("direction", "dir", config2);
  var DirectionClass = new ClassAttributor$1("direction", "ql-direction", config2);
  var DirectionStyle = new StyleAttributor$1("direction", "direction", config2);

  // node_modules/quill/formats/font.js
  var config3 = {
    scope: Scope.INLINE,
    whitelist: ["serif", "monospace"]
  };
  var FontClass = new ClassAttributor$1("font", "ql-font", config3);
  var FontStyleAttributor = class extends StyleAttributor$1 {
    static {
      __name(this, "FontStyleAttributor");
    }
    value(node) {
      return super.value(node).replace(/["']/g, "");
    }
  };
  var FontStyle = new FontStyleAttributor("font", "font-family", config3);

  // node_modules/quill/formats/size.js
  var SizeClass = new ClassAttributor$1("size", "ql-size", {
    scope: Scope.INLINE,
    whitelist: ["small", "large", "huge"]
  });
  var SizeStyle = new StyleAttributor$1("size", "font-size", {
    scope: Scope.INLINE,
    whitelist: ["10px", "18px", "32px"]
  });

  // node_modules/quill/modules/keyboard.js
  var import_quill_delta5 = __toESM(require_Delta(), 1);
  var debug5 = logger_default2("quill:keyboard");
  var SHORTKEY = /Mac/i.test(navigator.platform) ? "metaKey" : "ctrlKey";
  var Keyboard = class _Keyboard extends module_default {
    static {
      __name(this, "Keyboard");
    }
    static match(evt, binding) {
      if (["altKey", "ctrlKey", "metaKey", "shiftKey"].some((key) => {
        return !!binding[key] !== evt[key] && binding[key] !== null;
      })) {
        return false;
      }
      return binding.key === evt.key || binding.key === evt.which;
    }
    constructor(quill, options) {
      super(quill, options);
      this.bindings = {};
      Object.keys(this.options.bindings).forEach((name) => {
        if (this.options.bindings[name]) {
          this.addBinding(this.options.bindings[name]);
        }
      });
      this.addBinding({
        key: "Enter",
        shiftKey: null
      }, this.handleEnter);
      this.addBinding({
        key: "Enter",
        metaKey: null,
        ctrlKey: null,
        altKey: null
      }, () => {
      });
      if (/Firefox/i.test(navigator.userAgent)) {
        this.addBinding({
          key: "Backspace"
        }, {
          collapsed: true
        }, this.handleBackspace);
        this.addBinding({
          key: "Delete"
        }, {
          collapsed: true
        }, this.handleDelete);
      } else {
        this.addBinding({
          key: "Backspace"
        }, {
          collapsed: true,
          prefix: /^.?$/
        }, this.handleBackspace);
        this.addBinding({
          key: "Delete"
        }, {
          collapsed: true,
          suffix: /^.?$/
        }, this.handleDelete);
      }
      this.addBinding({
        key: "Backspace"
      }, {
        collapsed: false
      }, this.handleDeleteRange);
      this.addBinding({
        key: "Delete"
      }, {
        collapsed: false
      }, this.handleDeleteRange);
      this.addBinding({
        key: "Backspace",
        altKey: null,
        ctrlKey: null,
        metaKey: null,
        shiftKey: null
      }, {
        collapsed: true,
        offset: 0
      }, this.handleBackspace);
      this.listen();
    }
    addBinding(keyBinding) {
      let context = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      let handler = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      const binding = normalize(keyBinding);
      if (binding == null) {
        debug5.warn("Attempted to add invalid keyboard binding", binding);
        return;
      }
      if (typeof context === "function") {
        context = {
          handler: context
        };
      }
      if (typeof handler === "function") {
        handler = {
          handler
        };
      }
      const keys2 = Array.isArray(binding.key) ? binding.key : [binding.key];
      keys2.forEach((key) => {
        const singleBinding = {
          ...binding,
          key,
          ...context,
          ...handler
        };
        this.bindings[singleBinding.key] = this.bindings[singleBinding.key] || [];
        this.bindings[singleBinding.key].push(singleBinding);
      });
    }
    listen() {
      this.quill.root.addEventListener("keydown", (evt) => {
        if (evt.defaultPrevented || evt.isComposing)
          return;
        const bindings = (this.bindings[evt.key] || []).concat(this.bindings[evt.which] || []);
        const matches = bindings.filter((binding) => _Keyboard.match(evt, binding));
        if (matches.length === 0)
          return;
        const blot = Quill.find(evt.target, true);
        if (blot && blot.scroll !== this.quill.scroll)
          return;
        const range = this.quill.getSelection();
        if (range == null || !this.quill.hasFocus())
          return;
        const [line, offset] = this.quill.getLine(range.index);
        const [leafStart, offsetStart] = this.quill.getLeaf(range.index);
        const [leafEnd, offsetEnd] = range.length === 0 ? [leafStart, offsetStart] : this.quill.getLeaf(range.index + range.length);
        const prefixText = leafStart instanceof TextBlot$1 ? leafStart.value().slice(0, offsetStart) : "";
        const suffixText = leafEnd instanceof TextBlot$1 ? leafEnd.value().slice(offsetEnd) : "";
        const curContext = {
          collapsed: range.length === 0,
          // @ts-expect-error Fix me later
          empty: range.length === 0 && line.length() <= 1,
          format: this.quill.getFormat(range),
          line,
          offset,
          prefix: prefixText,
          suffix: suffixText,
          event: evt
        };
        const prevented = matches.some((binding) => {
          if (binding.collapsed != null && binding.collapsed !== curContext.collapsed) {
            return false;
          }
          if (binding.empty != null && binding.empty !== curContext.empty) {
            return false;
          }
          if (binding.offset != null && binding.offset !== curContext.offset) {
            return false;
          }
          if (Array.isArray(binding.format)) {
            if (binding.format.every((name) => curContext.format[name] == null)) {
              return false;
            }
          } else if (typeof binding.format === "object") {
            if (!Object.keys(binding.format).every((name) => {
              if (binding.format[name] === true)
                return curContext.format[name] != null;
              if (binding.format[name] === false)
                return curContext.format[name] == null;
              return isEqual_default(binding.format[name], curContext.format[name]);
            })) {
              return false;
            }
          }
          if (binding.prefix != null && !binding.prefix.test(curContext.prefix)) {
            return false;
          }
          if (binding.suffix != null && !binding.suffix.test(curContext.suffix)) {
            return false;
          }
          return binding.handler.call(this, range, curContext, binding) !== true;
        });
        if (prevented) {
          evt.preventDefault();
        }
      });
    }
    handleBackspace(range, context) {
      const length = /[\uD800-\uDBFF][\uDC00-\uDFFF]$/.test(context.prefix) ? 2 : 1;
      if (range.index === 0 || this.quill.getLength() <= 1)
        return;
      let formats2 = {};
      const [line] = this.quill.getLine(range.index);
      let delta = new import_quill_delta5.default().retain(range.index - length).delete(length);
      if (context.offset === 0) {
        const [prev] = this.quill.getLine(range.index - 1);
        if (prev) {
          const isPrevLineEmpty = prev.statics.blotName === "block" && prev.length() <= 1;
          if (!isPrevLineEmpty) {
            const curFormats = line.formats();
            const prevFormats = this.quill.getFormat(range.index - 1, 1);
            formats2 = import_quill_delta5.AttributeMap.diff(curFormats, prevFormats) || {};
            if (Object.keys(formats2).length > 0) {
              const formatDelta = new import_quill_delta5.default().retain(range.index + line.length() - 2).retain(1, formats2);
              delta = delta.compose(formatDelta);
            }
          }
        }
      }
      this.quill.updateContents(delta, Quill.sources.USER);
      this.quill.focus();
    }
    handleDelete(range, context) {
      const length = /^[\uD800-\uDBFF][\uDC00-\uDFFF]/.test(context.suffix) ? 2 : 1;
      if (range.index >= this.quill.getLength() - length)
        return;
      let formats2 = {};
      const [line] = this.quill.getLine(range.index);
      let delta = new import_quill_delta5.default().retain(range.index).delete(length);
      if (context.offset >= line.length() - 1) {
        const [next] = this.quill.getLine(range.index + 1);
        if (next) {
          const curFormats = line.formats();
          const nextFormats = this.quill.getFormat(range.index, 1);
          formats2 = import_quill_delta5.AttributeMap.diff(curFormats, nextFormats) || {};
          if (Object.keys(formats2).length > 0) {
            delta = delta.retain(next.length() - 1).retain(1, formats2);
          }
        }
      }
      this.quill.updateContents(delta, Quill.sources.USER);
      this.quill.focus();
    }
    handleDeleteRange(range) {
      deleteRange({
        range,
        quill: this.quill
      });
      this.quill.focus();
    }
    handleEnter(range, context) {
      const lineFormats = Object.keys(context.format).reduce((formats2, format) => {
        if (this.quill.scroll.query(format, Scope.BLOCK) && !Array.isArray(context.format[format])) {
          formats2[format] = context.format[format];
        }
        return formats2;
      }, {});
      const delta = new import_quill_delta5.default().retain(range.index).delete(range.length).insert("\n", lineFormats);
      this.quill.updateContents(delta, Quill.sources.USER);
      this.quill.setSelection(range.index + 1, Quill.sources.SILENT);
      this.quill.focus();
    }
  };
  var defaultOptions2 = {
    bindings: {
      bold: makeFormatHandler("bold"),
      italic: makeFormatHandler("italic"),
      underline: makeFormatHandler("underline"),
      indent: {
        // highlight tab or tab at beginning of list, indent or blockquote
        key: "Tab",
        format: ["blockquote", "indent", "list"],
        handler(range, context) {
          if (context.collapsed && context.offset !== 0)
            return true;
          this.quill.format("indent", "+1", Quill.sources.USER);
          return false;
        }
      },
      outdent: {
        key: "Tab",
        shiftKey: true,
        format: ["blockquote", "indent", "list"],
        // highlight tab or tab at beginning of list, indent or blockquote
        handler(range, context) {
          if (context.collapsed && context.offset !== 0)
            return true;
          this.quill.format("indent", "-1", Quill.sources.USER);
          return false;
        }
      },
      "outdent backspace": {
        key: "Backspace",
        collapsed: true,
        shiftKey: null,
        metaKey: null,
        ctrlKey: null,
        altKey: null,
        format: ["indent", "list"],
        offset: 0,
        handler(range, context) {
          if (context.format.indent != null) {
            this.quill.format("indent", "-1", Quill.sources.USER);
          } else if (context.format.list != null) {
            this.quill.format("list", false, Quill.sources.USER);
          }
        }
      },
      "indent code-block": makeCodeBlockHandler(true),
      "outdent code-block": makeCodeBlockHandler(false),
      "remove tab": {
        key: "Tab",
        shiftKey: true,
        collapsed: true,
        prefix: /\t$/,
        handler(range) {
          this.quill.deleteText(range.index - 1, 1, Quill.sources.USER);
        }
      },
      tab: {
        key: "Tab",
        handler(range, context) {
          if (context.format.table)
            return true;
          this.quill.history.cutoff();
          const delta = new import_quill_delta5.default().retain(range.index).delete(range.length).insert("	");
          this.quill.updateContents(delta, Quill.sources.USER);
          this.quill.history.cutoff();
          this.quill.setSelection(range.index + 1, Quill.sources.SILENT);
          return false;
        }
      },
      "blockquote empty enter": {
        key: "Enter",
        collapsed: true,
        format: ["blockquote"],
        empty: true,
        handler() {
          this.quill.format("blockquote", false, Quill.sources.USER);
        }
      },
      "list empty enter": {
        key: "Enter",
        collapsed: true,
        format: ["list"],
        empty: true,
        handler(range, context) {
          const formats2 = {
            list: false
          };
          if (context.format.indent) {
            formats2.indent = false;
          }
          this.quill.formatLine(range.index, range.length, formats2, Quill.sources.USER);
        }
      },
      "checklist enter": {
        key: "Enter",
        collapsed: true,
        format: {
          list: "checked"
        },
        handler(range) {
          const [line, offset] = this.quill.getLine(range.index);
          const formats2 = {
            // @ts-expect-error Fix me later
            ...line.formats(),
            list: "checked"
          };
          const delta = new import_quill_delta5.default().retain(range.index).insert("\n", formats2).retain(line.length() - offset - 1).retain(1, {
            list: "unchecked"
          });
          this.quill.updateContents(delta, Quill.sources.USER);
          this.quill.setSelection(range.index + 1, Quill.sources.SILENT);
          this.quill.scrollSelectionIntoView();
        }
      },
      "header enter": {
        key: "Enter",
        collapsed: true,
        format: ["header"],
        suffix: /^$/,
        handler(range, context) {
          const [line, offset] = this.quill.getLine(range.index);
          const delta = new import_quill_delta5.default().retain(range.index).insert("\n", context.format).retain(line.length() - offset - 1).retain(1, {
            header: null
          });
          this.quill.updateContents(delta, Quill.sources.USER);
          this.quill.setSelection(range.index + 1, Quill.sources.SILENT);
          this.quill.scrollSelectionIntoView();
        }
      },
      "table backspace": {
        key: "Backspace",
        format: ["table"],
        collapsed: true,
        offset: 0,
        handler() {
        }
      },
      "table delete": {
        key: "Delete",
        format: ["table"],
        collapsed: true,
        suffix: /^$/,
        handler() {
        }
      },
      "table enter": {
        key: "Enter",
        shiftKey: null,
        format: ["table"],
        handler(range) {
          const module2 = this.quill.getModule("table");
          if (module2) {
            const [table, row, cell, offset] = module2.getTable(range);
            const shift = tableSide(table, row, cell, offset);
            if (shift == null)
              return;
            let index = table.offset();
            if (shift < 0) {
              const delta = new import_quill_delta5.default().retain(index).insert("\n");
              this.quill.updateContents(delta, Quill.sources.USER);
              this.quill.setSelection(range.index + 1, range.length, Quill.sources.SILENT);
            } else if (shift > 0) {
              index += table.length();
              const delta = new import_quill_delta5.default().retain(index).insert("\n");
              this.quill.updateContents(delta, Quill.sources.USER);
              this.quill.setSelection(index, Quill.sources.USER);
            }
          }
        }
      },
      "table tab": {
        key: "Tab",
        shiftKey: null,
        format: ["table"],
        handler(range, context) {
          const {
            event,
            line: cell
          } = context;
          const offset = cell.offset(this.quill.scroll);
          if (event.shiftKey) {
            this.quill.setSelection(offset - 1, Quill.sources.USER);
          } else {
            this.quill.setSelection(offset + cell.length(), Quill.sources.USER);
          }
        }
      },
      "list autofill": {
        key: " ",
        shiftKey: null,
        collapsed: true,
        format: {
          "code-block": false,
          blockquote: false,
          table: false
        },
        prefix: /^\s*?(\d+\.|-|\*|\[ ?\]|\[x\])$/,
        handler(range, context) {
          if (this.quill.scroll.query("list") == null)
            return true;
          const {
            length
          } = context.prefix;
          const [line, offset] = this.quill.getLine(range.index);
          if (offset > length)
            return true;
          let value;
          switch (context.prefix.trim()) {
            case "[]":
            case "[ ]":
              value = "unchecked";
              break;
            case "[x]":
              value = "checked";
              break;
            case "-":
            case "*":
              value = "bullet";
              break;
            default:
              value = "ordered";
          }
          this.quill.insertText(range.index, " ", Quill.sources.USER);
          this.quill.history.cutoff();
          const delta = new import_quill_delta5.default().retain(range.index - offset).delete(length + 1).retain(line.length() - 2 - offset).retain(1, {
            list: value
          });
          this.quill.updateContents(delta, Quill.sources.USER);
          this.quill.history.cutoff();
          this.quill.setSelection(range.index - length, Quill.sources.SILENT);
          return false;
        }
      },
      "code exit": {
        key: "Enter",
        collapsed: true,
        format: ["code-block"],
        prefix: /^$/,
        suffix: /^\s*$/,
        handler(range) {
          const [line, offset] = this.quill.getLine(range.index);
          let numLines = 2;
          let cur = line;
          while (cur != null && cur.length() <= 1 && cur.formats()["code-block"]) {
            cur = cur.prev;
            numLines -= 1;
            if (numLines <= 0) {
              const delta = new import_quill_delta5.default().retain(range.index + line.length() - offset - 2).retain(1, {
                "code-block": null
              }).delete(1);
              this.quill.updateContents(delta, Quill.sources.USER);
              this.quill.setSelection(range.index - 1, Quill.sources.SILENT);
              return false;
            }
          }
          return true;
        }
      },
      "embed left": makeEmbedArrowHandler("ArrowLeft", false),
      "embed left shift": makeEmbedArrowHandler("ArrowLeft", true),
      "embed right": makeEmbedArrowHandler("ArrowRight", false),
      "embed right shift": makeEmbedArrowHandler("ArrowRight", true),
      "table down": makeTableArrowHandler(false),
      "table up": makeTableArrowHandler(true)
    }
  };
  Keyboard.DEFAULTS = defaultOptions2;
  function makeCodeBlockHandler(indent) {
    return {
      key: "Tab",
      shiftKey: !indent,
      format: {
        "code-block": true
      },
      handler(range, _ref) {
        let {
          event
        } = _ref;
        const CodeBlock2 = this.quill.scroll.query("code-block");
        const {
          TAB
        } = CodeBlock2;
        if (range.length === 0 && !event.shiftKey) {
          this.quill.insertText(range.index, TAB, Quill.sources.USER);
          this.quill.setSelection(range.index + TAB.length, Quill.sources.SILENT);
          return;
        }
        const lines = range.length === 0 ? this.quill.getLines(range.index, 1) : this.quill.getLines(range);
        let {
          index,
          length
        } = range;
        lines.forEach((line, i2) => {
          if (indent) {
            line.insertAt(0, TAB);
            if (i2 === 0) {
              index += TAB.length;
            } else {
              length += TAB.length;
            }
          } else if (line.domNode.textContent.startsWith(TAB)) {
            line.deleteAt(0, TAB.length);
            if (i2 === 0) {
              index -= TAB.length;
            } else {
              length -= TAB.length;
            }
          }
        });
        this.quill.update(Quill.sources.USER);
        this.quill.setSelection(index, length, Quill.sources.SILENT);
      }
    };
  }
  __name(makeCodeBlockHandler, "makeCodeBlockHandler");
  function makeEmbedArrowHandler(key, shiftKey) {
    const where = key === "ArrowLeft" ? "prefix" : "suffix";
    return {
      key,
      shiftKey,
      altKey: null,
      [where]: /^$/,
      handler(range) {
        let {
          index
        } = range;
        if (key === "ArrowRight") {
          index += range.length + 1;
        }
        const [leaf] = this.quill.getLeaf(index);
        if (!(leaf instanceof EmbedBlot$1))
          return true;
        if (key === "ArrowLeft") {
          if (shiftKey) {
            this.quill.setSelection(range.index - 1, range.length + 1, Quill.sources.USER);
          } else {
            this.quill.setSelection(range.index - 1, Quill.sources.USER);
          }
        } else if (shiftKey) {
          this.quill.setSelection(range.index, range.length + 1, Quill.sources.USER);
        } else {
          this.quill.setSelection(range.index + range.length + 1, Quill.sources.USER);
        }
        return false;
      }
    };
  }
  __name(makeEmbedArrowHandler, "makeEmbedArrowHandler");
  function makeFormatHandler(format) {
    return {
      key: format[0],
      shortKey: true,
      handler(range, context) {
        this.quill.format(format, !context.format[format], Quill.sources.USER);
      }
    };
  }
  __name(makeFormatHandler, "makeFormatHandler");
  function makeTableArrowHandler(up) {
    return {
      key: up ? "ArrowUp" : "ArrowDown",
      collapsed: true,
      format: ["table"],
      handler(range, context) {
        const key = up ? "prev" : "next";
        const cell = context.line;
        const targetRow = cell.parent[key];
        if (targetRow != null) {
          if (targetRow.statics.blotName === "table-row") {
            let targetCell = targetRow.children.head;
            let cur = cell;
            while (cur.prev != null) {
              cur = cur.prev;
              targetCell = targetCell.next;
            }
            const index = targetCell.offset(this.quill.scroll) + Math.min(context.offset, targetCell.length() - 1);
            this.quill.setSelection(index, 0, Quill.sources.USER);
          }
        } else {
          const targetLine = cell.table()[key];
          if (targetLine != null) {
            if (up) {
              this.quill.setSelection(targetLine.offset(this.quill.scroll) + targetLine.length() - 1, 0, Quill.sources.USER);
            } else {
              this.quill.setSelection(targetLine.offset(this.quill.scroll), 0, Quill.sources.USER);
            }
          }
        }
        return false;
      }
    };
  }
  __name(makeTableArrowHandler, "makeTableArrowHandler");
  function normalize(binding) {
    if (typeof binding === "string" || typeof binding === "number") {
      binding = {
        key: binding
      };
    } else if (typeof binding === "object") {
      binding = cloneDeep_default(binding);
    } else {
      return null;
    }
    if (binding.shortKey) {
      binding[SHORTKEY] = binding.shortKey;
      delete binding.shortKey;
    }
    return binding;
  }
  __name(normalize, "normalize");
  function deleteRange(_ref2) {
    let {
      quill,
      range
    } = _ref2;
    const lines = quill.getLines(range);
    let formats2 = {};
    if (lines.length > 1) {
      const firstFormats = lines[0].formats();
      const lastFormats = lines[lines.length - 1].formats();
      formats2 = import_quill_delta5.AttributeMap.diff(lastFormats, firstFormats) || {};
    }
    quill.deleteText(range, Quill.sources.USER);
    if (Object.keys(formats2).length > 0) {
      quill.formatLine(range.index, 1, formats2, Quill.sources.USER);
    }
    quill.setSelection(range.index, Quill.sources.SILENT);
  }
  __name(deleteRange, "deleteRange");
  function tableSide(_table, row, cell, offset) {
    if (row.prev == null && row.next == null) {
      if (cell.prev == null && cell.next == null) {
        return offset === 0 ? -1 : 1;
      }
      return cell.prev == null ? -1 : 1;
    }
    if (row.prev == null) {
      return -1;
    }
    if (row.next == null) {
      return 1;
    }
    return null;
  }
  __name(tableSide, "tableSide");

  // node_modules/quill/modules/normalizeExternalHTML/normalizers/googleDocs.js
  var normalWeightRegexp = /font-weight:\s*normal/;
  var blockTagNames = ["P", "OL", "UL"];
  var isBlockElement = /* @__PURE__ */ __name((element) => {
    return element && blockTagNames.includes(element.tagName);
  }, "isBlockElement");
  var normalizeEmptyLines = /* @__PURE__ */ __name((doc) => {
    Array.from(doc.querySelectorAll("br")).filter((br) => isBlockElement(br.previousElementSibling) && isBlockElement(br.nextElementSibling)).forEach((br) => {
      br.parentNode?.removeChild(br);
    });
  }, "normalizeEmptyLines");
  var normalizeFontWeight = /* @__PURE__ */ __name((doc) => {
    Array.from(doc.querySelectorAll('b[style*="font-weight"]')).filter((node) => node.getAttribute("style")?.match(normalWeightRegexp)).forEach((node) => {
      const fragment = doc.createDocumentFragment();
      fragment.append(...node.childNodes);
      node.parentNode?.replaceChild(fragment, node);
    });
  }, "normalizeFontWeight");
  function normalize2(doc) {
    if (doc.querySelector('[id^="docs-internal-guid-"]')) {
      normalizeFontWeight(doc);
      normalizeEmptyLines(doc);
    }
  }
  __name(normalize2, "normalize");

  // node_modules/quill/modules/normalizeExternalHTML/normalizers/msWord.js
  var ignoreRegexp = /\bmso-list:[^;]*ignore/i;
  var idRegexp = /\bmso-list:[^;]*\bl(\d+)/i;
  var indentRegexp = /\bmso-list:[^;]*\blevel(\d+)/i;
  var parseListItem = /* @__PURE__ */ __name((element, html) => {
    const style = element.getAttribute("style");
    const idMatch = style?.match(idRegexp);
    if (!idMatch) {
      return null;
    }
    const id = Number(idMatch[1]);
    const indentMatch = style?.match(indentRegexp);
    const indent = indentMatch ? Number(indentMatch[1]) : 1;
    const typeRegexp = new RegExp(`@list l${id}:level${indent}\\s*\\{[^\\}]*mso-level-number-format:\\s*([\\w-]+)`, "i");
    const typeMatch = html.match(typeRegexp);
    const type = typeMatch && typeMatch[1] === "bullet" ? "bullet" : "ordered";
    return {
      id,
      indent,
      type,
      element
    };
  }, "parseListItem");
  var normalizeListItem = /* @__PURE__ */ __name((doc) => {
    const msoList = Array.from(doc.querySelectorAll("[style*=mso-list]"));
    const ignored = [];
    const others = [];
    msoList.forEach((node) => {
      const shouldIgnore = (node.getAttribute("style") || "").match(ignoreRegexp);
      if (shouldIgnore) {
        ignored.push(node);
      } else {
        others.push(node);
      }
    });
    ignored.forEach((node) => node.parentNode?.removeChild(node));
    const html = doc.documentElement.innerHTML;
    const listItems = others.map((element) => parseListItem(element, html)).filter((parsed) => parsed);
    while (listItems.length) {
      const childListItems = [];
      let current = listItems.shift();
      while (current) {
        childListItems.push(current);
        current = listItems.length && listItems[0]?.element === current.element.nextElementSibling && // Different id means the next item doesn't belong to this group.
        listItems[0].id === current.id ? listItems.shift() : null;
      }
      const ul = document.createElement("ul");
      childListItems.forEach((listItem) => {
        const li = document.createElement("li");
        li.setAttribute("data-list", listItem.type);
        if (listItem.indent > 1) {
          li.setAttribute("class", `ql-indent-${listItem.indent - 1}`);
        }
        li.innerHTML = listItem.element.innerHTML;
        ul.appendChild(li);
      });
      const element = childListItems[0]?.element;
      const {
        parentNode
      } = element ?? {};
      if (element) {
        parentNode?.replaceChild(ul, element);
      }
      childListItems.slice(1).forEach((_ref) => {
        let {
          element: e2
        } = _ref;
        parentNode?.removeChild(e2);
      });
    }
  }, "normalizeListItem");
  function normalize3(doc) {
    if (doc.documentElement.getAttribute("xmlns:w") === "urn:schemas-microsoft-com:office:word") {
      normalizeListItem(doc);
    }
  }
  __name(normalize3, "normalize");

  // node_modules/quill/modules/normalizeExternalHTML/index.js
  var NORMALIZERS = [normalize3, normalize2];
  var normalizeExternalHTML = /* @__PURE__ */ __name((doc) => {
    if (doc.documentElement) {
      NORMALIZERS.forEach((normalize4) => {
        normalize4(doc);
      });
    }
  }, "normalizeExternalHTML");
  var normalizeExternalHTML_default = normalizeExternalHTML;

  // node_modules/quill/modules/clipboard.js
  var debug6 = logger_default2("quill:clipboard");
  var CLIPBOARD_CONFIG = [[Node.TEXT_NODE, matchText], [Node.TEXT_NODE, matchNewline], ["br", matchBreak], [Node.ELEMENT_NODE, matchNewline], [Node.ELEMENT_NODE, matchBlot], [Node.ELEMENT_NODE, matchAttributor], [Node.ELEMENT_NODE, matchStyles], ["li", matchIndent], ["ol, ul", matchList], ["pre", matchCodeBlock], ["tr", matchTable], ["b", createMatchAlias("bold")], ["i", createMatchAlias("italic")], ["strike", createMatchAlias("strike")], ["style", matchIgnore]];
  var ATTRIBUTE_ATTRIBUTORS = [AlignAttribute, DirectionAttribute].reduce((memo, attr) => {
    memo[attr.keyName] = attr;
    return memo;
  }, {});
  var STYLE_ATTRIBUTORS = [AlignStyle, BackgroundStyle, ColorStyle, DirectionStyle, FontStyle, SizeStyle].reduce((memo, attr) => {
    memo[attr.keyName] = attr;
    return memo;
  }, {});
  var Clipboard = class extends module_default {
    static {
      __name(this, "Clipboard");
    }
    static DEFAULTS = {
      matchers: []
    };
    constructor(quill, options) {
      super(quill, options);
      this.quill.root.addEventListener("copy", (e2) => this.onCaptureCopy(e2, false));
      this.quill.root.addEventListener("cut", (e2) => this.onCaptureCopy(e2, true));
      this.quill.root.addEventListener("paste", this.onCapturePaste.bind(this));
      this.matchers = [];
      CLIPBOARD_CONFIG.concat(this.options.matchers ?? []).forEach((_ref) => {
        let [selector, matcher] = _ref;
        this.addMatcher(selector, matcher);
      });
    }
    addMatcher(selector, matcher) {
      this.matchers.push([selector, matcher]);
    }
    convert(_ref2) {
      let {
        html,
        text
      } = _ref2;
      let formats2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (formats2[CodeBlock.blotName]) {
        return new import_quill_delta6.default().insert(text || "", {
          [CodeBlock.blotName]: formats2[CodeBlock.blotName]
        });
      }
      if (!html) {
        return new import_quill_delta6.default().insert(text || "", formats2);
      }
      const delta = this.convertHTML(html);
      if (deltaEndsWith(delta, "\n") && (delta.ops[delta.ops.length - 1].attributes == null || formats2.table)) {
        return delta.compose(new import_quill_delta6.default().retain(delta.length() - 1).delete(1));
      }
      return delta;
    }
    normalizeHTML(doc) {
      normalizeExternalHTML_default(doc);
    }
    convertHTML(html) {
      const doc = new DOMParser().parseFromString(html, "text/html");
      this.normalizeHTML(doc);
      const container = doc.body;
      const nodeMatches = /* @__PURE__ */ new WeakMap();
      const [elementMatchers, textMatchers] = this.prepareMatching(container, nodeMatches);
      return traverse(this.quill.scroll, container, elementMatchers, textMatchers, nodeMatches);
    }
    dangerouslyPasteHTML(index, html) {
      let source = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Quill.sources.API;
      if (typeof index === "string") {
        const delta = this.convert({
          html: index,
          text: ""
        });
        this.quill.setContents(delta, html);
        this.quill.setSelection(0, Quill.sources.SILENT);
      } else {
        const paste = this.convert({
          html,
          text: ""
        });
        this.quill.updateContents(new import_quill_delta6.default().retain(index).concat(paste), source);
        this.quill.setSelection(index + paste.length(), Quill.sources.SILENT);
      }
    }
    onCaptureCopy(e2) {
      let isCut = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      if (e2.defaultPrevented)
        return;
      e2.preventDefault();
      const [range] = this.quill.selection.getRange();
      if (range == null)
        return;
      const {
        html,
        text
      } = this.onCopy(range, isCut);
      e2.clipboardData?.setData("text/plain", text);
      e2.clipboardData?.setData("text/html", html);
      if (isCut) {
        deleteRange({
          range,
          quill: this.quill
        });
      }
    }
    /*
     * https://www.iana.org/assignments/media-types/text/uri-list
     */
    normalizeURIList(urlList) {
      return urlList.split(/\r?\n/).filter((url) => url[0] !== "#").join("\n");
    }
    onCapturePaste(e2) {
      if (e2.defaultPrevented || !this.quill.isEnabled())
        return;
      e2.preventDefault();
      const range = this.quill.getSelection(true);
      if (range == null)
        return;
      const html = e2.clipboardData?.getData("text/html");
      let text = e2.clipboardData?.getData("text/plain");
      if (!html && !text) {
        const urlList = e2.clipboardData?.getData("text/uri-list");
        if (urlList) {
          text = this.normalizeURIList(urlList);
        }
      }
      const files = Array.from(e2.clipboardData?.files || []);
      if (!html && files.length > 0) {
        this.quill.uploader.upload(range, files);
        return;
      }
      if (html && files.length > 0) {
        const doc = new DOMParser().parseFromString(html, "text/html");
        if (doc.body.childElementCount === 1 && doc.body.firstElementChild?.tagName === "IMG") {
          this.quill.uploader.upload(range, files);
          return;
        }
      }
      this.onPaste(range, {
        html,
        text
      });
    }
    onCopy(range) {
      const text = this.quill.getText(range);
      const html = this.quill.getSemanticHTML(range);
      return {
        html,
        text
      };
    }
    onPaste(range, _ref3) {
      let {
        text,
        html
      } = _ref3;
      const formats2 = this.quill.getFormat(range.index);
      const pastedDelta = this.convert({
        text,
        html
      }, formats2);
      debug6.log("onPaste", pastedDelta, {
        text,
        html
      });
      const delta = new import_quill_delta6.default().retain(range.index).delete(range.length).concat(pastedDelta);
      this.quill.updateContents(delta, Quill.sources.USER);
      this.quill.setSelection(delta.length() - range.length, Quill.sources.SILENT);
      this.quill.scrollSelectionIntoView();
    }
    prepareMatching(container, nodeMatches) {
      const elementMatchers = [];
      const textMatchers = [];
      this.matchers.forEach((pair) => {
        const [selector, matcher] = pair;
        switch (selector) {
          case Node.TEXT_NODE:
            textMatchers.push(matcher);
            break;
          case Node.ELEMENT_NODE:
            elementMatchers.push(matcher);
            break;
          default:
            Array.from(container.querySelectorAll(selector)).forEach((node) => {
              if (nodeMatches.has(node)) {
                const matches = nodeMatches.get(node);
                matches?.push(matcher);
              } else {
                nodeMatches.set(node, [matcher]);
              }
            });
            break;
        }
      });
      return [elementMatchers, textMatchers];
    }
  };
  function applyFormat(delta, format, value, scroll) {
    if (!scroll.query(format)) {
      return delta;
    }
    return delta.reduce((newDelta, op) => {
      if (!op.insert)
        return newDelta;
      if (op.attributes && op.attributes[format]) {
        return newDelta.push(op);
      }
      const formats2 = value ? {
        [format]: value
      } : {};
      return newDelta.insert(op.insert, {
        ...formats2,
        ...op.attributes
      });
    }, new import_quill_delta6.default());
  }
  __name(applyFormat, "applyFormat");
  function deltaEndsWith(delta, text) {
    let endText = "";
    for (let i2 = delta.ops.length - 1; i2 >= 0 && endText.length < text.length; --i2) {
      const op = delta.ops[i2];
      if (typeof op.insert !== "string")
        break;
      endText = op.insert + endText;
    }
    return endText.slice(-1 * text.length) === text;
  }
  __name(deltaEndsWith, "deltaEndsWith");
  function isLine2(node, scroll) {
    if (!(node instanceof Element))
      return false;
    const match2 = scroll.query(node);
    if (match2 && match2.prototype instanceof EmbedBlot$1)
      return false;
    return ["address", "article", "blockquote", "canvas", "dd", "div", "dl", "dt", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "header", "iframe", "li", "main", "nav", "ol", "output", "p", "pre", "section", "table", "td", "tr", "ul", "video"].includes(node.tagName.toLowerCase());
  }
  __name(isLine2, "isLine");
  function isBetweenInlineElements(node, scroll) {
    return node.previousElementSibling && node.nextElementSibling && !isLine2(node.previousElementSibling, scroll) && !isLine2(node.nextElementSibling, scroll);
  }
  __name(isBetweenInlineElements, "isBetweenInlineElements");
  var preNodes = /* @__PURE__ */ new WeakMap();
  function isPre(node) {
    if (node == null)
      return false;
    if (!preNodes.has(node)) {
      if (node.tagName === "PRE") {
        preNodes.set(node, true);
      } else {
        preNodes.set(node, isPre(node.parentNode));
      }
    }
    return preNodes.get(node);
  }
  __name(isPre, "isPre");
  function traverse(scroll, node, elementMatchers, textMatchers, nodeMatches) {
    if (node.nodeType === node.TEXT_NODE) {
      return textMatchers.reduce((delta, matcher) => {
        return matcher(node, delta, scroll);
      }, new import_quill_delta6.default());
    }
    if (node.nodeType === node.ELEMENT_NODE) {
      return Array.from(node.childNodes || []).reduce((delta, childNode) => {
        let childrenDelta = traverse(scroll, childNode, elementMatchers, textMatchers, nodeMatches);
        if (childNode.nodeType === node.ELEMENT_NODE) {
          childrenDelta = elementMatchers.reduce((reducedDelta, matcher) => {
            return matcher(childNode, reducedDelta, scroll);
          }, childrenDelta);
          childrenDelta = (nodeMatches.get(childNode) || []).reduce((reducedDelta, matcher) => {
            return matcher(childNode, reducedDelta, scroll);
          }, childrenDelta);
        }
        return delta.concat(childrenDelta);
      }, new import_quill_delta6.default());
    }
    return new import_quill_delta6.default();
  }
  __name(traverse, "traverse");
  function createMatchAlias(format) {
    return (_node, delta, scroll) => {
      return applyFormat(delta, format, true, scroll);
    };
  }
  __name(createMatchAlias, "createMatchAlias");
  function matchAttributor(node, delta, scroll) {
    const attributes = Attributor.keys(node);
    const classes = ClassAttributor$1.keys(node);
    const styles = StyleAttributor$1.keys(node);
    const formats2 = {};
    attributes.concat(classes).concat(styles).forEach((name) => {
      let attr = scroll.query(name, Scope.ATTRIBUTE);
      if (attr != null) {
        formats2[attr.attrName] = attr.value(node);
        if (formats2[attr.attrName])
          return;
      }
      attr = ATTRIBUTE_ATTRIBUTORS[name];
      if (attr != null && (attr.attrName === name || attr.keyName === name)) {
        formats2[attr.attrName] = attr.value(node) || void 0;
      }
      attr = STYLE_ATTRIBUTORS[name];
      if (attr != null && (attr.attrName === name || attr.keyName === name)) {
        attr = STYLE_ATTRIBUTORS[name];
        formats2[attr.attrName] = attr.value(node) || void 0;
      }
    });
    return Object.entries(formats2).reduce((newDelta, _ref4) => {
      let [name, value] = _ref4;
      return applyFormat(newDelta, name, value, scroll);
    }, delta);
  }
  __name(matchAttributor, "matchAttributor");
  function matchBlot(node, delta, scroll) {
    const match2 = scroll.query(node);
    if (match2 == null)
      return delta;
    if (match2.prototype instanceof EmbedBlot$1) {
      const embed = {};
      const value = match2.value(node);
      if (value != null) {
        embed[match2.blotName] = value;
        return new import_quill_delta6.default().insert(embed, match2.formats(node, scroll));
      }
    } else {
      if (match2.prototype instanceof BlockBlot$1 && !deltaEndsWith(delta, "\n")) {
        delta.insert("\n");
      }
      if ("blotName" in match2 && "formats" in match2 && typeof match2.formats === "function") {
        return applyFormat(delta, match2.blotName, match2.formats(node, scroll), scroll);
      }
    }
    return delta;
  }
  __name(matchBlot, "matchBlot");
  function matchBreak(node, delta) {
    if (!deltaEndsWith(delta, "\n")) {
      delta.insert("\n");
    }
    return delta;
  }
  __name(matchBreak, "matchBreak");
  function matchCodeBlock(node, delta, scroll) {
    const match2 = scroll.query("code-block");
    const language = match2 && "formats" in match2 && typeof match2.formats === "function" ? match2.formats(node, scroll) : true;
    return applyFormat(delta, "code-block", language, scroll);
  }
  __name(matchCodeBlock, "matchCodeBlock");
  function matchIgnore() {
    return new import_quill_delta6.default();
  }
  __name(matchIgnore, "matchIgnore");
  function matchIndent(node, delta, scroll) {
    const match2 = scroll.query(node);
    if (match2 == null || // @ts-expect-error
    match2.blotName !== "list" || !deltaEndsWith(delta, "\n")) {
      return delta;
    }
    let indent = -1;
    let parent = node.parentNode;
    while (parent != null) {
      if (["OL", "UL"].includes(parent.tagName)) {
        indent += 1;
      }
      parent = parent.parentNode;
    }
    if (indent <= 0)
      return delta;
    return delta.reduce((composed, op) => {
      if (!op.insert)
        return composed;
      if (op.attributes && typeof op.attributes.indent === "number") {
        return composed.push(op);
      }
      return composed.insert(op.insert, {
        indent,
        ...op.attributes || {}
      });
    }, new import_quill_delta6.default());
  }
  __name(matchIndent, "matchIndent");
  function matchList(node, delta, scroll) {
    const element = node;
    let list = element.tagName === "OL" ? "ordered" : "bullet";
    const checkedAttr = element.getAttribute("data-checked");
    if (checkedAttr) {
      list = checkedAttr === "true" ? "checked" : "unchecked";
    }
    return applyFormat(delta, "list", list, scroll);
  }
  __name(matchList, "matchList");
  function matchNewline(node, delta, scroll) {
    if (!deltaEndsWith(delta, "\n")) {
      if (isLine2(node, scroll) && (node.childNodes.length > 0 || node instanceof HTMLParagraphElement)) {
        return delta.insert("\n");
      }
      if (delta.length() > 0 && node.nextSibling) {
        let nextSibling = node.nextSibling;
        while (nextSibling != null) {
          if (isLine2(nextSibling, scroll)) {
            return delta.insert("\n");
          }
          const match2 = scroll.query(nextSibling);
          if (match2 && match2.prototype instanceof BlockEmbed) {
            return delta.insert("\n");
          }
          nextSibling = nextSibling.firstChild;
        }
      }
    }
    return delta;
  }
  __name(matchNewline, "matchNewline");
  function matchStyles(node, delta, scroll) {
    const formats2 = {};
    const style = node.style || {};
    if (style.fontStyle === "italic") {
      formats2.italic = true;
    }
    if (style.textDecoration === "underline") {
      formats2.underline = true;
    }
    if (style.textDecoration === "line-through") {
      formats2.strike = true;
    }
    if (style.fontWeight?.startsWith("bold") || // @ts-expect-error Fix me later
    parseInt(style.fontWeight, 10) >= 700) {
      formats2.bold = true;
    }
    delta = Object.entries(formats2).reduce((newDelta, _ref5) => {
      let [name, value] = _ref5;
      return applyFormat(newDelta, name, value, scroll);
    }, delta);
    if (parseFloat(style.textIndent || 0) > 0) {
      return new import_quill_delta6.default().insert("	").concat(delta);
    }
    return delta;
  }
  __name(matchStyles, "matchStyles");
  function matchTable(node, delta, scroll) {
    const table = node.parentElement?.tagName === "TABLE" ? node.parentElement : node.parentElement?.parentElement;
    if (table != null) {
      const rows = Array.from(table.querySelectorAll("tr"));
      const row = rows.indexOf(node) + 1;
      return applyFormat(delta, "table", row, scroll);
    }
    return delta;
  }
  __name(matchTable, "matchTable");
  function matchText(node, delta, scroll) {
    let text = node.data;
    if (node.parentElement?.tagName === "O:P") {
      return delta.insert(text.trim());
    }
    if (!isPre(node)) {
      if (text.trim().length === 0 && text.includes("\n") && !isBetweenInlineElements(node, scroll)) {
        return delta;
      }
      const replacer = /* @__PURE__ */ __name((collapse, match2) => {
        const replaced = match2.replace(/[^\u00a0]/g, "");
        return replaced.length < 1 && collapse ? " " : replaced;
      }, "replacer");
      text = text.replace(/\r\n/g, " ").replace(/\n/g, " ");
      text = text.replace(/\s\s+/g, replacer.bind(replacer, true));
      if (node.previousSibling == null && node.parentElement != null && isLine2(node.parentElement, scroll) || node.previousSibling instanceof Element && isLine2(node.previousSibling, scroll)) {
        text = text.replace(/^\s+/, replacer.bind(replacer, false));
      }
      if (node.nextSibling == null && node.parentElement != null && isLine2(node.parentElement, scroll) || node.nextSibling instanceof Element && isLine2(node.nextSibling, scroll)) {
        text = text.replace(/\s+$/, replacer.bind(replacer, false));
      }
    }
    return delta.insert(text);
  }
  __name(matchText, "matchText");

  // node_modules/quill/modules/history.js
  var History2 = class extends module_default {
    static {
      __name(this, "History");
    }
    static DEFAULTS = {
      delay: 1e3,
      maxStack: 100,
      userOnly: false
    };
    lastRecorded = 0;
    ignoreChange = false;
    stack = {
      undo: [],
      redo: []
    };
    currentRange = null;
    constructor(quill, options) {
      super(quill, options);
      this.quill.on(Quill.events.EDITOR_CHANGE, (eventName, value, oldValue, source) => {
        if (eventName === Quill.events.SELECTION_CHANGE) {
          if (value && source !== Quill.sources.SILENT) {
            this.currentRange = value;
          }
        } else if (eventName === Quill.events.TEXT_CHANGE) {
          if (!this.ignoreChange) {
            if (!this.options.userOnly || source === Quill.sources.USER) {
              this.record(value, oldValue);
            } else {
              this.transform(value);
            }
          }
          this.currentRange = transformRange(this.currentRange, value);
        }
      });
      this.quill.keyboard.addBinding({
        key: "z",
        shortKey: true
      }, this.undo.bind(this));
      this.quill.keyboard.addBinding({
        key: ["z", "Z"],
        shortKey: true,
        shiftKey: true
      }, this.redo.bind(this));
      if (/Win/i.test(navigator.platform)) {
        this.quill.keyboard.addBinding({
          key: "y",
          shortKey: true
        }, this.redo.bind(this));
      }
      this.quill.root.addEventListener("beforeinput", (event) => {
        if (event.inputType === "historyUndo") {
          this.undo();
          event.preventDefault();
        } else if (event.inputType === "historyRedo") {
          this.redo();
          event.preventDefault();
        }
      });
    }
    change(source, dest) {
      if (this.stack[source].length === 0)
        return;
      const item = this.stack[source].pop();
      if (!item)
        return;
      const base = this.quill.getContents();
      const inverseDelta = item.delta.invert(base);
      this.stack[dest].push({
        delta: inverseDelta,
        range: transformRange(item.range, inverseDelta)
      });
      this.lastRecorded = 0;
      this.ignoreChange = true;
      this.quill.updateContents(item.delta, Quill.sources.USER);
      this.ignoreChange = false;
      this.restoreSelection(item);
    }
    clear() {
      this.stack = {
        undo: [],
        redo: []
      };
    }
    cutoff() {
      this.lastRecorded = 0;
    }
    record(changeDelta, oldDelta) {
      if (changeDelta.ops.length === 0)
        return;
      this.stack.redo = [];
      let undoDelta = changeDelta.invert(oldDelta);
      let undoRange = this.currentRange;
      const timestamp = Date.now();
      if (
        // @ts-expect-error Fix me later
        this.lastRecorded + this.options.delay > timestamp && this.stack.undo.length > 0
      ) {
        const item = this.stack.undo.pop();
        if (item) {
          undoDelta = undoDelta.compose(item.delta);
          undoRange = item.range;
        }
      } else {
        this.lastRecorded = timestamp;
      }
      if (undoDelta.length() === 0)
        return;
      this.stack.undo.push({
        delta: undoDelta,
        range: undoRange
      });
      if (this.stack.undo.length > this.options.maxStack) {
        this.stack.undo.shift();
      }
    }
    redo() {
      this.change("redo", "undo");
    }
    transform(delta) {
      transformStack(this.stack.undo, delta);
      transformStack(this.stack.redo, delta);
    }
    undo() {
      this.change("undo", "redo");
    }
    restoreSelection(stackItem) {
      if (stackItem.range) {
        this.quill.setSelection(stackItem.range, Quill.sources.USER);
      } else {
        const index = getLastChangeIndex(this.quill.scroll, stackItem.delta);
        this.quill.setSelection(index, Quill.sources.USER);
      }
    }
  };
  function transformStack(stack, delta) {
    let remoteDelta = delta;
    for (let i2 = stack.length - 1; i2 >= 0; i2 -= 1) {
      const oldItem = stack[i2];
      stack[i2] = {
        delta: remoteDelta.transform(oldItem.delta, true),
        range: oldItem.range && transformRange(oldItem.range, remoteDelta)
      };
      remoteDelta = oldItem.delta.transform(remoteDelta);
      if (stack[i2].delta.length() === 0) {
        stack.splice(i2, 1);
      }
    }
  }
  __name(transformStack, "transformStack");
  function endsWithNewlineChange(scroll, delta) {
    const lastOp = delta.ops[delta.ops.length - 1];
    if (lastOp == null)
      return false;
    if (lastOp.insert != null) {
      return typeof lastOp.insert === "string" && lastOp.insert.endsWith("\n");
    }
    if (lastOp.attributes != null) {
      return Object.keys(lastOp.attributes).some((attr) => {
        return scroll.query(attr, Scope.BLOCK) != null;
      });
    }
    return false;
  }
  __name(endsWithNewlineChange, "endsWithNewlineChange");
  function getLastChangeIndex(scroll, delta) {
    const deleteLength = delta.reduce((length, op) => {
      return length + (op.delete || 0);
    }, 0);
    let changeIndex = delta.length() - deleteLength;
    if (endsWithNewlineChange(scroll, delta)) {
      changeIndex -= 1;
    }
    return changeIndex;
  }
  __name(getLastChangeIndex, "getLastChangeIndex");
  function transformRange(range, delta) {
    if (!range)
      return range;
    const start2 = delta.transformPosition(range.index);
    const end = delta.transformPosition(range.index + range.length);
    return {
      index: start2,
      length: end - start2
    };
  }
  __name(transformRange, "transformRange");

  // node_modules/quill/modules/uploader.js
  var import_quill_delta7 = __toESM(require_Delta(), 1);
  var Uploader = class extends module_default {
    static {
      __name(this, "Uploader");
    }
    constructor(quill, options) {
      super(quill, options);
      quill.root.addEventListener("drop", (e2) => {
        e2.preventDefault();
        let native = null;
        if (document.caretRangeFromPoint) {
          native = document.caretRangeFromPoint(e2.clientX, e2.clientY);
        } else if (document.caretPositionFromPoint) {
          const position = document.caretPositionFromPoint(e2.clientX, e2.clientY);
          native = document.createRange();
          native.setStart(position.offsetNode, position.offset);
          native.setEnd(position.offsetNode, position.offset);
        }
        const normalized = native && quill.selection.normalizeNative(native);
        if (normalized) {
          const range = quill.selection.normalizedToRange(normalized);
          if (e2.dataTransfer?.files) {
            this.upload(range, e2.dataTransfer.files);
          }
        }
      });
    }
    upload(range, files) {
      const uploads = [];
      Array.from(files).forEach((file) => {
        if (file && this.options.mimetypes?.includes(file.type)) {
          uploads.push(file);
        }
      });
      if (uploads.length > 0) {
        this.options.handler.call(this, range, uploads);
      }
    }
  };
  Uploader.DEFAULTS = {
    mimetypes: ["image/png", "image/jpeg"],
    handler(range, files) {
      const promises = files.map((file) => {
        return new Promise((resolve) => {
          const reader = new FileReader();
          reader.onload = (e2) => {
            resolve(e2.target.result);
          };
          reader.readAsDataURL(file);
        });
      });
      Promise.all(promises).then((images) => {
        const update = images.reduce((delta, image) => {
          return delta.insert({
            image
          });
        }, new import_quill_delta7.default().retain(range.index).delete(range.length));
        this.quill.updateContents(update, emitter_default.sources.USER);
        this.quill.setSelection(range.index + images.length, emitter_default.sources.SILENT);
      });
    }
  };
  var uploader_default = Uploader;

  // node_modules/quill/core.js
  var import_quill_delta9 = __toESM(require_Delta(), 1);

  // node_modules/quill/modules/input.js
  var import_quill_delta8 = __toESM(require_Delta(), 1);
  var INSERT_TYPES = ["insertText", "insertReplacementText"];
  var Input = class extends module_default {
    static {
      __name(this, "Input");
    }
    constructor(quill, options) {
      super(quill, options);
      quill.root.addEventListener("beforeinput", (event) => {
        this.handleBeforeInput(event);
      });
      if (!/Android/i.test(navigator.userAgent)) {
        quill.on(Quill.events.COMPOSITION_BEFORE_START, () => {
          this.handleCompositionStart();
        });
      }
    }
    deleteRange(range) {
      deleteRange({
        range,
        quill: this.quill
      });
    }
    replaceText(range) {
      let text = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
      if (range.length === 0)
        return false;
      if (text) {
        const formats2 = this.quill.getFormat(range.index, 1);
        this.deleteRange(range);
        this.quill.updateContents(new import_quill_delta8.default().retain(range.index).insert(text, formats2), Quill.sources.USER);
      } else {
        this.deleteRange(range);
      }
      this.quill.setSelection(range.index + text.length, 0, Quill.sources.SILENT);
      return true;
    }
    handleBeforeInput(event) {
      if (this.quill.composition.isComposing || event.defaultPrevented || !INSERT_TYPES.includes(event.inputType)) {
        return;
      }
      const staticRange = event.getTargetRanges ? event.getTargetRanges()[0] : null;
      if (!staticRange || staticRange.collapsed === true) {
        return;
      }
      const text = getPlainTextFromInputEvent(event);
      if (text == null) {
        return;
      }
      const normalized = this.quill.selection.normalizeNative(staticRange);
      const range = normalized ? this.quill.selection.normalizedToRange(normalized) : null;
      if (range && this.replaceText(range, text)) {
        event.preventDefault();
      }
    }
    handleCompositionStart() {
      const range = this.quill.getSelection();
      if (range) {
        this.replaceText(range);
      }
    }
  };
  function getPlainTextFromInputEvent(event) {
    if (typeof event.data === "string") {
      return event.data;
    }
    if (event.dataTransfer?.types.includes("text/plain")) {
      return event.dataTransfer.getData("text/plain");
    }
    return null;
  }
  __name(getPlainTextFromInputEvent, "getPlainTextFromInputEvent");
  var input_default = Input;

  // node_modules/quill/modules/uiNode.js
  var isMac = /Mac/i.test(navigator.platform);
  var TTL_FOR_VALID_SELECTION_CHANGE = 100;
  var canMoveCaretBeforeUINode = /* @__PURE__ */ __name((event) => {
    if (event.key === "ArrowLeft" || event.key === "ArrowRight" || // RTL scripts or moving from the end of the previous line
    event.key === "ArrowUp" || event.key === "ArrowDown" || event.key === "Home") {
      return true;
    }
    if (isMac && event.key === "a" && event.ctrlKey === true) {
      return true;
    }
    return false;
  }, "canMoveCaretBeforeUINode");
  var UINode = class extends module_default {
    static {
      __name(this, "UINode");
    }
    isListening = false;
    selectionChangeDeadline = 0;
    constructor(quill, options) {
      super(quill, options);
      this.handleArrowKeys();
      this.handleNavigationShortcuts();
    }
    handleArrowKeys() {
      this.quill.keyboard.addBinding({
        key: ["ArrowLeft", "ArrowRight"],
        offset: 0,
        shiftKey: null,
        handler(range, _ref) {
          let {
            line,
            event
          } = _ref;
          if (!(line instanceof ParentBlot$1) || !line.uiNode) {
            return true;
          }
          const isRTL = getComputedStyle(line.domNode)["direction"] === "rtl";
          if (isRTL && event.key !== "ArrowRight" || !isRTL && event.key !== "ArrowLeft") {
            return true;
          }
          this.quill.setSelection(range.index - 1, range.length + (event.shiftKey ? 1 : 0), Quill.sources.USER);
          return false;
        }
      });
    }
    handleNavigationShortcuts() {
      this.quill.root.addEventListener("keydown", (event) => {
        if (!event.defaultPrevented && canMoveCaretBeforeUINode(event)) {
          this.ensureListeningToSelectionChange();
        }
      });
    }
    /**
     * We only listen to the `selectionchange` event when
     * there is an intention of moving the caret to the beginning using shortcuts.
     * This is primarily implemented to prevent infinite loops, as we are changing
     * the selection within the handler of a `selectionchange` event.
     */
    ensureListeningToSelectionChange() {
      this.selectionChangeDeadline = Date.now() + TTL_FOR_VALID_SELECTION_CHANGE;
      if (this.isListening)
        return;
      this.isListening = true;
      const listener = /* @__PURE__ */ __name(() => {
        this.isListening = false;
        if (Date.now() <= this.selectionChangeDeadline) {
          this.handleSelectionChange();
        }
      }, "listener");
      document.addEventListener("selectionchange", listener, {
        once: true
      });
    }
    handleSelectionChange() {
      const selection = document.getSelection();
      if (!selection)
        return;
      const range = selection.getRangeAt(0);
      if (range.collapsed !== true || range.startOffset !== 0)
        return;
      const line = this.quill.scroll.find(range.startContainer);
      if (!(line instanceof ParentBlot$1) || !line.uiNode)
        return;
      const newRange = document.createRange();
      newRange.setStartAfter(line.uiNode);
      newRange.setEndAfter(line.uiNode);
      selection.removeAllRanges();
      selection.addRange(newRange);
    }
  };
  var uiNode_default = UINode;

  // node_modules/quill/core.js
  Quill.register({
    "blots/block": Block,
    "blots/block/embed": BlockEmbed,
    "blots/break": break_default,
    "blots/container": container_default,
    "blots/cursor": cursor_default,
    "blots/embed": embed_default,
    "blots/inline": inline_default,
    "blots/scroll": scroll_default,
    "blots/text": Text2,
    "modules/clipboard": Clipboard,
    "modules/history": History2,
    "modules/keyboard": Keyboard,
    "modules/uploader": uploader_default,
    "modules/input": input_default,
    "modules/uiNode": uiNode_default
  });
  var core_default = Quill;

  // node_modules/quill/formats/indent.js
  var IndentAttributor = class extends ClassAttributor$1 {
    static {
      __name(this, "IndentAttributor");
    }
    add(node, value) {
      let normalizedValue = 0;
      if (value === "+1" || value === "-1") {
        const indent = this.value(node) || 0;
        normalizedValue = value === "+1" ? indent + 1 : indent - 1;
      } else if (typeof value === "number") {
        normalizedValue = value;
      }
      if (normalizedValue === 0) {
        this.remove(node);
        return true;
      }
      return super.add(node, normalizedValue.toString());
    }
    canAdd(node, value) {
      return super.canAdd(node, value) || super.canAdd(node, parseInt(value, 10));
    }
    value(node) {
      return parseInt(super.value(node), 10) || void 0;
    }
  };
  var IndentClass = new IndentAttributor("indent", "ql-indent", {
    scope: Scope.BLOCK,
    // @ts-expect-error
    whitelist: [1, 2, 3, 4, 5, 6, 7, 8]
  });
  var indent_default = IndentClass;

  // node_modules/quill/formats/blockquote.js
  var Blockquote = class extends Block {
    static {
      __name(this, "Blockquote");
    }
    static blotName = "blockquote";
    static tagName = "blockquote";
  };
  var blockquote_default = Blockquote;

  // node_modules/quill/formats/header.js
  var Header = class extends Block {
    static {
      __name(this, "Header");
    }
    static blotName = "header";
    static tagName = ["H1", "H2", "H3", "H4", "H5", "H6"];
    static formats(domNode) {
      return this.tagName.indexOf(domNode.tagName) + 1;
    }
  };
  var header_default = Header;

  // node_modules/quill/formats/list.js
  var ListContainer = class extends container_default {
    static {
      __name(this, "ListContainer");
    }
  };
  ListContainer.blotName = "list-container";
  ListContainer.tagName = "OL";
  var ListItem = class extends Block {
    static {
      __name(this, "ListItem");
    }
    static create(value) {
      const node = super.create();
      node.setAttribute("data-list", value);
      return node;
    }
    static formats(domNode) {
      return domNode.getAttribute("data-list") || void 0;
    }
    static register() {
      Quill.register(ListContainer);
    }
    constructor(scroll, domNode) {
      super(scroll, domNode);
      const ui = domNode.ownerDocument.createElement("span");
      const listEventHandler = /* @__PURE__ */ __name((e2) => {
        if (!scroll.isEnabled())
          return;
        const format = this.statics.formats(domNode, scroll);
        if (format === "checked") {
          this.format("list", "unchecked");
          e2.preventDefault();
        } else if (format === "unchecked") {
          this.format("list", "checked");
          e2.preventDefault();
        }
      }, "listEventHandler");
      ui.addEventListener("mousedown", listEventHandler);
      ui.addEventListener("touchstart", listEventHandler);
      this.attachUI(ui);
    }
    format(name, value) {
      if (name === this.statics.blotName && value) {
        this.domNode.setAttribute("data-list", value);
      } else {
        super.format(name, value);
      }
    }
  };
  ListItem.blotName = "list";
  ListItem.tagName = "LI";
  ListContainer.allowedChildren = [ListItem];
  ListItem.requiredContainer = ListContainer;

  // node_modules/quill/formats/bold.js
  var Bold = class extends inline_default {
    static {
      __name(this, "Bold");
    }
    static blotName = "bold";
    static tagName = ["STRONG", "B"];
    static create() {
      return super.create();
    }
    static formats() {
      return true;
    }
    optimize(context) {
      super.optimize(context);
      if (this.domNode.tagName !== this.statics.tagName[0]) {
        this.replaceWith(this.statics.blotName);
      }
    }
  };
  var bold_default = Bold;

  // node_modules/quill/formats/italic.js
  var Italic = class extends bold_default {
    static {
      __name(this, "Italic");
    }
    static blotName = "italic";
    static tagName = ["EM", "I"];
  };
  var italic_default = Italic;

  // node_modules/quill/formats/link.js
  var Link = class extends inline_default {
    static {
      __name(this, "Link");
    }
    static blotName = "link";
    static tagName = "A";
    static SANITIZED_URL = "about:blank";
    static PROTOCOL_WHITELIST = ["http", "https", "mailto", "tel", "sms"];
    static create(value) {
      const node = super.create(value);
      node.setAttribute("href", this.sanitize(value));
      node.setAttribute("rel", "noopener noreferrer");
      node.setAttribute("target", "_blank");
      return node;
    }
    static formats(domNode) {
      return domNode.getAttribute("href");
    }
    static sanitize(url) {
      return sanitize(url, this.PROTOCOL_WHITELIST) ? url : this.SANITIZED_URL;
    }
    format(name, value) {
      if (name !== this.statics.blotName || !value) {
        super.format(name, value);
      } else {
        this.domNode.setAttribute("href", this.constructor.sanitize(value));
      }
    }
  };
  function sanitize(url, protocols2) {
    const anchor = document.createElement("a");
    anchor.href = url;
    const protocol = anchor.href.slice(0, anchor.href.indexOf(":"));
    return protocols2.indexOf(protocol) > -1;
  }
  __name(sanitize, "sanitize");

  // node_modules/quill/formats/script.js
  var Script = class extends inline_default {
    static {
      __name(this, "Script");
    }
    static blotName = "script";
    static tagName = ["SUB", "SUP"];
    static create(value) {
      if (value === "super") {
        return document.createElement("sup");
      }
      if (value === "sub") {
        return document.createElement("sub");
      }
      return super.create(value);
    }
    static formats(domNode) {
      if (domNode.tagName === "SUB")
        return "sub";
      if (domNode.tagName === "SUP")
        return "super";
      return void 0;
    }
  };
  var script_default = Script;

  // node_modules/quill/formats/strike.js
  var Strike = class extends bold_default {
    static {
      __name(this, "Strike");
    }
    static blotName = "strike";
    static tagName = ["S", "STRIKE"];
  };
  var strike_default = Strike;

  // node_modules/quill/formats/underline.js
  var Underline = class extends inline_default {
    static {
      __name(this, "Underline");
    }
    static blotName = "underline";
    static tagName = "U";
  };
  var underline_default = Underline;

  // node_modules/quill/formats/formula.js
  var Formula = class extends embed_default {
    static {
      __name(this, "Formula");
    }
    static blotName = "formula";
    static className = "ql-formula";
    static tagName = "SPAN";
    static create(value) {
      if (window.katex == null) {
        throw new Error("Formula module requires KaTeX.");
      }
      const node = super.create(value);
      if (typeof value === "string") {
        window.katex.render(value, node, {
          throwOnError: false,
          errorColor: "#f00"
        });
        node.setAttribute("data-value", value);
      }
      return node;
    }
    static value(domNode) {
      return domNode.getAttribute("data-value");
    }
    html() {
      const {
        formula
      } = this.value();
      return `<span>${formula}</span>`;
    }
  };
  var formula_default = Formula;

  // node_modules/quill/formats/image.js
  var ATTRIBUTES = ["alt", "height", "width"];
  var Image = class extends EmbedBlot$1 {
    static {
      __name(this, "Image");
    }
    static blotName = "image";
    static tagName = "IMG";
    static create(value) {
      const node = super.create(value);
      if (typeof value === "string") {
        node.setAttribute("src", this.sanitize(value));
      }
      return node;
    }
    static formats(domNode) {
      return ATTRIBUTES.reduce((formats2, attribute) => {
        if (domNode.hasAttribute(attribute)) {
          formats2[attribute] = domNode.getAttribute(attribute);
        }
        return formats2;
      }, {});
    }
    static match(url) {
      return /\.(jpe?g|gif|png)$/.test(url) || /^data:image\/.+;base64/.test(url);
    }
    static sanitize(url) {
      return sanitize(url, ["http", "https", "data"]) ? url : "//:0";
    }
    static value(domNode) {
      return domNode.getAttribute("src");
    }
    format(name, value) {
      if (ATTRIBUTES.indexOf(name) > -1) {
        if (value) {
          this.domNode.setAttribute(name, value);
        } else {
          this.domNode.removeAttribute(name);
        }
      } else {
        super.format(name, value);
      }
    }
  };
  var image_default = Image;

  // node_modules/quill/formats/video.js
  var ATTRIBUTES2 = ["height", "width"];
  var Video = class extends BlockEmbed {
    static {
      __name(this, "Video");
    }
    static blotName = "video";
    static className = "ql-video";
    static tagName = "IFRAME";
    static create(value) {
      const node = super.create(value);
      node.setAttribute("frameborder", "0");
      node.setAttribute("allowfullscreen", "true");
      node.setAttribute("src", this.sanitize(value));
      return node;
    }
    static formats(domNode) {
      return ATTRIBUTES2.reduce((formats2, attribute) => {
        if (domNode.hasAttribute(attribute)) {
          formats2[attribute] = domNode.getAttribute(attribute);
        }
        return formats2;
      }, {});
    }
    static sanitize(url) {
      return Link.sanitize(url);
    }
    static value(domNode) {
      return domNode.getAttribute("src");
    }
    format(name, value) {
      if (ATTRIBUTES2.indexOf(name) > -1) {
        if (value) {
          this.domNode.setAttribute(name, value);
        } else {
          this.domNode.removeAttribute(name);
        }
      } else {
        super.format(name, value);
      }
    }
    html() {
      const {
        video
      } = this.value();
      return `<a href="${video}">${video}</a>`;
    }
  };
  var video_default = Video;

  // node_modules/quill/modules/syntax.js
  var import_quill_delta10 = __toESM(require_Delta(), 1);
  var TokenAttributor = new ClassAttributor$1("code-token", "hljs", {
    scope: Scope.INLINE
  });
  var CodeToken = class _CodeToken extends inline_default {
    static {
      __name(this, "CodeToken");
    }
    static formats(node, scroll) {
      while (node != null && node !== scroll.domNode) {
        if (node.classList && node.classList.contains(CodeBlock.className)) {
          return super.formats(node, scroll);
        }
        node = node.parentNode;
      }
      return void 0;
    }
    constructor(scroll, domNode, value) {
      super(scroll, domNode, value);
      TokenAttributor.add(this.domNode, value);
    }
    format(format, value) {
      if (format !== _CodeToken.blotName) {
        super.format(format, value);
      } else if (value) {
        TokenAttributor.add(this.domNode, value);
      } else {
        TokenAttributor.remove(this.domNode);
        this.domNode.classList.remove(this.statics.className);
      }
    }
    optimize() {
      super.optimize(...arguments);
      if (!TokenAttributor.value(this.domNode)) {
        this.unwrap();
      }
    }
  };
  CodeToken.blotName = "code-token";
  CodeToken.className = "ql-token";
  var SyntaxCodeBlock = class extends CodeBlock {
    static {
      __name(this, "SyntaxCodeBlock");
    }
    static create(value) {
      const domNode = super.create(value);
      if (typeof value === "string") {
        domNode.setAttribute("data-language", value);
      }
      return domNode;
    }
    static formats(domNode) {
      return domNode.getAttribute("data-language") || "plain";
    }
    static register() {
    }
    // Syntax module will register
    format(name, value) {
      if (name === this.statics.blotName && value) {
        this.domNode.setAttribute("data-language", value);
      } else {
        super.format(name, value);
      }
    }
    replaceWith(name, value) {
      this.formatAt(0, this.length(), CodeToken.blotName, false);
      return super.replaceWith(name, value);
    }
  };
  var SyntaxCodeBlockContainer = class extends CodeBlockContainer {
    static {
      __name(this, "SyntaxCodeBlockContainer");
    }
    attach() {
      super.attach();
      this.forceNext = false;
      this.scroll.emitMount(this);
    }
    format(name, value) {
      if (name === SyntaxCodeBlock.blotName) {
        this.forceNext = true;
        this.children.forEach((child) => {
          child.format(name, value);
        });
      }
    }
    formatAt(index, length, name, value) {
      if (name === SyntaxCodeBlock.blotName) {
        this.forceNext = true;
      }
      super.formatAt(index, length, name, value);
    }
    highlight(highlight2) {
      let forced = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      if (this.children.head == null)
        return;
      const nodes = Array.from(this.domNode.childNodes).filter((node) => node !== this.uiNode);
      const text = `${nodes.map((node) => node.textContent).join("\n")}
`;
      const language = SyntaxCodeBlock.formats(this.children.head.domNode);
      if (forced || this.forceNext || this.cachedText !== text) {
        if (text.trim().length > 0 || this.cachedText == null) {
          const oldDelta = this.children.reduce((delta2, child) => {
            return delta2.concat(blockDelta(child, false));
          }, new import_quill_delta10.default());
          const delta = highlight2(text, language);
          oldDelta.diff(delta).reduce((index, _ref) => {
            let {
              retain,
              attributes
            } = _ref;
            if (!retain)
              return index;
            if (attributes) {
              Object.keys(attributes).forEach((format) => {
                if ([SyntaxCodeBlock.blotName, CodeToken.blotName].includes(format)) {
                  this.formatAt(index, retain, format, attributes[format]);
                }
              });
            }
            return index + retain;
          }, 0);
        }
        this.cachedText = text;
        this.forceNext = false;
      }
    }
    html(index, length) {
      const [codeBlock] = this.children.find(index);
      const language = codeBlock ? SyntaxCodeBlock.formats(codeBlock.domNode) : "plain";
      return `<pre data-language="${language}">
${escapeText(this.code(index, length))}
</pre>`;
    }
    optimize(context) {
      super.optimize(context);
      if (this.parent != null && this.children.head != null && this.uiNode != null) {
        const language = SyntaxCodeBlock.formats(this.children.head.domNode);
        if (language !== this.uiNode.value) {
          this.uiNode.value = language;
        }
      }
    }
  };
  SyntaxCodeBlockContainer.allowedChildren = [SyntaxCodeBlock];
  SyntaxCodeBlock.requiredContainer = SyntaxCodeBlockContainer;
  SyntaxCodeBlock.allowedChildren = [CodeToken, cursor_default, Text2, break_default];
  var highlight = /* @__PURE__ */ __name((lib, language, text) => {
    if (typeof lib.versionString === "string") {
      const majorVersion = lib.versionString.split(".")[0];
      if (parseInt(majorVersion, 10) >= 11) {
        return lib.highlight(text, {
          language
        }).value;
      }
    }
    return lib.highlight(language, text).value;
  }, "highlight");
  var Syntax = class extends module_default {
    static {
      __name(this, "Syntax");
    }
    static register() {
      Quill.register(CodeToken, true);
      Quill.register(SyntaxCodeBlock, true);
      Quill.register(SyntaxCodeBlockContainer, true);
    }
    constructor(quill, options) {
      super(quill, options);
      if (this.options.hljs == null) {
        throw new Error("Syntax module requires highlight.js. Please include the library on the page before Quill.");
      }
      this.languages = this.options.languages.reduce((memo, _ref2) => {
        let {
          key
        } = _ref2;
        memo[key] = true;
        return memo;
      }, {});
      this.highlightBlot = this.highlightBlot.bind(this);
      this.initListener();
      this.initTimer();
    }
    initListener() {
      this.quill.on(Quill.events.SCROLL_BLOT_MOUNT, (blot) => {
        if (!(blot instanceof SyntaxCodeBlockContainer))
          return;
        const select = this.quill.root.ownerDocument.createElement("select");
        this.options.languages.forEach((_ref3) => {
          let {
            key,
            label
          } = _ref3;
          const option = select.ownerDocument.createElement("option");
          option.textContent = label;
          option.setAttribute("value", key);
          select.appendChild(option);
        });
        select.addEventListener("change", () => {
          blot.format(SyntaxCodeBlock.blotName, select.value);
          this.quill.root.focus();
          this.highlight(blot, true);
        });
        if (blot.uiNode == null) {
          blot.attachUI(select);
          if (blot.children.head) {
            select.value = SyntaxCodeBlock.formats(blot.children.head.domNode);
          }
        }
      });
    }
    initTimer() {
      let timer = null;
      this.quill.on(Quill.events.SCROLL_OPTIMIZE, () => {
        if (timer) {
          clearTimeout(timer);
        }
        timer = setTimeout(() => {
          this.highlight();
          timer = null;
        }, this.options.interval);
      });
    }
    highlight() {
      let blot = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
      let force = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      if (this.quill.selection.composing)
        return;
      this.quill.update(Quill.sources.USER);
      const range = this.quill.getSelection();
      const blots = blot == null ? this.quill.scroll.descendants(SyntaxCodeBlockContainer) : [blot];
      blots.forEach((container) => {
        container.highlight(this.highlightBlot, force);
      });
      this.quill.update(Quill.sources.SILENT);
      if (range != null) {
        this.quill.setSelection(range, Quill.sources.SILENT);
      }
    }
    highlightBlot(text) {
      let language = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "plain";
      language = this.languages[language] ? language : "plain";
      if (language === "plain") {
        return escapeText(text).split("\n").reduce((delta, line, i2) => {
          if (i2 !== 0) {
            delta.insert("\n", {
              [CodeBlock.blotName]: language
            });
          }
          return delta.insert(line);
        }, new import_quill_delta10.default());
      }
      const container = this.quill.root.ownerDocument.createElement("div");
      container.classList.add(CodeBlock.className);
      container.innerHTML = highlight(this.options.hljs, language, text);
      return traverse(this.quill.scroll, container, [(node, delta) => {
        const value = TokenAttributor.value(node);
        if (value) {
          return delta.compose(new import_quill_delta10.default().retain(delta.length(), {
            [CodeToken.blotName]: value
          }));
        }
        return delta;
      }], [(node, delta) => {
        return node.data.split("\n").reduce((memo, nodeText, i2) => {
          if (i2 !== 0)
            memo.insert("\n", {
              [CodeBlock.blotName]: language
            });
          return memo.insert(nodeText);
        }, delta);
      }], /* @__PURE__ */ new WeakMap());
    }
  };
  Syntax.DEFAULTS = {
    hljs: (() => {
      return window.hljs;
    })(),
    interval: 1e3,
    languages: [{
      key: "plain",
      label: "Plain"
    }, {
      key: "bash",
      label: "Bash"
    }, {
      key: "cpp",
      label: "C++"
    }, {
      key: "cs",
      label: "C#"
    }, {
      key: "css",
      label: "CSS"
    }, {
      key: "diff",
      label: "Diff"
    }, {
      key: "xml",
      label: "HTML/XML"
    }, {
      key: "java",
      label: "Java"
    }, {
      key: "javascript",
      label: "JavaScript"
    }, {
      key: "markdown",
      label: "Markdown"
    }, {
      key: "php",
      label: "PHP"
    }, {
      key: "python",
      label: "Python"
    }, {
      key: "ruby",
      label: "Ruby"
    }, {
      key: "sql",
      label: "SQL"
    }]
  };

  // node_modules/quill/modules/table.js
  var import_quill_delta11 = __toESM(require_Delta(), 1);

  // node_modules/quill/formats/table.js
  var TableCell = class _TableCell extends Block {
    static {
      __name(this, "TableCell");
    }
    static blotName = "table";
    static tagName = "TD";
    static create(value) {
      const node = super.create();
      if (value) {
        node.setAttribute("data-row", value);
      } else {
        node.setAttribute("data-row", tableId());
      }
      return node;
    }
    static formats(domNode) {
      if (domNode.hasAttribute("data-row")) {
        return domNode.getAttribute("data-row");
      }
      return void 0;
    }
    cellOffset() {
      if (this.parent) {
        return this.parent.children.indexOf(this);
      }
      return -1;
    }
    format(name, value) {
      if (name === _TableCell.blotName && value) {
        this.domNode.setAttribute("data-row", value);
      } else {
        super.format(name, value);
      }
    }
    row() {
      return this.parent;
    }
    rowOffset() {
      if (this.row()) {
        return this.row().rowOffset();
      }
      return -1;
    }
    table() {
      return this.row() && this.row().table();
    }
  };
  var TableRow = class extends container_default {
    static {
      __name(this, "TableRow");
    }
    static blotName = "table-row";
    static tagName = "TR";
    checkMerge() {
      if (super.checkMerge() && this.next.children.head != null) {
        const thisHead = this.children.head.formats();
        const thisTail = this.children.tail.formats();
        const nextHead = this.next.children.head.formats();
        const nextTail = this.next.children.tail.formats();
        return thisHead.table === thisTail.table && thisHead.table === nextHead.table && thisHead.table === nextTail.table;
      }
      return false;
    }
    optimize(context) {
      super.optimize(context);
      this.children.forEach((child) => {
        if (child.next == null)
          return;
        const childFormats = child.formats();
        const nextFormats = child.next.formats();
        if (childFormats.table !== nextFormats.table) {
          const next = this.splitAfter(child);
          if (next) {
            next.optimize();
          }
          if (this.prev) {
            this.prev.optimize();
          }
        }
      });
    }
    rowOffset() {
      if (this.parent) {
        return this.parent.children.indexOf(this);
      }
      return -1;
    }
    table() {
      return this.parent && this.parent.parent;
    }
  };
  var TableBody = class extends container_default {
    static {
      __name(this, "TableBody");
    }
    static blotName = "table-body";
    static tagName = "TBODY";
  };
  var TableContainer = class extends container_default {
    static {
      __name(this, "TableContainer");
    }
    static blotName = "table-container";
    static tagName = "TABLE";
    balanceCells() {
      const rows = this.descendants(TableRow);
      const maxColumns = rows.reduce((max, row) => {
        return Math.max(row.children.length, max);
      }, 0);
      rows.forEach((row) => {
        new Array(maxColumns - row.children.length).fill(0).forEach(() => {
          let value;
          if (row.children.head != null) {
            value = TableCell.formats(row.children.head.domNode);
          }
          const blot = this.scroll.create(TableCell.blotName, value);
          row.appendChild(blot);
          blot.optimize();
        });
      });
    }
    cells(column) {
      return this.rows().map((row) => row.children.at(column));
    }
    deleteColumn(index) {
      const [body] = this.descendant(TableBody);
      if (body == null || body.children.head == null)
        return;
      body.children.forEach((row) => {
        const cell = row.children.at(index);
        if (cell != null) {
          cell.remove();
        }
      });
    }
    insertColumn(index) {
      const [body] = this.descendant(TableBody);
      if (body == null || body.children.head == null)
        return;
      body.children.forEach((row) => {
        const ref = row.children.at(index);
        const value = TableCell.formats(row.children.head.domNode);
        const cell = this.scroll.create(TableCell.blotName, value);
        row.insertBefore(cell, ref);
      });
    }
    insertRow(index) {
      const [body] = this.descendant(TableBody);
      if (body == null || body.children.head == null)
        return;
      const id = tableId();
      const row = this.scroll.create(TableRow.blotName);
      body.children.head.children.forEach(() => {
        const cell = this.scroll.create(TableCell.blotName, id);
        row.appendChild(cell);
      });
      const ref = body.children.at(index);
      body.insertBefore(row, ref);
    }
    rows() {
      const body = this.children.head;
      if (body == null)
        return [];
      return body.children.map((row) => row);
    }
  };
  TableContainer.allowedChildren = [TableBody];
  TableBody.requiredContainer = TableContainer;
  TableBody.allowedChildren = [TableRow];
  TableRow.requiredContainer = TableBody;
  TableRow.allowedChildren = [TableCell];
  TableCell.requiredContainer = TableRow;
  function tableId() {
    const id = Math.random().toString(36).slice(2, 6);
    return `row-${id}`;
  }
  __name(tableId, "tableId");

  // node_modules/quill/modules/table.js
  var Table = class extends module_default {
    static {
      __name(this, "Table");
    }
    static register() {
      Quill.register(TableCell);
      Quill.register(TableRow);
      Quill.register(TableBody);
      Quill.register(TableContainer);
    }
    constructor() {
      super(...arguments);
      this.listenBalanceCells();
    }
    balanceTables() {
      this.quill.scroll.descendants(TableContainer).forEach((table) => {
        table.balanceCells();
      });
    }
    deleteColumn() {
      const [table, , cell] = this.getTable();
      if (cell == null)
        return;
      table.deleteColumn(cell.cellOffset());
      this.quill.update(Quill.sources.USER);
    }
    deleteRow() {
      const [, row] = this.getTable();
      if (row == null)
        return;
      row.remove();
      this.quill.update(Quill.sources.USER);
    }
    deleteTable() {
      const [table] = this.getTable();
      if (table == null)
        return;
      const offset = table.offset();
      table.remove();
      this.quill.update(Quill.sources.USER);
      this.quill.setSelection(offset, Quill.sources.SILENT);
    }
    getTable() {
      let range = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.quill.getSelection();
      if (range == null)
        return [null, null, null, -1];
      const [cell, offset] = this.quill.getLine(range.index);
      if (cell == null || cell.statics.blotName !== TableCell.blotName) {
        return [null, null, null, -1];
      }
      const row = cell.parent;
      const table = row.parent.parent;
      return [table, row, cell, offset];
    }
    insertColumn(offset) {
      const range = this.quill.getSelection();
      if (!range)
        return;
      const [table, row, cell] = this.getTable(range);
      if (cell == null)
        return;
      const column = cell.cellOffset();
      table.insertColumn(column + offset);
      this.quill.update(Quill.sources.USER);
      let shift = row.rowOffset();
      if (offset === 0) {
        shift += 1;
      }
      this.quill.setSelection(range.index + shift, range.length, Quill.sources.SILENT);
    }
    insertColumnLeft() {
      this.insertColumn(0);
    }
    insertColumnRight() {
      this.insertColumn(1);
    }
    insertRow(offset) {
      const range = this.quill.getSelection();
      if (!range)
        return;
      const [table, row, cell] = this.getTable(range);
      if (cell == null)
        return;
      const index = row.rowOffset();
      table.insertRow(index + offset);
      this.quill.update(Quill.sources.USER);
      if (offset > 0) {
        this.quill.setSelection(range, Quill.sources.SILENT);
      } else {
        this.quill.setSelection(range.index + row.children.length, range.length, Quill.sources.SILENT);
      }
    }
    insertRowAbove() {
      this.insertRow(0);
    }
    insertRowBelow() {
      this.insertRow(1);
    }
    insertTable(rows, columns) {
      const range = this.quill.getSelection();
      if (range == null)
        return;
      const delta = new Array(rows).fill(0).reduce((memo) => {
        const text = new Array(columns).fill("\n").join("");
        return memo.insert(text, {
          table: tableId()
        });
      }, new import_quill_delta11.default().retain(range.index));
      this.quill.updateContents(delta, Quill.sources.USER);
      this.quill.setSelection(range.index, Quill.sources.SILENT);
      this.balanceTables();
    }
    listenBalanceCells() {
      this.quill.on(Quill.events.SCROLL_OPTIMIZE, (mutations) => {
        mutations.some((mutation) => {
          if (["TD", "TR", "TBODY", "TABLE"].includes(mutation.target.tagName)) {
            this.quill.once(Quill.events.TEXT_CHANGE, (delta, old, source) => {
              if (source !== Quill.sources.USER)
                return;
              this.balanceTables();
            });
            return true;
          }
          return false;
        });
      });
    }
  };
  var table_default = Table;

  // node_modules/quill/modules/toolbar.js
  var import_quill_delta12 = __toESM(require_Delta(), 1);
  var debug7 = logger_default2("quill:toolbar");
  var Toolbar = class extends module_default {
    static {
      __name(this, "Toolbar");
    }
    constructor(quill, options) {
      super(quill, options);
      if (Array.isArray(this.options.container)) {
        const container = document.createElement("div");
        container.setAttribute("role", "toolbar");
        addControls(container, this.options.container);
        quill.container?.parentNode?.insertBefore(container, quill.container);
        this.container = container;
      } else if (typeof this.options.container === "string") {
        this.container = document.querySelector(this.options.container);
      } else {
        this.container = this.options.container;
      }
      if (!(this.container instanceof HTMLElement)) {
        debug7.error("Container required for toolbar", this.options);
        return;
      }
      this.container.classList.add("ql-toolbar");
      this.controls = [];
      this.handlers = {};
      if (this.options.handlers) {
        Object.keys(this.options.handlers).forEach((format) => {
          const handler = this.options.handlers?.[format];
          if (handler) {
            this.addHandler(format, handler);
          }
        });
      }
      Array.from(this.container.querySelectorAll("button, select")).forEach((input) => {
        this.attach(input);
      });
      this.quill.on(Quill.events.EDITOR_CHANGE, () => {
        const [range] = this.quill.selection.getRange();
        this.update(range);
      });
    }
    addHandler(format, handler) {
      this.handlers[format] = handler;
    }
    attach(input) {
      let format = Array.from(input.classList).find((className) => {
        return className.indexOf("ql-") === 0;
      });
      if (!format)
        return;
      format = format.slice("ql-".length);
      if (input.tagName === "BUTTON") {
        input.setAttribute("type", "button");
      }
      if (this.handlers[format] == null && this.quill.scroll.query(format) == null) {
        debug7.warn("ignoring attaching to nonexistent format", format, input);
        return;
      }
      const eventName = input.tagName === "SELECT" ? "change" : "click";
      input.addEventListener(eventName, (e2) => {
        let value;
        if (input.tagName === "SELECT") {
          if (input.selectedIndex < 0)
            return;
          const selected = input.options[input.selectedIndex];
          if (selected.hasAttribute("selected")) {
            value = false;
          } else {
            value = selected.value || false;
          }
        } else {
          if (input.classList.contains("ql-active")) {
            value = false;
          } else {
            value = input.value || !input.hasAttribute("value");
          }
          e2.preventDefault();
        }
        this.quill.focus();
        const [range] = this.quill.selection.getRange();
        if (this.handlers[format] != null) {
          this.handlers[format].call(this, value);
        } else if (
          // @ts-expect-error
          this.quill.scroll.query(format).prototype instanceof EmbedBlot$1
        ) {
          value = prompt(`Enter ${format}`);
          if (!value)
            return;
          this.quill.updateContents(new import_quill_delta12.default().retain(range.index).delete(range.length).insert({
            [format]: value
          }), Quill.sources.USER);
        } else {
          this.quill.format(format, value, Quill.sources.USER);
        }
        this.update(range);
      });
      this.controls.push([format, input]);
    }
    update(range) {
      const formats2 = range == null ? {} : this.quill.getFormat(range);
      this.controls.forEach((pair) => {
        const [format, input] = pair;
        if (input.tagName === "SELECT") {
          let option = null;
          if (range == null) {
            option = null;
          } else if (formats2[format] == null) {
            option = input.querySelector("option[selected]");
          } else if (!Array.isArray(formats2[format])) {
            let value = formats2[format];
            if (typeof value === "string") {
              value = value.replace(/"/g, '\\"');
            }
            option = input.querySelector(`option[value="${value}"]`);
          }
          if (option == null) {
            input.value = "";
            input.selectedIndex = -1;
          } else {
            option.selected = true;
          }
        } else if (range == null) {
          input.classList.remove("ql-active");
          input.setAttribute("aria-pressed", "false");
        } else if (input.hasAttribute("value")) {
          const value = formats2[format];
          const isActive = value === input.getAttribute("value") || value != null && value.toString() === input.getAttribute("value") || value == null && !input.getAttribute("value");
          input.classList.toggle("ql-active", isActive);
          input.setAttribute("aria-pressed", isActive.toString());
        } else {
          const isActive = formats2[format] != null;
          input.classList.toggle("ql-active", isActive);
          input.setAttribute("aria-pressed", isActive.toString());
        }
      });
    }
  };
  Toolbar.DEFAULTS = {};
  function addButton(container, format, value) {
    const input = document.createElement("button");
    input.setAttribute("type", "button");
    input.classList.add(`ql-${format}`);
    input.setAttribute("aria-pressed", "false");
    if (value != null) {
      input.value = value;
      input.setAttribute("aria-label", `${format}: ${value}`);
    } else {
      input.setAttribute("aria-label", format);
    }
    container.appendChild(input);
  }
  __name(addButton, "addButton");
  function addControls(container, groups) {
    if (!Array.isArray(groups[0])) {
      groups = [groups];
    }
    groups.forEach((controls) => {
      const group = document.createElement("span");
      group.classList.add("ql-formats");
      controls.forEach((control) => {
        if (typeof control === "string") {
          addButton(group, control);
        } else {
          const format = Object.keys(control)[0];
          const value = control[format];
          if (Array.isArray(value)) {
            addSelect(group, format, value);
          } else {
            addButton(group, format, value);
          }
        }
      });
      container.appendChild(group);
    });
  }
  __name(addControls, "addControls");
  function addSelect(container, format, values) {
    const input = document.createElement("select");
    input.classList.add(`ql-${format}`);
    values.forEach((value) => {
      const option = document.createElement("option");
      if (value !== false) {
        option.setAttribute("value", String(value));
      } else {
        option.setAttribute("selected", "selected");
      }
      input.appendChild(option);
    });
    container.appendChild(input);
  }
  __name(addSelect, "addSelect");
  Toolbar.DEFAULTS = {
    container: null,
    handlers: {
      clean() {
        const range = this.quill.getSelection();
        if (range == null)
          return;
        if (range.length === 0) {
          const formats2 = this.quill.getFormat();
          Object.keys(formats2).forEach((name) => {
            if (this.quill.scroll.query(name, Scope.INLINE) != null) {
              this.quill.format(name, false, Quill.sources.USER);
            }
          });
        } else {
          this.quill.removeFormat(range, Quill.sources.USER);
        }
      },
      direction(value) {
        const {
          align
        } = this.quill.getFormat();
        if (value === "rtl" && align == null) {
          this.quill.format("align", "right", Quill.sources.USER);
        } else if (!value && align === "right") {
          this.quill.format("align", false, Quill.sources.USER);
        }
        this.quill.format("direction", value, Quill.sources.USER);
      },
      indent(value) {
        const range = this.quill.getSelection();
        const formats2 = this.quill.getFormat(range);
        const indent = parseInt(formats2.indent || 0, 10);
        if (value === "+1" || value === "-1") {
          let modifier = value === "+1" ? 1 : -1;
          if (formats2.direction === "rtl")
            modifier *= -1;
          this.quill.format("indent", indent + modifier, Quill.sources.USER);
        }
      },
      link(value) {
        if (value === true) {
          value = prompt("Enter link URL:");
        }
        this.quill.format("link", value, Quill.sources.USER);
      },
      list(value) {
        const range = this.quill.getSelection();
        const formats2 = this.quill.getFormat(range);
        if (value === "check") {
          if (formats2.list === "checked" || formats2.list === "unchecked") {
            this.quill.format("list", false, Quill.sources.USER);
          } else {
            this.quill.format("list", "unchecked", Quill.sources.USER);
          }
        } else {
          this.quill.format("list", value, Quill.sources.USER);
        }
      }
    }
  };

  // node_modules/quill/ui/icons.js
  var alignLeftIcon = '<svg viewbox="0 0 18 18"><line class="ql-stroke" x1="3" x2="15" y1="9" y2="9"/><line class="ql-stroke" x1="3" x2="13" y1="14" y2="14"/><line class="ql-stroke" x1="3" x2="9" y1="4" y2="4"/></svg>';
  var alignCenterIcon = '<svg viewbox="0 0 18 18"><line class="ql-stroke" x1="15" x2="3" y1="9" y2="9"/><line class="ql-stroke" x1="14" x2="4" y1="14" y2="14"/><line class="ql-stroke" x1="12" x2="6" y1="4" y2="4"/></svg>';
  var alignRightIcon = '<svg viewbox="0 0 18 18"><line class="ql-stroke" x1="15" x2="3" y1="9" y2="9"/><line class="ql-stroke" x1="15" x2="5" y1="14" y2="14"/><line class="ql-stroke" x1="15" x2="9" y1="4" y2="4"/></svg>';
  var alignJustifyIcon = '<svg viewbox="0 0 18 18"><line class="ql-stroke" x1="15" x2="3" y1="9" y2="9"/><line class="ql-stroke" x1="15" x2="3" y1="14" y2="14"/><line class="ql-stroke" x1="15" x2="3" y1="4" y2="4"/></svg>';
  var backgroundIcon = '<svg viewbox="0 0 18 18"><g class="ql-fill ql-color-label"><polygon points="6 6.868 6 6 5 6 5 7 5.942 7 6 6.868"/><rect height="1" width="1" x="4" y="4"/><polygon points="6.817 5 6 5 6 6 6.38 6 6.817 5"/><rect height="1" width="1" x="2" y="6"/><rect height="1" width="1" x="3" y="5"/><rect height="1" width="1" x="4" y="7"/><polygon points="4 11.439 4 11 3 11 3 12 3.755 12 4 11.439"/><rect height="1" width="1" x="2" y="12"/><rect height="1" width="1" x="2" y="9"/><rect height="1" width="1" x="2" y="15"/><polygon points="4.63 10 4 10 4 11 4.192 11 4.63 10"/><rect height="1" width="1" x="3" y="8"/><path d="M10.832,4.2L11,4.582V4H10.708A1.948,1.948,0,0,1,10.832,4.2Z"/><path d="M7,4.582L7.168,4.2A1.929,1.929,0,0,1,7.292,4H7V4.582Z"/><path d="M8,13H7.683l-0.351.8a1.933,1.933,0,0,1-.124.2H8V13Z"/><rect height="1" width="1" x="12" y="2"/><rect height="1" width="1" x="11" y="3"/><path d="M9,3H8V3.282A1.985,1.985,0,0,1,9,3Z"/><rect height="1" width="1" x="2" y="3"/><rect height="1" width="1" x="6" y="2"/><rect height="1" width="1" x="3" y="2"/><rect height="1" width="1" x="5" y="3"/><rect height="1" width="1" x="9" y="2"/><rect height="1" width="1" x="15" y="14"/><polygon points="13.447 10.174 13.469 10.225 13.472 10.232 13.808 11 14 11 14 10 13.37 10 13.447 10.174"/><rect height="1" width="1" x="13" y="7"/><rect height="1" width="1" x="15" y="5"/><rect height="1" width="1" x="14" y="6"/><rect height="1" width="1" x="15" y="8"/><rect height="1" width="1" x="14" y="9"/><path d="M3.775,14H3v1H4V14.314A1.97,1.97,0,0,1,3.775,14Z"/><rect height="1" width="1" x="14" y="3"/><polygon points="12 6.868 12 6 11.62 6 12 6.868"/><rect height="1" width="1" x="15" y="2"/><rect height="1" width="1" x="12" y="5"/><rect height="1" width="1" x="13" y="4"/><polygon points="12.933 9 13 9 13 8 12.495 8 12.933 9"/><rect height="1" width="1" x="9" y="14"/><rect height="1" width="1" x="8" y="15"/><path d="M6,14.926V15H7V14.316A1.993,1.993,0,0,1,6,14.926Z"/><rect height="1" width="1" x="5" y="15"/><path d="M10.668,13.8L10.317,13H10v1h0.792A1.947,1.947,0,0,1,10.668,13.8Z"/><rect height="1" width="1" x="11" y="15"/><path d="M14.332,12.2a1.99,1.99,0,0,1,.166.8H15V12H14.245Z"/><rect height="1" width="1" x="14" y="15"/><rect height="1" width="1" x="15" y="11"/></g><polyline class="ql-stroke" points="5.5 13 9 5 12.5 13"/><line class="ql-stroke" x1="11.63" x2="6.38" y1="11" y2="11"/></svg>';
  var blockquoteIcon = '<svg viewbox="0 0 18 18"><rect class="ql-fill ql-stroke" height="3" width="3" x="4" y="5"/><rect class="ql-fill ql-stroke" height="3" width="3" x="11" y="5"/><path class="ql-even ql-fill ql-stroke" d="M7,8c0,4.031-3,5-3,5"/><path class="ql-even ql-fill ql-stroke" d="M14,8c0,4.031-3,5-3,5"/></svg>';
  var boldIcon = '<svg viewbox="0 0 18 18"><path class="ql-stroke" d="M5,4H9.5A2.5,2.5,0,0,1,12,6.5v0A2.5,2.5,0,0,1,9.5,9H5A0,0,0,0,1,5,9V4A0,0,0,0,1,5,4Z"/><path class="ql-stroke" d="M5,9h5.5A2.5,2.5,0,0,1,13,11.5v0A2.5,2.5,0,0,1,10.5,14H5a0,0,0,0,1,0,0V9A0,0,0,0,1,5,9Z"/></svg>';
  var cleanIcon = '<svg class="" viewbox="0 0 18 18"><line class="ql-stroke" x1="5" x2="13" y1="3" y2="3"/><line class="ql-stroke" x1="6" x2="9.35" y1="12" y2="3"/><line class="ql-stroke" x1="11" x2="15" y1="11" y2="15"/><line class="ql-stroke" x1="15" x2="11" y1="11" y2="15"/><rect class="ql-fill" height="1" rx="0.5" ry="0.5" width="7" x="2" y="14"/></svg>';
  var codeIcon = '<svg viewbox="0 0 18 18"><polyline class="ql-even ql-stroke" points="5 7 3 9 5 11"/><polyline class="ql-even ql-stroke" points="13 7 15 9 13 11"/><line class="ql-stroke" x1="10" x2="8" y1="5" y2="13"/></svg>';
  var colorIcon = '<svg viewbox="0 0 18 18"><line class="ql-color-label ql-stroke ql-transparent" x1="3" x2="15" y1="15" y2="15"/><polyline class="ql-stroke" points="5.5 11 9 3 12.5 11"/><line class="ql-stroke" x1="11.63" x2="6.38" y1="9" y2="9"/></svg>';
  var directionLeftToRightIcon = '<svg viewbox="0 0 18 18"><polygon class="ql-stroke ql-fill" points="3 11 5 9 3 7 3 11"/><line class="ql-stroke ql-fill" x1="15" x2="11" y1="4" y2="4"/><path class="ql-fill" d="M11,3a3,3,0,0,0,0,6h1V3H11Z"/><rect class="ql-fill" height="11" width="1" x="11" y="4"/><rect class="ql-fill" height="11" width="1" x="13" y="4"/></svg>';
  var directionRightToLeftIcon = '<svg viewbox="0 0 18 18"><polygon class="ql-stroke ql-fill" points="15 12 13 10 15 8 15 12"/><line class="ql-stroke ql-fill" x1="9" x2="5" y1="4" y2="4"/><path class="ql-fill" d="M5,3A3,3,0,0,0,5,9H6V3H5Z"/><rect class="ql-fill" height="11" width="1" x="5" y="4"/><rect class="ql-fill" height="11" width="1" x="7" y="4"/></svg>';
  var formulaIcon = '<svg viewbox="0 0 18 18"><path class="ql-fill" d="M11.759,2.482a2.561,2.561,0,0,0-3.53.607A7.656,7.656,0,0,0,6.8,6.2C6.109,9.188,5.275,14.677,4.15,14.927a1.545,1.545,0,0,0-1.3-.933A0.922,0.922,0,0,0,2,15.036S1.954,16,4.119,16s3.091-2.691,3.7-5.553c0.177-.826.36-1.726,0.554-2.6L8.775,6.2c0.381-1.421.807-2.521,1.306-2.676a1.014,1.014,0,0,0,1.02.56A0.966,0.966,0,0,0,11.759,2.482Z"/><rect class="ql-fill" height="1.6" rx="0.8" ry="0.8" width="5" x="5.15" y="6.2"/><path class="ql-fill" d="M13.663,12.027a1.662,1.662,0,0,1,.266-0.276q0.193,0.069.456,0.138a2.1,2.1,0,0,0,.535.069,1.075,1.075,0,0,0,.767-0.3,1.044,1.044,0,0,0,.314-0.8,0.84,0.84,0,0,0-.238-0.619,0.8,0.8,0,0,0-.594-0.239,1.154,1.154,0,0,0-.781.3,4.607,4.607,0,0,0-.781,1q-0.091.15-.218,0.346l-0.246.38c-0.068-.288-0.137-0.582-0.212-0.885-0.459-1.847-2.494-.984-2.941-0.8-0.482.2-.353,0.647-0.094,0.529a0.869,0.869,0,0,1,1.281.585c0.217,0.751.377,1.436,0.527,2.038a5.688,5.688,0,0,1-.362.467,2.69,2.69,0,0,1-.264.271q-0.221-.08-0.471-0.147a2.029,2.029,0,0,0-.522-0.066,1.079,1.079,0,0,0-.768.3A1.058,1.058,0,0,0,9,15.131a0.82,0.82,0,0,0,.832.852,1.134,1.134,0,0,0,.787-0.3,5.11,5.11,0,0,0,.776-0.993q0.141-.219.215-0.34c0.046-.076.122-0.194,0.223-0.346a2.786,2.786,0,0,0,.918,1.726,2.582,2.582,0,0,0,2.376-.185c0.317-.181.212-0.565,0-0.494A0.807,0.807,0,0,1,14.176,15a5.159,5.159,0,0,1-.913-2.446l0,0Q13.487,12.24,13.663,12.027Z"/></svg>';
  var headerIcon = '<svg viewBox="0 0 18 18"><path class="ql-fill" d="M10,4V14a1,1,0,0,1-2,0V10H3v4a1,1,0,0,1-2,0V4A1,1,0,0,1,3,4V8H8V4a1,1,0,0,1,2,0Zm6.06787,9.209H14.98975V7.59863a.54085.54085,0,0,0-.605-.60547h-.62744a1.01119,1.01119,0,0,0-.748.29688L11.645,8.56641a.5435.5435,0,0,0-.022.8584l.28613.30762a.53861.53861,0,0,0,.84717.0332l.09912-.08789a1.2137,1.2137,0,0,0,.2417-.35254h.02246s-.01123.30859-.01123.60547V13.209H12.041a.54085.54085,0,0,0-.605.60547v.43945a.54085.54085,0,0,0,.605.60547h4.02686a.54085.54085,0,0,0,.605-.60547v-.43945A.54085.54085,0,0,0,16.06787,13.209Z"/></svg>';
  var header2Icon = '<svg viewBox="0 0 18 18"><path class="ql-fill" d="M16.73975,13.81445v.43945a.54085.54085,0,0,1-.605.60547H11.855a.58392.58392,0,0,1-.64893-.60547V14.0127c0-2.90527,3.39941-3.42187,3.39941-4.55469a.77675.77675,0,0,0-.84717-.78125,1.17684,1.17684,0,0,0-.83594.38477c-.2749.26367-.561.374-.85791.13184l-.4292-.34082c-.30811-.24219-.38525-.51758-.1543-.81445a2.97155,2.97155,0,0,1,2.45361-1.17676,2.45393,2.45393,0,0,1,2.68408,2.40918c0,2.45312-3.1792,2.92676-3.27832,3.93848h2.79443A.54085.54085,0,0,1,16.73975,13.81445ZM9,3A.99974.99974,0,0,0,8,4V8H3V4A1,1,0,0,0,1,4V14a1,1,0,0,0,2,0V10H8v4a1,1,0,0,0,2,0V4A.99974.99974,0,0,0,9,3Z"/></svg>';
  var italicIcon = '<svg viewbox="0 0 18 18"><line class="ql-stroke" x1="7" x2="13" y1="4" y2="4"/><line class="ql-stroke" x1="5" x2="11" y1="14" y2="14"/><line class="ql-stroke" x1="8" x2="10" y1="14" y2="4"/></svg>';
  var imageIcon = '<svg viewbox="0 0 18 18"><rect class="ql-stroke" height="10" width="12" x="3" y="4"/><circle class="ql-fill" cx="6" cy="7" r="1"/><polyline class="ql-even ql-fill" points="5 12 5 11 7 9 8 10 11 7 13 9 13 12 5 12"/></svg>';
  var indentIcon = '<svg viewbox="0 0 18 18"><line class="ql-stroke" x1="3" x2="15" y1="14" y2="14"/><line class="ql-stroke" x1="3" x2="15" y1="4" y2="4"/><line class="ql-stroke" x1="9" x2="15" y1="9" y2="9"/><polyline class="ql-fill ql-stroke" points="3 7 3 11 5 9 3 7"/></svg>';
  var outdentIcon = '<svg viewbox="0 0 18 18"><line class="ql-stroke" x1="3" x2="15" y1="14" y2="14"/><line class="ql-stroke" x1="3" x2="15" y1="4" y2="4"/><line class="ql-stroke" x1="9" x2="15" y1="9" y2="9"/><polyline class="ql-stroke" points="5 7 5 11 3 9 5 7"/></svg>';
  var linkIcon = '<svg viewbox="0 0 18 18"><line class="ql-stroke" x1="7" x2="11" y1="7" y2="11"/><path class="ql-even ql-stroke" d="M8.9,4.577a3.476,3.476,0,0,1,.36,4.679A3.476,3.476,0,0,1,4.577,8.9C3.185,7.5,2.035,6.4,4.217,4.217S7.5,3.185,8.9,4.577Z"/><path class="ql-even ql-stroke" d="M13.423,9.1a3.476,3.476,0,0,0-4.679-.36,3.476,3.476,0,0,0,.36,4.679c1.392,1.392,2.5,2.542,4.679.36S14.815,10.5,13.423,9.1Z"/></svg>';
  var listBulletIcon = '<svg viewbox="0 0 18 18"><line class="ql-stroke" x1="6" x2="15" y1="4" y2="4"/><line class="ql-stroke" x1="6" x2="15" y1="9" y2="9"/><line class="ql-stroke" x1="6" x2="15" y1="14" y2="14"/><line class="ql-stroke" x1="3" x2="3" y1="4" y2="4"/><line class="ql-stroke" x1="3" x2="3" y1="9" y2="9"/><line class="ql-stroke" x1="3" x2="3" y1="14" y2="14"/></svg>';
  var listCheckIcon = '<svg class="" viewbox="0 0 18 18"><line class="ql-stroke" x1="9" x2="15" y1="4" y2="4"/><polyline class="ql-stroke" points="3 4 4 5 6 3"/><line class="ql-stroke" x1="9" x2="15" y1="14" y2="14"/><polyline class="ql-stroke" points="3 14 4 15 6 13"/><line class="ql-stroke" x1="9" x2="15" y1="9" y2="9"/><polyline class="ql-stroke" points="3 9 4 10 6 8"/></svg>';
  var listOrderedIcon = '<svg viewbox="0 0 18 18"><line class="ql-stroke" x1="7" x2="15" y1="4" y2="4"/><line class="ql-stroke" x1="7" x2="15" y1="9" y2="9"/><line class="ql-stroke" x1="7" x2="15" y1="14" y2="14"/><line class="ql-stroke ql-thin" x1="2.5" x2="4.5" y1="5.5" y2="5.5"/><path class="ql-fill" d="M3.5,6A0.5,0.5,0,0,1,3,5.5V3.085l-0.276.138A0.5,0.5,0,0,1,2.053,3c-0.124-.247-0.023-0.324.224-0.447l1-.5A0.5,0.5,0,0,1,4,2.5v3A0.5,0.5,0,0,1,3.5,6Z"/><path class="ql-stroke ql-thin" d="M4.5,10.5h-2c0-.234,1.85-1.076,1.85-2.234A0.959,0.959,0,0,0,2.5,8.156"/><path class="ql-stroke ql-thin" d="M2.5,14.846a0.959,0.959,0,0,0,1.85-.109A0.7,0.7,0,0,0,3.75,14a0.688,0.688,0,0,0,.6-0.736,0.959,0.959,0,0,0-1.85-.109"/></svg>';
  var subscriptIcon = '<svg viewbox="0 0 18 18"><path class="ql-fill" d="M15.5,15H13.861a3.858,3.858,0,0,0,1.914-2.975,1.8,1.8,0,0,0-1.6-1.751A1.921,1.921,0,0,0,12.021,11.7a0.50013,0.50013,0,1,0,.957.291h0a0.914,0.914,0,0,1,1.053-.725,0.81,0.81,0,0,1,.744.762c0,1.076-1.16971,1.86982-1.93971,2.43082A1.45639,1.45639,0,0,0,12,15.5a0.5,0.5,0,0,0,.5.5h3A0.5,0.5,0,0,0,15.5,15Z"/><path class="ql-fill" d="M9.65,5.241a1,1,0,0,0-1.409.108L6,7.964,3.759,5.349A1,1,0,0,0,2.192,6.59178Q2.21541,6.6213,2.241,6.649L4.684,9.5,2.241,12.35A1,1,0,0,0,3.71,13.70722q0.02557-.02768.049-0.05722L6,11.036,8.241,13.65a1,1,0,1,0,1.567-1.24277Q9.78459,12.3777,9.759,12.35L7.316,9.5,9.759,6.651A1,1,0,0,0,9.65,5.241Z"/></svg>';
  var superscriptIcon = '<svg viewbox="0 0 18 18"><path class="ql-fill" d="M15.5,7H13.861a4.015,4.015,0,0,0,1.914-2.975,1.8,1.8,0,0,0-1.6-1.751A1.922,1.922,0,0,0,12.021,3.7a0.5,0.5,0,1,0,.957.291,0.917,0.917,0,0,1,1.053-.725,0.81,0.81,0,0,1,.744.762c0,1.077-1.164,1.925-1.934,2.486A1.423,1.423,0,0,0,12,7.5a0.5,0.5,0,0,0,.5.5h3A0.5,0.5,0,0,0,15.5,7Z"/><path class="ql-fill" d="M9.651,5.241a1,1,0,0,0-1.41.108L6,7.964,3.759,5.349a1,1,0,1,0-1.519,1.3L4.683,9.5,2.241,12.35a1,1,0,1,0,1.519,1.3L6,11.036,8.241,13.65a1,1,0,0,0,1.519-1.3L7.317,9.5,9.759,6.651A1,1,0,0,0,9.651,5.241Z"/></svg>';
  var strikeIcon = '<svg viewbox="0 0 18 18"><line class="ql-stroke ql-thin" x1="15.5" x2="2.5" y1="8.5" y2="9.5"/><path class="ql-fill" d="M9.007,8C6.542,7.791,6,7.519,6,6.5,6,5.792,7.283,5,9,5c1.571,0,2.765.679,2.969,1.309a1,1,0,0,0,1.9-.617C13.356,4.106,11.354,3,9,3,6.2,3,4,4.538,4,6.5a3.2,3.2,0,0,0,.5,1.843Z"/><path class="ql-fill" d="M8.984,10C11.457,10.208,12,10.479,12,11.5c0,0.708-1.283,1.5-3,1.5-1.571,0-2.765-.679-2.969-1.309a1,1,0,1,0-1.9.617C4.644,13.894,6.646,15,9,15c2.8,0,5-1.538,5-3.5a3.2,3.2,0,0,0-.5-1.843Z"/></svg>';
  var tableIcon = '<svg viewbox="0 0 18 18"><rect class="ql-stroke" height="12" width="12" x="3" y="3"/><rect class="ql-fill" height="2" width="3" x="5" y="5"/><rect class="ql-fill" height="2" width="4" x="9" y="5"/><g class="ql-fill ql-transparent"><rect height="2" width="3" x="5" y="8"/><rect height="2" width="4" x="9" y="8"/><rect height="2" width="3" x="5" y="11"/><rect height="2" width="4" x="9" y="11"/></g></svg>';
  var underlineIcon = '<svg viewbox="0 0 18 18"><path class="ql-stroke" d="M5,3V9a4.012,4.012,0,0,0,4,4H9a4.012,4.012,0,0,0,4-4V3"/><rect class="ql-fill" height="1" rx="0.5" ry="0.5" width="12" x="3" y="15"/></svg>';
  var videoIcon = '<svg viewbox="0 0 18 18"><rect class="ql-stroke" height="12" width="12" x="3" y="3"/><rect class="ql-fill" height="12" width="1" x="5" y="3"/><rect class="ql-fill" height="12" width="1" x="12" y="3"/><rect class="ql-fill" height="2" width="8" x="5" y="8"/><rect class="ql-fill" height="1" width="3" x="3" y="5"/><rect class="ql-fill" height="1" width="3" x="3" y="7"/><rect class="ql-fill" height="1" width="3" x="3" y="10"/><rect class="ql-fill" height="1" width="3" x="3" y="12"/><rect class="ql-fill" height="1" width="3" x="12" y="5"/><rect class="ql-fill" height="1" width="3" x="12" y="7"/><rect class="ql-fill" height="1" width="3" x="12" y="10"/><rect class="ql-fill" height="1" width="3" x="12" y="12"/></svg>';
  var icons_default = {
    align: {
      "": alignLeftIcon,
      center: alignCenterIcon,
      right: alignRightIcon,
      justify: alignJustifyIcon
    },
    background: backgroundIcon,
    blockquote: blockquoteIcon,
    bold: boldIcon,
    clean: cleanIcon,
    code: codeIcon,
    "code-block": codeIcon,
    color: colorIcon,
    direction: {
      "": directionLeftToRightIcon,
      rtl: directionRightToLeftIcon
    },
    formula: formulaIcon,
    header: {
      "1": headerIcon,
      "2": header2Icon
    },
    italic: italicIcon,
    image: imageIcon,
    indent: {
      "+1": indentIcon,
      "-1": outdentIcon
    },
    link: linkIcon,
    list: {
      bullet: listBulletIcon,
      check: listCheckIcon,
      ordered: listOrderedIcon
    },
    script: {
      sub: subscriptIcon,
      super: superscriptIcon
    },
    strike: strikeIcon,
    table: tableIcon,
    underline: underlineIcon,
    video: videoIcon
  };

  // node_modules/quill/ui/picker.js
  var DropdownIcon = '<svg viewbox="0 0 18 18"><polygon class="ql-stroke" points="7 11 9 13 11 11 7 11"/><polygon class="ql-stroke" points="7 7 9 5 11 7 7 7"/></svg>';
  var optionsCounter = 0;
  function toggleAriaAttribute(element, attribute) {
    element.setAttribute(attribute, `${!(element.getAttribute(attribute) === "true")}`);
  }
  __name(toggleAriaAttribute, "toggleAriaAttribute");
  var Picker = class {
    static {
      __name(this, "Picker");
    }
    constructor(select) {
      this.select = select;
      this.container = document.createElement("span");
      this.buildPicker();
      this.select.style.display = "none";
      this.select.parentNode.insertBefore(this.container, this.select);
      this.label.addEventListener("mousedown", () => {
        this.togglePicker();
      });
      this.label.addEventListener("keydown", (event) => {
        switch (event.key) {
          case "Enter":
            this.togglePicker();
            break;
          case "Escape":
            this.escape();
            event.preventDefault();
            break;
          default:
        }
      });
      this.select.addEventListener("change", this.update.bind(this));
    }
    togglePicker() {
      this.container.classList.toggle("ql-expanded");
      toggleAriaAttribute(this.label, "aria-expanded");
      toggleAriaAttribute(this.options, "aria-hidden");
    }
    buildItem(option) {
      const item = document.createElement("span");
      item.tabIndex = "0";
      item.setAttribute("role", "button");
      item.classList.add("ql-picker-item");
      const value = option.getAttribute("value");
      if (value) {
        item.setAttribute("data-value", value);
      }
      if (option.textContent) {
        item.setAttribute("data-label", option.textContent);
      }
      item.addEventListener("click", () => {
        this.selectItem(item, true);
      });
      item.addEventListener("keydown", (event) => {
        switch (event.key) {
          case "Enter":
            this.selectItem(item, true);
            event.preventDefault();
            break;
          case "Escape":
            this.escape();
            event.preventDefault();
            break;
          default:
        }
      });
      return item;
    }
    buildLabel() {
      const label = document.createElement("span");
      label.classList.add("ql-picker-label");
      label.innerHTML = DropdownIcon;
      label.tabIndex = "0";
      label.setAttribute("role", "button");
      label.setAttribute("aria-expanded", "false");
      this.container.appendChild(label);
      return label;
    }
    buildOptions() {
      const options = document.createElement("span");
      options.classList.add("ql-picker-options");
      options.setAttribute("aria-hidden", "true");
      options.tabIndex = "-1";
      options.id = `ql-picker-options-${optionsCounter}`;
      optionsCounter += 1;
      this.label.setAttribute("aria-controls", options.id);
      this.options = options;
      Array.from(this.select.options).forEach((option) => {
        const item = this.buildItem(option);
        options.appendChild(item);
        if (option.selected === true) {
          this.selectItem(item);
        }
      });
      this.container.appendChild(options);
    }
    buildPicker() {
      Array.from(this.select.attributes).forEach((item) => {
        this.container.setAttribute(item.name, item.value);
      });
      this.container.classList.add("ql-picker");
      this.label = this.buildLabel();
      this.buildOptions();
    }
    escape() {
      this.close();
      setTimeout(() => this.label.focus(), 1);
    }
    close() {
      this.container.classList.remove("ql-expanded");
      this.label.setAttribute("aria-expanded", "false");
      this.options.setAttribute("aria-hidden", "true");
    }
    selectItem(item) {
      let trigger = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      const selected = this.container.querySelector(".ql-selected");
      if (item === selected)
        return;
      if (selected != null) {
        selected.classList.remove("ql-selected");
      }
      if (item == null)
        return;
      item.classList.add("ql-selected");
      this.select.selectedIndex = Array.from(item.parentNode.children).indexOf(item);
      if (item.hasAttribute("data-value")) {
        this.label.setAttribute("data-value", item.getAttribute("data-value"));
      } else {
        this.label.removeAttribute("data-value");
      }
      if (item.hasAttribute("data-label")) {
        this.label.setAttribute("data-label", item.getAttribute("data-label"));
      } else {
        this.label.removeAttribute("data-label");
      }
      if (trigger) {
        this.select.dispatchEvent(new Event("change"));
        this.close();
      }
    }
    update() {
      let option;
      if (this.select.selectedIndex > -1) {
        const item = (
          // @ts-expect-error Fix me later
          this.container.querySelector(".ql-picker-options").children[this.select.selectedIndex]
        );
        option = this.select.options[this.select.selectedIndex];
        this.selectItem(item);
      } else {
        this.selectItem(null);
      }
      const isActive = option != null && option !== this.select.querySelector("option[selected]");
      this.label.classList.toggle("ql-active", isActive);
    }
  };
  var picker_default = Picker;

  // node_modules/quill/ui/color-picker.js
  var ColorPicker = class extends picker_default {
    static {
      __name(this, "ColorPicker");
    }
    constructor(select, label) {
      super(select);
      this.label.innerHTML = label;
      this.container.classList.add("ql-color-picker");
      Array.from(this.container.querySelectorAll(".ql-picker-item")).slice(0, 7).forEach((item) => {
        item.classList.add("ql-primary");
      });
    }
    buildItem(option) {
      const item = super.buildItem(option);
      item.style.backgroundColor = option.getAttribute("value") || "";
      return item;
    }
    selectItem(item, trigger) {
      super.selectItem(item, trigger);
      const colorLabel = this.label.querySelector(".ql-color-label");
      const value = item ? item.getAttribute("data-value") || "" : "";
      if (colorLabel) {
        if (colorLabel.tagName === "line") {
          colorLabel.style.stroke = value;
        } else {
          colorLabel.style.fill = value;
        }
      }
    }
  };
  var color_picker_default = ColorPicker;

  // node_modules/quill/ui/icon-picker.js
  var IconPicker = class extends picker_default {
    static {
      __name(this, "IconPicker");
    }
    constructor(select, icons) {
      super(select);
      this.container.classList.add("ql-icon-picker");
      Array.from(this.container.querySelectorAll(".ql-picker-item")).forEach((item) => {
        item.innerHTML = icons[item.getAttribute("data-value") || ""];
      });
      this.defaultItem = this.container.querySelector(".ql-selected");
      this.selectItem(this.defaultItem);
    }
    selectItem(target, trigger) {
      super.selectItem(target, trigger);
      const item = target || this.defaultItem;
      if (item != null) {
        if (this.label.innerHTML === item.innerHTML)
          return;
        this.label.innerHTML = item.innerHTML;
      }
    }
  };
  var icon_picker_default = IconPicker;

  // node_modules/quill/ui/tooltip.js
  var isScrollable = /* @__PURE__ */ __name((el) => {
    const {
      overflowY
    } = getComputedStyle(el, null);
    return overflowY !== "visible" && overflowY !== "clip";
  }, "isScrollable");
  var Tooltip = class {
    static {
      __name(this, "Tooltip");
    }
    constructor(quill, boundsContainer) {
      this.quill = quill;
      this.boundsContainer = boundsContainer || document.body;
      this.root = quill.addContainer("ql-tooltip");
      this.root.innerHTML = this.constructor.TEMPLATE;
      if (isScrollable(this.quill.root)) {
        this.quill.root.addEventListener("scroll", () => {
          this.root.style.marginTop = `${-1 * this.quill.root.scrollTop}px`;
        });
      }
      this.hide();
    }
    hide() {
      this.root.classList.add("ql-hidden");
    }
    position(reference) {
      const left = reference.left + reference.width / 2 - this.root.offsetWidth / 2;
      const top = reference.bottom + this.quill.root.scrollTop;
      this.root.style.left = `${left}px`;
      this.root.style.top = `${top}px`;
      this.root.classList.remove("ql-flip");
      const containerBounds = this.boundsContainer.getBoundingClientRect();
      const rootBounds = this.root.getBoundingClientRect();
      let shift = 0;
      if (rootBounds.right > containerBounds.right) {
        shift = containerBounds.right - rootBounds.right;
        this.root.style.left = `${left + shift}px`;
      }
      if (rootBounds.left < containerBounds.left) {
        shift = containerBounds.left - rootBounds.left;
        this.root.style.left = `${left + shift}px`;
      }
      if (rootBounds.bottom > containerBounds.bottom) {
        const height = rootBounds.bottom - rootBounds.top;
        const verticalShift = reference.bottom - reference.top + height;
        this.root.style.top = `${top - verticalShift}px`;
        this.root.classList.add("ql-flip");
      }
      return shift;
    }
    show() {
      this.root.classList.remove("ql-editing");
      this.root.classList.remove("ql-hidden");
    }
  };
  var tooltip_default = Tooltip;

  // node_modules/quill/themes/base.js
  var ALIGNS = [false, "center", "right", "justify"];
  var COLORS = ["#000000", "#e60000", "#ff9900", "#ffff00", "#008a00", "#0066cc", "#9933ff", "#ffffff", "#facccc", "#ffebcc", "#ffffcc", "#cce8cc", "#cce0f5", "#ebd6ff", "#bbbbbb", "#f06666", "#ffc266", "#ffff66", "#66b966", "#66a3e0", "#c285ff", "#888888", "#a10000", "#b26b00", "#b2b200", "#006100", "#0047b2", "#6b24b2", "#444444", "#5c0000", "#663d00", "#666600", "#003700", "#002966", "#3d1466"];
  var FONTS = [false, "serif", "monospace"];
  var HEADERS = ["1", "2", "3", false];
  var SIZES = ["small", false, "large", "huge"];
  var BaseTheme = class extends theme_default {
    static {
      __name(this, "BaseTheme");
    }
    constructor(quill, options) {
      super(quill, options);
      const listener = /* @__PURE__ */ __name((e2) => {
        if (!document.body.contains(quill.root)) {
          document.body.removeEventListener("click", listener);
          return;
        }
        if (this.tooltip != null && // @ts-expect-error
        !this.tooltip.root.contains(e2.target) && // @ts-expect-error
        document.activeElement !== this.tooltip.textbox && !this.quill.hasFocus()) {
          this.tooltip.hide();
        }
        if (this.pickers != null) {
          this.pickers.forEach((picker) => {
            if (!picker.container.contains(e2.target)) {
              picker.close();
            }
          });
        }
      }, "listener");
      quill.emitter.listenDOM("click", document.body, listener);
    }
    addModule(name) {
      const module2 = super.addModule(name);
      if (name === "toolbar") {
        this.extendToolbar(module2);
      }
      return module2;
    }
    buildButtons(buttons, icons) {
      Array.from(buttons).forEach((button) => {
        const className = button.getAttribute("class") || "";
        className.split(/\s+/).forEach((name) => {
          if (!name.startsWith("ql-"))
            return;
          name = name.slice("ql-".length);
          if (icons[name] == null)
            return;
          if (name === "direction") {
            button.innerHTML = icons[name][""] + icons[name].rtl;
          } else if (typeof icons[name] === "string") {
            button.innerHTML = icons[name];
          } else {
            const value = button.value || "";
            if (value != null && icons[name][value]) {
              button.innerHTML = icons[name][value];
            }
          }
        });
      });
    }
    buildPickers(selects, icons) {
      this.pickers = Array.from(selects).map((select) => {
        if (select.classList.contains("ql-align")) {
          if (select.querySelector("option") == null) {
            fillSelect(select, ALIGNS);
          }
          if (typeof icons.align === "object") {
            return new icon_picker_default(select, icons.align);
          }
        }
        if (select.classList.contains("ql-background") || select.classList.contains("ql-color")) {
          const format = select.classList.contains("ql-background") ? "background" : "color";
          if (select.querySelector("option") == null) {
            fillSelect(select, COLORS, format === "background" ? "#ffffff" : "#000000");
          }
          return new color_picker_default(select, icons[format]);
        }
        if (select.querySelector("option") == null) {
          if (select.classList.contains("ql-font")) {
            fillSelect(select, FONTS);
          } else if (select.classList.contains("ql-header")) {
            fillSelect(select, HEADERS);
          } else if (select.classList.contains("ql-size")) {
            fillSelect(select, SIZES);
          }
        }
        return new picker_default(select);
      });
      const update = /* @__PURE__ */ __name(() => {
        this.pickers.forEach((picker) => {
          picker.update();
        });
      }, "update");
      this.quill.on(emitter_default.events.EDITOR_CHANGE, update);
    }
  };
  BaseTheme.DEFAULTS = merge_default({}, theme_default.DEFAULTS, {
    modules: {
      toolbar: {
        handlers: {
          formula() {
            this.quill.theme.tooltip.edit("formula");
          },
          image() {
            let fileInput = this.container.querySelector("input.ql-image[type=file]");
            if (fileInput == null) {
              fileInput = document.createElement("input");
              fileInput.setAttribute("type", "file");
              fileInput.setAttribute("accept", this.quill.uploader.options.mimetypes.join(", "));
              fileInput.classList.add("ql-image");
              fileInput.addEventListener("change", () => {
                const range = this.quill.getSelection(true);
                this.quill.uploader.upload(range, fileInput.files);
                fileInput.value = "";
              });
              this.container.appendChild(fileInput);
            }
            fileInput.click();
          },
          video() {
            this.quill.theme.tooltip.edit("video");
          }
        }
      }
    }
  });
  var BaseTooltip = class extends tooltip_default {
    static {
      __name(this, "BaseTooltip");
    }
    constructor(quill, boundsContainer) {
      super(quill, boundsContainer);
      this.textbox = this.root.querySelector('input[type="text"]');
      this.listen();
    }
    listen() {
      this.textbox.addEventListener("keydown", (event) => {
        if (event.key === "Enter") {
          this.save();
          event.preventDefault();
        } else if (event.key === "Escape") {
          this.cancel();
          event.preventDefault();
        }
      });
    }
    cancel() {
      this.hide();
      this.restoreFocus();
    }
    edit() {
      let mode = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "link";
      let preview = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
      this.root.classList.remove("ql-hidden");
      this.root.classList.add("ql-editing");
      if (this.textbox == null)
        return;
      if (preview != null) {
        this.textbox.value = preview;
      } else if (mode !== this.root.getAttribute("data-mode")) {
        this.textbox.value = "";
      }
      const bounds = this.quill.getBounds(this.quill.selection.savedRange);
      if (bounds != null) {
        this.position(bounds);
      }
      this.textbox.select();
      this.textbox.setAttribute("placeholder", this.textbox.getAttribute(`data-${mode}`) || "");
      this.root.setAttribute("data-mode", mode);
    }
    restoreFocus() {
      this.quill.focus({
        preventScroll: true
      });
    }
    save() {
      let {
        value
      } = this.textbox;
      switch (this.root.getAttribute("data-mode")) {
        case "link": {
          const {
            scrollTop
          } = this.quill.root;
          if (this.linkRange) {
            this.quill.formatText(this.linkRange, "link", value, emitter_default.sources.USER);
            delete this.linkRange;
          } else {
            this.restoreFocus();
            this.quill.format("link", value, emitter_default.sources.USER);
          }
          this.quill.root.scrollTop = scrollTop;
          break;
        }
        case "video": {
          value = extractVideoUrl(value);
        }
        case "formula": {
          if (!value)
            break;
          const range = this.quill.getSelection(true);
          if (range != null) {
            const index = range.index + range.length;
            this.quill.insertEmbed(
              index,
              // @ts-expect-error Fix me later
              this.root.getAttribute("data-mode"),
              value,
              emitter_default.sources.USER
            );
            if (this.root.getAttribute("data-mode") === "formula") {
              this.quill.insertText(index + 1, " ", emitter_default.sources.USER);
            }
            this.quill.setSelection(index + 2, emitter_default.sources.USER);
          }
          break;
        }
        default:
      }
      this.textbox.value = "";
      this.hide();
    }
  };
  function extractVideoUrl(url) {
    let match2 = url.match(/^(?:(https?):\/\/)?(?:(?:www|m)\.)?youtube\.com\/watch.*v=([a-zA-Z0-9_-]+)/) || url.match(/^(?:(https?):\/\/)?(?:(?:www|m)\.)?youtu\.be\/([a-zA-Z0-9_-]+)/);
    if (match2) {
      return `${match2[1] || "https"}://www.youtube.com/embed/${match2[2]}?showinfo=0`;
    }
    if (match2 = url.match(/^(?:(https?):\/\/)?(?:www\.)?vimeo\.com\/(\d+)/)) {
      return `${match2[1] || "https"}://player.vimeo.com/video/${match2[2]}/`;
    }
    return url;
  }
  __name(extractVideoUrl, "extractVideoUrl");
  function fillSelect(select, values) {
    let defaultValue = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    values.forEach((value) => {
      const option = document.createElement("option");
      if (value === defaultValue) {
        option.setAttribute("selected", "selected");
      } else {
        option.setAttribute("value", String(value));
      }
      select.appendChild(option);
    });
  }
  __name(fillSelect, "fillSelect");

  // node_modules/quill/themes/bubble.js
  var TOOLBAR_CONFIG = [["bold", "italic", "link"], [{
    header: 1
  }, {
    header: 2
  }, "blockquote"]];
  var BubbleTooltip = class extends BaseTooltip {
    static {
      __name(this, "BubbleTooltip");
    }
    static TEMPLATE = ['<span class="ql-tooltip-arrow"></span>', '<div class="ql-tooltip-editor">', '<input type="text" data-formula="e=mc^2" data-link="https://quilljs.com" data-video="Embed URL">', '<a class="ql-close"></a>', "</div>"].join("");
    constructor(quill, bounds) {
      super(quill, bounds);
      this.quill.on(emitter_default.events.EDITOR_CHANGE, (type, range, oldRange, source) => {
        if (type !== emitter_default.events.SELECTION_CHANGE)
          return;
        if (range != null && range.length > 0 && source === emitter_default.sources.USER) {
          this.show();
          this.root.style.left = "0px";
          this.root.style.width = "";
          this.root.style.width = `${this.root.offsetWidth}px`;
          const lines = this.quill.getLines(range.index, range.length);
          if (lines.length === 1) {
            const bounds2 = this.quill.getBounds(range);
            if (bounds2 != null) {
              this.position(bounds2);
            }
          } else {
            const lastLine = lines[lines.length - 1];
            const index = this.quill.getIndex(lastLine);
            const length = Math.min(lastLine.length() - 1, range.index + range.length - index);
            const indexBounds = this.quill.getBounds(new Range(index, length));
            if (indexBounds != null) {
              this.position(indexBounds);
            }
          }
        } else if (document.activeElement !== this.textbox && this.quill.hasFocus()) {
          this.hide();
        }
      });
    }
    listen() {
      super.listen();
      this.root.querySelector(".ql-close").addEventListener("click", () => {
        this.root.classList.remove("ql-editing");
      });
      this.quill.on(emitter_default.events.SCROLL_OPTIMIZE, () => {
        setTimeout(() => {
          if (this.root.classList.contains("ql-hidden"))
            return;
          const range = this.quill.getSelection();
          if (range != null) {
            const bounds = this.quill.getBounds(range);
            if (bounds != null) {
              this.position(bounds);
            }
          }
        }, 1);
      });
    }
    cancel() {
      this.show();
    }
    position(reference) {
      const shift = super.position(reference);
      const arrow = this.root.querySelector(".ql-tooltip-arrow");
      arrow.style.marginLeft = "";
      if (shift !== 0) {
        arrow.style.marginLeft = `${-1 * shift - arrow.offsetWidth / 2}px`;
      }
      return shift;
    }
  };
  var BubbleTheme = class extends BaseTheme {
    static {
      __name(this, "BubbleTheme");
    }
    constructor(quill, options) {
      if (options.modules.toolbar != null && options.modules.toolbar.container == null) {
        options.modules.toolbar.container = TOOLBAR_CONFIG;
      }
      super(quill, options);
      this.quill.container.classList.add("ql-bubble");
    }
    extendToolbar(toolbar) {
      this.tooltip = new BubbleTooltip(this.quill, this.options.bounds);
      if (toolbar.container != null) {
        this.tooltip.root.appendChild(toolbar.container);
        this.buildButtons(toolbar.container.querySelectorAll("button"), icons_default);
        this.buildPickers(toolbar.container.querySelectorAll("select"), icons_default);
      }
    }
  };
  BubbleTheme.DEFAULTS = merge_default({}, BaseTheme.DEFAULTS, {
    modules: {
      toolbar: {
        handlers: {
          link(value) {
            if (!value) {
              this.quill.format("link", false);
            } else {
              this.quill.theme.tooltip.edit();
            }
          }
        }
      }
    }
  });

  // node_modules/quill/themes/snow.js
  var TOOLBAR_CONFIG2 = [[{
    header: ["1", "2", "3", false]
  }], ["bold", "italic", "underline", "link"], [{
    list: "ordered"
  }, {
    list: "bullet"
  }], ["clean"]];
  var SnowTooltip = class extends BaseTooltip {
    static {
      __name(this, "SnowTooltip");
    }
    static TEMPLATE = ['<a class="ql-preview" rel="noopener noreferrer" target="_blank" href="about:blank"></a>', '<input type="text" data-formula="e=mc^2" data-link="https://quilljs.com" data-video="Embed URL">', '<a class="ql-action"></a>', '<a class="ql-remove"></a>'].join("");
    preview = this.root.querySelector("a.ql-preview");
    listen() {
      super.listen();
      this.root.querySelector("a.ql-action").addEventListener("click", (event) => {
        if (this.root.classList.contains("ql-editing")) {
          this.save();
        } else {
          this.edit("link", this.preview.textContent);
        }
        event.preventDefault();
      });
      this.root.querySelector("a.ql-remove").addEventListener("click", (event) => {
        if (this.linkRange != null) {
          const range = this.linkRange;
          this.restoreFocus();
          this.quill.formatText(range, "link", false, emitter_default.sources.USER);
          delete this.linkRange;
        }
        event.preventDefault();
        this.hide();
      });
      this.quill.on(emitter_default.events.SELECTION_CHANGE, (range, oldRange, source) => {
        if (range == null)
          return;
        if (range.length === 0 && source === emitter_default.sources.USER) {
          const [link, offset] = this.quill.scroll.descendant(Link, range.index);
          if (link != null) {
            this.linkRange = new Range(range.index - offset, link.length());
            const preview = Link.formats(link.domNode);
            this.preview.textContent = preview;
            this.preview.setAttribute("href", preview);
            this.show();
            const bounds = this.quill.getBounds(this.linkRange);
            if (bounds != null) {
              this.position(bounds);
            }
            return;
          }
        } else {
          delete this.linkRange;
        }
        this.hide();
      });
    }
    show() {
      super.show();
      this.root.removeAttribute("data-mode");
    }
  };
  var SnowTheme = class extends BaseTheme {
    static {
      __name(this, "SnowTheme");
    }
    constructor(quill, options) {
      if (options.modules.toolbar != null && options.modules.toolbar.container == null) {
        options.modules.toolbar.container = TOOLBAR_CONFIG2;
      }
      super(quill, options);
      this.quill.container.classList.add("ql-snow");
    }
    extendToolbar(toolbar) {
      if (toolbar.container != null) {
        toolbar.container.classList.add("ql-snow");
        this.buildButtons(toolbar.container.querySelectorAll("button"), icons_default);
        this.buildPickers(toolbar.container.querySelectorAll("select"), icons_default);
        this.tooltip = new SnowTooltip(this.quill, this.options.bounds);
        if (toolbar.container.querySelector(".ql-link")) {
          this.quill.keyboard.addBinding({
            key: "k",
            shortKey: true
          }, (_range, context) => {
            toolbar.handlers.link.call(toolbar, !context.format.link);
          });
        }
      }
    }
  };
  SnowTheme.DEFAULTS = merge_default({}, BaseTheme.DEFAULTS, {
    modules: {
      toolbar: {
        handlers: {
          link(value) {
            if (value) {
              const range = this.quill.getSelection();
              if (range == null || range.length === 0)
                return;
              let preview = this.quill.getText(range);
              if (/^\S+@\S+\.\S+$/.test(preview) && preview.indexOf("mailto:") !== 0) {
                preview = `mailto:${preview}`;
              }
              const {
                tooltip
              } = this.quill.theme;
              tooltip.edit("link", preview);
            } else {
              this.quill.format("link", false);
            }
          }
        }
      }
    }
  });
  var snow_default = SnowTheme;

  // node_modules/quill/quill.js
  core_default.register({
    "attributors/attribute/direction": DirectionAttribute,
    "attributors/class/align": AlignClass,
    "attributors/class/background": BackgroundClass,
    "attributors/class/color": ColorClass,
    "attributors/class/direction": DirectionClass,
    "attributors/class/font": FontClass,
    "attributors/class/size": SizeClass,
    "attributors/style/align": AlignStyle,
    "attributors/style/background": BackgroundStyle,
    "attributors/style/color": ColorStyle,
    "attributors/style/direction": DirectionStyle,
    "attributors/style/font": FontStyle,
    "attributors/style/size": SizeStyle
  }, true);
  core_default.register({
    "formats/align": AlignClass,
    "formats/direction": DirectionClass,
    "formats/indent": indent_default,
    "formats/background": BackgroundStyle,
    "formats/color": ColorStyle,
    "formats/font": FontClass,
    "formats/size": SizeClass,
    "formats/blockquote": blockquote_default,
    "formats/code-block": CodeBlock,
    "formats/header": header_default,
    "formats/list": ListItem,
    "formats/bold": bold_default,
    "formats/code": Code,
    "formats/italic": italic_default,
    "formats/link": Link,
    "formats/script": script_default,
    "formats/strike": strike_default,
    "formats/underline": underline_default,
    "formats/formula": formula_default,
    "formats/image": image_default,
    "formats/video": video_default,
    "modules/syntax": Syntax,
    "modules/table": table_default,
    "modules/toolbar": Toolbar,
    "themes/bubble": BubbleTheme,
    "themes/snow": snow_default,
    "ui/icons": icons_default,
    "ui/picker": picker_default,
    "ui/icon-picker": icon_picker_default,
    "ui/color-picker": color_picker_default,
    "ui/tooltip": tooltip_default
  }, true);
  var quill_default = core_default;

  // app/javascript/controllers/rich_text_editor_controller.js
  var import_quill_html_edit_button = __toESM(require_quill_htmlEditButton_min());
  quill_default.register("modules/htmlEditButton", import_quill_html_edit_button.default);
  var RichTextEditorController = class extends Controller {
    static {
      __name(this, "RichTextEditorController");
    }
    static targets = ["field"];
    connect() {
      const field = this.fieldTarget;
      this.quill = new quill_default(this.querySelector(".quill"), { theme: "snow", modules: { htmlEditButton: {} } });
      this.quill.on("text-change", (delta, oldDelta, source) => {
        this.fieldTarget.value = this.quill.root.innerHTML;
      });
    }
    disconnect() {
      delete this.quill;
    }
  };

  // app/javascript/controllers/slugonator_controller.js
  var SlugonatorController = class extends Controller {
    static {
      __name(this, "SlugonatorController");
    }
    static targets = ["slug"];
    onChange(e2) {
      this.slugTarget.value = this.slugonate(e2.target.value);
    }
    slugonate(str) {
      return str.toLowerCase().normalize("NFD").replaceAll(/[\u0300-\u036f]/g, "").replaceAll(/[.,!@#$%^&*()]/g, "").replaceAll(" ", "-");
    }
  };

  // app/javascript/controllers/select_all_controller.js
  var SelectAllController = class extends Controller {
    static {
      __name(this, "SelectAllController");
    }
    static targets = ["resource"];
    change(e2) {
      const event = new Event("change");
      this.resourceTargets.forEach((target) => target.checked = e2.target.checked);
      this.resourceTargets[0].dispatchEvent(event);
    }
  };

  // node_modules/@yaireo/tagify/dist/tagify.esm.js
  var t = "&#8203;";
  function e(t2, e2) {
    (null == e2 || e2 > t2.length) && (e2 = t2.length);
    for (var i2 = 0, n2 = new Array(e2); i2 < e2; i2++)
      n2[i2] = t2[i2];
    return n2;
  }
  __name(e, "e");
  function i(t2) {
    return function(t3) {
      if (Array.isArray(t3))
        return e(t3);
    }(t2) || function(t3) {
      if ("undefined" != typeof Symbol && null != t3[Symbol.iterator] || null != t3["@@iterator"])
        return Array.from(t3);
    }(t2) || function(t3, i2) {
      if (!t3)
        return;
      if ("string" == typeof t3)
        return e(t3, i2);
      var n2 = Object.prototype.toString.call(t3).slice(8, -1);
      "Object" === n2 && t3.constructor && (n2 = t3.constructor.name);
      if ("Map" === n2 || "Set" === n2)
        return Array.from(n2);
      if ("Arguments" === n2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
        return e(t3, i2);
    }(t2) || function() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }();
  }
  __name(i, "i");
  var n = { isEnabled: function() {
    var t2;
    return null === (t2 = window.TAGIFY_DEBUG) || void 0 === t2 || t2;
  }, log: function() {
    for (var t2 = arguments.length, e2 = new Array(t2), n2 = 0; n2 < t2; n2++)
      e2[n2] = arguments[n2];
    var s2;
    this.isEnabled() && (s2 = console).log.apply(s2, ["[Tagify]:"].concat(i(e2)));
  }, warn: function() {
    for (var t2 = arguments.length, e2 = new Array(t2), n2 = 0; n2 < t2; n2++)
      e2[n2] = arguments[n2];
    var s2;
    this.isEnabled() && (s2 = console).warn.apply(s2, ["[Tagify]:"].concat(i(e2)));
  } };
  var s = /* @__PURE__ */ __name(function(t2, e2, i2, n2) {
    return t2 = "" + t2, e2 = "" + e2, n2 && (t2 = t2.trim(), e2 = e2.trim()), i2 ? t2 == e2 : t2.toLowerCase() == e2.toLowerCase();
  }, "s");
  var a = /* @__PURE__ */ __name(function(t2, e2) {
    return t2 && Array.isArray(t2) && t2.map(function(t3) {
      return o(t3, e2);
    });
  }, "a");
  function o(t2, e2) {
    var i2, n2 = {};
    for (i2 in t2)
      e2.indexOf(i2) < 0 && (n2[i2] = t2[i2]);
    return n2;
  }
  __name(o, "o");
  function r(t2) {
    var e2 = document.createElement("div");
    return t2.replace(/\&#?[0-9a-z]+;/gi, function(t3) {
      return e2.innerHTML = t3, e2.innerText;
    });
  }
  __name(r, "r");
  function l(t2) {
    return new DOMParser().parseFromString(t2.trim(), "text/html").body.firstElementChild;
  }
  __name(l, "l");
  function d(t2, e2) {
    for (e2 = e2 || "previous"; t2 = t2[e2 + "Sibling"]; )
      if (3 == t2.nodeType)
        return t2;
  }
  __name(d, "d");
  function c(t2) {
    return "string" == typeof t2 ? t2.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/`|'/g, "&#039;") : t2;
  }
  __name(c, "c");
  function u(t2) {
    var e2 = Object.prototype.toString.call(t2).split(" ")[1].slice(0, -1);
    return t2 === Object(t2) && "Array" != e2 && "Function" != e2 && "RegExp" != e2 && "HTMLUnknownElement" != e2;
  }
  __name(u, "u");
  function g(t2, e2, i2) {
    var n2, s2;
    function a2(t3, e3) {
      for (var i3 in e3)
        if (e3.hasOwnProperty(i3)) {
          if (u(e3[i3])) {
            u(t3[i3]) ? a2(t3[i3], e3[i3]) : t3[i3] = Object.assign({}, e3[i3]);
            continue;
          }
          if (Array.isArray(e3[i3])) {
            t3[i3] = Object.assign([], e3[i3]);
            continue;
          }
          t3[i3] = e3[i3];
        }
    }
    __name(a2, "a");
    return n2 = t2, (null != (s2 = Object) && "undefined" != typeof Symbol && s2[Symbol.hasInstance] ? s2[Symbol.hasInstance](n2) : n2 instanceof s2) || (t2 = {}), a2(t2, e2), i2 && a2(t2, i2), t2;
  }
  __name(g, "g");
  function h() {
    var t2 = [], e2 = {}, i2 = true, n2 = false, s2 = void 0;
    try {
      for (var a2, o2 = arguments[Symbol.iterator](); !(i2 = (a2 = o2.next()).done); i2 = true) {
        var r2 = a2.value, l2 = true, d2 = false, c2 = void 0;
        try {
          for (var g2, h2 = r2[Symbol.iterator](); !(l2 = (g2 = h2.next()).done); l2 = true) {
            var p2 = g2.value;
            u(p2) ? e2[p2.value] || (t2.push(p2), e2[p2.value] = 1) : t2.includes(p2) || t2.push(p2);
          }
        } catch (t3) {
          d2 = true, c2 = t3;
        } finally {
          try {
            l2 || null == h2.return || h2.return();
          } finally {
            if (d2)
              throw c2;
          }
        }
      }
    } catch (t3) {
      n2 = true, s2 = t3;
    } finally {
      try {
        i2 || null == o2.return || o2.return();
      } finally {
        if (n2)
          throw s2;
      }
    }
    return t2;
  }
  __name(h, "h");
  function p(t2) {
    return String.prototype.normalize ? "string" == typeof t2 ? t2.normalize("NFD").replace(/[\u0300-\u036f]/g, "") : void 0 : t2;
  }
  __name(p, "p");
  var f = /* @__PURE__ */ __name(function() {
    return /(?=.*chrome)(?=.*android)/i.test(navigator.userAgent);
  }, "f");
  function m() {
    return ("10000000-1000-4000-8000" + -1e11).replace(/[018]/g, function(t2) {
      return (t2 ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> t2 / 4).toString(16);
    });
  }
  __name(m, "m");
  function v(t2) {
    return t2 && t2.classList && t2.classList.contains(this.settings.classNames.tag);
  }
  __name(v, "v");
  function b(t2) {
    return t2 && t2.closest(this.settings.classNames.tagSelector);
  }
  __name(b, "b");
  function w(t2, e2) {
    var i2 = window.getSelection();
    return e2 = e2 || i2.getRangeAt(0), "string" == typeof t2 && (t2 = document.createTextNode(t2)), e2 && (e2.deleteContents(), e2.insertNode(t2)), t2;
  }
  __name(w, "w");
  function y(t2, e2, i2) {
    return t2 ? (e2 && (t2.__tagifyTagData = i2 ? e2 : g({}, t2.__tagifyTagData || {}, e2)), t2.__tagifyTagData) : (n.warn("tag element doesn't exist", { tagElm: t2, data: e2 }), e2);
  }
  __name(y, "y");
  function T(t2) {
    if (t2 && t2.parentNode) {
      var e2 = t2, i2 = window.getSelection(), n2 = i2.getRangeAt(0);
      i2.rangeCount && (n2.setStartAfter(e2), n2.collapse(true), i2.removeAllRanges(), i2.addRange(n2));
    }
  }
  __name(T, "T");
  function O(t2, e2) {
    t2.forEach(function(t3) {
      if (y(t3.previousSibling) || !t3.previousSibling) {
        var i2 = document.createTextNode("\u200B");
        t3.before(i2), e2 && T(i2);
      }
    });
  }
  __name(O, "O");
  var x = { delimiters: ",", pattern: null, tagTextProp: "value", maxTags: 1 / 0, callbacks: {}, addTagOnBlur: true, addTagOn: ["blur", "tab", "enter"], onChangeAfterBlur: true, duplicates: false, whitelist: [], blacklist: [], enforceWhitelist: false, userInput: true, focusable: true, keepInvalidTags: false, createInvalidTags: true, mixTagsAllowedAfter: /,|\.|\:|\s/, mixTagsInterpolator: ["[[", "]]"], backspace: true, skipInvalid: false, pasteAsTags: true, editTags: { clicks: 2, keepInvalid: true }, transformTag: function() {
  }, trim: true, a11y: { focusableTags: false }, mixMode: { insertAfterTag: "\xA0" }, autoComplete: { enabled: true, rightKey: false, tabKey: false }, classNames: { namespace: "tagify", mixMode: "tagify--mix", selectMode: "tagify--select", input: "tagify__input", focus: "tagify--focus", tagNoAnimation: "tagify--noAnim", tagInvalid: "tagify--invalid", tagNotAllowed: "tagify--notAllowed", scopeLoading: "tagify--loading", hasMaxTags: "tagify--hasMaxTags", hasNoTags: "tagify--noTags", empty: "tagify--empty", inputInvalid: "tagify__input--invalid", dropdown: "tagify__dropdown", dropdownWrapper: "tagify__dropdown__wrapper", dropdownHeader: "tagify__dropdown__header", dropdownFooter: "tagify__dropdown__footer", dropdownItem: "tagify__dropdown__item", dropdownItemActive: "tagify__dropdown__item--active", dropdownItemHidden: "tagify__dropdown__item--hidden", dropdownInital: "tagify__dropdown--initial", tag: "tagify__tag", tagText: "tagify__tag-text", tagX: "tagify__tag__removeBtn", tagLoading: "tagify__tag--loading", tagEditing: "tagify__tag--editable", tagFlash: "tagify__tag--flash", tagHide: "tagify__tag--hide" }, dropdown: { classname: "", enabled: 2, maxItems: 10, searchKeys: ["value", "searchBy"], fuzzySearch: true, caseSensitive: false, accentedSearch: true, includeSelectedTags: false, escapeHTML: true, highlightFirst: true, closeOnSelect: true, clearOnSelect: true, position: "all", appendTarget: null }, hooks: { beforeRemoveTag: function() {
    return Promise.resolve();
  }, beforePaste: function() {
    return Promise.resolve();
  }, suggestionClick: function() {
    return Promise.resolve();
  }, beforeKeyDown: function() {
    return Promise.resolve();
  } } };
  function D(t2, e2, i2) {
    return e2 in t2 ? Object.defineProperty(t2, e2, { value: i2, enumerable: true, configurable: true, writable: true }) : t2[e2] = i2, t2;
  }
  __name(D, "D");
  function S(t2) {
    for (var e2 = 1; e2 < arguments.length; e2++) {
      var i2 = null != arguments[e2] ? arguments[e2] : {}, n2 = Object.keys(i2);
      "function" == typeof Object.getOwnPropertySymbols && (n2 = n2.concat(Object.getOwnPropertySymbols(i2).filter(function(t3) {
        return Object.getOwnPropertyDescriptor(i2, t3).enumerable;
      }))), n2.forEach(function(e3) {
        D(t2, e3, i2[e3]);
      });
    }
    return t2;
  }
  __name(S, "S");
  function I(t2, e2) {
    return e2 = null != e2 ? e2 : {}, Object.getOwnPropertyDescriptors ? Object.defineProperties(t2, Object.getOwnPropertyDescriptors(e2)) : function(t3, e3) {
      var i2 = Object.keys(t3);
      if (Object.getOwnPropertySymbols) {
        var n2 = Object.getOwnPropertySymbols(t3);
        e3 && (n2 = n2.filter(function(e4) {
          return Object.getOwnPropertyDescriptor(t3, e4).enumerable;
        })), i2.push.apply(i2, n2);
      }
      return i2;
    }(Object(e2)).forEach(function(i2) {
      Object.defineProperty(t2, i2, Object.getOwnPropertyDescriptor(e2, i2));
    }), t2;
  }
  __name(I, "I");
  function M(t2, e2) {
    (null == e2 || e2 > t2.length) && (e2 = t2.length);
    for (var i2 = 0, n2 = new Array(e2); i2 < e2; i2++)
      n2[i2] = t2[i2];
    return n2;
  }
  __name(M, "M");
  function E(t2, e2, i2) {
    return e2 in t2 ? Object.defineProperty(t2, e2, { value: i2, enumerable: true, configurable: true, writable: true }) : t2[e2] = i2, t2;
  }
  __name(E, "E");
  function N(t2) {
    return function(t3) {
      if (Array.isArray(t3))
        return M(t3);
    }(t2) || function(t3) {
      if ("undefined" != typeof Symbol && null != t3[Symbol.iterator] || null != t3["@@iterator"])
        return Array.from(t3);
    }(t2) || function(t3, e2) {
      if (!t3)
        return;
      if ("string" == typeof t3)
        return M(t3, e2);
      var i2 = Object.prototype.toString.call(t3).slice(8, -1);
      "Object" === i2 && t3.constructor && (i2 = t3.constructor.name);
      if ("Map" === i2 || "Set" === i2)
        return Array.from(i2);
      if ("Arguments" === i2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i2))
        return M(t3, e2);
    }(t2) || function() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }();
  }
  __name(N, "N");
  function _() {
    for (var t2 in this.dropdown = {}, this._dropdown)
      this.dropdown[t2] = "function" == typeof this._dropdown[t2] ? this._dropdown[t2].bind(this) : this._dropdown[t2];
    this.dropdown.refs(), this.DOM.dropdown.__tagify = this;
  }
  __name(_, "_");
  var A;
  var C;
  var k;
  var L = (A = function(t2) {
    for (var e2 = 1; e2 < arguments.length; e2++) {
      var i2 = null != arguments[e2] ? arguments[e2] : {}, n2 = Object.keys(i2);
      "function" == typeof Object.getOwnPropertySymbols && (n2 = n2.concat(Object.getOwnPropertySymbols(i2).filter(function(t3) {
        return Object.getOwnPropertyDescriptor(i2, t3).enumerable;
      }))), n2.forEach(function(e3) {
        E(t2, e3, i2[e3]);
      });
    }
    return t2;
  }({}, { events: { binding: function() {
    var t2 = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0], e2 = this.dropdown.events.callbacks, i2 = this.listeners.dropdown = this.listeners.dropdown || { position: this.dropdown.position.bind(this, null), onKeyDown: e2.onKeyDown.bind(this), onMouseOver: e2.onMouseOver.bind(this), onMouseLeave: e2.onMouseLeave.bind(this), onClick: e2.onClick.bind(this), onScroll: e2.onScroll.bind(this) }, n2 = t2 ? "addEventListener" : "removeEventListener";
    "manual" != this.settings.dropdown.position && (document[n2]("scroll", i2.position, true), window[n2]("resize", i2.position), window[n2]("keydown", i2.onKeyDown)), this.DOM.dropdown[n2]("mouseover", i2.onMouseOver), this.DOM.dropdown[n2]("mouseleave", i2.onMouseLeave), this.DOM.dropdown[n2]("mousedown", i2.onClick), this.DOM.dropdown.content[n2]("scroll", i2.onScroll);
  }, callbacks: { onKeyDown: function(t2) {
    var e2 = this;
    if (this.state.hasFocus && !this.state.composing) {
      var i2 = this.settings, s2 = this.DOM.dropdown.querySelector(i2.classNames.dropdownItemActiveSelector), a2 = this.dropdown.getSuggestionDataByNode(s2), o2 = "mix" == i2.mode, r2 = "select" == i2.mode;
      i2.hooks.beforeKeyDown(t2, { tagify: this }).then(function(l2) {
        switch (t2.key) {
          case "ArrowDown":
          case "ArrowUp":
          case "Down":
          case "Up":
            t2.preventDefault();
            var d2 = e2.dropdown.getAllSuggestionsRefs(), c2 = "ArrowUp" == t2.key || "Up" == t2.key;
            s2 && (s2 = e2.dropdown.getNextOrPrevOption(s2, !c2)), s2 && s2.matches(i2.classNames.dropdownItemSelector) || (s2 = d2[c2 ? d2.length - 1 : 0]), e2.dropdown.highlightOption(s2, true);
            break;
          case "Escape":
          case "Esc":
            e2.dropdown.hide();
            break;
          case "ArrowRight":
            if (e2.state.actions.ArrowLeft)
              return;
          case "Tab":
            var u2 = !i2.autoComplete.rightKey || !i2.autoComplete.tabKey;
            if (!o2 && !r2 && s2 && u2 && !e2.state.editing) {
              t2.preventDefault();
              var g2 = e2.dropdown.getMappedValue(a2);
              return e2.input.autocomplete.set.call(e2, g2), false;
            }
            return true;
          case "Enter":
            t2.preventDefault(), i2.hooks.suggestionClick(t2, { tagify: e2, tagData: a2, suggestionElm: s2 }).then(function() {
              if (s2)
                return e2.dropdown.selectOption(s2), s2 = e2.dropdown.getNextOrPrevOption(s2, !c2), void e2.dropdown.highlightOption(s2);
              e2.dropdown.hide(), o2 || e2.addTags(e2.state.inputText.trim(), true);
            }).catch(function(t3) {
              return n.warn(t3);
            });
            break;
          case "Backspace":
            if (o2 || e2.state.editing.scope)
              return;
            var h2 = e2.input.raw.call(e2);
            "" != h2 && 8203 != h2.charCodeAt(0) || (true === i2.backspace ? e2.removeTags() : "edit" == i2.backspace && setTimeout(e2.editTag.bind(e2), 0));
        }
      });
    }
  }, onMouseOver: function(t2) {
    var e2 = t2.target.closest(this.settings.classNames.dropdownItemSelector);
    this.dropdown.highlightOption(e2);
  }, onMouseLeave: function(t2) {
    this.dropdown.highlightOption();
  }, onClick: function(t2) {
    var e2 = this;
    if (0 == t2.button && t2.target != this.DOM.dropdown && t2.target != this.DOM.dropdown.content) {
      var i2 = t2.target.closest(this.settings.classNames.dropdownItemSelector), s2 = this.dropdown.getSuggestionDataByNode(i2);
      this.state.actions.selectOption = true, setTimeout(function() {
        return e2.state.actions.selectOption = false;
      }, 50), this.settings.hooks.suggestionClick(t2, { tagify: this, tagData: s2, suggestionElm: i2 }).then(function() {
        i2 ? e2.dropdown.selectOption(i2, t2) : e2.dropdown.hide();
      }).catch(function(t3) {
        return n.warn(t3);
      });
    }
  }, onScroll: function(t2) {
    var e2 = t2.target, i2 = e2.scrollTop / (e2.scrollHeight - e2.parentNode.clientHeight) * 100;
    this.trigger("dropdown:scroll", { percentage: Math.round(i2) });
  } } }, refilter: function(t2) {
    t2 = t2 || this.state.dropdown.query || "", this.suggestedListItems = this.dropdown.filterListItems(t2), this.dropdown.fill(), this.suggestedListItems.length || this.dropdown.hide(), this.trigger("dropdown:updated", this.DOM.dropdown);
  }, getSuggestionDataByNode: function(t2) {
    var e2 = t2 && t2.getAttribute("value");
    return this.suggestedListItems.find(function(t3) {
      return t3.value == e2;
    }) || null;
  }, getNextOrPrevOption: function(t2) {
    var e2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], i2 = this.dropdown.getAllSuggestionsRefs(), n2 = i2.findIndex(function(e3) {
      return e3 === t2;
    });
    return e2 ? i2[n2 + 1] : i2[n2 - 1];
  }, highlightOption: function(t2, e2) {
    var i2, n2 = this.settings.classNames.dropdownItemActive;
    if (this.state.ddItemElm && (this.state.ddItemElm.classList.remove(n2), this.state.ddItemElm.removeAttribute("aria-selected")), !t2)
      return this.state.ddItemData = null, this.state.ddItemElm = null, void this.input.autocomplete.suggest.call(this);
    i2 = this.dropdown.getSuggestionDataByNode(t2), this.state.ddItemData = i2, this.state.ddItemElm = t2, t2.classList.add(n2), t2.setAttribute("aria-selected", true), e2 && (t2.parentNode.scrollTop = t2.clientHeight + t2.offsetTop - t2.parentNode.clientHeight), this.settings.autoComplete && (this.input.autocomplete.suggest.call(this, i2), this.dropdown.position());
  }, selectOption: function(t2, e2) {
    var i2 = this, n2 = this.settings, s2 = n2.dropdown, a2 = s2.clearOnSelect, o2 = s2.closeOnSelect;
    if (!t2)
      return this.addTags(this.state.inputText, true), void (o2 && this.dropdown.hide());
    e2 = e2 || {};
    var r2 = t2.getAttribute("value"), l2 = "noMatch" == r2, d2 = "mix" == n2.mode, c2 = this.suggestedListItems.find(function(t3) {
      var e3;
      return (null !== (e3 = t3.value) && void 0 !== e3 ? e3 : t3) == r2;
    });
    if (this.trigger("dropdown:select", { data: c2, elm: t2, event: e2 }), r2 && (c2 || l2)) {
      if (this.state.editing) {
        var u2 = this.normalizeTags([c2])[0];
        c2 = n2.transformTag.call(this, u2) || u2, this.onEditTagDone(null, g({ __isValid: true }, c2));
      } else
        this[d2 ? "addMixTags" : "addTags"]([c2 || this.input.raw.call(this)], a2);
      (d2 || this.DOM.input.parentNode) && (setTimeout(function() {
        i2.DOM.input.focus(), i2.toggleFocusClass(true);
      }), o2 && setTimeout(this.dropdown.hide.bind(this)), t2.addEventListener("transitionend", function() {
        i2.dropdown.fillHeaderFooter(), setTimeout(function() {
          t2.remove(), i2.dropdown.refilter();
        }, 100);
      }, { once: true }), t2.classList.add(this.settings.classNames.dropdownItemHidden));
    } else
      o2 && setTimeout(this.dropdown.hide.bind(this));
  }, selectAll: function(t2) {
    this.suggestedListItems.length = 0, this.dropdown.hide(), this.dropdown.filterListItems("");
    var e2 = this.dropdown.filterListItems("");
    return t2 || (e2 = this.state.dropdown.suggestions), this.addTags(e2, true), this;
  }, filterListItems: function(t2, e2) {
    var i2, n2, s2, a2, o2, r2, l2 = /* @__PURE__ */ __name(function() {
      var t3, l3, d3 = void 0, c3 = void 0;
      t3 = m2[w2], n2 = (null != (l3 = Object) && "undefined" != typeof Symbol && l3[Symbol.hasInstance] ? l3[Symbol.hasInstance](t3) : t3 instanceof l3) ? m2[w2] : { value: m2[w2] };
      var v3, y2 = !Object.keys(n2).some(function(t4) {
        return b2.includes(t4);
      }) ? ["value"] : b2;
      g2.fuzzySearch && !e2.exact ? (a2 = y2.reduce(function(t4, e3) {
        return t4 + " " + (n2[e3] || "");
      }, "").toLowerCase().trim(), g2.accentedSearch && (a2 = p(a2), r2 = p(r2)), d3 = 0 == a2.indexOf(r2), c3 = a2 === r2, v3 = a2, s2 = r2.toLowerCase().split(" ").every(function(t4) {
        return v3.includes(t4.toLowerCase());
      })) : (d3 = true, s2 = y2.some(function(t4) {
        var i3 = "" + (n2[t4] || "");
        return g2.accentedSearch && (i3 = p(i3), r2 = p(r2)), g2.caseSensitive || (i3 = i3.toLowerCase()), c3 = i3 === r2, e2.exact ? i3 === r2 : 0 == i3.indexOf(r2);
      })), o2 = !g2.includeSelectedTags && i2.isTagDuplicate(u(n2) ? n2.value : n2), s2 && !o2 && (c3 && d3 ? f2.push(n2) : "startsWith" == g2.sortby && d3 ? h2.unshift(n2) : h2.push(n2));
    }, "l"), d2 = this, c2 = this.settings, g2 = c2.dropdown, h2 = (e2 = e2 || {}, []), f2 = [], m2 = c2.whitelist, v2 = g2.maxItems >= 0 ? g2.maxItems : 1 / 0, b2 = g2.searchKeys, w2 = 0;
    if (!(t2 = "select" == c2.mode && this.value.length && this.value[0][c2.tagTextProp] == t2 ? "" : t2) || !b2.length)
      return h2 = g2.includeSelectedTags ? m2 : m2.filter(function(t3) {
        return !d2.isTagDuplicate(u(t3) ? t3.value : t3);
      }), this.state.dropdown.suggestions = h2, h2.slice(0, v2);
    for (r2 = g2.caseSensitive ? "" + t2 : ("" + t2).toLowerCase(); w2 < m2.length; w2++)
      i2 = this, l2();
    return this.state.dropdown.suggestions = f2.concat(h2), "function" == typeof g2.sortby ? g2.sortby(f2.concat(h2), r2) : f2.concat(h2).slice(0, v2);
  }, getMappedValue: function(t2) {
    var e2 = this.settings.dropdown.mapValueTo;
    return e2 ? "function" == typeof e2 ? e2(t2) : t2[e2] || t2.value : t2.value;
  }, createListHTML: function(t2) {
    var e2 = this;
    return g([], t2).map(function(t3, i2) {
      "string" != typeof t3 && "number" != typeof t3 || (t3 = { value: t3 });
      var n2 = e2.dropdown.getMappedValue(t3);
      return n2 = "string" == typeof n2 && e2.settings.dropdown.escapeHTML ? c(n2) : n2, e2.settings.templates.dropdownItem.apply(e2, [I(S({}, t3), { mappedValue: n2 }), e2]);
    }).join("");
  } }), C = null != (C = { refs: function() {
    this.DOM.dropdown = this.parseTemplate("dropdown", [this.settings]), this.DOM.dropdown.content = this.DOM.dropdown.querySelector("[data-selector='tagify-suggestions-wrapper']");
  }, getHeaderRef: function() {
    return this.DOM.dropdown.querySelector("[data-selector='tagify-suggestions-header']");
  }, getFooterRef: function() {
    return this.DOM.dropdown.querySelector("[data-selector='tagify-suggestions-footer']");
  }, getAllSuggestionsRefs: function() {
    return N(this.DOM.dropdown.content.querySelectorAll(this.settings.classNames.dropdownItemSelector));
  }, show: function(t2) {
    var e2, i2, n2, a2 = this, o2 = this.settings, r2 = "mix" == o2.mode && !o2.enforceWhitelist, l2 = !o2.whitelist || !o2.whitelist.length, d2 = "manual" == o2.dropdown.position;
    if (t2 = void 0 === t2 ? this.state.inputText : t2, !(l2 && !r2 && !o2.templates.dropdownItemNoMatch || false === o2.dropdown.enable || this.state.isLoading || this.settings.readonly)) {
      if (clearTimeout(this.dropdownHide__bindEventsTimeout), this.suggestedListItems = this.dropdown.filterListItems(t2), t2 && !this.suggestedListItems.length && (this.trigger("dropdown:noMatch", t2), o2.templates.dropdownItemNoMatch && (n2 = o2.templates.dropdownItemNoMatch.call(this, { value: t2 }))), !n2) {
        if (this.suggestedListItems.length)
          t2 && r2 && !this.state.editing.scope && !s(this.suggestedListItems[0].value, t2) && this.suggestedListItems.unshift({ value: t2 });
        else {
          if (!t2 || !r2 || this.state.editing.scope)
            return this.input.autocomplete.suggest.call(this), void this.dropdown.hide();
          this.suggestedListItems = [{ value: t2 }];
        }
        i2 = "" + (u(e2 = this.suggestedListItems[0]) ? e2.value : e2), o2.autoComplete && i2 && 0 == i2.indexOf(t2) && this.input.autocomplete.suggest.call(this, e2);
      }
      this.dropdown.fill(n2), o2.dropdown.highlightFirst && this.dropdown.highlightOption(this.DOM.dropdown.content.querySelector(o2.classNames.dropdownItemSelector)), this.state.dropdown.visible || setTimeout(this.dropdown.events.binding.bind(this)), this.state.dropdown.visible = t2 || true, this.state.dropdown.query = t2, this.setStateSelection(), d2 || setTimeout(function() {
        a2.dropdown.position(), a2.dropdown.render();
      }), setTimeout(function() {
        a2.trigger("dropdown:show", a2.DOM.dropdown);
      });
    }
  }, hide: function(t2) {
    var e2 = this, i2 = this.DOM, n2 = i2.scope, s2 = i2.dropdown, a2 = "manual" == this.settings.dropdown.position && !t2;
    if (s2 && document.body.contains(s2) && !a2)
      return window.removeEventListener("resize", this.dropdown.position), this.dropdown.events.binding.call(this, false), n2.setAttribute("aria-expanded", false), s2.parentNode.removeChild(s2), setTimeout(function() {
        e2.state.dropdown.visible = false;
      }, 100), this.state.dropdown.query = this.state.ddItemData = this.state.ddItemElm = this.state.selection = null, this.state.tag && this.state.tag.value.length && (this.state.flaggedTags[this.state.tag.baseOffset] = this.state.tag), this.trigger("dropdown:hide", s2), this;
  }, toggle: function(t2) {
    this.dropdown[this.state.dropdown.visible && !t2 ? "hide" : "show"]();
  }, getAppendTarget: function() {
    var t2 = this.settings.dropdown;
    return "function" == typeof t2.appendTarget ? t2.appendTarget() : t2.appendTarget;
  }, render: function() {
    var t2, e2, i2, n2 = this, s2 = (t2 = this.DOM.dropdown, (i2 = t2.cloneNode(true)).style.cssText = "position:fixed; top:-9999px; opacity:0", document.body.appendChild(i2), e2 = i2.clientHeight, i2.parentNode.removeChild(i2), e2), a2 = this.settings, o2 = "number" == typeof a2.dropdown.enabled && a2.dropdown.enabled >= 0, r2 = this.dropdown.getAppendTarget();
    return o2 ? (this.DOM.scope.setAttribute("aria-expanded", true), document.body.contains(this.DOM.dropdown) || (this.DOM.dropdown.classList.add(a2.classNames.dropdownInital), this.dropdown.position(s2), r2.appendChild(this.DOM.dropdown), setTimeout(function() {
      return n2.DOM.dropdown.classList.remove(a2.classNames.dropdownInital);
    })), this) : this;
  }, fill: function(t2) {
    t2 = "string" == typeof t2 ? t2 : this.dropdown.createListHTML(t2 || this.suggestedListItems);
    var e2, i2 = this.settings.templates.dropdownContent.call(this, t2);
    this.DOM.dropdown.content.innerHTML = (e2 = i2) ? e2.replace(/\>[\r\n ]+\</g, "><").split(/>\s+</).join("><").trim() : "";
  }, fillHeaderFooter: function() {
    var t2 = this.dropdown.filterListItems(this.state.dropdown.query), e2 = this.parseTemplate("dropdownHeader", [t2]), i2 = this.parseTemplate("dropdownFooter", [t2]), n2 = this.dropdown.getHeaderRef(), s2 = this.dropdown.getFooterRef();
    e2 && (null == n2 || n2.parentNode.replaceChild(e2, n2)), i2 && (null == s2 || s2.parentNode.replaceChild(i2, s2));
  }, position: function(t2) {
    var e2 = this.settings.dropdown, i2 = this.dropdown.getAppendTarget();
    if ("manual" != e2.position && i2) {
      var n2, s2, a2, o2, r2, l2, d2, c2, u2, g2 = this.DOM.dropdown, h2 = e2.RTL, p2 = i2 === document.body, f2 = i2 === this.DOM.scope, m2 = p2 ? window.pageYOffset : i2.scrollTop, v2 = document.fullscreenElement || document.webkitFullscreenElement || document.documentElement, b2 = v2.clientHeight, w2 = Math.max(v2.clientWidth || 0, window.innerWidth || 0) > 480 ? e2.position : "all", y2 = this.DOM["input" == w2 ? "input" : "scope"];
      if (t2 = t2 || g2.clientHeight, this.state.dropdown.visible) {
        if ("text" == w2 ? (a2 = (n2 = function() {
          var t3 = document.getSelection();
          if (t3.rangeCount) {
            var e3, i3, n3 = t3.getRangeAt(0), s3 = n3.startContainer, a3 = n3.startOffset;
            if (a3 > 0)
              return (i3 = document.createRange()).setStart(s3, a3 - 1), i3.setEnd(s3, a3), { left: (e3 = i3.getBoundingClientRect()).right, top: e3.top, bottom: e3.bottom };
            if (s3.getBoundingClientRect)
              return s3.getBoundingClientRect();
          }
          return { left: -9999, top: -9999 };
        }()).bottom, s2 = n2.top, o2 = n2.left, r2 = "auto") : (l2 = function(t3) {
          var e3 = 0, i3 = 0;
          for (t3 = t3.parentNode; t3 && t3 != v2; )
            e3 += t3.offsetTop || 0, i3 += t3.offsetLeft || 0, t3 = t3.parentNode;
          return { top: e3, left: i3 };
        }(i2), n2 = y2.getBoundingClientRect(), s2 = f2 ? -1 : n2.top - l2.top, a2 = (f2 ? n2.height : n2.bottom - l2.top) - 1, o2 = f2 ? -1 : n2.left - l2.left, r2 = n2.width + "px"), !p2) {
          var T2 = function() {
            for (var t3 = 0, i3 = e2.appendTarget.parentNode; i3; )
              t3 += i3.scrollTop || 0, i3 = i3.parentNode;
            return t3;
          }();
          s2 += T2, a2 += T2;
        }
        var O2;
        s2 = Math.floor(s2), a2 = Math.ceil(a2), c2 = ((d2 = null !== (O2 = e2.placeAbove) && void 0 !== O2 ? O2 : b2 - n2.bottom < t2) ? s2 : a2) + m2, u2 = "left: ".concat(o2 + (h2 && n2.width || 0) + window.pageXOffset, "px;"), g2.style.cssText = "".concat(u2, "; top: ").concat(c2, "px; min-width: ").concat(r2, "; max-width: ").concat(r2), g2.setAttribute("placement", d2 ? "top" : "bottom"), g2.setAttribute("position", w2);
      }
    }
  } }) ? C : {}, Object.getOwnPropertyDescriptors ? Object.defineProperties(A, Object.getOwnPropertyDescriptors(C)) : function(t2, e2) {
    var i2 = Object.keys(t2);
    if (Object.getOwnPropertySymbols) {
      var n2 = Object.getOwnPropertySymbols(t2);
      e2 && (n2 = n2.filter(function(e3) {
        return Object.getOwnPropertyDescriptor(t2, e3).enumerable;
      })), i2.push.apply(i2, n2);
    }
    return i2;
  }(Object(C)).forEach(function(t2) {
    Object.defineProperty(A, t2, Object.getOwnPropertyDescriptor(C, t2));
  }), A);
  var j = "@yaireo/tagify/";
  var P = { empty: "empty", exceed: "number of tags exceeded", pattern: "pattern mismatch", duplicate: "already exists", notAllowed: "not allowed" };
  var V = { wrapper: function(e2, i2) {
    return '<tags class="'.concat(i2.classNames.namespace, " ").concat(i2.mode ? "".concat(i2.classNames[i2.mode + "Mode"]) : "", " ").concat(e2.className, '"\n                    ').concat(i2.readonly ? "readonly" : "", "\n                    ").concat(i2.disabled ? "disabled" : "", "\n                    ").concat(i2.required ? "required" : "", "\n                    ").concat("select" === i2.mode ? "spellcheck='false'" : "", '\n                    tabIndex="-1">\n                    ').concat(this.settings.templates.input.call(this), "\n                ").concat(t, "\n        </tags>");
  }, input: function() {
    var e2 = this.settings, i2 = e2.placeholder || t;
    return "<span ".concat(!e2.readonly && e2.userInput ? "contenteditable" : "", ' tabIndex="0" data-placeholder="').concat(i2, '" aria-placeholder="').concat(e2.placeholder || "", '"\n                    class="').concat(e2.classNames.input, '"\n                    role="textbox"\n                    aria-autocomplete="both"\n                    aria-multiline="').concat("mix" == e2.mode, '"></span>');
  }, tag: function(t2, e2) {
    var i2 = e2.settings;
    return '<tag title="'.concat(t2.title || t2.value, `"
                    contenteditable='false'
                    spellcheck='false'
                    tabIndex="`).concat(i2.a11y.focusableTags ? 0 : -1, '"\n                    class="').concat(i2.classNames.tag, " ").concat(t2.class || "", '"\n                    ').concat(this.getAttributes(t2), `>
            <x title='' tabIndex="`).concat(i2.a11y.focusableTags ? 0 : -1, '" class="').concat(i2.classNames.tagX, `" role='button' aria-label='remove tag'></x>
            <div>
                <span `).concat("select" === i2.mode && i2.userInput ? "contenteditable='true'" : "", ' class="').concat(i2.classNames.tagText, '">').concat(t2[i2.tagTextProp] || t2.value, "</span>\n            </div>\n        </tag>");
  }, dropdown: function(t2) {
    var e2 = t2.dropdown, i2 = "manual" == e2.position;
    return '<div class="'.concat(i2 ? "" : t2.classNames.dropdown, " ").concat(e2.classname, '" role="listbox" aria-labelledby="dropdown" dir="').concat(e2.RTL ? "rtl" : "", `">
                    <div data-selector='tagify-suggestions-wrapper' class="`).concat(t2.classNames.dropdownWrapper, '"></div>\n                </div>');
  }, dropdownContent: function(t2) {
    var e2 = this.settings.templates, i2 = this.state.dropdown.suggestions;
    return "\n            ".concat(e2.dropdownHeader.call(this, i2), "\n            ").concat(t2, "\n            ").concat(e2.dropdownFooter.call(this, i2), "\n        ");
  }, dropdownItem: function(t2) {
    return "<div ".concat(this.getAttributes(t2), "\n                    class='").concat(this.settings.classNames.dropdownItem, " ").concat(t2.class || "", `'
                    tabindex="0"
                    role="option">`).concat(t2.mappedValue || t2.value, "</div>");
  }, dropdownHeader: function(t2) {
    return `<header data-selector='tagify-suggestions-header' class="`.concat(this.settings.classNames.dropdownHeader, '"></header>');
  }, dropdownFooter: function(t2) {
    var e2 = t2.length - this.settings.dropdown.maxItems;
    return e2 > 0 ? `<footer data-selector='tagify-suggestions-footer' class="`.concat(this.settings.classNames.dropdownFooter, '">\n                ').concat(e2, " more items. Refine your search.\n            </footer>") : "";
  }, dropdownItemNoMatch: null };
  function F(t2, e2) {
    (null == e2 || e2 > t2.length) && (e2 = t2.length);
    for (var i2 = 0, n2 = new Array(e2); i2 < e2; i2++)
      n2[i2] = t2[i2];
    return n2;
  }
  __name(F, "F");
  function R(t2, e2) {
    return null != e2 && "undefined" != typeof Symbol && e2[Symbol.hasInstance] ? !!e2[Symbol.hasInstance](t2) : t2 instanceof e2;
  }
  __name(R, "R");
  function H(t2, e2) {
    return function(t3) {
      if (Array.isArray(t3))
        return t3;
    }(t2) || function(t3, e3) {
      var i2 = null == t3 ? null : "undefined" != typeof Symbol && t3[Symbol.iterator] || t3["@@iterator"];
      if (null != i2) {
        var n2, s2, a2 = [], o2 = true, r2 = false;
        try {
          for (i2 = i2.call(t3); !(o2 = (n2 = i2.next()).done) && (a2.push(n2.value), !e3 || a2.length !== e3); o2 = true)
            ;
        } catch (t4) {
          r2 = true, s2 = t4;
        } finally {
          try {
            o2 || null == i2.return || i2.return();
          } finally {
            if (r2)
              throw s2;
          }
        }
        return a2;
      }
    }(t2, e2) || function(t3, e3) {
      if (!t3)
        return;
      if ("string" == typeof t3)
        return F(t3, e3);
      var i2 = Object.prototype.toString.call(t3).slice(8, -1);
      "Object" === i2 && t3.constructor && (i2 = t3.constructor.name);
      if ("Map" === i2 || "Set" === i2)
        return Array.from(i2);
      if ("Arguments" === i2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i2))
        return F(t3, e3);
    }(t2, e2) || function() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }();
  }
  __name(H, "H");
  function B(t2, e2) {
    (null == e2 || e2 > t2.length) && (e2 = t2.length);
    for (var i2 = 0, n2 = new Array(e2); i2 < e2; i2++)
      n2[i2] = t2[i2];
    return n2;
  }
  __name(B, "B");
  function W(t2, e2, i2) {
    return e2 in t2 ? Object.defineProperty(t2, e2, { value: i2, enumerable: true, configurable: true, writable: true }) : t2[e2] = i2, t2;
  }
  __name(W, "W");
  function U(t2, e2) {
    return null != e2 && "undefined" != typeof Symbol && e2[Symbol.hasInstance] ? !!e2[Symbol.hasInstance](t2) : t2 instanceof e2;
  }
  __name(U, "U");
  function q(t2, e2) {
    return e2 = null != e2 ? e2 : {}, Object.getOwnPropertyDescriptors ? Object.defineProperties(t2, Object.getOwnPropertyDescriptors(e2)) : function(t3, e3) {
      var i2 = Object.keys(t3);
      if (Object.getOwnPropertySymbols) {
        var n2 = Object.getOwnPropertySymbols(t3);
        e3 && (n2 = n2.filter(function(e4) {
          return Object.getOwnPropertyDescriptor(t3, e4).enumerable;
        })), i2.push.apply(i2, n2);
      }
      return i2;
    }(Object(e2)).forEach(function(i2) {
      Object.defineProperty(t2, i2, Object.getOwnPropertyDescriptor(e2, i2));
    }), t2;
  }
  __name(q, "q");
  function K(t2) {
    return function(t3) {
      if (Array.isArray(t3))
        return B(t3);
    }(t2) || function(t3) {
      if ("undefined" != typeof Symbol && null != t3[Symbol.iterator] || null != t3["@@iterator"])
        return Array.from(t3);
    }(t2) || function(t3, e2) {
      if (!t3)
        return;
      if ("string" == typeof t3)
        return B(t3, e2);
      var i2 = Object.prototype.toString.call(t3).slice(8, -1);
      "Object" === i2 && t3.constructor && (i2 = t3.constructor.name);
      if ("Map" === i2 || "Set" === i2)
        return Array.from(i2);
      if ("Arguments" === i2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i2))
        return B(t3, e2);
    }(t2) || function() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }();
  }
  __name(K, "K");
  var z = { customBinding: function() {
    var t2 = this;
    this.customEventsList.forEach(function(e2) {
      t2.on(e2, t2.settings.callbacks[e2]);
    });
  }, binding: function() {
    var t2, e2 = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0], i2 = this.settings, n2 = this.events.callbacks, s2 = e2 ? "addEventListener" : "removeEventListener";
    if (!this.state.mainEvents || !e2) {
      for (var a2 in this.state.mainEvents = e2, e2 && !this.listeners.main && (this.events.bindGlobal.call(this), this.settings.isJQueryPlugin && jQuery(this.DOM.originalInput).on("tagify.removeAllTags", this.removeAllTags.bind(this))), t2 = this.listeners.main = this.listeners.main || { keydown: ["input", n2.onKeydown.bind(this)], click: ["scope", n2.onClickScope.bind(this)], dblclick: "select" != i2.mode && ["scope", n2.onDoubleClickScope.bind(this)], paste: ["input", n2.onPaste.bind(this)], drop: ["input", n2.onDrop.bind(this)], compositionstart: ["input", n2.onCompositionStart.bind(this)], compositionend: ["input", n2.onCompositionEnd.bind(this)] })
        t2[a2] && this.DOM[t2[a2][0]][s2](a2, t2[a2][1]);
      var o2 = this.listeners.main.inputMutationObserver || new MutationObserver(n2.onInputDOMChange.bind(this));
      o2.disconnect(), "mix" == i2.mode && o2.observe(this.DOM.input, { childList: true }), this.events.bindOriginaInputListener.call(this);
    }
  }, bindOriginaInputListener: function(t2) {
    var e2 = (t2 || 0) + 500;
    this.listeners.main && (clearInterval(this.listeners.main.originalInputValueObserverInterval), this.listeners.main.originalInputValueObserverInterval = setInterval(this.events.callbacks.observeOriginalInputValue.bind(this), e2));
  }, bindGlobal: function(t2) {
    var e2, i2 = this.events.callbacks, n2 = t2 ? "removeEventListener" : "addEventListener";
    if (this.listeners && (t2 || !this.listeners.global)) {
      this.listeners.global = this.listeners.global || [{ type: this.isIE ? "keydown" : "input", target: this.DOM.input, cb: i2[this.isIE ? "onInputIE" : "onInput"].bind(this) }, { type: "keydown", target: window, cb: i2.onWindowKeyDown.bind(this) }, { type: "focusin", target: this.DOM.scope, cb: i2.onFocusBlur.bind(this) }, { type: "focusout", target: this.DOM.scope, cb: i2.onFocusBlur.bind(this) }, { type: "click", target: document, cb: i2.onClickAnywhere.bind(this), useCapture: true }];
      var s2 = true, a2 = false, o2 = void 0;
      try {
        for (var r2, l2 = this.listeners.global[Symbol.iterator](); !(s2 = (r2 = l2.next()).done); s2 = true)
          (e2 = r2.value).target[n2](e2.type, e2.cb, !!e2.useCapture);
      } catch (t3) {
        a2 = true, o2 = t3;
      } finally {
        try {
          s2 || null == l2.return || l2.return();
        } finally {
          if (a2)
            throw o2;
        }
      }
    }
  }, unbindGlobal: function() {
    this.events.bindGlobal.call(this, true);
  }, callbacks: { onFocusBlur: function(t2) {
    var e2, i2, n2, s2 = b.call(this, t2.target), a2 = v.call(this, t2.target), o2 = "focusin" == t2.type, r2 = "focusout" == t2.type;
    null === (e2 = t2.target) || void 0 === e2 || e2.closest(this.settings.classNames.tagTextSelector), s2 && o2 && !a2 && this.toggleFocusClass(this.state.hasFocus = +/* @__PURE__ */ new Date());
    var l2 = this.settings, d2 = t2.target ? this.trim(this.DOM.input.textContent) : "", c2 = null === (n2 = this.value) || void 0 === n2 || null === (i2 = n2[0]) || void 0 === i2 ? void 0 : i2[l2.tagTextProp], u2 = l2.dropdown.enabled >= 0, g2 = { relatedTarget: t2.relatedTarget }, h2 = this.state.actions.selectOption && (u2 || !l2.dropdown.closeOnSelect), p2 = this.state.actions.addNew && u2;
    if (r2) {
      if (t2.relatedTarget === this.DOM.scope)
        return this.dropdown.hide(), void this.DOM.input.focus();
      this.postUpdate();
    }
    if (!h2 && !p2)
      if (o2 || s2 ? (this.state.hasFocus = +/* @__PURE__ */ new Date(), this.toggleFocusClass(this.state.hasFocus)) : this.state.hasFocus = false, "mix" != l2.mode) {
        if (o2) {
          if (!l2.focusable)
            return;
          var f2 = 0 === l2.dropdown.enabled && !this.state.dropdown.visible;
          return this.toggleFocusClass(true), this.trigger("focus", g2), void (!f2 || a2 && "select" !== l2.mode || this.dropdown.show(this.value.length ? "" : void 0));
        }
        if (r2) {
          if (this.trigger("blur", g2), this.loading(false), "select" == l2.mode) {
            if (this.value.length) {
              var m2 = this.getTagElms()[0];
              d2 = this.trim(m2.textContent);
            }
            c2 === d2 && (d2 = "");
          }
          d2 && !this.state.actions.selectOption && l2.addTagOnBlur && l2.addTagOn.includes("blur") && this.addTags(d2, true);
        }
        s2 || (this.DOM.input.removeAttribute("style"), this.dropdown.hide());
      } else
        o2 ? this.trigger("focus", g2) : r2 && (this.trigger("blur", g2), this.loading(false), this.dropdown.hide(), this.state.dropdown.visible = void 0, this.setStateSelection());
  }, onCompositionStart: function(t2) {
    this.state.composing = true;
  }, onCompositionEnd: function(t2) {
    this.state.composing = false;
  }, onWindowKeyDown: function(t2) {
    var e2, i2 = this.settings, n2 = document.activeElement, s2 = b.call(this, n2) && this.DOM.scope.contains(document.activeElement), a2 = s2 && n2.hasAttribute("readonly");
    if (this.state.hasFocus || s2 && !a2) {
      e2 = n2.nextElementSibling;
      var o2 = t2.target.classList.contains(i2.classNames.tagX);
      switch (t2.key) {
        case "Backspace":
          i2.readonly || this.state.editing || (this.removeTags(n2), (e2 || this.DOM.input).focus());
          break;
        case "Enter":
          if (o2)
            return void this.removeTags(t2.target.parentNode);
          i2.a11y.focusableTags && v.call(this, n2) && setTimeout(this.editTag.bind(this), 0, n2);
          break;
        case "ArrowDown":
          this.state.dropdown.visible || "mix" == i2.mode || this.dropdown.show();
      }
    }
  }, onKeydown: function(t2) {
    var e2 = this, i2 = this.settings;
    if (!this.state.composing && i2.userInput) {
      "select" == i2.mode && i2.enforceWhitelist && this.value.length && "Tab" != t2.key && t2.preventDefault();
      var n2 = this.trim(t2.target.textContent);
      this.trigger("keydown", { event: t2 }), i2.hooks.beforeKeyDown(t2, { tagify: this }).then(function(s2) {
        if ("mix" == i2.mode) {
          switch (t2.key) {
            case "Left":
            case "ArrowLeft":
              e2.state.actions.ArrowLeft = true;
              break;
            case "Delete":
            case "Backspace":
              if (e2.state.editing)
                return;
              var a2 = document.getSelection(), o2 = "Delete" == t2.key && a2.anchorOffset == (a2.anchorNode.length || 0), l2 = a2.anchorNode.previousSibling, c2 = 1 == a2.anchorNode.nodeType || !a2.anchorOffset && l2 && 1 == l2.nodeType && a2.anchorNode.previousSibling;
              r(e2.DOM.input.innerHTML);
              var u2, g2, h2, p2 = e2.getTagElms(), m2 = 1 === a2.anchorNode.length && a2.anchorNode.nodeValue == String.fromCharCode(8203);
              if ("edit" == i2.backspace && c2)
                return u2 = 1 == a2.anchorNode.nodeType ? null : a2.anchorNode.previousElementSibling, setTimeout(e2.editTag.bind(e2), 0, u2), void t2.preventDefault();
              if (f() && U(c2, Element))
                return h2 = d(c2), c2.hasAttribute("readonly") || c2.remove(), e2.DOM.input.focus(), void setTimeout(function() {
                  T(h2), e2.DOM.input.click();
                });
              if ("BR" == a2.anchorNode.nodeName)
                return;
              if ((o2 || c2) && 1 == a2.anchorNode.nodeType ? g2 = 0 == a2.anchorOffset ? o2 ? p2[0] : null : p2[Math.min(p2.length, a2.anchorOffset) - 1] : o2 ? g2 = a2.anchorNode.nextElementSibling : U(c2, Element) && (g2 = c2), 3 == a2.anchorNode.nodeType && !a2.anchorNode.nodeValue && a2.anchorNode.previousElementSibling && t2.preventDefault(), (c2 || o2) && !i2.backspace)
                return void t2.preventDefault();
              if ("Range" != a2.type && !a2.anchorOffset && a2.anchorNode == e2.DOM.input && "Delete" != t2.key)
                return void t2.preventDefault();
              if ("Range" != a2.type && g2 && g2.hasAttribute("readonly"))
                return void T(d(g2));
              "Delete" == t2.key && m2 && y(a2.anchorNode.nextSibling) && e2.removeTags(a2.anchorNode.nextSibling), clearTimeout(k), k = setTimeout(function() {
                var t3 = document.getSelection();
                r(e2.DOM.input.innerHTML), !o2 && t3.anchorNode.previousSibling, e2.value = [].map.call(p2, function(t4, i3) {
                  var n3 = y(t4);
                  if (t4.parentNode || n3.readonly)
                    return n3;
                  e2.trigger("remove", { tag: t4, index: i3, data: n3 });
                }).filter(function(t4) {
                  return t4;
                });
              }, 20);
          }
          return true;
        }
        var v2 = "manual" == i2.dropdown.position;
        switch (t2.key) {
          case "Backspace":
            "select" == i2.mode && i2.enforceWhitelist && e2.value.length ? e2.removeTags() : e2.state.dropdown.visible && "manual" != i2.dropdown.position || "" != t2.target.textContent && 8203 != n2.charCodeAt(0) || (true === i2.backspace ? e2.removeTags() : "edit" == i2.backspace && setTimeout(e2.editTag.bind(e2), 0));
            break;
          case "Esc":
          case "Escape":
            if (e2.state.dropdown.visible)
              return;
            t2.target.blur();
            break;
          case "Down":
          case "ArrowDown":
            e2.state.dropdown.visible || e2.dropdown.show();
            break;
          case "ArrowRight":
            var b2 = e2.state.inputSuggestion || e2.state.ddItemData;
            if (b2 && i2.autoComplete.rightKey)
              return void e2.addTags([b2], true);
            break;
          case "Tab":
            var w2 = "select" == i2.mode;
            if (!n2 || w2)
              return true;
            t2.preventDefault();
          case "Enter":
            if (e2.state.dropdown.visible && !v2)
              return;
            t2.preventDefault(), setTimeout(function() {
              e2.state.dropdown.visible && !v2 || e2.state.actions.selectOption || !i2.addTagOn.includes(t2.key.toLowerCase()) || e2.addTags(n2, true);
            });
        }
      }).catch(function(t3) {
        return t3;
      });
    }
  }, onInput: function(t2) {
    this.postUpdate();
    var e2 = this.settings;
    if ("mix" == e2.mode)
      return this.events.callbacks.onMixTagsInput.call(this, t2);
    var i2 = this.input.normalize.call(this, void 0, { trim: false }), n2 = i2.length >= e2.dropdown.enabled, s2 = { value: i2, inputElm: this.DOM.input }, a2 = this.validateTag({ value: i2 });
    "select" == e2.mode && this.toggleScopeValidation(a2), s2.isValid = a2, this.state.inputText != i2 && (this.input.set.call(this, i2, false), -1 != i2.search(e2.delimiters) ? this.addTags(i2) && this.input.set.call(this) : e2.dropdown.enabled >= 0 && this.dropdown[n2 ? "show" : "hide"](i2), this.trigger("input", s2));
  }, onMixTagsInput: function(t2) {
    var e2, i2, n2, s2, a2, o2, r2, l2, d2 = this, c2 = this.settings, u2 = this.value.length, h2 = this.getTagElms(), p2 = document.createDocumentFragment(), m2 = window.getSelection().getRangeAt(0), v2 = [].map.call(h2, function(t3) {
      return y(t3).value;
    });
    if ("deleteContentBackward" == t2.inputType && f() && this.events.callbacks.onKeydown.call(this, { target: t2.target, key: "Backspace" }), O(this.getTagElms()), this.value.slice().forEach(function(t3) {
      t3.readonly && !v2.includes(t3.value) && p2.appendChild(d2.createTagElem(t3));
    }), p2.childNodes.length && (m2.insertNode(p2), this.setRangeAtStartEnd(false, p2.lastChild)), h2.length != u2)
      return this.value = [].map.call(this.getTagElms(), function(t3) {
        return y(t3);
      }), void this.update({ withoutChangeEvent: true });
    if (this.hasMaxTags())
      return true;
    if (window.getSelection && (o2 = window.getSelection()).rangeCount > 0 && 3 == o2.anchorNode.nodeType) {
      if ((m2 = o2.getRangeAt(0).cloneRange()).collapse(true), m2.setStart(o2.focusNode, 0), n2 = (e2 = m2.toString().slice(0, m2.endOffset)).split(c2.pattern).length - 1, (i2 = e2.match(c2.pattern)) && (s2 = e2.slice(e2.lastIndexOf(i2[i2.length - 1]))), s2) {
        if (this.state.actions.ArrowLeft = false, this.state.tag = { prefix: s2.match(c2.pattern)[0], value: s2.replace(c2.pattern, "") }, this.state.tag.baseOffset = o2.baseOffset - this.state.tag.value.length, l2 = this.state.tag.value.match(c2.delimiters))
          return this.state.tag.value = this.state.tag.value.replace(c2.delimiters, ""), this.state.tag.delimiters = l2[0], this.addTags(this.state.tag.value, c2.dropdown.clearOnSelect), void this.dropdown.hide();
        a2 = this.state.tag.value.length >= c2.dropdown.enabled;
        try {
          r2 = (r2 = this.state.flaggedTags[this.state.tag.baseOffset]).prefix == this.state.tag.prefix && r2.value[0] == this.state.tag.value[0], this.state.flaggedTags[this.state.tag.baseOffset] && !this.state.tag.value && delete this.state.flaggedTags[this.state.tag.baseOffset];
        } catch (t3) {
        }
        (r2 || n2 < this.state.mixMode.matchedPatternCount) && (a2 = false);
      } else
        this.state.flaggedTags = {};
      this.state.mixMode.matchedPatternCount = n2;
    }
    setTimeout(function() {
      d2.update({ withoutChangeEvent: true }), d2.trigger("input", g({}, d2.state.tag, { textContent: d2.DOM.input.textContent })), d2.state.tag && d2.dropdown[a2 ? "show" : "hide"](d2.state.tag.value);
    }, 10);
  }, onInputIE: function(t2) {
    var e2 = this;
    setTimeout(function() {
      e2.events.callbacks.onInput.call(e2, t2);
    });
  }, observeOriginalInputValue: function() {
    this.DOM.originalInput.parentNode || this.destroy(), this.DOM.originalInput.value != this.DOM.originalInput.tagifyValue && this.loadOriginalValues();
  }, onClickAnywhere: function(t2) {
    t2.target == this.DOM.scope || this.DOM.scope.contains(t2.target) || (this.toggleFocusClass(false), this.state.hasFocus = false, t2.target.closest(".tagify__dropdown") && t2.target.closest(".tagify__dropdown").__tagify != this && this.dropdown.hide());
  }, onClickScope: function(t2) {
    var e2 = this.settings, i2 = t2.target.closest("." + e2.classNames.tag), n2 = t2.target === this.DOM.scope, s2 = +/* @__PURE__ */ new Date() - this.state.hasFocus;
    if (n2 && "select" != e2.mode)
      this.DOM.input.focus();
    else {
      if (!t2.target.classList.contains(e2.classNames.tagX))
        return i2 && !this.state.editing ? (this.trigger("click", { tag: i2, index: this.getNodeIndex(i2), data: y(i2), event: t2 }), void (1 !== e2.editTags && 1 !== e2.editTags.clicks && "select" != e2.mode || this.events.callbacks.onDoubleClickScope.call(this, t2))) : void (t2.target == this.DOM.input && ("mix" == e2.mode && this.fixFirefoxLastTagNoCaret(), s2 > 500 || !e2.focusable) ? this.state.dropdown.visible ? this.dropdown.hide() : 0 === e2.dropdown.enabled && "mix" != e2.mode && this.dropdown.show(this.value.length ? "" : void 0) : "select" != e2.mode || 0 !== e2.dropdown.enabled || this.state.dropdown.visible || (this.events.callbacks.onDoubleClickScope.call(this, q(function(t3) {
          for (var e3 = 1; e3 < arguments.length; e3++) {
            var i3 = null != arguments[e3] ? arguments[e3] : {}, n3 = Object.keys(i3);
            "function" == typeof Object.getOwnPropertySymbols && (n3 = n3.concat(Object.getOwnPropertySymbols(i3).filter(function(t4) {
              return Object.getOwnPropertyDescriptor(i3, t4).enumerable;
            }))), n3.forEach(function(e4) {
              W(t3, e4, i3[e4]);
            });
          }
          return t3;
        }({}, t2), { target: this.getTagElms()[0] })), !e2.userInput && this.dropdown.show()));
      this.removeTags(t2.target.parentNode);
    }
  }, onPaste: function(t2) {
    var e2 = this;
    t2.preventDefault();
    var i2, n2, s2, a2 = this.settings;
    if ("select" == a2.mode && a2.enforceWhitelist || !a2.userInput)
      return false;
    a2.readonly || (n2 = t2.clipboardData || window.clipboardData, s2 = n2.getData("Text"), a2.hooks.beforePaste(t2, { tagify: this, pastedText: s2, clipboardData: n2 }).then(function(a3) {
      void 0 === a3 && (a3 = s2), a3 && (e2.injectAtCaret(a3, window.getSelection().getRangeAt(0)), "mix" == e2.settings.mode ? e2.events.callbacks.onMixTagsInput.call(e2, t2) : e2.settings.pasteAsTags ? i2 = e2.addTags(e2.state.inputText + a3, true) : (e2.state.inputText = a3, e2.dropdown.show(a3))), e2.trigger("paste", { event: t2, pastedText: s2, clipboardData: n2, tagsElems: i2 });
    }).catch(function(t3) {
      return t3;
    }));
  }, onDrop: function(t2) {
    t2.preventDefault();
  }, onEditTagInput: function(t2, e2) {
    var i2, n2 = t2.closest("." + this.settings.classNames.tag), s2 = this.getNodeIndex(n2), a2 = y(n2), o2 = this.input.normalize.call(this, t2), r2 = (W(i2 = {}, this.settings.tagTextProp, o2), W(i2, "__tagId", a2.__tagId), i2), l2 = this.validateTag(r2);
    this.editTagChangeDetected(g(a2, r2)) || true !== t2.originalIsValid || (l2 = true), n2.classList.toggle(this.settings.classNames.tagInvalid, true !== l2), a2.__isValid = l2, n2.title = true === l2 ? a2.title || a2.value : l2, o2.length >= this.settings.dropdown.enabled && (this.state.editing && (this.state.editing.value = o2), this.dropdown.show(o2)), this.trigger("edit:input", { tag: n2, index: s2, data: g({}, this.value[s2], { newValue: o2 }), event: e2 });
  }, onEditTagPaste: function(t2, e2) {
    var i2 = (e2.clipboardData || window.clipboardData).getData("Text");
    e2.preventDefault();
    var n2 = w(i2);
    this.setRangeAtStartEnd(false, n2);
  }, onEditTagClick: function(t2, e2) {
    this.events.callbacks.onClickScope.call(this, e2);
  }, onEditTagFocus: function(t2) {
    this.state.editing = { scope: t2, input: t2.querySelector("[contenteditable]") };
  }, onEditTagBlur: function(t2, e2) {
    var i2 = v.call(this, e2.relatedTarget);
    if ("select" == this.settings.mode && i2 && e2.relatedTarget.contains(e2.target))
      this.dropdown.hide();
    else if (this.state.editing && (this.state.hasFocus || this.toggleFocusClass(), this.DOM.scope.contains(t2))) {
      var n2, s2, a2, o2 = this.settings, r2 = t2.closest("." + o2.classNames.tag), l2 = y(r2), d2 = this.input.normalize.call(this, t2), c2 = (W(n2 = {}, o2.tagTextProp, d2), W(n2, "__tagId", l2.__tagId), n2), u2 = l2.__originalData, h2 = this.editTagChangeDetected(g(l2, c2)), p2 = this.validateTag(c2);
      if (d2)
        if (h2) {
          var f2;
          if (s2 = this.hasMaxTags(), a2 = g({}, u2, (W(f2 = {}, o2.tagTextProp, this.trim(d2)), W(f2, "__isValid", p2), f2)), o2.transformTag.call(this, a2, u2), true !== (p2 = (!s2 || true === u2.__isValid) && this.validateTag(a2))) {
            if (this.trigger("invalid", { data: a2, tag: r2, message: p2 }), o2.editTags.keepInvalid)
              return;
            o2.keepInvalidTags ? a2.__isValid = p2 : a2 = u2;
          } else
            o2.keepInvalidTags && (delete a2.title, delete a2["aria-invalid"], delete a2.class);
          this.onEditTagDone(r2, a2);
        } else
          this.onEditTagDone(r2, u2);
      else
        this.onEditTagDone(r2);
    }
  }, onEditTagkeydown: function(t2, e2) {
    if (!this.state.composing)
      switch (this.trigger("edit:keydown", { event: t2 }), t2.key) {
        case "Esc":
        case "Escape":
          this.state.editing = false, !!e2.__tagifyTagData.__originalData.value ? e2.parentNode.replaceChild(e2.__tagifyTagData.__originalHTML, e2) : e2.remove();
          break;
        case "Enter":
        case "Tab":
          t2.preventDefault();
          setTimeout(function() {
            return t2.target.blur();
          }, 0);
      }
  }, onDoubleClickScope: function(t2) {
    var e2, i2, n2 = t2.target.closest("." + this.settings.classNames.tag), s2 = y(n2), a2 = this.settings;
    n2 && false !== s2.editable && (e2 = n2.classList.contains(this.settings.classNames.tagEditing), i2 = n2.hasAttribute("readonly"), a2.readonly || e2 || i2 || !this.settings.editTags || !a2.userInput || (this.events.callbacks.onEditTagFocus.call(this, n2), this.editTag(n2)), this.toggleFocusClass(true), "select" != a2.mode && this.trigger("dblclick", { tag: n2, index: this.getNodeIndex(n2), data: y(n2) }));
  }, onInputDOMChange: function(t2) {
    var e2 = this;
    t2.forEach(function(t3) {
      t3.addedNodes.forEach(function(t4) {
        if ("<div><br></div>" == t4.outerHTML)
          t4.replaceWith(document.createElement("br"));
        else if (1 == t4.nodeType && t4.querySelector(e2.settings.classNames.tagSelector)) {
          var i3, n2 = document.createTextNode("");
          3 == t4.childNodes[0].nodeType && "BR" != t4.previousSibling.nodeName && (n2 = document.createTextNode("\n")), (i3 = t4).replaceWith.apply(i3, K([n2].concat(K(K(t4.childNodes).slice(0, -1))))), T(n2);
        } else if (v.call(e2, t4)) {
          var s2;
          if (3 != (null === (s2 = t4.previousSibling) || void 0 === s2 ? void 0 : s2.nodeType) || t4.previousSibling.textContent || t4.previousSibling.remove(), t4.previousSibling && "BR" == t4.previousSibling.nodeName) {
            t4.previousSibling.replaceWith("\n\u200B");
            for (var a2 = t4.nextSibling, o2 = ""; a2; )
              o2 += a2.textContent, a2 = a2.nextSibling;
            o2.trim() && T(t4.previousSibling);
          } else
            t4.previousSibling && !y(t4.previousSibling) || t4.before("\u200B");
        }
      }), t3.removedNodes.forEach(function(t4) {
        t4 && "BR" == t4.nodeName && v.call(e2, i2) && (e2.removeTags(i2), e2.fixFirefoxLastTagNoCaret());
      });
    });
    var i2 = this.DOM.input.lastChild;
    i2 && "" == i2.nodeValue && i2.remove(), i2 && "BR" == i2.nodeName || this.DOM.input.appendChild(document.createElement("br"));
  } } };
  function X(t2, e2) {
    (null == e2 || e2 > t2.length) && (e2 = t2.length);
    for (var i2 = 0, n2 = new Array(e2); i2 < e2; i2++)
      n2[i2] = t2[i2];
    return n2;
  }
  __name(X, "X");
  function J(t2, e2, i2) {
    return e2 in t2 ? Object.defineProperty(t2, e2, { value: i2, enumerable: true, configurable: true, writable: true }) : t2[e2] = i2, t2;
  }
  __name(J, "J");
  function G(t2, e2) {
    return null != e2 && "undefined" != typeof Symbol && e2[Symbol.hasInstance] ? !!e2[Symbol.hasInstance](t2) : t2 instanceof e2;
  }
  __name(G, "G");
  function $(t2) {
    for (var e2 = 1; e2 < arguments.length; e2++) {
      var i2 = null != arguments[e2] ? arguments[e2] : {}, n2 = Object.keys(i2);
      "function" == typeof Object.getOwnPropertySymbols && (n2 = n2.concat(Object.getOwnPropertySymbols(i2).filter(function(t3) {
        return Object.getOwnPropertyDescriptor(i2, t3).enumerable;
      }))), n2.forEach(function(e3) {
        J(t2, e3, i2[e3]);
      });
    }
    return t2;
  }
  __name($, "$");
  function Q(t2) {
    return function(t3) {
      if (Array.isArray(t3))
        return X(t3);
    }(t2) || function(t3) {
      if ("undefined" != typeof Symbol && null != t3[Symbol.iterator] || null != t3["@@iterator"])
        return Array.from(t3);
    }(t2) || function(t3, e2) {
      if (!t3)
        return;
      if ("string" == typeof t3)
        return X(t3, e2);
      var i2 = Object.prototype.toString.call(t3).slice(8, -1);
      "Object" === i2 && t3.constructor && (i2 = t3.constructor.name);
      if ("Map" === i2 || "Set" === i2)
        return Array.from(i2);
      if ("Arguments" === i2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i2))
        return X(t3, e2);
    }(t2) || function() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }();
  }
  __name(Q, "Q");
  function Y(t2, e2) {
    if (!t2) {
      n.warn("input element not found", t2);
      var i2 = new Proxy(this, { get: function() {
        return function() {
          return i2;
        };
      } });
      return i2;
    }
    if (t2.__tagify)
      return n.warn("input element is already Tagified - Same instance is returned.", t2), t2.__tagify;
    var s2;
    g(this, function(t3) {
      var e3 = document.createTextNode(""), i3 = {};
      function s3(t4, i4, n2) {
        n2 && i4.split(/\s+/g).forEach(function(i5) {
          return e3[t4 + "EventListener"].call(e3, i5, n2);
        });
      }
      __name(s3, "s");
      return { removeAllCustomListeners: function() {
        Object.entries(i3).forEach(function(t4) {
          var e4 = H(t4, 2), i4 = e4[0];
          e4[1].forEach(function(t5) {
            return s3("remove", i4, t5);
          });
        }), i3 = {};
      }, off: function(t4, e4) {
        return t4 && (e4 ? s3("remove", t4, e4) : t4.split(/\s+/g).forEach(function(t5) {
          var e5;
          null === (e5 = i3[t5]) || void 0 === e5 || e5.forEach(function(e6) {
            return s3("remove", t5, e6);
          }), delete i3[t5];
        })), this;
      }, on: function(t4, e4) {
        return e4 && "function" == typeof e4 && (t4.split(/\s+/g).forEach(function(t5) {
          Array.isArray(i3[t5]) ? i3[t5].push(e4) : i3[t5] = [e4];
        }), s3("add", t4, e4)), this;
      }, trigger: function(i4, s4, a2) {
        var o2;
        if (a2 = a2 || { cloneData: true }, i4)
          if (t3.settings.isJQueryPlugin)
            "remove" == i4 && (i4 = "removeTag"), jQuery(t3.DOM.originalInput).triggerHandler(i4, [s4]);
          else {
            try {
              var r2 = "object" == typeof s4 ? s4 : { value: s4 };
              if ((r2 = a2.cloneData ? g({}, r2) : r2).tagify = this, s4.event && (r2.event = this.cloneEvent(s4.event)), R(s4, Object))
                for (var l2 in s4)
                  R(s4[l2], HTMLElement) && (r2[l2] = s4[l2]);
              o2 = new CustomEvent(i4, { detail: r2 });
            } catch (t4) {
              n.warn(t4);
            }
            e3.dispatchEvent(o2);
          }
      } };
    }(this)), this.isFirefox = /firefox|fxios/i.test(navigator.userAgent) && !/seamonkey/i.test(navigator.userAgent), this.isIE = window.document.documentMode, e2 = e2 || {}, this.getPersistedData = (s2 = e2.id, function(t3) {
      var e3, i3 = "/" + t3;
      if (1 == localStorage.getItem(j + s2 + "/v", 1))
        try {
          e3 = JSON.parse(localStorage[j + s2 + i3]);
        } catch (t4) {
        }
      return e3;
    }), this.setPersistedData = function(t3) {
      return t3 ? (localStorage.setItem(j + t3 + "/v", 1), function(e3, i3) {
        var n2 = "/" + i3, s3 = JSON.stringify(e3);
        e3 && i3 && (localStorage.setItem(j + t3 + n2, s3), dispatchEvent(new Event("storage")));
      }) : function() {
      };
    }(e2.id), this.clearPersistedData = /* @__PURE__ */ function(t3) {
      return function(e3) {
        var i3 = j + "/" + t3 + "/";
        if (e3)
          localStorage.removeItem(i3 + e3);
        else
          for (var n2 in localStorage)
            n2.includes(i3) && localStorage.removeItem(n2);
      };
    }(e2.id), this.applySettings(t2, e2), this.state = { inputText: "", editing: false, composing: false, actions: {}, mixMode: {}, dropdown: {}, flaggedTags: {} }, this.value = [], this.listeners = {}, this.DOM = {}, this.build(t2), _.call(this), this.getCSSVars(), this.loadOriginalValues(), this.events.customBinding.call(this), this.events.binding.call(this), t2.autofocus && this.DOM.input.focus(), t2.__tagify = this;
  }
  __name(Y, "Y");
  Y.prototype = { _dropdown: L, placeCaretAfterNode: T, getSetTagData: y, helpers: { sameStr: s, removeCollectionProp: a, omit: o, isObject: u, parseHTML: l, escapeHTML: c, extend: g, concatWithoutDups: h, getUID: m, isNodeTag: v }, customEventsList: ["change", "add", "remove", "invalid", "input", "paste", "click", "keydown", "focus", "blur", "edit:input", "edit:beforeUpdate", "edit:updated", "edit:start", "edit:keydown", "dropdown:show", "dropdown:hide", "dropdown:select", "dropdown:updated", "dropdown:noMatch", "dropdown:scroll"], dataProps: ["__isValid", "__removed", "__originalData", "__originalHTML", "__tagId"], trim: function(t2) {
    return this.settings.trim && t2 && "string" == typeof t2 ? t2.trim() : t2;
  }, parseHTML: l, templates: V, parseTemplate: function(t2, e2) {
    return l((t2 = this.settings.templates[t2] || t2).apply(this, e2));
  }, set whitelist(t2) {
    var e2 = t2 && Array.isArray(t2);
    this.settings.whitelist = e2 ? t2 : [], this.setPersistedData(e2 ? t2 : [], "whitelist");
  }, get whitelist() {
    return this.settings.whitelist;
  }, set userInput(t2) {
    this.settings.userInput = !!t2, this.setContentEditable(!!t2);
  }, get userInput() {
    return this.settings.userInput;
  }, generateClassSelectors: function(t2) {
    var e2 = /* @__PURE__ */ __name(function(e3) {
      var i3 = e3;
      Object.defineProperty(t2, i3 + "Selector", { get: function() {
        return "." + this[i3].split(" ")[0];
      } });
    }, "e");
    for (var i2 in t2)
      e2(i2);
  }, applySettings: function(t2, e2) {
    var i2, n2;
    x.templates = this.templates;
    var s2 = g({}, x, "mix" == e2.mode ? { dropdown: { position: "text" } } : {}), a2 = this.settings = g({}, s2, e2);
    if (a2.disabled = t2.hasAttribute("disabled"), a2.readonly = a2.readonly || t2.hasAttribute("readonly"), a2.placeholder = c(t2.getAttribute("placeholder") || a2.placeholder || ""), a2.required = t2.hasAttribute("required"), this.generateClassSelectors(a2.classNames), void 0 === a2.dropdown.includeSelectedTags && (a2.dropdown.includeSelectedTags = a2.duplicates), this.isIE && (a2.autoComplete = false), ["whitelist", "blacklist"].forEach(function(e3) {
      var i3 = t2.getAttribute("data-" + e3);
      i3 && G(i3 = i3.split(a2.delimiters), Array) && (a2[e3] = i3);
    }), "autoComplete" in e2 && !u(e2.autoComplete) && (a2.autoComplete = x.autoComplete, a2.autoComplete.enabled = e2.autoComplete), "mix" == a2.mode && (a2.pattern = a2.pattern || /@/, a2.autoComplete.rightKey = true, a2.delimiters = e2.delimiters || null, a2.tagTextProp && !a2.dropdown.searchKeys.includes(a2.tagTextProp) && a2.dropdown.searchKeys.push(a2.tagTextProp)), t2.pattern)
      try {
        a2.pattern = new RegExp(t2.pattern);
      } catch (t3) {
      }
    if (a2.delimiters) {
      a2._delimiters = a2.delimiters;
      try {
        a2.delimiters = new RegExp(this.settings.delimiters, "g");
      } catch (t3) {
      }
    }
    a2.disabled && (a2.userInput = false), this.TEXTS = $({}, P, a2.texts || {}), ("select" != a2.mode || (null === (i2 = e2.dropdown) || void 0 === i2 ? void 0 : i2.enabled)) && a2.userInput || (a2.dropdown.enabled = 0), a2.dropdown.appendTarget = (null === (n2 = e2.dropdown) || void 0 === n2 ? void 0 : n2.appendTarget) || document.body;
    var o2 = this.getPersistedData("whitelist");
    Array.isArray(o2) && (this.whitelist = Array.isArray(a2.whitelist) ? h(a2.whitelist, o2) : o2);
  }, getAttributes: function(t2) {
    var e2, i2 = this.getCustomAttributes(t2), n2 = "";
    for (e2 in i2)
      n2 += " " + e2 + (void 0 !== t2[e2] ? '="'.concat(i2[e2], '"') : "");
    return n2;
  }, getCustomAttributes: function(t2) {
    if (!u(t2))
      return "";
    var e2, i2 = {};
    for (e2 in t2)
      "__" != e2.slice(0, 2) && "class" != e2 && t2.hasOwnProperty(e2) && void 0 !== t2[e2] && (i2[e2] = c(t2[e2]));
    return i2;
  }, setStateSelection: function() {
    var t2 = window.getSelection(), e2 = { anchorOffset: t2.anchorOffset, anchorNode: t2.anchorNode, range: t2.getRangeAt && t2.rangeCount && t2.getRangeAt(0) };
    return this.state.selection = e2, e2;
  }, getCSSVars: function() {
    var t2, e2, i2, n2 = getComputedStyle(this.DOM.scope, null);
    this.CSSVars = { tagHideTransition: (t2 = function(t3) {
      if (!t3)
        return {};
      var e3 = (t3 = t3.trim().split(" ")[0]).split(/\d+/g).filter(function(t4) {
        return t4;
      }).pop().trim();
      return { value: +t3.split(e3).filter(function(t4) {
        return t4;
      })[0].trim(), unit: e3 };
    }((i2 = "tag-hide-transition", n2.getPropertyValue("--" + i2))), e2 = t2.value, "s" == t2.unit ? 1e3 * e2 : e2) };
  }, build: function(t2) {
    var e2 = this.DOM, i2 = t2.closest("label");
    this.settings.mixMode.integrated ? (e2.originalInput = null, e2.scope = t2, e2.input = t2) : (e2.originalInput = t2, e2.originalInput_tabIndex = t2.tabIndex, e2.scope = this.parseTemplate("wrapper", [t2, this.settings]), e2.input = e2.scope.querySelector(this.settings.classNames.inputSelector), t2.parentNode.insertBefore(e2.scope, t2), t2.tabIndex = -1), i2 && i2.setAttribute("for", "");
  }, destroy: function() {
    this.events.unbindGlobal.call(this), this.DOM.scope.parentNode.removeChild(this.DOM.scope), this.DOM.originalInput.tabIndex = this.DOM.originalInput_tabIndex, delete this.DOM.originalInput.__tagify, this.dropdown.hide(true), this.removeAllCustomListeners(), clearTimeout(this.dropdownHide__bindEventsTimeout), clearInterval(this.listeners.main.originalInputValueObserverInterval);
  }, loadOriginalValues: function(t2) {
    var e2, i2 = this.settings;
    if (this.state.blockChangeEvent = true, void 0 === t2) {
      var n2 = this.getPersistedData("value");
      t2 = n2 && !this.DOM.originalInput.value ? n2 : i2.mixMode.integrated ? this.DOM.input.textContent : this.DOM.originalInput.value;
    }
    if (this.removeAllTags(), t2)
      if ("mix" == i2.mode)
        this.parseMixTags(t2), (e2 = this.DOM.input.lastChild) && "BR" == e2.tagName || this.DOM.input.insertAdjacentHTML("beforeend", "<br>");
      else {
        try {
          G(JSON.parse(t2), Array) && (t2 = JSON.parse(t2));
        } catch (t3) {
        }
        this.addTags(t2, true).forEach(function(t3) {
          return t3 && t3.classList.add(i2.classNames.tagNoAnimation);
        });
      }
    else
      this.postUpdate();
    this.state.lastOriginalValueReported = i2.mixMode.integrated ? "" : this.DOM.originalInput.value;
  }, cloneEvent: function(t2) {
    var e2 = {};
    for (var i2 in t2)
      "path" != i2 && (e2[i2] = t2[i2]);
    return e2;
  }, loading: function(t2) {
    return this.state.isLoading = t2, this.DOM.scope.classList[t2 ? "add" : "remove"](this.settings.classNames.scopeLoading), this;
  }, tagLoading: function(t2, e2) {
    return t2 && t2.classList[e2 ? "add" : "remove"](this.settings.classNames.tagLoading), this;
  }, toggleClass: function(t2, e2) {
    "string" == typeof t2 && this.DOM.scope.classList.toggle(t2, e2);
  }, toggleScopeValidation: function(t2) {
    var e2 = true === t2 || void 0 === t2;
    !this.settings.required && t2 && t2 === this.TEXTS.empty && (e2 = true), this.toggleClass(this.settings.classNames.tagInvalid, !e2), this.DOM.scope.title = e2 ? "" : t2;
  }, toggleFocusClass: function(t2) {
    this.toggleClass(this.settings.classNames.focus, !!t2);
  }, setPlaceholder: function(t2) {
    var e2 = this;
    ["data", "aria"].forEach(function(i2) {
      return e2.DOM.input.setAttribute("".concat(i2, "-placeholder"), t2);
    });
  }, triggerChangeEvent: function() {
    if (!this.settings.mixMode.integrated) {
      var t2 = this.DOM.originalInput, e2 = this.state.lastOriginalValueReported !== t2.value, i2 = new CustomEvent("change", { bubbles: true });
      e2 && (this.state.lastOriginalValueReported = t2.value, i2.simulated = true, t2._valueTracker && t2._valueTracker.setValue(Math.random()), t2.dispatchEvent(i2), this.trigger("change", this.state.lastOriginalValueReported), t2.value = this.state.lastOriginalValueReported);
    }
  }, events: z, fixFirefoxLastTagNoCaret: function() {
  }, setRangeAtStartEnd: function(t2, e2) {
    if (e2) {
      t2 = "number" == typeof t2 ? t2 : !!t2, e2 = e2.lastChild || e2;
      var i2 = document.getSelection();
      if (G(i2.focusNode, Element) && !this.DOM.input.contains(i2.focusNode))
        return true;
      try {
        i2.rangeCount >= 1 && ["Start", "End"].forEach(function(n2) {
          return i2.getRangeAt(0)["set" + n2](e2, t2 || e2.length);
        });
      } catch (t3) {
        console.warn(t3);
      }
    }
  }, insertAfterTag: function(t2, e2) {
    if (e2 = e2 || this.settings.mixMode.insertAfterTag, t2 && t2.parentNode && e2)
      return e2 = "string" == typeof e2 ? document.createTextNode(e2) : e2, t2.parentNode.insertBefore(e2, t2.nextSibling), e2;
  }, editTagChangeDetected: function(t2) {
    var e2 = t2.__originalData;
    for (var i2 in e2)
      if (!this.dataProps.includes(i2) && t2[i2] != e2[i2])
        return true;
    return false;
  }, getTagTextNode: function(t2) {
    return t2.querySelector(this.settings.classNames.tagTextSelector);
  }, setTagTextNode: function(t2, e2) {
    this.getTagTextNode(t2).innerHTML = c(e2);
  }, editTag: function(t2, e2) {
    var i2 = this;
    t2 = t2 || this.getLastTag(), e2 = e2 || {};
    var s2 = this.settings, a2 = this.getTagTextNode(t2), o2 = this.getNodeIndex(t2), r2 = y(t2), l2 = this.events.callbacks, d2 = true, c2 = "select" == s2.mode;
    if (!c2 && this.dropdown.hide(), a2) {
      if (!G(r2, Object) || !("editable" in r2) || r2.editable)
        return r2 = y(t2, { __originalData: g({}, r2), __originalHTML: t2.cloneNode(true) }), y(r2.__originalHTML, r2.__originalData), a2.setAttribute("contenteditable", true), t2.classList.add(s2.classNames.tagEditing), a2.addEventListener("click", l2.onEditTagClick.bind(this, t2)), a2.addEventListener("blur", l2.onEditTagBlur.bind(this, this.getTagTextNode(t2))), a2.addEventListener("input", l2.onEditTagInput.bind(this, a2)), a2.addEventListener("paste", l2.onEditTagPaste.bind(this, a2)), a2.addEventListener("keydown", function(e3) {
          return l2.onEditTagkeydown.call(i2, e3, t2);
        }), a2.addEventListener("compositionstart", l2.onCompositionStart.bind(this)), a2.addEventListener("compositionend", l2.onCompositionEnd.bind(this)), e2.skipValidation || (d2 = this.editTagToggleValidity(t2)), a2.originalIsValid = d2, this.trigger("edit:start", { tag: t2, index: o2, data: r2, isValid: d2 }), a2.focus(), !c2 && this.setRangeAtStartEnd(false, a2), 0 === s2.dropdown.enabled && !c2 && this.dropdown.show(), this.state.hasFocus = true, this;
    } else
      n.warn("Cannot find element in Tag template: .", s2.classNames.tagTextSelector);
  }, editTagToggleValidity: function(t2, e2) {
    var i2;
    if (e2 = e2 || y(t2))
      return (i2 = !("__isValid" in e2) || true === e2.__isValid) || this.removeTagsFromValue(t2), this.update(), t2.classList.toggle(this.settings.classNames.tagNotAllowed, !i2), e2.__isValid = i2, e2.__isValid;
    n.warn("tag has no data: ", t2, e2);
  }, onEditTagDone: function(t2, e2) {
    t2 = t2 || this.state.editing.scope, e2 = e2 || {};
    var i2, n2, s2 = { tag: t2, index: this.getNodeIndex(t2), previousData: y(t2), data: e2 }, a2 = this.settings;
    this.trigger("edit:beforeUpdate", s2, { cloneData: false }), this.state.editing = false, delete e2.__originalData, delete e2.__originalHTML, t2 && (void 0 !== (n2 = e2[a2.tagTextProp]) ? null === (i2 = (n2 += "").trim) || void 0 === i2 ? void 0 : i2.call(n2) : a2.tagTextProp in e2 ? void 0 : e2.value) ? (t2 = this.replaceTag(t2, e2), this.editTagToggleValidity(t2, e2), a2.a11y.focusableTags ? t2.focus() : "select" != a2.mode && T(t2)) : t2 && this.removeTags(t2), this.trigger("edit:updated", s2), this.dropdown.hide(), this.settings.keepInvalidTags && this.reCheckInvalidTags();
  }, replaceTag: function(t2, e2) {
    e2 && "" !== e2.value && void 0 !== e2.value || (e2 = t2.__tagifyTagData), e2.__isValid && 1 != e2.__isValid && g(e2, this.getInvalidTagAttrs(e2, e2.__isValid));
    var i2 = this.createTagElem(e2);
    return t2.parentNode.replaceChild(i2, t2), this.updateValueByDOMTags(), i2;
  }, updateValueByDOMTags: function() {
    var t2 = this;
    this.value.length = 0, [].forEach.call(this.getTagElms(), function(e2) {
      e2.classList.contains(t2.settings.classNames.tagNotAllowed.split(" ")[0]) || t2.value.push(y(e2));
    }), this.update();
  }, injectAtCaret: function(t2, e2) {
    var i2;
    if (!(e2 = e2 || (null === (i2 = this.state.selection) || void 0 === i2 ? void 0 : i2.range)) && t2)
      return this.appendMixTags(t2), this;
    var n2 = w(t2, e2);
    return this.setRangeAtStartEnd(false, n2), this.updateValueByDOMTags(), this.update(), this;
  }, input: { set: function() {
    var t2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "", e2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], i2 = this.settings.dropdown.closeOnSelect;
    this.state.inputText = t2, e2 && (this.DOM.input.innerHTML = c("" + t2)), !t2 && i2 && this.dropdown.hide.bind(this), this.input.autocomplete.suggest.call(this), this.input.validate.call(this);
  }, raw: function() {
    return this.DOM.input.textContent;
  }, validate: function() {
    var t2 = !this.state.inputText || true === this.validateTag({ value: this.state.inputText });
    return this.DOM.input.classList.toggle(this.settings.classNames.inputInvalid, !t2), t2;
  }, normalize: function(t2, e2) {
    var i2 = t2 || this.DOM.input, n2 = [];
    i2.childNodes.forEach(function(t3) {
      return 3 == t3.nodeType && n2.push(t3.nodeValue);
    }), n2 = n2.join("\n");
    try {
      n2 = n2.replace(/(?:\r\n|\r|\n)/g, this.settings.delimiters.source.charAt(0));
    } catch (t3) {
    }
    return n2 = n2.replace(/\s/g, " "), (null == e2 ? void 0 : e2.trim) ? this.trim(n2) : n2;
  }, autocomplete: { suggest: function(t2) {
    if (this.settings.autoComplete.enabled) {
      "object" != typeof (t2 = t2 || { value: "" }) && (t2 = { value: t2 });
      var e2 = this.dropdown.getMappedValue(t2);
      if ("number" != typeof e2) {
        var i2 = this.state.inputText.toLowerCase(), n2 = e2.substr(0, this.state.inputText.length).toLowerCase(), s2 = e2.substring(this.state.inputText.length);
        e2 && this.state.inputText && n2 == i2 ? (this.DOM.input.setAttribute("data-suggest", s2), this.state.inputSuggestion = t2) : (this.DOM.input.removeAttribute("data-suggest"), delete this.state.inputSuggestion);
      }
    }
  }, set: function(t2) {
    var e2 = this.DOM.input.getAttribute("data-suggest"), i2 = t2 || (e2 ? this.state.inputText + e2 : null);
    return !!i2 && ("mix" == this.settings.mode ? this.replaceTextWithNode(document.createTextNode(this.state.tag.prefix + i2)) : (this.input.set.call(this, i2), this.setRangeAtStartEnd(false, this.DOM.input)), this.input.autocomplete.suggest.call(this), this.dropdown.hide(), true);
  } } }, getTagIdx: function(t2) {
    return this.value.findIndex(function(e2) {
      return e2.__tagId == (t2 || {}).__tagId;
    });
  }, getNodeIndex: function(t2) {
    var e2 = 0;
    if (t2)
      for (; t2 = t2.previousElementSibling; )
        e2++;
    return e2;
  }, getTagElms: function() {
    for (var t2 = arguments.length, e2 = new Array(t2), i2 = 0; i2 < t2; i2++)
      e2[i2] = arguments[i2];
    var n2 = "." + Q(this.settings.classNames.tag.split(" ")).concat(Q(e2)).join(".");
    return [].slice.call(this.DOM.scope.querySelectorAll(n2));
  }, getLastTag: function() {
    var t2 = this.settings.classNames, e2 = this.DOM.scope.querySelectorAll("".concat(t2.tagSelector, ":not(.").concat(t2.tagHide, "):not([readonly])"));
    return e2[e2.length - 1];
  }, isTagDuplicate: function(t2, e2, i2) {
    var n2 = 0;
    if ("select" == this.settings.mode)
      return false;
    var a2 = true, o2 = false, r2 = void 0;
    try {
      for (var l2, d2 = this.value[Symbol.iterator](); !(a2 = (l2 = d2.next()).done); a2 = true) {
        var c2 = l2.value;
        s(this.trim("" + t2), c2.value, e2) && i2 != c2.__tagId && n2++;
      }
    } catch (t3) {
      o2 = true, r2 = t3;
    } finally {
      try {
        a2 || null == d2.return || d2.return();
      } finally {
        if (o2)
          throw r2;
      }
    }
    return n2;
  }, getTagIndexByValue: function(t2) {
    var e2 = this, i2 = [], n2 = this.settings.dropdown.caseSensitive;
    return this.getTagElms().forEach(function(a2, o2) {
      a2.__tagifyTagData && s(e2.trim(a2.__tagifyTagData.value), t2, n2) && i2.push(o2);
    }), i2;
  }, getTagElmByValue: function(t2) {
    var e2 = this.getTagIndexByValue(t2)[0];
    return this.getTagElms()[e2];
  }, flashTag: function(t2) {
    var e2 = this;
    t2 && (t2.classList.add(this.settings.classNames.tagFlash), setTimeout(function() {
      t2.classList.remove(e2.settings.classNames.tagFlash);
    }, 100));
  }, isTagBlacklisted: function(t2) {
    return t2 = this.trim(t2.toLowerCase()), this.settings.blacklist.filter(function(e2) {
      return ("" + e2).toLowerCase() == t2;
    }).length;
  }, isTagWhitelisted: function(t2) {
    return !!this.getWhitelistItem(t2);
  }, getWhitelistItem: function(t2, e2, i2) {
    e2 = e2 || "value";
    var n2, a2 = this.settings;
    return (i2 = i2 || a2.whitelist).some(function(i3) {
      var o2 = "object" == typeof i3 ? i3[e2] || i3.value : i3;
      if (s(o2, t2, a2.dropdown.caseSensitive, a2.trim))
        return n2 = "object" == typeof i3 ? i3 : { value: i3 }, true;
    }), n2 || "value" != e2 || "value" == a2.tagTextProp || (n2 = this.getWhitelistItem(t2, a2.tagTextProp, i2)), n2;
  }, validateTag: function(t2) {
    var e2 = this.settings, i2 = "value" in t2 ? "value" : e2.tagTextProp, n2 = this.trim(t2[i2] + "");
    return (t2[i2] + "").trim() ? "mix" != e2.mode && e2.pattern && G(e2.pattern, RegExp) && !e2.pattern.test(n2) ? this.TEXTS.pattern : !e2.duplicates && this.isTagDuplicate(n2, e2.dropdown.caseSensitive, t2.__tagId) ? this.TEXTS.duplicate : this.isTagBlacklisted(n2) || e2.enforceWhitelist && !this.isTagWhitelisted(n2) ? this.TEXTS.notAllowed : !e2.validate || e2.validate(t2) : this.TEXTS.empty;
  }, getInvalidTagAttrs: function(t2, e2) {
    return { "aria-invalid": true, class: "".concat(t2.class || "", " ").concat(this.settings.classNames.tagNotAllowed).trim(), title: e2 };
  }, hasMaxTags: function() {
    return this.value.length >= this.settings.maxTags && this.TEXTS.exceed;
  }, setReadonly: function(t2, e2) {
    var i2 = this.settings;
    this.DOM.scope.contains(document.activeElement) && document.activeElement.blur(), i2[e2 || "readonly"] = t2, this.DOM.scope[(t2 ? "set" : "remove") + "Attribute"](e2 || "readonly", true), this.settings.userInput = true, this.setContentEditable(!t2);
  }, setContentEditable: function(t2) {
    this.DOM.input.contentEditable = t2, this.DOM.input.tabIndex = t2 ? 0 : -1;
  }, setDisabled: function(t2) {
    this.setReadonly(t2, "disabled");
  }, normalizeTags: function(t2) {
    var e2 = this, i2 = this.settings, n2 = i2.whitelist, s2 = i2.delimiters, a2 = i2.mode, o2 = i2.tagTextProp, r2 = [], l2 = !!n2 && G(n2[0], Object), d2 = Array.isArray(t2), c2 = d2 && t2[0].value, h2 = /* @__PURE__ */ __name(function(t3) {
      return (t3 + "").split(s2).reduce(function(t4, i3) {
        var n3, s3 = e2.trim(i3);
        return s3 && t4.push((J(n3 = {}, o2, s3), J(n3, "value", s3), n3)), t4;
      }, []);
    }, "h");
    if ("number" == typeof t2 && (t2 = t2.toString()), "string" == typeof t2) {
      if (!t2.trim())
        return [];
      t2 = h2(t2);
    } else
      d2 && (t2 = t2.reduce(function(t3, i3) {
        if (u(i3)) {
          var n3 = g({}, i3);
          n3[o2] = e2.trim(n3[o2]), n3[o2] && t3.push(n3);
        } else if (i3) {
          var s3;
          (s3 = t3).push.apply(s3, Q(h2(i3)));
        }
        return t3;
      }, []));
    return l2 && !c2 && (t2.forEach(function(t3) {
      var i3 = r2.map(function(t4) {
        return t4.value;
      }), n3 = e2.dropdown.filterListItems.call(e2, t3[o2], { exact: true });
      e2.settings.duplicates || (n3 = n3.filter(function(t4) {
        return !i3.includes(t4.value);
      }));
      var s3 = n3.length > 1 ? e2.getWhitelistItem(t3[o2], o2, n3) : n3[0];
      s3 && G(s3, Object) ? r2.push(s3) : "mix" != a2 && (null == t3.value && (t3.value = t3[o2]), r2.push(t3));
    }), r2.length && (t2 = r2)), t2;
  }, parseMixTags: function(t2) {
    var e2 = this, i2 = this.settings, n2 = i2.mixTagsInterpolator, s2 = i2.duplicates, a2 = i2.transformTag, o2 = i2.enforceWhitelist, r2 = i2.maxTags, l2 = i2.tagTextProp, d2 = [];
    t2 = t2.split(n2[0]).map(function(t3, i3) {
      var c3, u2, g2, h2 = t3.split(n2[1]), p2 = h2[0], f2 = d2.length == r2;
      try {
        if (p2 == +p2)
          throw Error;
        u2 = JSON.parse(p2);
      } catch (t4) {
        u2 = e2.normalizeTags(p2)[0] || { value: p2 };
      }
      if (a2.call(e2, u2), f2 || !(h2.length > 1) || o2 && !e2.isTagWhitelisted(u2.value) || !s2 && e2.isTagDuplicate(u2.value)) {
        if (t3)
          return i3 ? n2[0] + t3 : t3;
      } else
        u2[c3 = u2[l2] ? l2 : "value"] = e2.trim(u2[c3]), g2 = e2.createTagElem(u2), d2.push(u2), g2.classList.add(e2.settings.classNames.tagNoAnimation), h2[0] = g2.outerHTML, e2.value.push(u2);
      return h2.join("");
    }).join(""), this.DOM.input.innerHTML = t2, this.DOM.input.appendChild(document.createTextNode("")), this.DOM.input.normalize();
    var c2 = this.getTagElms();
    return c2.forEach(function(t3, e3) {
      return y(t3, d2[e3]);
    }), this.update({ withoutChangeEvent: true }), O(c2, this.state.hasFocus), t2;
  }, replaceTextWithNode: function(t2, e2) {
    if (this.state.tag || e2) {
      e2 = e2 || this.state.tag.prefix + this.state.tag.value;
      var i2, n2, s2 = this.state.selection || window.getSelection(), a2 = s2.anchorNode, o2 = this.state.tag.delimiters ? this.state.tag.delimiters.length : 0;
      return a2.splitText(s2.anchorOffset - o2), -1 == (i2 = a2.nodeValue.lastIndexOf(e2)) ? true : (n2 = a2.splitText(i2), t2 && a2.parentNode.replaceChild(t2, n2), true);
    }
  }, prepareNewTagNode: function(t2, e2) {
    e2 = e2 || {};
    var i2 = this.settings, n2 = [], s2 = {}, a2 = Object.assign({}, t2, { value: t2.value + "" });
    if (t2 = Object.assign({}, a2), i2.transformTag.call(this, t2), t2.__isValid = this.hasMaxTags() || this.validateTag(t2), true !== t2.__isValid) {
      if (e2.skipInvalid)
        return;
      if (g(s2, this.getInvalidTagAttrs(t2, t2.__isValid), { __preInvalidData: a2 }), t2.__isValid == this.TEXTS.duplicate && this.flashTag(this.getTagElmByValue(t2.value)), !i2.createInvalidTags)
        return void n2.push(t2.value);
    }
    return "readonly" in t2 && (t2.readonly ? s2["aria-readonly"] = true : delete t2.readonly), { tagElm: this.createTagElem(t2, s2), tagData: t2, aggregatedInvalidInput: n2 };
  }, postProcessNewTagNode: function(t2, e2) {
    var i2 = this, n2 = this.settings, s2 = e2.__isValid;
    s2 && true === s2 ? (this.value.push(e2), this.trigger("add", { tag: t2, index: this.value.length - 1, data: e2 })) : (this.trigger("invalid", { data: e2, index: this.value.length, tag: t2, message: s2 }), n2.keepInvalidTags || setTimeout(function() {
      return i2.removeTags(t2, true);
    }, 1e3)), this.dropdown.position();
  }, selectTag: function(t2, e2) {
    var i2 = this;
    if (!this.settings.enforceWhitelist || this.isTagWhitelisted(e2.value)) {
      this.state.actions.selectOption && setTimeout(function() {
        return i2.setRangeAtStartEnd(false, i2.DOM.input);
      });
      var n2 = this.getLastTag();
      return n2 ? this.replaceTag(n2, e2) : this.appendTag(t2), this.value[0] = e2, this.update(), this.trigger("add", { tag: t2, data: e2 }), [t2];
    }
  }, addEmptyTag: function(t2) {
    var e2 = g({ value: "" }, t2 || {}), i2 = this.createTagElem(e2);
    y(i2, e2), this.appendTag(i2), this.editTag(i2, { skipValidation: true }), this.toggleFocusClass(true);
  }, addTags: function(t2, e2, i2) {
    var n2 = this, s2 = [], a2 = this.settings, o2 = [], r2 = document.createDocumentFragment();
    if (!t2 || 0 == t2.length)
      return s2;
    switch (t2 = this.normalizeTags(t2), a2.mode) {
      case "mix":
        return this.addMixTags(t2);
      case "select":
        e2 = false, this.removeAllTags();
    }
    return this.DOM.input.removeAttribute("style"), t2.forEach(function(t3) {
      var e3 = n2.prepareNewTagNode(t3, { skipInvalid: i2 || a2.skipInvalid });
      if (e3) {
        var l2 = e3.tagElm;
        if (t3 = e3.tagData, o2 = e3.aggregatedInvalidInput, s2.push(l2), "select" == a2.mode)
          return n2.selectTag(l2, t3);
        r2.appendChild(l2), n2.postProcessNewTagNode(l2, t3);
      }
    }), this.appendTag(r2), this.update(), t2.length && e2 && (this.input.set.call(this, a2.createInvalidTags ? "" : o2.join(a2._delimiters)), this.setRangeAtStartEnd(false, this.DOM.input)), a2.dropdown.enabled && this.dropdown.refilter(), s2;
  }, addMixTags: function(t2) {
    var e2 = this;
    if ((t2 = this.normalizeTags(t2))[0].prefix || this.state.tag)
      return this.prefixedTextToTag(t2[0]);
    var i2 = document.createDocumentFragment();
    return t2.forEach(function(t3) {
      var n2 = e2.prepareNewTagNode(t3);
      i2.appendChild(n2.tagElm), e2.insertAfterTag(n2.tagElm), e2.postProcessNewTagNode(n2.tagElm, n2.tagData);
    }), this.appendMixTags(i2), i2.children;
  }, appendMixTags: function(t2) {
    var e2 = !!this.state.selection;
    e2 ? this.injectAtCaret(t2) : (this.DOM.input.focus(), (e2 = this.setStateSelection()).range.setStart(this.DOM.input, e2.range.endOffset), e2.range.setEnd(this.DOM.input, e2.range.endOffset), this.DOM.input.appendChild(t2), this.updateValueByDOMTags(), this.update());
  }, prefixedTextToTag: function(t2) {
    var e2, i2, n2, s2 = this, a2 = this.settings, o2 = null === (e2 = this.state.tag) || void 0 === e2 ? void 0 : e2.delimiters;
    if (t2.prefix = t2.prefix || this.state.tag ? this.state.tag.prefix : (a2.pattern.source || a2.pattern)[0], n2 = this.prepareNewTagNode(t2), i2 = n2.tagElm, this.replaceTextWithNode(i2) || this.DOM.input.appendChild(i2), setTimeout(function() {
      return i2.classList.add(s2.settings.classNames.tagNoAnimation);
    }, 300), this.value.push(n2.tagData), this.update(), !o2) {
      var r2 = this.insertAfterTag(i2) || i2;
      setTimeout(T, 0, r2);
    }
    return this.state.tag = null, this.postProcessNewTagNode(i2, n2.tagData), i2;
  }, appendTag: function(t2) {
    var e2 = this.DOM, i2 = e2.input;
    e2.scope.insertBefore(t2, i2);
  }, createTagElem: function(t2, e2) {
    t2.__tagId = m();
    var i2, n2 = g({}, t2, $({ value: c(t2.value + "") }, e2));
    return function(t3) {
      for (var e3, i3 = document.createNodeIterator(t3, NodeFilter.SHOW_TEXT, null, false); e3 = i3.nextNode(); )
        e3.textContent.trim() || e3.parentNode.removeChild(e3);
    }(i2 = this.parseTemplate("tag", [n2, this])), y(i2, t2), i2;
  }, reCheckInvalidTags: function() {
    var t2 = this, e2 = this.settings;
    this.getTagElms(e2.classNames.tagNotAllowed).forEach(function(i2, n2) {
      var s2 = y(i2), a2 = t2.hasMaxTags(), o2 = t2.validateTag(s2), r2 = true === o2 && !a2;
      if ("select" == e2.mode && t2.toggleScopeValidation(o2), r2)
        return s2 = s2.__preInvalidData ? s2.__preInvalidData : { value: s2.value }, t2.replaceTag(i2, s2);
      i2.title = a2 || o2;
    });
  }, removeTags: function(t2, e2, i2) {
    var n2, s2 = this, a2 = this.settings;
    if (t2 = t2 && G(t2, HTMLElement) ? [t2] : G(t2, Array) ? t2 : t2 ? [t2] : [this.getLastTag()].filter(function(t3) {
      return t3;
    }), n2 = t2.reduce(function(t3, e3) {
      e3 && "string" == typeof e3 && (e3 = s2.getTagElmByValue(e3));
      var i3 = y(e3);
      return e3 && i3 && !i3.readonly && t3.push({ node: e3, idx: s2.getTagIdx(i3), data: y(e3, { __removed: true }) }), t3;
    }, []), i2 = "number" == typeof i2 ? i2 : this.CSSVars.tagHideTransition, "select" == a2.mode && (i2 = 0, this.input.set.call(this)), 1 == n2.length && "select" != a2.mode && n2[0].node.classList.contains(a2.classNames.tagNotAllowed) && (e2 = true), n2.length)
      return a2.hooks.beforeRemoveTag(n2, { tagify: this }).then(function() {
        var t3 = /* @__PURE__ */ __name(function(t4) {
          t4.node.parentNode && (t4.node.parentNode.removeChild(t4.node), e2 ? a2.keepInvalidTags && this.trigger("remove", { tag: t4.node, index: t4.idx }) : (this.trigger("remove", { tag: t4.node, index: t4.idx, data: t4.data }), this.dropdown.refilter(), this.dropdown.position(), this.DOM.input.normalize(), a2.keepInvalidTags && this.reCheckInvalidTags()));
        }, "t");
        i2 && i2 > 10 && 1 == n2.length ? function(e3) {
          e3.node.style.width = parseFloat(window.getComputedStyle(e3.node).width) + "px", document.body.clientTop, e3.node.classList.add(a2.classNames.tagHide), setTimeout(t3.bind(this), i2, e3);
        }.call(s2, n2[0]) : n2.forEach(t3.bind(s2)), e2 || (s2.removeTagsFromValue(n2.map(function(t4) {
          return t4.node;
        })), s2.update(), "select" == a2.mode && a2.userInput && s2.setContentEditable(true));
      }).catch(function(t3) {
      });
  }, removeTagsFromDOM: function() {
    this.getTagElms().forEach(function(t2) {
      return t2.remove();
    });
  }, removeTagsFromValue: function(t2) {
    var e2 = this;
    (t2 = Array.isArray(t2) ? t2 : [t2]).forEach(function(t3) {
      var i2 = y(t3), n2 = e2.getTagIdx(i2);
      n2 > -1 && e2.value.splice(n2, 1);
    });
  }, removeAllTags: function(t2) {
    var e2 = this;
    t2 = t2 || {}, this.value = [], "mix" == this.settings.mode ? this.DOM.input.innerHTML = "" : this.removeTagsFromDOM(), this.dropdown.refilter(), this.dropdown.position(), this.state.dropdown.visible && setTimeout(function() {
      e2.DOM.input.focus();
    }), "select" == this.settings.mode && (this.input.set.call(this), this.settings.userInput && this.setContentEditable(true)), this.update(t2);
  }, postUpdate: function() {
    this.state.blockChangeEvent = false;
    var t2, e2, i2 = this.settings, n2 = i2.classNames, s2 = "mix" == i2.mode ? i2.mixMode.integrated ? this.DOM.input.textContent : this.DOM.originalInput.value.trim() : this.value.length + this.input.raw.call(this).length;
    (this.toggleClass(n2.hasMaxTags, this.value.length >= i2.maxTags), this.toggleClass(n2.hasNoTags, !this.value.length), this.toggleClass(n2.empty, !s2), "select" == i2.mode) && this.toggleScopeValidation(null === (e2 = this.value) || void 0 === e2 || null === (t2 = e2[0]) || void 0 === t2 ? void 0 : t2.__isValid);
  }, setOriginalInputValue: function(t2) {
    var e2 = this.DOM.originalInput;
    this.settings.mixMode.integrated || (e2.value = t2, e2.tagifyValue = e2.value, this.setPersistedData(t2, "value"));
  }, update: function(t2) {
    clearTimeout(this.debouncedUpdateTimeout), this.debouncedUpdateTimeout = setTimeout(function() {
      var e2 = this.getInputValue();
      this.setOriginalInputValue(e2), this.settings.onChangeAfterBlur && (t2 || {}).withoutChangeEvent || this.state.blockChangeEvent || this.triggerChangeEvent();
      this.postUpdate();
    }.bind(this), 100), this.events.bindOriginaInputListener.call(this, 100);
  }, getInputValue: function() {
    var t2 = this.getCleanValue();
    return "mix" == this.settings.mode ? this.getMixedTagsAsString(t2) : t2.length ? this.settings.originalInputValueFormat ? this.settings.originalInputValueFormat(t2) : JSON.stringify(t2) : "";
  }, getCleanValue: function(t2) {
    return a(t2 || this.value, this.dataProps);
  }, getMixedTagsAsString: function() {
    var t2 = "", e2 = this, i2 = this.settings, n2 = i2.originalInputValueFormat || JSON.stringify, s2 = i2.mixTagsInterpolator;
    return (/* @__PURE__ */ __name(function i3(a2) {
      a2.childNodes.forEach(function(a3) {
        if (1 == a3.nodeType) {
          var r2 = y(a3);
          if ("BR" == a3.tagName && (t2 += "\r\n"), r2 && v.call(e2, a3)) {
            if (r2.__removed)
              return;
            t2 += s2[0] + n2(o(r2, e2.dataProps)) + s2[1];
          } else
            a3.getAttribute("style") || ["B", "I", "U"].includes(a3.tagName) ? t2 += a3.textContent : "DIV" != a3.tagName && "P" != a3.tagName || (t2 += "\r\n", i3(a3));
        } else
          t2 += a3.textContent;
      });
    }, "i"))(this.DOM.input), t2;
  } }, Y.prototype.removeTag = Y.prototype.removeTags;

  // app/javascript/controllers/tag_field_controller.js
  var TagFieldController = class extends Controller {
    static {
      __name(this, "TagFieldController");
    }
    connect() {
      this.tagify = new Y(this.querySelector("textarea"), this.opticons());
    }
    opticons() {
      const options = JSON.parse(this.dataset["tagify"] || "{}");
      return Object.assign({ originalInputValueFormat: this.mapValue }, options);
    }
    mapValue(valuesArr) {
      return valuesArr.map((item) => item.value).join(",");
    }
  };

  // app/javascript/schladming.js
  application.register(AdminTabController);
  application.register(AdminCleaveController);
  application.register(BackToScopeController);
  application.register(BatchActionController);
  application.register(ClickableRowController);
  application.register(HamburgerMenuController);
  application.register(GeoSearchController);
  application.register(DatetimeSelectController);
  application.register(ImagePreviewController);
  application.register(RelationSearchController);
  application.register(RichTextEditorController);
  application.register(SlugonatorController);
  application.register(SelectAllController);
  application.register(TagFieldController);
  application.start();
})();
/*! Bundled license information:

@hotwired/turbo/dist/turbo.es2017-esm.js:
  (*!
  Turbo 8.0.4
  Copyright  2024 37signals LLC
   *)

js-cookie/dist/js.cookie.mjs:
  (*! js-cookie v3.0.5 | MIT *)

lodash-es/lodash.js:
  (**
   * @license
   * Lodash (Custom Build) <https://lodash.com/>
   * Build: `lodash modularize exports="es" -o ./`
   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   *)
*/
//# sourceMappingURL=schladming.js.map
