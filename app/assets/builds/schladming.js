(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb2, mod) => function __require() {
    return mod || (0, cb2[__getOwnPropNames(cb2)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));

  // node_modules/@rails/actioncable/src/adapters.js
  var adapters_default;
  var init_adapters = __esm({
    "node_modules/@rails/actioncable/src/adapters.js"() {
      adapters_default = {
        logger: typeof console !== "undefined" ? console : void 0,
        WebSocket: typeof WebSocket !== "undefined" ? WebSocket : void 0
      };
    }
  });

  // node_modules/@rails/actioncable/src/logger.js
  var logger_default;
  var init_logger = __esm({
    "node_modules/@rails/actioncable/src/logger.js"() {
      init_adapters();
      logger_default = {
        log(...messages) {
          if (this.enabled) {
            messages.push(Date.now());
            adapters_default.logger.log("[ActionCable]", ...messages);
          }
        }
      };
    }
  });

  // node_modules/@rails/actioncable/src/connection_monitor.js
  var now, secondsSince, ConnectionMonitor, connection_monitor_default;
  var init_connection_monitor = __esm({
    "node_modules/@rails/actioncable/src/connection_monitor.js"() {
      init_logger();
      now = /* @__PURE__ */ __name(() => (/* @__PURE__ */ new Date()).getTime(), "now");
      secondsSince = /* @__PURE__ */ __name((time) => (now() - time) / 1e3, "secondsSince");
      ConnectionMonitor = class {
        static {
          __name(this, "ConnectionMonitor");
        }
        constructor(connection) {
          this.visibilityDidChange = this.visibilityDidChange.bind(this);
          this.connection = connection;
          this.reconnectAttempts = 0;
        }
        start() {
          if (!this.isRunning()) {
            this.startedAt = now();
            delete this.stoppedAt;
            this.startPolling();
            addEventListener("visibilitychange", this.visibilityDidChange);
            logger_default.log(`ConnectionMonitor started. stale threshold = ${this.constructor.staleThreshold} s`);
          }
        }
        stop() {
          if (this.isRunning()) {
            this.stoppedAt = now();
            this.stopPolling();
            removeEventListener("visibilitychange", this.visibilityDidChange);
            logger_default.log("ConnectionMonitor stopped");
          }
        }
        isRunning() {
          return this.startedAt && !this.stoppedAt;
        }
        recordPing() {
          this.pingedAt = now();
        }
        recordConnect() {
          this.reconnectAttempts = 0;
          this.recordPing();
          delete this.disconnectedAt;
          logger_default.log("ConnectionMonitor recorded connect");
        }
        recordDisconnect() {
          this.disconnectedAt = now();
          logger_default.log("ConnectionMonitor recorded disconnect");
        }
        // Private
        startPolling() {
          this.stopPolling();
          this.poll();
        }
        stopPolling() {
          clearTimeout(this.pollTimeout);
        }
        poll() {
          this.pollTimeout = setTimeout(
            () => {
              this.reconnectIfStale();
              this.poll();
            },
            this.getPollInterval()
          );
        }
        getPollInterval() {
          const { staleThreshold, reconnectionBackoffRate } = this.constructor;
          const backoff = Math.pow(1 + reconnectionBackoffRate, Math.min(this.reconnectAttempts, 10));
          const jitterMax = this.reconnectAttempts === 0 ? 1 : reconnectionBackoffRate;
          const jitter = jitterMax * Math.random();
          return staleThreshold * 1e3 * backoff * (1 + jitter);
        }
        reconnectIfStale() {
          if (this.connectionIsStale()) {
            logger_default.log(`ConnectionMonitor detected stale connection. reconnectAttempts = ${this.reconnectAttempts}, time stale = ${secondsSince(this.refreshedAt)} s, stale threshold = ${this.constructor.staleThreshold} s`);
            this.reconnectAttempts++;
            if (this.disconnectedRecently()) {
              logger_default.log(`ConnectionMonitor skipping reopening recent disconnect. time disconnected = ${secondsSince(this.disconnectedAt)} s`);
            } else {
              logger_default.log("ConnectionMonitor reopening");
              this.connection.reopen();
            }
          }
        }
        get refreshedAt() {
          return this.pingedAt ? this.pingedAt : this.startedAt;
        }
        connectionIsStale() {
          return secondsSince(this.refreshedAt) > this.constructor.staleThreshold;
        }
        disconnectedRecently() {
          return this.disconnectedAt && secondsSince(this.disconnectedAt) < this.constructor.staleThreshold;
        }
        visibilityDidChange() {
          if (document.visibilityState === "visible") {
            setTimeout(
              () => {
                if (this.connectionIsStale() || !this.connection.isOpen()) {
                  logger_default.log(`ConnectionMonitor reopening stale connection on visibilitychange. visibilityState = ${document.visibilityState}`);
                  this.connection.reopen();
                }
              },
              200
            );
          }
        }
      };
      ConnectionMonitor.staleThreshold = 6;
      ConnectionMonitor.reconnectionBackoffRate = 0.15;
      connection_monitor_default = ConnectionMonitor;
    }
  });

  // node_modules/@rails/actioncable/src/internal.js
  var internal_default;
  var init_internal = __esm({
    "node_modules/@rails/actioncable/src/internal.js"() {
      internal_default = {
        "message_types": {
          "welcome": "welcome",
          "disconnect": "disconnect",
          "ping": "ping",
          "confirmation": "confirm_subscription",
          "rejection": "reject_subscription"
        },
        "disconnect_reasons": {
          "unauthorized": "unauthorized",
          "invalid_request": "invalid_request",
          "server_restart": "server_restart",
          "remote": "remote"
        },
        "default_mount_path": "/cable",
        "protocols": [
          "actioncable-v1-json",
          "actioncable-unsupported"
        ]
      };
    }
  });

  // node_modules/@rails/actioncable/src/connection.js
  var message_types, protocols, supportedProtocols, indexOf, Connection, connection_default;
  var init_connection = __esm({
    "node_modules/@rails/actioncable/src/connection.js"() {
      init_adapters();
      init_connection_monitor();
      init_internal();
      init_logger();
      ({ message_types, protocols } = internal_default);
      supportedProtocols = protocols.slice(0, protocols.length - 1);
      indexOf = [].indexOf;
      Connection = class {
        static {
          __name(this, "Connection");
        }
        constructor(consumer2) {
          this.open = this.open.bind(this);
          this.consumer = consumer2;
          this.subscriptions = this.consumer.subscriptions;
          this.monitor = new connection_monitor_default(this);
          this.disconnected = true;
        }
        send(data) {
          if (this.isOpen()) {
            this.webSocket.send(JSON.stringify(data));
            return true;
          } else {
            return false;
          }
        }
        open() {
          if (this.isActive()) {
            logger_default.log(`Attempted to open WebSocket, but existing socket is ${this.getState()}`);
            return false;
          } else {
            const socketProtocols = [...protocols, ...this.consumer.subprotocols || []];
            logger_default.log(`Opening WebSocket, current state is ${this.getState()}, subprotocols: ${socketProtocols}`);
            if (this.webSocket) {
              this.uninstallEventHandlers();
            }
            this.webSocket = new adapters_default.WebSocket(this.consumer.url, socketProtocols);
            this.installEventHandlers();
            this.monitor.start();
            return true;
          }
        }
        close({ allowReconnect } = { allowReconnect: true }) {
          if (!allowReconnect) {
            this.monitor.stop();
          }
          if (this.isOpen()) {
            return this.webSocket.close();
          }
        }
        reopen() {
          logger_default.log(`Reopening WebSocket, current state is ${this.getState()}`);
          if (this.isActive()) {
            try {
              return this.close();
            } catch (error) {
              logger_default.log("Failed to reopen WebSocket", error);
            } finally {
              logger_default.log(`Reopening WebSocket in ${this.constructor.reopenDelay}ms`);
              setTimeout(this.open, this.constructor.reopenDelay);
            }
          } else {
            return this.open();
          }
        }
        getProtocol() {
          if (this.webSocket) {
            return this.webSocket.protocol;
          }
        }
        isOpen() {
          return this.isState("open");
        }
        isActive() {
          return this.isState("open", "connecting");
        }
        triedToReconnect() {
          return this.monitor.reconnectAttempts > 0;
        }
        // Private
        isProtocolSupported() {
          return indexOf.call(supportedProtocols, this.getProtocol()) >= 0;
        }
        isState(...states) {
          return indexOf.call(states, this.getState()) >= 0;
        }
        getState() {
          if (this.webSocket) {
            for (let state in adapters_default.WebSocket) {
              if (adapters_default.WebSocket[state] === this.webSocket.readyState) {
                return state.toLowerCase();
              }
            }
          }
          return null;
        }
        installEventHandlers() {
          for (let eventName in this.events) {
            const handler = this.events[eventName].bind(this);
            this.webSocket[`on${eventName}`] = handler;
          }
        }
        uninstallEventHandlers() {
          for (let eventName in this.events) {
            this.webSocket[`on${eventName}`] = function() {
            };
          }
        }
      };
      Connection.reopenDelay = 500;
      Connection.prototype.events = {
        message(event) {
          if (!this.isProtocolSupported()) {
            return;
          }
          const { identifier, message, reason, reconnect, type } = JSON.parse(event.data);
          switch (type) {
            case message_types.welcome:
              if (this.triedToReconnect()) {
                this.reconnectAttempted = true;
              }
              this.monitor.recordConnect();
              return this.subscriptions.reload();
            case message_types.disconnect:
              logger_default.log(`Disconnecting. Reason: ${reason}`);
              return this.close({ allowReconnect: reconnect });
            case message_types.ping:
              return this.monitor.recordPing();
            case message_types.confirmation:
              this.subscriptions.confirmSubscription(identifier);
              if (this.reconnectAttempted) {
                this.reconnectAttempted = false;
                return this.subscriptions.notify(identifier, "connected", { reconnected: true });
              } else {
                return this.subscriptions.notify(identifier, "connected", { reconnected: false });
              }
            case message_types.rejection:
              return this.subscriptions.reject(identifier);
            default:
              return this.subscriptions.notify(identifier, "received", message);
          }
        },
        open() {
          logger_default.log(`WebSocket onopen event, using '${this.getProtocol()}' subprotocol`);
          this.disconnected = false;
          if (!this.isProtocolSupported()) {
            logger_default.log("Protocol is unsupported. Stopping monitor and disconnecting.");
            return this.close({ allowReconnect: false });
          }
        },
        close(event) {
          logger_default.log("WebSocket onclose event");
          if (this.disconnected) {
            return;
          }
          this.disconnected = true;
          this.monitor.recordDisconnect();
          return this.subscriptions.notifyAll("disconnected", { willAttemptReconnect: this.monitor.isRunning() });
        },
        error() {
          logger_default.log("WebSocket onerror event");
        }
      };
      connection_default = Connection;
    }
  });

  // node_modules/@rails/actioncable/src/subscription.js
  var extend, Subscription;
  var init_subscription = __esm({
    "node_modules/@rails/actioncable/src/subscription.js"() {
      extend = /* @__PURE__ */ __name(function(object, properties) {
        if (properties != null) {
          for (let key in properties) {
            const value = properties[key];
            object[key] = value;
          }
        }
        return object;
      }, "extend");
      Subscription = class {
        static {
          __name(this, "Subscription");
        }
        constructor(consumer2, params = {}, mixin) {
          this.consumer = consumer2;
          this.identifier = JSON.stringify(params);
          extend(this, mixin);
        }
        // Perform a channel action with the optional data passed as an attribute
        perform(action, data = {}) {
          data.action = action;
          return this.send(data);
        }
        send(data) {
          return this.consumer.send({ command: "message", identifier: this.identifier, data: JSON.stringify(data) });
        }
        unsubscribe() {
          return this.consumer.subscriptions.remove(this);
        }
      };
    }
  });

  // node_modules/@rails/actioncable/src/subscription_guarantor.js
  var SubscriptionGuarantor, subscription_guarantor_default;
  var init_subscription_guarantor = __esm({
    "node_modules/@rails/actioncable/src/subscription_guarantor.js"() {
      init_logger();
      SubscriptionGuarantor = class {
        static {
          __name(this, "SubscriptionGuarantor");
        }
        constructor(subscriptions) {
          this.subscriptions = subscriptions;
          this.pendingSubscriptions = [];
        }
        guarantee(subscription) {
          if (this.pendingSubscriptions.indexOf(subscription) == -1) {
            logger_default.log(`SubscriptionGuarantor guaranteeing ${subscription.identifier}`);
            this.pendingSubscriptions.push(subscription);
          } else {
            logger_default.log(`SubscriptionGuarantor already guaranteeing ${subscription.identifier}`);
          }
          this.startGuaranteeing();
        }
        forget(subscription) {
          logger_default.log(`SubscriptionGuarantor forgetting ${subscription.identifier}`);
          this.pendingSubscriptions = this.pendingSubscriptions.filter((s3) => s3 !== subscription);
        }
        startGuaranteeing() {
          this.stopGuaranteeing();
          this.retrySubscribing();
        }
        stopGuaranteeing() {
          clearTimeout(this.retryTimeout);
        }
        retrySubscribing() {
          this.retryTimeout = setTimeout(
            () => {
              if (this.subscriptions && typeof this.subscriptions.subscribe === "function") {
                this.pendingSubscriptions.map((subscription) => {
                  logger_default.log(`SubscriptionGuarantor resubscribing ${subscription.identifier}`);
                  this.subscriptions.subscribe(subscription);
                });
              }
            },
            500
          );
        }
      };
      subscription_guarantor_default = SubscriptionGuarantor;
    }
  });

  // node_modules/@rails/actioncable/src/subscriptions.js
  var Subscriptions;
  var init_subscriptions = __esm({
    "node_modules/@rails/actioncable/src/subscriptions.js"() {
      init_subscription();
      init_subscription_guarantor();
      init_logger();
      Subscriptions = class {
        static {
          __name(this, "Subscriptions");
        }
        constructor(consumer2) {
          this.consumer = consumer2;
          this.guarantor = new subscription_guarantor_default(this);
          this.subscriptions = [];
        }
        create(channelName, mixin) {
          const channel = channelName;
          const params = typeof channel === "object" ? channel : { channel };
          const subscription = new Subscription(this.consumer, params, mixin);
          return this.add(subscription);
        }
        // Private
        add(subscription) {
          this.subscriptions.push(subscription);
          this.consumer.ensureActiveConnection();
          this.notify(subscription, "initialized");
          this.subscribe(subscription);
          return subscription;
        }
        remove(subscription) {
          this.forget(subscription);
          if (!this.findAll(subscription.identifier).length) {
            this.sendCommand(subscription, "unsubscribe");
          }
          return subscription;
        }
        reject(identifier) {
          return this.findAll(identifier).map((subscription) => {
            this.forget(subscription);
            this.notify(subscription, "rejected");
            return subscription;
          });
        }
        forget(subscription) {
          this.guarantor.forget(subscription);
          this.subscriptions = this.subscriptions.filter((s3) => s3 !== subscription);
          return subscription;
        }
        findAll(identifier) {
          return this.subscriptions.filter((s3) => s3.identifier === identifier);
        }
        reload() {
          return this.subscriptions.map((subscription) => this.subscribe(subscription));
        }
        notifyAll(callbackName, ...args) {
          return this.subscriptions.map((subscription) => this.notify(subscription, callbackName, ...args));
        }
        notify(subscription, callbackName, ...args) {
          let subscriptions;
          if (typeof subscription === "string") {
            subscriptions = this.findAll(subscription);
          } else {
            subscriptions = [subscription];
          }
          return subscriptions.map((subscription2) => typeof subscription2[callbackName] === "function" ? subscription2[callbackName](...args) : void 0);
        }
        subscribe(subscription) {
          if (this.sendCommand(subscription, "subscribe")) {
            this.guarantor.guarantee(subscription);
          }
        }
        confirmSubscription(identifier) {
          logger_default.log(`Subscription confirmed ${identifier}`);
          this.findAll(identifier).map((subscription) => this.guarantor.forget(subscription));
        }
        sendCommand(subscription, command) {
          const { identifier } = subscription;
          return this.consumer.send({ command, identifier });
        }
      };
    }
  });

  // node_modules/@rails/actioncable/src/consumer.js
  function createWebSocketURL(url) {
    if (typeof url === "function") {
      url = url();
    }
    if (url && !/^wss?:/i.test(url)) {
      const a3 = document.createElement("a");
      a3.href = url;
      a3.href = a3.href;
      a3.protocol = a3.protocol.replace("http", "ws");
      return a3.href;
    } else {
      return url;
    }
  }
  var Consumer;
  var init_consumer = __esm({
    "node_modules/@rails/actioncable/src/consumer.js"() {
      init_connection();
      init_subscriptions();
      Consumer = class {
        static {
          __name(this, "Consumer");
        }
        constructor(url) {
          this._url = url;
          this.subscriptions = new Subscriptions(this);
          this.connection = new connection_default(this);
          this.subprotocols = [];
        }
        get url() {
          return createWebSocketURL(this._url);
        }
        send(data) {
          return this.connection.send(data);
        }
        connect() {
          return this.connection.open();
        }
        disconnect() {
          return this.connection.close({ allowReconnect: false });
        }
        ensureActiveConnection() {
          if (!this.connection.isActive()) {
            return this.connection.open();
          }
        }
        addSubProtocol(subprotocol) {
          this.subprotocols = [...this.subprotocols, subprotocol];
        }
      };
      __name(createWebSocketURL, "createWebSocketURL");
    }
  });

  // node_modules/@rails/actioncable/src/index.js
  var src_exports = {};
  __export(src_exports, {
    Connection: () => connection_default,
    ConnectionMonitor: () => connection_monitor_default,
    Consumer: () => Consumer,
    INTERNAL: () => internal_default,
    Subscription: () => Subscription,
    SubscriptionGuarantor: () => subscription_guarantor_default,
    Subscriptions: () => Subscriptions,
    adapters: () => adapters_default,
    createConsumer: () => createConsumer,
    createWebSocketURL: () => createWebSocketURL,
    getConfig: () => getConfig,
    logger: () => logger_default
  });
  function createConsumer(url = getConfig("url") || internal_default.default_mount_path) {
    return new Consumer(url);
  }
  function getConfig(name) {
    const element = document.head.querySelector(`meta[name='action-cable-${name}']`);
    if (element) {
      return element.getAttribute("content");
    }
  }
  var init_src = __esm({
    "node_modules/@rails/actioncable/src/index.js"() {
      init_connection();
      init_connection_monitor();
      init_consumer();
      init_internal();
      init_subscription();
      init_subscriptions();
      init_subscription_guarantor();
      init_adapters();
      init_logger();
      __name(createConsumer, "createConsumer");
      __name(getConfig, "getConfig");
    }
  });

  // node_modules/debounce/index.js
  var require_debounce = __commonJS({
    "node_modules/debounce/index.js"(exports2, module2) {
      function debounce7(function_, wait = 100, options = {}) {
        if (typeof function_ !== "function") {
          throw new TypeError(`Expected the first parameter to be a function, got \`${typeof function_}\`.`);
        }
        if (wait < 0) {
          throw new RangeError("`wait` must not be negative.");
        }
        const { immediate } = typeof options === "boolean" ? { immediate: options } : options;
        let storedContext;
        let storedArguments;
        let timeoutId;
        let timestamp;
        let result;
        function later() {
          const last = Date.now() - timestamp;
          if (last < wait && last >= 0) {
            timeoutId = setTimeout(later, wait - last);
          } else {
            timeoutId = void 0;
            if (!immediate) {
              const callContext = storedContext;
              const callArguments = storedArguments;
              storedContext = void 0;
              storedArguments = void 0;
              result = function_.apply(callContext, callArguments);
            }
          }
        }
        __name(later, "later");
        const debounced = /* @__PURE__ */ __name(function(...arguments_) {
          if (storedContext && this !== storedContext) {
            throw new Error("Debounced method called with different contexts.");
          }
          storedContext = this;
          storedArguments = arguments_;
          timestamp = Date.now();
          const callNow = immediate && !timeoutId;
          if (!timeoutId) {
            timeoutId = setTimeout(later, wait);
          }
          if (callNow) {
            const callContext = storedContext;
            const callArguments = storedArguments;
            storedContext = void 0;
            storedArguments = void 0;
            result = function_.apply(callContext, callArguments);
          }
          return result;
        }, "debounced");
        debounced.clear = () => {
          if (!timeoutId) {
            return;
          }
          clearTimeout(timeoutId);
          timeoutId = void 0;
        };
        debounced.flush = () => {
          if (!timeoutId) {
            return;
          }
          const callContext = storedContext;
          const callArguments = storedArguments;
          storedContext = void 0;
          storedArguments = void 0;
          result = function_.apply(callContext, callArguments);
          clearTimeout(timeoutId);
          timeoutId = void 0;
        };
        return debounced;
      }
      __name(debounce7, "debounce");
      module2.exports.debounce = debounce7;
      module2.exports = debounce7;
    }
  });

  // ../highway/node_modules/debounce/index.js
  var require_debounce2 = __commonJS({
    "../highway/node_modules/debounce/index.js"(exports2, module2) {
      function debounce7(func, wait, immediate) {
        var timeout, args, context, timestamp, result;
        if (null == wait)
          wait = 100;
        function later() {
          var last = Date.now() - timestamp;
          if (last < wait && last >= 0) {
            timeout = setTimeout(later, wait - last);
          } else {
            timeout = null;
            if (!immediate) {
              result = func.apply(context, args);
              context = args = null;
            }
          }
        }
        __name(later, "later");
        ;
        var debounced = /* @__PURE__ */ __name(function() {
          context = this;
          args = arguments;
          timestamp = Date.now();
          var callNow = immediate && !timeout;
          if (!timeout)
            timeout = setTimeout(later, wait);
          if (callNow) {
            result = func.apply(context, args);
            context = args = null;
          }
          return result;
        }, "debounced");
        debounced.clear = function() {
          if (timeout) {
            clearTimeout(timeout);
            timeout = null;
          }
        };
        debounced.flush = function() {
          if (timeout) {
            result = func.apply(context, args);
            context = args = null;
            clearTimeout(timeout);
            timeout = null;
          }
        };
        return debounced;
      }
      __name(debounce7, "debounce");
      debounce7.debounce = debounce7;
      module2.exports = debounce7;
    }
  });

  // ../highway/node_modules/leaflet/dist/leaflet-src.js
  var require_leaflet_src = __commonJS({
    "../highway/node_modules/leaflet/dist/leaflet-src.js"(exports2, module2) {
      (function(global2, factory) {
        typeof exports2 === "object" && typeof module2 !== "undefined" ? factory(exports2) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.leaflet = {}));
      })(exports2, function(exports3) {
        "use strict";
        var version2 = "1.9.4";
        function extend3(dest) {
          var i3, j3, len, src;
          for (j3 = 1, len = arguments.length; j3 < len; j3++) {
            src = arguments[j3];
            for (i3 in src) {
              dest[i3] = src[i3];
            }
          }
          return dest;
        }
        __name(extend3, "extend");
        var create$2 = Object.create || /* @__PURE__ */ function() {
          function F3() {
          }
          __name(F3, "F");
          return function(proto) {
            F3.prototype = proto;
            return new F3();
          };
        }();
        function bind(fn, obj) {
          var slice = Array.prototype.slice;
          if (fn.bind) {
            return fn.bind.apply(fn, slice.call(arguments, 1));
          }
          var args = slice.call(arguments, 2);
          return function() {
            return fn.apply(obj, args.length ? args.concat(slice.call(arguments)) : arguments);
          };
        }
        __name(bind, "bind");
        var lastId = 0;
        function stamp(obj) {
          if (!("_leaflet_id" in obj)) {
            obj["_leaflet_id"] = ++lastId;
          }
          return obj._leaflet_id;
        }
        __name(stamp, "stamp");
        function throttle2(fn, time, context) {
          var lock, args, wrapperFn, later;
          later = /* @__PURE__ */ __name(function() {
            lock = false;
            if (args) {
              wrapperFn.apply(context, args);
              args = false;
            }
          }, "later");
          wrapperFn = /* @__PURE__ */ __name(function() {
            if (lock) {
              args = arguments;
            } else {
              fn.apply(context, arguments);
              setTimeout(later, time);
              lock = true;
            }
          }, "wrapperFn");
          return wrapperFn;
        }
        __name(throttle2, "throttle");
        function wrapNum(x3, range, includeMax) {
          var max = range[1], min = range[0], d3 = max - min;
          return x3 === max && includeMax ? x3 : ((x3 - min) % d3 + d3) % d3 + min;
        }
        __name(wrapNum, "wrapNum");
        function falseFn() {
          return false;
        }
        __name(falseFn, "falseFn");
        function formatNum(num, precision) {
          if (precision === false) {
            return num;
          }
          var pow = Math.pow(10, precision === void 0 ? 6 : precision);
          return Math.round(num * pow) / pow;
        }
        __name(formatNum, "formatNum");
        function trim(str) {
          return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "");
        }
        __name(trim, "trim");
        function splitWords(str) {
          return trim(str).split(/\s+/);
        }
        __name(splitWords, "splitWords");
        function setOptions(obj, options) {
          if (!Object.prototype.hasOwnProperty.call(obj, "options")) {
            obj.options = obj.options ? create$2(obj.options) : {};
          }
          for (var i3 in options) {
            obj.options[i3] = options[i3];
          }
          return obj.options;
        }
        __name(setOptions, "setOptions");
        function getParamString(obj, existingUrl, uppercase) {
          var params = [];
          for (var i3 in obj) {
            params.push(encodeURIComponent(uppercase ? i3.toUpperCase() : i3) + "=" + encodeURIComponent(obj[i3]));
          }
          return (!existingUrl || existingUrl.indexOf("?") === -1 ? "?" : "&") + params.join("&");
        }
        __name(getParamString, "getParamString");
        var templateRe = /\{ *([\w_ -]+) *\}/g;
        function template(str, data) {
          return str.replace(templateRe, function(str2, key) {
            var value = data[key];
            if (value === void 0) {
              throw new Error("No value provided for variable " + str2);
            } else if (typeof value === "function") {
              value = value(data);
            }
            return value;
          });
        }
        __name(template, "template");
        var isArray2 = Array.isArray || function(obj) {
          return Object.prototype.toString.call(obj) === "[object Array]";
        };
        function indexOf2(array, el) {
          for (var i3 = 0; i3 < array.length; i3++) {
            if (array[i3] === el) {
              return i3;
            }
          }
          return -1;
        }
        __name(indexOf2, "indexOf");
        var emptyImageUrl = "data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=";
        function getPrefixed(name) {
          return window["webkit" + name] || window["moz" + name] || window["ms" + name];
        }
        __name(getPrefixed, "getPrefixed");
        var lastTime = 0;
        function timeoutDefer(fn) {
          var time = +/* @__PURE__ */ new Date(), timeToCall = Math.max(0, 16 - (time - lastTime));
          lastTime = time + timeToCall;
          return window.setTimeout(fn, timeToCall);
        }
        __name(timeoutDefer, "timeoutDefer");
        var requestFn = window.requestAnimationFrame || getPrefixed("RequestAnimationFrame") || timeoutDefer;
        var cancelFn = window.cancelAnimationFrame || getPrefixed("CancelAnimationFrame") || getPrefixed("CancelRequestAnimationFrame") || function(id) {
          window.clearTimeout(id);
        };
        function requestAnimFrame(fn, context, immediate) {
          if (immediate && requestFn === timeoutDefer) {
            fn.call(context);
          } else {
            return requestFn.call(window, bind(fn, context));
          }
        }
        __name(requestAnimFrame, "requestAnimFrame");
        function cancelAnimFrame(id) {
          if (id) {
            cancelFn.call(window, id);
          }
        }
        __name(cancelAnimFrame, "cancelAnimFrame");
        var Util = {
          __proto__: null,
          extend: extend3,
          create: create$2,
          bind,
          get lastId() {
            return lastId;
          },
          stamp,
          throttle: throttle2,
          wrapNum,
          falseFn,
          formatNum,
          trim,
          splitWords,
          setOptions,
          getParamString,
          template,
          isArray: isArray2,
          indexOf: indexOf2,
          emptyImageUrl,
          requestFn,
          cancelFn,
          requestAnimFrame,
          cancelAnimFrame
        };
        function Class() {
        }
        __name(Class, "Class");
        Class.extend = function(props) {
          var NewClass = /* @__PURE__ */ __name(function() {
            setOptions(this);
            if (this.initialize) {
              this.initialize.apply(this, arguments);
            }
            this.callInitHooks();
          }, "NewClass");
          var parentProto = NewClass.__super__ = this.prototype;
          var proto = create$2(parentProto);
          proto.constructor = NewClass;
          NewClass.prototype = proto;
          for (var i3 in this) {
            if (Object.prototype.hasOwnProperty.call(this, i3) && i3 !== "prototype" && i3 !== "__super__") {
              NewClass[i3] = this[i3];
            }
          }
          if (props.statics) {
            extend3(NewClass, props.statics);
          }
          if (props.includes) {
            checkDeprecatedMixinEvents(props.includes);
            extend3.apply(null, [proto].concat(props.includes));
          }
          extend3(proto, props);
          delete proto.statics;
          delete proto.includes;
          if (proto.options) {
            proto.options = parentProto.options ? create$2(parentProto.options) : {};
            extend3(proto.options, props.options);
          }
          proto._initHooks = [];
          proto.callInitHooks = function() {
            if (this._initHooksCalled) {
              return;
            }
            if (parentProto.callInitHooks) {
              parentProto.callInitHooks.call(this);
            }
            this._initHooksCalled = true;
            for (var i4 = 0, len = proto._initHooks.length; i4 < len; i4++) {
              proto._initHooks[i4].call(this);
            }
          };
          return NewClass;
        };
        Class.include = function(props) {
          var parentOptions = this.prototype.options;
          extend3(this.prototype, props);
          if (props.options) {
            this.prototype.options = parentOptions;
            this.mergeOptions(props.options);
          }
          return this;
        };
        Class.mergeOptions = function(options) {
          extend3(this.prototype.options, options);
          return this;
        };
        Class.addInitHook = function(fn) {
          var args = Array.prototype.slice.call(arguments, 1);
          var init2 = typeof fn === "function" ? fn : function() {
            this[fn].apply(this, args);
          };
          this.prototype._initHooks = this.prototype._initHooks || [];
          this.prototype._initHooks.push(init2);
          return this;
        };
        function checkDeprecatedMixinEvents(includes) {
          if (typeof L === "undefined" || !L || !L.Mixin) {
            return;
          }
          includes = isArray2(includes) ? includes : [includes];
          for (var i3 = 0; i3 < includes.length; i3++) {
            if (includes[i3] === L.Mixin.Events) {
              console.warn("Deprecated include of L.Mixin.Events: this property will be removed in future releases, please inherit from L.Evented instead.", new Error().stack);
            }
          }
        }
        __name(checkDeprecatedMixinEvents, "checkDeprecatedMixinEvents");
        var Events = {
          /* @method on(type: String, fn: Function, context?: Object): this
           * Adds a listener function (`fn`) to a particular event type of the object. You can optionally specify the context of the listener (object the this keyword will point to). You can also pass several space-separated types (e.g. `'click dblclick'`).
           *
           * @alternative
           * @method on(eventMap: Object): this
           * Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`
           */
          on: function(types, fn, context) {
            if (typeof types === "object") {
              for (var type in types) {
                this._on(type, types[type], fn);
              }
            } else {
              types = splitWords(types);
              for (var i3 = 0, len = types.length; i3 < len; i3++) {
                this._on(types[i3], fn, context);
              }
            }
            return this;
          },
          /* @method off(type: String, fn?: Function, context?: Object): this
           * Removes a previously added listener function. If no function is specified, it will remove all the listeners of that particular event from the object. Note that if you passed a custom context to `on`, you must pass the same context to `off` in order to remove the listener.
           *
           * @alternative
           * @method off(eventMap: Object): this
           * Removes a set of type/listener pairs.
           *
           * @alternative
           * @method off: this
           * Removes all listeners to all events on the object. This includes implicitly attached events.
           */
          off: function(types, fn, context) {
            if (!arguments.length) {
              delete this._events;
            } else if (typeof types === "object") {
              for (var type in types) {
                this._off(type, types[type], fn);
              }
            } else {
              types = splitWords(types);
              var removeAll = arguments.length === 1;
              for (var i3 = 0, len = types.length; i3 < len; i3++) {
                if (removeAll) {
                  this._off(types[i3]);
                } else {
                  this._off(types[i3], fn, context);
                }
              }
            }
            return this;
          },
          // attach listener (without syntactic sugar now)
          _on: function(type, fn, context, _once) {
            if (typeof fn !== "function") {
              console.warn("wrong listener type: " + typeof fn);
              return;
            }
            if (this._listens(type, fn, context) !== false) {
              return;
            }
            if (context === this) {
              context = void 0;
            }
            var newListener = { fn, ctx: context };
            if (_once) {
              newListener.once = true;
            }
            this._events = this._events || {};
            this._events[type] = this._events[type] || [];
            this._events[type].push(newListener);
          },
          _off: function(type, fn, context) {
            var listeners, i3, len;
            if (!this._events) {
              return;
            }
            listeners = this._events[type];
            if (!listeners) {
              return;
            }
            if (arguments.length === 1) {
              if (this._firingCount) {
                for (i3 = 0, len = listeners.length; i3 < len; i3++) {
                  listeners[i3].fn = falseFn;
                }
              }
              delete this._events[type];
              return;
            }
            if (typeof fn !== "function") {
              console.warn("wrong listener type: " + typeof fn);
              return;
            }
            var index3 = this._listens(type, fn, context);
            if (index3 !== false) {
              var listener = listeners[index3];
              if (this._firingCount) {
                listener.fn = falseFn;
                this._events[type] = listeners = listeners.slice();
              }
              listeners.splice(index3, 1);
            }
          },
          // @method fire(type: String, data?: Object, propagate?: Boolean): this
          // Fires an event of the specified type. You can optionally provide a data
          // object — the first argument of the listener function will contain its
          // properties. The event can optionally be propagated to event parents.
          fire: function(type, data, propagate) {
            if (!this.listens(type, propagate)) {
              return this;
            }
            var event = extend3({}, data, {
              type,
              target: this,
              sourceTarget: data && data.sourceTarget || this
            });
            if (this._events) {
              var listeners = this._events[type];
              if (listeners) {
                this._firingCount = this._firingCount + 1 || 1;
                for (var i3 = 0, len = listeners.length; i3 < len; i3++) {
                  var l3 = listeners[i3];
                  var fn = l3.fn;
                  if (l3.once) {
                    this.off(type, fn, l3.ctx);
                  }
                  fn.call(l3.ctx || this, event);
                }
                this._firingCount--;
              }
            }
            if (propagate) {
              this._propagateEvent(event);
            }
            return this;
          },
          // @method listens(type: String, propagate?: Boolean): Boolean
          // @method listens(type: String, fn: Function, context?: Object, propagate?: Boolean): Boolean
          // Returns `true` if a particular event type has any listeners attached to it.
          // The verification can optionally be propagated, it will return `true` if parents have the listener attached to it.
          listens: function(type, fn, context, propagate) {
            if (typeof type !== "string") {
              console.warn('"string" type argument expected');
            }
            var _fn = fn;
            if (typeof fn !== "function") {
              propagate = !!fn;
              _fn = void 0;
              context = void 0;
            }
            var listeners = this._events && this._events[type];
            if (listeners && listeners.length) {
              if (this._listens(type, _fn, context) !== false) {
                return true;
              }
            }
            if (propagate) {
              for (var id in this._eventParents) {
                if (this._eventParents[id].listens(type, fn, context, propagate)) {
                  return true;
                }
              }
            }
            return false;
          },
          // returns the index (number) or false
          _listens: function(type, fn, context) {
            if (!this._events) {
              return false;
            }
            var listeners = this._events[type] || [];
            if (!fn) {
              return !!listeners.length;
            }
            if (context === this) {
              context = void 0;
            }
            for (var i3 = 0, len = listeners.length; i3 < len; i3++) {
              if (listeners[i3].fn === fn && listeners[i3].ctx === context) {
                return i3;
              }
            }
            return false;
          },
          // @method once(…): this
          // Behaves as [`on(…)`](#evented-on), except the listener will only get fired once and then removed.
          once: function(types, fn, context) {
            if (typeof types === "object") {
              for (var type in types) {
                this._on(type, types[type], fn, true);
              }
            } else {
              types = splitWords(types);
              for (var i3 = 0, len = types.length; i3 < len; i3++) {
                this._on(types[i3], fn, context, true);
              }
            }
            return this;
          },
          // @method addEventParent(obj: Evented): this
          // Adds an event parent - an `Evented` that will receive propagated events
          addEventParent: function(obj) {
            this._eventParents = this._eventParents || {};
            this._eventParents[stamp(obj)] = obj;
            return this;
          },
          // @method removeEventParent(obj: Evented): this
          // Removes an event parent, so it will stop receiving propagated events
          removeEventParent: function(obj) {
            if (this._eventParents) {
              delete this._eventParents[stamp(obj)];
            }
            return this;
          },
          _propagateEvent: function(e3) {
            for (var id in this._eventParents) {
              this._eventParents[id].fire(e3.type, extend3({
                layer: e3.target,
                propagatedFrom: e3.target
              }, e3), true);
            }
          }
        };
        Events.addEventListener = Events.on;
        Events.removeEventListener = Events.clearAllEventListeners = Events.off;
        Events.addOneTimeEventListener = Events.once;
        Events.fireEvent = Events.fire;
        Events.hasEventListeners = Events.listens;
        var Evented = Class.extend(Events);
        function Point(x3, y3, round) {
          this.x = round ? Math.round(x3) : x3;
          this.y = round ? Math.round(y3) : y3;
        }
        __name(Point, "Point");
        var trunc = Math.trunc || function(v3) {
          return v3 > 0 ? Math.floor(v3) : Math.ceil(v3);
        };
        Point.prototype = {
          // @method clone(): Point
          // Returns a copy of the current point.
          clone: function() {
            return new Point(this.x, this.y);
          },
          // @method add(otherPoint: Point): Point
          // Returns the result of addition of the current and the given points.
          add: function(point) {
            return this.clone()._add(toPoint(point));
          },
          _add: function(point) {
            this.x += point.x;
            this.y += point.y;
            return this;
          },
          // @method subtract(otherPoint: Point): Point
          // Returns the result of subtraction of the given point from the current.
          subtract: function(point) {
            return this.clone()._subtract(toPoint(point));
          },
          _subtract: function(point) {
            this.x -= point.x;
            this.y -= point.y;
            return this;
          },
          // @method divideBy(num: Number): Point
          // Returns the result of division of the current point by the given number.
          divideBy: function(num) {
            return this.clone()._divideBy(num);
          },
          _divideBy: function(num) {
            this.x /= num;
            this.y /= num;
            return this;
          },
          // @method multiplyBy(num: Number): Point
          // Returns the result of multiplication of the current point by the given number.
          multiplyBy: function(num) {
            return this.clone()._multiplyBy(num);
          },
          _multiplyBy: function(num) {
            this.x *= num;
            this.y *= num;
            return this;
          },
          // @method scaleBy(scale: Point): Point
          // Multiply each coordinate of the current point by each coordinate of
          // `scale`. In linear algebra terms, multiply the point by the
          // [scaling matrix](https://en.wikipedia.org/wiki/Scaling_%28geometry%29#Matrix_representation)
          // defined by `scale`.
          scaleBy: function(point) {
            return new Point(this.x * point.x, this.y * point.y);
          },
          // @method unscaleBy(scale: Point): Point
          // Inverse of `scaleBy`. Divide each coordinate of the current point by
          // each coordinate of `scale`.
          unscaleBy: function(point) {
            return new Point(this.x / point.x, this.y / point.y);
          },
          // @method round(): Point
          // Returns a copy of the current point with rounded coordinates.
          round: function() {
            return this.clone()._round();
          },
          _round: function() {
            this.x = Math.round(this.x);
            this.y = Math.round(this.y);
            return this;
          },
          // @method floor(): Point
          // Returns a copy of the current point with floored coordinates (rounded down).
          floor: function() {
            return this.clone()._floor();
          },
          _floor: function() {
            this.x = Math.floor(this.x);
            this.y = Math.floor(this.y);
            return this;
          },
          // @method ceil(): Point
          // Returns a copy of the current point with ceiled coordinates (rounded up).
          ceil: function() {
            return this.clone()._ceil();
          },
          _ceil: function() {
            this.x = Math.ceil(this.x);
            this.y = Math.ceil(this.y);
            return this;
          },
          // @method trunc(): Point
          // Returns a copy of the current point with truncated coordinates (rounded towards zero).
          trunc: function() {
            return this.clone()._trunc();
          },
          _trunc: function() {
            this.x = trunc(this.x);
            this.y = trunc(this.y);
            return this;
          },
          // @method distanceTo(otherPoint: Point): Number
          // Returns the cartesian distance between the current and the given points.
          distanceTo: function(point) {
            point = toPoint(point);
            var x3 = point.x - this.x, y3 = point.y - this.y;
            return Math.sqrt(x3 * x3 + y3 * y3);
          },
          // @method equals(otherPoint: Point): Boolean
          // Returns `true` if the given point has the same coordinates.
          equals: function(point) {
            point = toPoint(point);
            return point.x === this.x && point.y === this.y;
          },
          // @method contains(otherPoint: Point): Boolean
          // Returns `true` if both coordinates of the given point are less than the corresponding current point coordinates (in absolute values).
          contains: function(point) {
            point = toPoint(point);
            return Math.abs(point.x) <= Math.abs(this.x) && Math.abs(point.y) <= Math.abs(this.y);
          },
          // @method toString(): String
          // Returns a string representation of the point for debugging purposes.
          toString: function() {
            return "Point(" + formatNum(this.x) + ", " + formatNum(this.y) + ")";
          }
        };
        function toPoint(x3, y3, round) {
          if (x3 instanceof Point) {
            return x3;
          }
          if (isArray2(x3)) {
            return new Point(x3[0], x3[1]);
          }
          if (x3 === void 0 || x3 === null) {
            return x3;
          }
          if (typeof x3 === "object" && "x" in x3 && "y" in x3) {
            return new Point(x3.x, x3.y);
          }
          return new Point(x3, y3, round);
        }
        __name(toPoint, "toPoint");
        function Bounds(a3, b3) {
          if (!a3) {
            return;
          }
          var points = b3 ? [a3, b3] : a3;
          for (var i3 = 0, len = points.length; i3 < len; i3++) {
            this.extend(points[i3]);
          }
        }
        __name(Bounds, "Bounds");
        Bounds.prototype = {
          // @method extend(point: Point): this
          // Extends the bounds to contain the given point.
          // @alternative
          // @method extend(otherBounds: Bounds): this
          // Extend the bounds to contain the given bounds
          extend: function(obj) {
            var min2, max2;
            if (!obj) {
              return this;
            }
            if (obj instanceof Point || typeof obj[0] === "number" || "x" in obj) {
              min2 = max2 = toPoint(obj);
            } else {
              obj = toBounds(obj);
              min2 = obj.min;
              max2 = obj.max;
              if (!min2 || !max2) {
                return this;
              }
            }
            if (!this.min && !this.max) {
              this.min = min2.clone();
              this.max = max2.clone();
            } else {
              this.min.x = Math.min(min2.x, this.min.x);
              this.max.x = Math.max(max2.x, this.max.x);
              this.min.y = Math.min(min2.y, this.min.y);
              this.max.y = Math.max(max2.y, this.max.y);
            }
            return this;
          },
          // @method getCenter(round?: Boolean): Point
          // Returns the center point of the bounds.
          getCenter: function(round) {
            return toPoint(
              (this.min.x + this.max.x) / 2,
              (this.min.y + this.max.y) / 2,
              round
            );
          },
          // @method getBottomLeft(): Point
          // Returns the bottom-left point of the bounds.
          getBottomLeft: function() {
            return toPoint(this.min.x, this.max.y);
          },
          // @method getTopRight(): Point
          // Returns the top-right point of the bounds.
          getTopRight: function() {
            return toPoint(this.max.x, this.min.y);
          },
          // @method getTopLeft(): Point
          // Returns the top-left point of the bounds (i.e. [`this.min`](#bounds-min)).
          getTopLeft: function() {
            return this.min;
          },
          // @method getBottomRight(): Point
          // Returns the bottom-right point of the bounds (i.e. [`this.max`](#bounds-max)).
          getBottomRight: function() {
            return this.max;
          },
          // @method getSize(): Point
          // Returns the size of the given bounds
          getSize: function() {
            return this.max.subtract(this.min);
          },
          // @method contains(otherBounds: Bounds): Boolean
          // Returns `true` if the rectangle contains the given one.
          // @alternative
          // @method contains(point: Point): Boolean
          // Returns `true` if the rectangle contains the given point.
          contains: function(obj) {
            var min, max;
            if (typeof obj[0] === "number" || obj instanceof Point) {
              obj = toPoint(obj);
            } else {
              obj = toBounds(obj);
            }
            if (obj instanceof Bounds) {
              min = obj.min;
              max = obj.max;
            } else {
              min = max = obj;
            }
            return min.x >= this.min.x && max.x <= this.max.x && min.y >= this.min.y && max.y <= this.max.y;
          },
          // @method intersects(otherBounds: Bounds): Boolean
          // Returns `true` if the rectangle intersects the given bounds. Two bounds
          // intersect if they have at least one point in common.
          intersects: function(bounds) {
            bounds = toBounds(bounds);
            var min = this.min, max = this.max, min2 = bounds.min, max2 = bounds.max, xIntersects = max2.x >= min.x && min2.x <= max.x, yIntersects = max2.y >= min.y && min2.y <= max.y;
            return xIntersects && yIntersects;
          },
          // @method overlaps(otherBounds: Bounds): Boolean
          // Returns `true` if the rectangle overlaps the given bounds. Two bounds
          // overlap if their intersection is an area.
          overlaps: function(bounds) {
            bounds = toBounds(bounds);
            var min = this.min, max = this.max, min2 = bounds.min, max2 = bounds.max, xOverlaps = max2.x > min.x && min2.x < max.x, yOverlaps = max2.y > min.y && min2.y < max.y;
            return xOverlaps && yOverlaps;
          },
          // @method isValid(): Boolean
          // Returns `true` if the bounds are properly initialized.
          isValid: function() {
            return !!(this.min && this.max);
          },
          // @method pad(bufferRatio: Number): Bounds
          // Returns bounds created by extending or retracting the current bounds by a given ratio in each direction.
          // For example, a ratio of 0.5 extends the bounds by 50% in each direction.
          // Negative values will retract the bounds.
          pad: function(bufferRatio) {
            var min = this.min, max = this.max, heightBuffer = Math.abs(min.x - max.x) * bufferRatio, widthBuffer = Math.abs(min.y - max.y) * bufferRatio;
            return toBounds(
              toPoint(min.x - heightBuffer, min.y - widthBuffer),
              toPoint(max.x + heightBuffer, max.y + widthBuffer)
            );
          },
          // @method equals(otherBounds: Bounds): Boolean
          // Returns `true` if the rectangle is equivalent to the given bounds.
          equals: function(bounds) {
            if (!bounds) {
              return false;
            }
            bounds = toBounds(bounds);
            return this.min.equals(bounds.getTopLeft()) && this.max.equals(bounds.getBottomRight());
          }
        };
        function toBounds(a3, b3) {
          if (!a3 || a3 instanceof Bounds) {
            return a3;
          }
          return new Bounds(a3, b3);
        }
        __name(toBounds, "toBounds");
        function LatLngBounds(corner1, corner2) {
          if (!corner1) {
            return;
          }
          var latlngs = corner2 ? [corner1, corner2] : corner1;
          for (var i3 = 0, len = latlngs.length; i3 < len; i3++) {
            this.extend(latlngs[i3]);
          }
        }
        __name(LatLngBounds, "LatLngBounds");
        LatLngBounds.prototype = {
          // @method extend(latlng: LatLng): this
          // Extend the bounds to contain the given point
          // @alternative
          // @method extend(otherBounds: LatLngBounds): this
          // Extend the bounds to contain the given bounds
          extend: function(obj) {
            var sw = this._southWest, ne = this._northEast, sw2, ne2;
            if (obj instanceof LatLng) {
              sw2 = obj;
              ne2 = obj;
            } else if (obj instanceof LatLngBounds) {
              sw2 = obj._southWest;
              ne2 = obj._northEast;
              if (!sw2 || !ne2) {
                return this;
              }
            } else {
              return obj ? this.extend(toLatLng(obj) || toLatLngBounds(obj)) : this;
            }
            if (!sw && !ne) {
              this._southWest = new LatLng(sw2.lat, sw2.lng);
              this._northEast = new LatLng(ne2.lat, ne2.lng);
            } else {
              sw.lat = Math.min(sw2.lat, sw.lat);
              sw.lng = Math.min(sw2.lng, sw.lng);
              ne.lat = Math.max(ne2.lat, ne.lat);
              ne.lng = Math.max(ne2.lng, ne.lng);
            }
            return this;
          },
          // @method pad(bufferRatio: Number): LatLngBounds
          // Returns bounds created by extending or retracting the current bounds by a given ratio in each direction.
          // For example, a ratio of 0.5 extends the bounds by 50% in each direction.
          // Negative values will retract the bounds.
          pad: function(bufferRatio) {
            var sw = this._southWest, ne = this._northEast, heightBuffer = Math.abs(sw.lat - ne.lat) * bufferRatio, widthBuffer = Math.abs(sw.lng - ne.lng) * bufferRatio;
            return new LatLngBounds(
              new LatLng(sw.lat - heightBuffer, sw.lng - widthBuffer),
              new LatLng(ne.lat + heightBuffer, ne.lng + widthBuffer)
            );
          },
          // @method getCenter(): LatLng
          // Returns the center point of the bounds.
          getCenter: function() {
            return new LatLng(
              (this._southWest.lat + this._northEast.lat) / 2,
              (this._southWest.lng + this._northEast.lng) / 2
            );
          },
          // @method getSouthWest(): LatLng
          // Returns the south-west point of the bounds.
          getSouthWest: function() {
            return this._southWest;
          },
          // @method getNorthEast(): LatLng
          // Returns the north-east point of the bounds.
          getNorthEast: function() {
            return this._northEast;
          },
          // @method getNorthWest(): LatLng
          // Returns the north-west point of the bounds.
          getNorthWest: function() {
            return new LatLng(this.getNorth(), this.getWest());
          },
          // @method getSouthEast(): LatLng
          // Returns the south-east point of the bounds.
          getSouthEast: function() {
            return new LatLng(this.getSouth(), this.getEast());
          },
          // @method getWest(): Number
          // Returns the west longitude of the bounds
          getWest: function() {
            return this._southWest.lng;
          },
          // @method getSouth(): Number
          // Returns the south latitude of the bounds
          getSouth: function() {
            return this._southWest.lat;
          },
          // @method getEast(): Number
          // Returns the east longitude of the bounds
          getEast: function() {
            return this._northEast.lng;
          },
          // @method getNorth(): Number
          // Returns the north latitude of the bounds
          getNorth: function() {
            return this._northEast.lat;
          },
          // @method contains(otherBounds: LatLngBounds): Boolean
          // Returns `true` if the rectangle contains the given one.
          // @alternative
          // @method contains (latlng: LatLng): Boolean
          // Returns `true` if the rectangle contains the given point.
          contains: function(obj) {
            if (typeof obj[0] === "number" || obj instanceof LatLng || "lat" in obj) {
              obj = toLatLng(obj);
            } else {
              obj = toLatLngBounds(obj);
            }
            var sw = this._southWest, ne = this._northEast, sw2, ne2;
            if (obj instanceof LatLngBounds) {
              sw2 = obj.getSouthWest();
              ne2 = obj.getNorthEast();
            } else {
              sw2 = ne2 = obj;
            }
            return sw2.lat >= sw.lat && ne2.lat <= ne.lat && sw2.lng >= sw.lng && ne2.lng <= ne.lng;
          },
          // @method intersects(otherBounds: LatLngBounds): Boolean
          // Returns `true` if the rectangle intersects the given bounds. Two bounds intersect if they have at least one point in common.
          intersects: function(bounds) {
            bounds = toLatLngBounds(bounds);
            var sw = this._southWest, ne = this._northEast, sw2 = bounds.getSouthWest(), ne2 = bounds.getNorthEast(), latIntersects = ne2.lat >= sw.lat && sw2.lat <= ne.lat, lngIntersects = ne2.lng >= sw.lng && sw2.lng <= ne.lng;
            return latIntersects && lngIntersects;
          },
          // @method overlaps(otherBounds: LatLngBounds): Boolean
          // Returns `true` if the rectangle overlaps the given bounds. Two bounds overlap if their intersection is an area.
          overlaps: function(bounds) {
            bounds = toLatLngBounds(bounds);
            var sw = this._southWest, ne = this._northEast, sw2 = bounds.getSouthWest(), ne2 = bounds.getNorthEast(), latOverlaps = ne2.lat > sw.lat && sw2.lat < ne.lat, lngOverlaps = ne2.lng > sw.lng && sw2.lng < ne.lng;
            return latOverlaps && lngOverlaps;
          },
          // @method toBBoxString(): String
          // Returns a string with bounding box coordinates in a 'southwest_lng,southwest_lat,northeast_lng,northeast_lat' format. Useful for sending requests to web services that return geo data.
          toBBoxString: function() {
            return [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join(",");
          },
          // @method equals(otherBounds: LatLngBounds, maxMargin?: Number): Boolean
          // Returns `true` if the rectangle is equivalent (within a small margin of error) to the given bounds. The margin of error can be overridden by setting `maxMargin` to a small number.
          equals: function(bounds, maxMargin) {
            if (!bounds) {
              return false;
            }
            bounds = toLatLngBounds(bounds);
            return this._southWest.equals(bounds.getSouthWest(), maxMargin) && this._northEast.equals(bounds.getNorthEast(), maxMargin);
          },
          // @method isValid(): Boolean
          // Returns `true` if the bounds are properly initialized.
          isValid: function() {
            return !!(this._southWest && this._northEast);
          }
        };
        function toLatLngBounds(a3, b3) {
          if (a3 instanceof LatLngBounds) {
            return a3;
          }
          return new LatLngBounds(a3, b3);
        }
        __name(toLatLngBounds, "toLatLngBounds");
        function LatLng(lat, lng, alt) {
          if (isNaN(lat) || isNaN(lng)) {
            throw new Error("Invalid LatLng object: (" + lat + ", " + lng + ")");
          }
          this.lat = +lat;
          this.lng = +lng;
          if (alt !== void 0) {
            this.alt = +alt;
          }
        }
        __name(LatLng, "LatLng");
        LatLng.prototype = {
          // @method equals(otherLatLng: LatLng, maxMargin?: Number): Boolean
          // Returns `true` if the given `LatLng` point is at the same position (within a small margin of error). The margin of error can be overridden by setting `maxMargin` to a small number.
          equals: function(obj, maxMargin) {
            if (!obj) {
              return false;
            }
            obj = toLatLng(obj);
            var margin = Math.max(
              Math.abs(this.lat - obj.lat),
              Math.abs(this.lng - obj.lng)
            );
            return margin <= (maxMargin === void 0 ? 1e-9 : maxMargin);
          },
          // @method toString(): String
          // Returns a string representation of the point (for debugging purposes).
          toString: function(precision) {
            return "LatLng(" + formatNum(this.lat, precision) + ", " + formatNum(this.lng, precision) + ")";
          },
          // @method distanceTo(otherLatLng: LatLng): Number
          // Returns the distance (in meters) to the given `LatLng` calculated using the [Spherical Law of Cosines](https://en.wikipedia.org/wiki/Spherical_law_of_cosines).
          distanceTo: function(other) {
            return Earth.distance(this, toLatLng(other));
          },
          // @method wrap(): LatLng
          // Returns a new `LatLng` object with the longitude wrapped so it's always between -180 and +180 degrees.
          wrap: function() {
            return Earth.wrapLatLng(this);
          },
          // @method toBounds(sizeInMeters: Number): LatLngBounds
          // Returns a new `LatLngBounds` object in which each boundary is `sizeInMeters/2` meters apart from the `LatLng`.
          toBounds: function(sizeInMeters) {
            var latAccuracy = 180 * sizeInMeters / 40075017, lngAccuracy = latAccuracy / Math.cos(Math.PI / 180 * this.lat);
            return toLatLngBounds(
              [this.lat - latAccuracy, this.lng - lngAccuracy],
              [this.lat + latAccuracy, this.lng + lngAccuracy]
            );
          },
          clone: function() {
            return new LatLng(this.lat, this.lng, this.alt);
          }
        };
        function toLatLng(a3, b3, c3) {
          if (a3 instanceof LatLng) {
            return a3;
          }
          if (isArray2(a3) && typeof a3[0] !== "object") {
            if (a3.length === 3) {
              return new LatLng(a3[0], a3[1], a3[2]);
            }
            if (a3.length === 2) {
              return new LatLng(a3[0], a3[1]);
            }
            return null;
          }
          if (a3 === void 0 || a3 === null) {
            return a3;
          }
          if (typeof a3 === "object" && "lat" in a3) {
            return new LatLng(a3.lat, "lng" in a3 ? a3.lng : a3.lon, a3.alt);
          }
          if (b3 === void 0) {
            return null;
          }
          return new LatLng(a3, b3, c3);
        }
        __name(toLatLng, "toLatLng");
        var CRS = {
          // @method latLngToPoint(latlng: LatLng, zoom: Number): Point
          // Projects geographical coordinates into pixel coordinates for a given zoom.
          latLngToPoint: function(latlng, zoom2) {
            var projectedPoint = this.projection.project(latlng), scale2 = this.scale(zoom2);
            return this.transformation._transform(projectedPoint, scale2);
          },
          // @method pointToLatLng(point: Point, zoom: Number): LatLng
          // The inverse of `latLngToPoint`. Projects pixel coordinates on a given
          // zoom into geographical coordinates.
          pointToLatLng: function(point, zoom2) {
            var scale2 = this.scale(zoom2), untransformedPoint = this.transformation.untransform(point, scale2);
            return this.projection.unproject(untransformedPoint);
          },
          // @method project(latlng: LatLng): Point
          // Projects geographical coordinates into coordinates in units accepted for
          // this CRS (e.g. meters for EPSG:3857, for passing it to WMS services).
          project: function(latlng) {
            return this.projection.project(latlng);
          },
          // @method unproject(point: Point): LatLng
          // Given a projected coordinate returns the corresponding LatLng.
          // The inverse of `project`.
          unproject: function(point) {
            return this.projection.unproject(point);
          },
          // @method scale(zoom: Number): Number
          // Returns the scale used when transforming projected coordinates into
          // pixel coordinates for a particular zoom. For example, it returns
          // `256 * 2^zoom` for Mercator-based CRS.
          scale: function(zoom2) {
            return 256 * Math.pow(2, zoom2);
          },
          // @method zoom(scale: Number): Number
          // Inverse of `scale()`, returns the zoom level corresponding to a scale
          // factor of `scale`.
          zoom: function(scale2) {
            return Math.log(scale2 / 256) / Math.LN2;
          },
          // @method getProjectedBounds(zoom: Number): Bounds
          // Returns the projection's bounds scaled and transformed for the provided `zoom`.
          getProjectedBounds: function(zoom2) {
            if (this.infinite) {
              return null;
            }
            var b3 = this.projection.bounds, s3 = this.scale(zoom2), min = this.transformation.transform(b3.min, s3), max = this.transformation.transform(b3.max, s3);
            return new Bounds(min, max);
          },
          // @method distance(latlng1: LatLng, latlng2: LatLng): Number
          // Returns the distance between two geographical coordinates.
          // @property code: String
          // Standard code name of the CRS passed into WMS services (e.g. `'EPSG:3857'`)
          //
          // @property wrapLng: Number[]
          // An array of two numbers defining whether the longitude (horizontal) coordinate
          // axis wraps around a given range and how. Defaults to `[-180, 180]` in most
          // geographical CRSs. If `undefined`, the longitude axis does not wrap around.
          //
          // @property wrapLat: Number[]
          // Like `wrapLng`, but for the latitude (vertical) axis.
          // wrapLng: [min, max],
          // wrapLat: [min, max],
          // @property infinite: Boolean
          // If true, the coordinate space will be unbounded (infinite in both axes)
          infinite: false,
          // @method wrapLatLng(latlng: LatLng): LatLng
          // Returns a `LatLng` where lat and lng has been wrapped according to the
          // CRS's `wrapLat` and `wrapLng` properties, if they are outside the CRS's bounds.
          wrapLatLng: function(latlng) {
            var lng = this.wrapLng ? wrapNum(latlng.lng, this.wrapLng, true) : latlng.lng, lat = this.wrapLat ? wrapNum(latlng.lat, this.wrapLat, true) : latlng.lat, alt = latlng.alt;
            return new LatLng(lat, lng, alt);
          },
          // @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds
          // Returns a `LatLngBounds` with the same size as the given one, ensuring
          // that its center is within the CRS's bounds.
          // Only accepts actual `L.LatLngBounds` instances, not arrays.
          wrapLatLngBounds: function(bounds) {
            var center = bounds.getCenter(), newCenter = this.wrapLatLng(center), latShift = center.lat - newCenter.lat, lngShift = center.lng - newCenter.lng;
            if (latShift === 0 && lngShift === 0) {
              return bounds;
            }
            var sw = bounds.getSouthWest(), ne = bounds.getNorthEast(), newSw = new LatLng(sw.lat - latShift, sw.lng - lngShift), newNe = new LatLng(ne.lat - latShift, ne.lng - lngShift);
            return new LatLngBounds(newSw, newNe);
          }
        };
        var Earth = extend3({}, CRS, {
          wrapLng: [-180, 180],
          // Mean Earth Radius, as recommended for use by
          // the International Union of Geodesy and Geophysics,
          // see https://rosettacode.org/wiki/Haversine_formula
          R: 6371e3,
          // distance between two geographical points using spherical law of cosines approximation
          distance: function(latlng1, latlng2) {
            var rad = Math.PI / 180, lat1 = latlng1.lat * rad, lat2 = latlng2.lat * rad, sinDLat = Math.sin((latlng2.lat - latlng1.lat) * rad / 2), sinDLon = Math.sin((latlng2.lng - latlng1.lng) * rad / 2), a3 = sinDLat * sinDLat + Math.cos(lat1) * Math.cos(lat2) * sinDLon * sinDLon, c3 = 2 * Math.atan2(Math.sqrt(a3), Math.sqrt(1 - a3));
            return this.R * c3;
          }
        });
        var earthRadius = 6378137;
        var SphericalMercator = {
          R: earthRadius,
          MAX_LATITUDE: 85.0511287798,
          project: function(latlng) {
            var d3 = Math.PI / 180, max = this.MAX_LATITUDE, lat = Math.max(Math.min(max, latlng.lat), -max), sin = Math.sin(lat * d3);
            return new Point(
              this.R * latlng.lng * d3,
              this.R * Math.log((1 + sin) / (1 - sin)) / 2
            );
          },
          unproject: function(point) {
            var d3 = 180 / Math.PI;
            return new LatLng(
              (2 * Math.atan(Math.exp(point.y / this.R)) - Math.PI / 2) * d3,
              point.x * d3 / this.R
            );
          },
          bounds: function() {
            var d3 = earthRadius * Math.PI;
            return new Bounds([-d3, -d3], [d3, d3]);
          }()
        };
        function Transformation(a3, b3, c3, d3) {
          if (isArray2(a3)) {
            this._a = a3[0];
            this._b = a3[1];
            this._c = a3[2];
            this._d = a3[3];
            return;
          }
          this._a = a3;
          this._b = b3;
          this._c = c3;
          this._d = d3;
        }
        __name(Transformation, "Transformation");
        Transformation.prototype = {
          // @method transform(point: Point, scale?: Number): Point
          // Returns a transformed point, optionally multiplied by the given scale.
          // Only accepts actual `L.Point` instances, not arrays.
          transform: function(point, scale2) {
            return this._transform(point.clone(), scale2);
          },
          // destructive transform (faster)
          _transform: function(point, scale2) {
            scale2 = scale2 || 1;
            point.x = scale2 * (this._a * point.x + this._b);
            point.y = scale2 * (this._c * point.y + this._d);
            return point;
          },
          // @method untransform(point: Point, scale?: Number): Point
          // Returns the reverse transformation of the given point, optionally divided
          // by the given scale. Only accepts actual `L.Point` instances, not arrays.
          untransform: function(point, scale2) {
            scale2 = scale2 || 1;
            return new Point(
              (point.x / scale2 - this._b) / this._a,
              (point.y / scale2 - this._d) / this._c
            );
          }
        };
        function toTransformation(a3, b3, c3, d3) {
          return new Transformation(a3, b3, c3, d3);
        }
        __name(toTransformation, "toTransformation");
        var EPSG3857 = extend3({}, Earth, {
          code: "EPSG:3857",
          projection: SphericalMercator,
          transformation: function() {
            var scale2 = 0.5 / (Math.PI * SphericalMercator.R);
            return toTransformation(scale2, 0.5, -scale2, 0.5);
          }()
        });
        var EPSG900913 = extend3({}, EPSG3857, {
          code: "EPSG:900913"
        });
        function svgCreate(name) {
          return document.createElementNS("http://www.w3.org/2000/svg", name);
        }
        __name(svgCreate, "svgCreate");
        function pointsToPath(rings, closed) {
          var str = "", i3, j3, len, len2, points, p3;
          for (i3 = 0, len = rings.length; i3 < len; i3++) {
            points = rings[i3];
            for (j3 = 0, len2 = points.length; j3 < len2; j3++) {
              p3 = points[j3];
              str += (j3 ? "L" : "M") + p3.x + " " + p3.y;
            }
            str += closed ? Browser.svg ? "z" : "x" : "";
          }
          return str || "M0 0";
        }
        __name(pointsToPath, "pointsToPath");
        var style = document.documentElement.style;
        var ie = "ActiveXObject" in window;
        var ielt9 = ie && !document.addEventListener;
        var edge = "msLaunchUri" in navigator && !("documentMode" in document);
        var webkit = userAgentContains("webkit");
        var android = userAgentContains("android");
        var android23 = userAgentContains("android 2") || userAgentContains("android 3");
        var webkitVer = parseInt(/WebKit\/([0-9]+)|$/.exec(navigator.userAgent)[1], 10);
        var androidStock = android && userAgentContains("Google") && webkitVer < 537 && !("AudioNode" in window);
        var opera = !!window.opera;
        var chrome = !edge && userAgentContains("chrome");
        var gecko = userAgentContains("gecko") && !webkit && !opera && !ie;
        var safari = !chrome && userAgentContains("safari");
        var phantom = userAgentContains("phantom");
        var opera12 = "OTransition" in style;
        var win = navigator.platform.indexOf("Win") === 0;
        var ie3d = ie && "transition" in style;
        var webkit3d = "WebKitCSSMatrix" in window && "m11" in new window.WebKitCSSMatrix() && !android23;
        var gecko3d = "MozPerspective" in style;
        var any3d = !window.L_DISABLE_3D && (ie3d || webkit3d || gecko3d) && !opera12 && !phantom;
        var mobile = typeof orientation !== "undefined" || userAgentContains("mobile");
        var mobileWebkit = mobile && webkit;
        var mobileWebkit3d = mobile && webkit3d;
        var msPointer = !window.PointerEvent && window.MSPointerEvent;
        var pointer = !!(window.PointerEvent || msPointer);
        var touchNative = "ontouchstart" in window || !!window.TouchEvent;
        var touch = !window.L_NO_TOUCH && (touchNative || pointer);
        var mobileOpera = mobile && opera;
        var mobileGecko = mobile && gecko;
        var retina = (window.devicePixelRatio || window.screen.deviceXDPI / window.screen.logicalXDPI) > 1;
        var passiveEvents = function() {
          var supportsPassiveOption = false;
          try {
            var opts = Object.defineProperty({}, "passive", {
              get: function() {
                supportsPassiveOption = true;
              }
            });
            window.addEventListener("testPassiveEventSupport", falseFn, opts);
            window.removeEventListener("testPassiveEventSupport", falseFn, opts);
          } catch (e3) {
          }
          return supportsPassiveOption;
        }();
        var canvas$1 = function() {
          return !!document.createElement("canvas").getContext;
        }();
        var svg$1 = !!(document.createElementNS && svgCreate("svg").createSVGRect);
        var inlineSvg = !!svg$1 && function() {
          var div = document.createElement("div");
          div.innerHTML = "<svg/>";
          return (div.firstChild && div.firstChild.namespaceURI) === "http://www.w3.org/2000/svg";
        }();
        var vml = !svg$1 && function() {
          try {
            var div = document.createElement("div");
            div.innerHTML = '<v:shape adj="1"/>';
            var shape = div.firstChild;
            shape.style.behavior = "url(#default#VML)";
            return shape && typeof shape.adj === "object";
          } catch (e3) {
            return false;
          }
        }();
        var mac = navigator.platform.indexOf("Mac") === 0;
        var linux = navigator.platform.indexOf("Linux") === 0;
        function userAgentContains(str) {
          return navigator.userAgent.toLowerCase().indexOf(str) >= 0;
        }
        __name(userAgentContains, "userAgentContains");
        var Browser = {
          ie,
          ielt9,
          edge,
          webkit,
          android,
          android23,
          androidStock,
          opera,
          chrome,
          gecko,
          safari,
          phantom,
          opera12,
          win,
          ie3d,
          webkit3d,
          gecko3d,
          any3d,
          mobile,
          mobileWebkit,
          mobileWebkit3d,
          msPointer,
          pointer,
          touch,
          touchNative,
          mobileOpera,
          mobileGecko,
          retina,
          passiveEvents,
          canvas: canvas$1,
          svg: svg$1,
          vml,
          inlineSvg,
          mac,
          linux
        };
        var POINTER_DOWN = Browser.msPointer ? "MSPointerDown" : "pointerdown";
        var POINTER_MOVE = Browser.msPointer ? "MSPointerMove" : "pointermove";
        var POINTER_UP = Browser.msPointer ? "MSPointerUp" : "pointerup";
        var POINTER_CANCEL = Browser.msPointer ? "MSPointerCancel" : "pointercancel";
        var pEvent = {
          touchstart: POINTER_DOWN,
          touchmove: POINTER_MOVE,
          touchend: POINTER_UP,
          touchcancel: POINTER_CANCEL
        };
        var handle = {
          touchstart: _onPointerStart,
          touchmove: _handlePointer,
          touchend: _handlePointer,
          touchcancel: _handlePointer
        };
        var _pointers = {};
        var _pointerDocListener = false;
        function addPointerListener(obj, type, handler) {
          if (type === "touchstart") {
            _addPointerDocListener();
          }
          if (!handle[type]) {
            console.warn("wrong event specified:", type);
            return falseFn;
          }
          handler = handle[type].bind(this, handler);
          obj.addEventListener(pEvent[type], handler, false);
          return handler;
        }
        __name(addPointerListener, "addPointerListener");
        function removePointerListener(obj, type, handler) {
          if (!pEvent[type]) {
            console.warn("wrong event specified:", type);
            return;
          }
          obj.removeEventListener(pEvent[type], handler, false);
        }
        __name(removePointerListener, "removePointerListener");
        function _globalPointerDown(e3) {
          _pointers[e3.pointerId] = e3;
        }
        __name(_globalPointerDown, "_globalPointerDown");
        function _globalPointerMove(e3) {
          if (_pointers[e3.pointerId]) {
            _pointers[e3.pointerId] = e3;
          }
        }
        __name(_globalPointerMove, "_globalPointerMove");
        function _globalPointerUp(e3) {
          delete _pointers[e3.pointerId];
        }
        __name(_globalPointerUp, "_globalPointerUp");
        function _addPointerDocListener() {
          if (!_pointerDocListener) {
            document.addEventListener(POINTER_DOWN, _globalPointerDown, true);
            document.addEventListener(POINTER_MOVE, _globalPointerMove, true);
            document.addEventListener(POINTER_UP, _globalPointerUp, true);
            document.addEventListener(POINTER_CANCEL, _globalPointerUp, true);
            _pointerDocListener = true;
          }
        }
        __name(_addPointerDocListener, "_addPointerDocListener");
        function _handlePointer(handler, e3) {
          if (e3.pointerType === (e3.MSPOINTER_TYPE_MOUSE || "mouse")) {
            return;
          }
          e3.touches = [];
          for (var i3 in _pointers) {
            e3.touches.push(_pointers[i3]);
          }
          e3.changedTouches = [e3];
          handler(e3);
        }
        __name(_handlePointer, "_handlePointer");
        function _onPointerStart(handler, e3) {
          if (e3.MSPOINTER_TYPE_TOUCH && e3.pointerType === e3.MSPOINTER_TYPE_TOUCH) {
            preventDefault(e3);
          }
          _handlePointer(handler, e3);
        }
        __name(_onPointerStart, "_onPointerStart");
        function makeDblclick(event) {
          var newEvent = {}, prop, i3;
          for (i3 in event) {
            prop = event[i3];
            newEvent[i3] = prop && prop.bind ? prop.bind(event) : prop;
          }
          event = newEvent;
          newEvent.type = "dblclick";
          newEvent.detail = 2;
          newEvent.isTrusted = false;
          newEvent._simulated = true;
          return newEvent;
        }
        __name(makeDblclick, "makeDblclick");
        var delay = 200;
        function addDoubleTapListener(obj, handler) {
          obj.addEventListener("dblclick", handler);
          var last = 0, detail;
          function simDblclick(e3) {
            if (e3.detail !== 1) {
              detail = e3.detail;
              return;
            }
            if (e3.pointerType === "mouse" || e3.sourceCapabilities && !e3.sourceCapabilities.firesTouchEvents) {
              return;
            }
            var path = getPropagationPath(e3);
            if (path.some(function(el) {
              return el instanceof HTMLLabelElement && el.attributes.for;
            }) && !path.some(function(el) {
              return el instanceof HTMLInputElement || el instanceof HTMLSelectElement;
            })) {
              return;
            }
            var now2 = Date.now();
            if (now2 - last <= delay) {
              detail++;
              if (detail === 2) {
                handler(makeDblclick(e3));
              }
            } else {
              detail = 1;
            }
            last = now2;
          }
          __name(simDblclick, "simDblclick");
          obj.addEventListener("click", simDblclick);
          return {
            dblclick: handler,
            simDblclick
          };
        }
        __name(addDoubleTapListener, "addDoubleTapListener");
        function removeDoubleTapListener(obj, handlers) {
          obj.removeEventListener("dblclick", handlers.dblclick);
          obj.removeEventListener("click", handlers.simDblclick);
        }
        __name(removeDoubleTapListener, "removeDoubleTapListener");
        var TRANSFORM = testProp(
          ["transform", "webkitTransform", "OTransform", "MozTransform", "msTransform"]
        );
        var TRANSITION = testProp(
          ["webkitTransition", "transition", "OTransition", "MozTransition", "msTransition"]
        );
        var TRANSITION_END = TRANSITION === "webkitTransition" || TRANSITION === "OTransition" ? TRANSITION + "End" : "transitionend";
        function get(id) {
          return typeof id === "string" ? document.getElementById(id) : id;
        }
        __name(get, "get");
        function getStyle(el, style2) {
          var value = el.style[style2] || el.currentStyle && el.currentStyle[style2];
          if ((!value || value === "auto") && document.defaultView) {
            var css2 = document.defaultView.getComputedStyle(el, null);
            value = css2 ? css2[style2] : null;
          }
          return value === "auto" ? null : value;
        }
        __name(getStyle, "getStyle");
        function create$1(tagName, className, container) {
          var el = document.createElement(tagName);
          el.className = className || "";
          if (container) {
            container.appendChild(el);
          }
          return el;
        }
        __name(create$1, "create$1");
        function remove(el) {
          var parent = el.parentNode;
          if (parent) {
            parent.removeChild(el);
          }
        }
        __name(remove, "remove");
        function empty(el) {
          while (el.firstChild) {
            el.removeChild(el.firstChild);
          }
        }
        __name(empty, "empty");
        function toFront(el) {
          var parent = el.parentNode;
          if (parent && parent.lastChild !== el) {
            parent.appendChild(el);
          }
        }
        __name(toFront, "toFront");
        function toBack(el) {
          var parent = el.parentNode;
          if (parent && parent.firstChild !== el) {
            parent.insertBefore(el, parent.firstChild);
          }
        }
        __name(toBack, "toBack");
        function hasClass(el, name) {
          if (el.classList !== void 0) {
            return el.classList.contains(name);
          }
          var className = getClass(el);
          return className.length > 0 && new RegExp("(^|\\s)" + name + "(\\s|$)").test(className);
        }
        __name(hasClass, "hasClass");
        function addClass(el, name) {
          if (el.classList !== void 0) {
            var classes = splitWords(name);
            for (var i3 = 0, len = classes.length; i3 < len; i3++) {
              el.classList.add(classes[i3]);
            }
          } else if (!hasClass(el, name)) {
            var className = getClass(el);
            setClass(el, (className ? className + " " : "") + name);
          }
        }
        __name(addClass, "addClass");
        function removeClass(el, name) {
          if (el.classList !== void 0) {
            el.classList.remove(name);
          } else {
            setClass(el, trim((" " + getClass(el) + " ").replace(" " + name + " ", " ")));
          }
        }
        __name(removeClass, "removeClass");
        function setClass(el, name) {
          if (el.className.baseVal === void 0) {
            el.className = name;
          } else {
            el.className.baseVal = name;
          }
        }
        __name(setClass, "setClass");
        function getClass(el) {
          if (el.correspondingElement) {
            el = el.correspondingElement;
          }
          return el.className.baseVal === void 0 ? el.className : el.className.baseVal;
        }
        __name(getClass, "getClass");
        function setOpacity(el, value) {
          if ("opacity" in el.style) {
            el.style.opacity = value;
          } else if ("filter" in el.style) {
            _setOpacityIE(el, value);
          }
        }
        __name(setOpacity, "setOpacity");
        function _setOpacityIE(el, value) {
          var filter = false, filterName = "DXImageTransform.Microsoft.Alpha";
          try {
            filter = el.filters.item(filterName);
          } catch (e3) {
            if (value === 1) {
              return;
            }
          }
          value = Math.round(value * 100);
          if (filter) {
            filter.Enabled = value !== 100;
            filter.Opacity = value;
          } else {
            el.style.filter += " progid:" + filterName + "(opacity=" + value + ")";
          }
        }
        __name(_setOpacityIE, "_setOpacityIE");
        function testProp(props) {
          var style2 = document.documentElement.style;
          for (var i3 = 0; i3 < props.length; i3++) {
            if (props[i3] in style2) {
              return props[i3];
            }
          }
          return false;
        }
        __name(testProp, "testProp");
        function setTransform(el, offset, scale2) {
          var pos = offset || new Point(0, 0);
          el.style[TRANSFORM] = (Browser.ie3d ? "translate(" + pos.x + "px," + pos.y + "px)" : "translate3d(" + pos.x + "px," + pos.y + "px,0)") + (scale2 ? " scale(" + scale2 + ")" : "");
        }
        __name(setTransform, "setTransform");
        function setPosition(el, point) {
          el._leaflet_pos = point;
          if (Browser.any3d) {
            setTransform(el, point);
          } else {
            el.style.left = point.x + "px";
            el.style.top = point.y + "px";
          }
        }
        __name(setPosition, "setPosition");
        function getPosition(el) {
          return el._leaflet_pos || new Point(0, 0);
        }
        __name(getPosition, "getPosition");
        var disableTextSelection;
        var enableTextSelection;
        var _userSelect;
        if ("onselectstart" in document) {
          disableTextSelection = /* @__PURE__ */ __name(function() {
            on2(window, "selectstart", preventDefault);
          }, "disableTextSelection");
          enableTextSelection = /* @__PURE__ */ __name(function() {
            off2(window, "selectstart", preventDefault);
          }, "enableTextSelection");
        } else {
          var userSelectProperty = testProp(
            ["userSelect", "WebkitUserSelect", "OUserSelect", "MozUserSelect", "msUserSelect"]
          );
          disableTextSelection = /* @__PURE__ */ __name(function() {
            if (userSelectProperty) {
              var style2 = document.documentElement.style;
              _userSelect = style2[userSelectProperty];
              style2[userSelectProperty] = "none";
            }
          }, "disableTextSelection");
          enableTextSelection = /* @__PURE__ */ __name(function() {
            if (userSelectProperty) {
              document.documentElement.style[userSelectProperty] = _userSelect;
              _userSelect = void 0;
            }
          }, "enableTextSelection");
        }
        function disableImageDrag() {
          on2(window, "dragstart", preventDefault);
        }
        __name(disableImageDrag, "disableImageDrag");
        function enableImageDrag() {
          off2(window, "dragstart", preventDefault);
        }
        __name(enableImageDrag, "enableImageDrag");
        var _outlineElement, _outlineStyle;
        function preventOutline(element) {
          while (element.tabIndex === -1) {
            element = element.parentNode;
          }
          if (!element.style) {
            return;
          }
          restoreOutline();
          _outlineElement = element;
          _outlineStyle = element.style.outlineStyle;
          element.style.outlineStyle = "none";
          on2(window, "keydown", restoreOutline);
        }
        __name(preventOutline, "preventOutline");
        function restoreOutline() {
          if (!_outlineElement) {
            return;
          }
          _outlineElement.style.outlineStyle = _outlineStyle;
          _outlineElement = void 0;
          _outlineStyle = void 0;
          off2(window, "keydown", restoreOutline);
        }
        __name(restoreOutline, "restoreOutline");
        function getSizedParentNode(element) {
          do {
            element = element.parentNode;
          } while ((!element.offsetWidth || !element.offsetHeight) && element !== document.body);
          return element;
        }
        __name(getSizedParentNode, "getSizedParentNode");
        function getScale(element) {
          var rect = element.getBoundingClientRect();
          return {
            x: rect.width / element.offsetWidth || 1,
            y: rect.height / element.offsetHeight || 1,
            boundingClientRect: rect
          };
        }
        __name(getScale, "getScale");
        var DomUtil = {
          __proto__: null,
          TRANSFORM,
          TRANSITION,
          TRANSITION_END,
          get,
          getStyle,
          create: create$1,
          remove,
          empty,
          toFront,
          toBack,
          hasClass,
          addClass,
          removeClass,
          setClass,
          getClass,
          setOpacity,
          testProp,
          setTransform,
          setPosition,
          getPosition,
          get disableTextSelection() {
            return disableTextSelection;
          },
          get enableTextSelection() {
            return enableTextSelection;
          },
          disableImageDrag,
          enableImageDrag,
          preventOutline,
          restoreOutline,
          getSizedParentNode,
          getScale
        };
        function on2(obj, types, fn, context) {
          if (types && typeof types === "object") {
            for (var type in types) {
              addOne(obj, type, types[type], fn);
            }
          } else {
            types = splitWords(types);
            for (var i3 = 0, len = types.length; i3 < len; i3++) {
              addOne(obj, types[i3], fn, context);
            }
          }
          return this;
        }
        __name(on2, "on");
        var eventsKey = "_leaflet_events";
        function off2(obj, types, fn, context) {
          if (arguments.length === 1) {
            batchRemove(obj);
            delete obj[eventsKey];
          } else if (types && typeof types === "object") {
            for (var type in types) {
              removeOne(obj, type, types[type], fn);
            }
          } else {
            types = splitWords(types);
            if (arguments.length === 2) {
              batchRemove(obj, function(type2) {
                return indexOf2(types, type2) !== -1;
              });
            } else {
              for (var i3 = 0, len = types.length; i3 < len; i3++) {
                removeOne(obj, types[i3], fn, context);
              }
            }
          }
          return this;
        }
        __name(off2, "off");
        function batchRemove(obj, filterFn) {
          for (var id in obj[eventsKey]) {
            var type = id.split(/\d/)[0];
            if (!filterFn || filterFn(type)) {
              removeOne(obj, type, null, null, id);
            }
          }
        }
        __name(batchRemove, "batchRemove");
        var mouseSubst = {
          mouseenter: "mouseover",
          mouseleave: "mouseout",
          wheel: !("onwheel" in window) && "mousewheel"
        };
        function addOne(obj, type, fn, context) {
          var id = type + stamp(fn) + (context ? "_" + stamp(context) : "");
          if (obj[eventsKey] && obj[eventsKey][id]) {
            return this;
          }
          var handler = /* @__PURE__ */ __name(function(e3) {
            return fn.call(context || obj, e3 || window.event);
          }, "handler");
          var originalHandler = handler;
          if (!Browser.touchNative && Browser.pointer && type.indexOf("touch") === 0) {
            handler = addPointerListener(obj, type, handler);
          } else if (Browser.touch && type === "dblclick") {
            handler = addDoubleTapListener(obj, handler);
          } else if ("addEventListener" in obj) {
            if (type === "touchstart" || type === "touchmove" || type === "wheel" || type === "mousewheel") {
              obj.addEventListener(mouseSubst[type] || type, handler, Browser.passiveEvents ? { passive: false } : false);
            } else if (type === "mouseenter" || type === "mouseleave") {
              handler = /* @__PURE__ */ __name(function(e3) {
                e3 = e3 || window.event;
                if (isExternalTarget(obj, e3)) {
                  originalHandler(e3);
                }
              }, "handler");
              obj.addEventListener(mouseSubst[type], handler, false);
            } else {
              obj.addEventListener(type, originalHandler, false);
            }
          } else {
            obj.attachEvent("on" + type, handler);
          }
          obj[eventsKey] = obj[eventsKey] || {};
          obj[eventsKey][id] = handler;
        }
        __name(addOne, "addOne");
        function removeOne(obj, type, fn, context, id) {
          id = id || type + stamp(fn) + (context ? "_" + stamp(context) : "");
          var handler = obj[eventsKey] && obj[eventsKey][id];
          if (!handler) {
            return this;
          }
          if (!Browser.touchNative && Browser.pointer && type.indexOf("touch") === 0) {
            removePointerListener(obj, type, handler);
          } else if (Browser.touch && type === "dblclick") {
            removeDoubleTapListener(obj, handler);
          } else if ("removeEventListener" in obj) {
            obj.removeEventListener(mouseSubst[type] || type, handler, false);
          } else {
            obj.detachEvent("on" + type, handler);
          }
          obj[eventsKey][id] = null;
        }
        __name(removeOne, "removeOne");
        function stopPropagation(e3) {
          if (e3.stopPropagation) {
            e3.stopPropagation();
          } else if (e3.originalEvent) {
            e3.originalEvent._stopped = true;
          } else {
            e3.cancelBubble = true;
          }
          return this;
        }
        __name(stopPropagation, "stopPropagation");
        function disableScrollPropagation(el) {
          addOne(el, "wheel", stopPropagation);
          return this;
        }
        __name(disableScrollPropagation, "disableScrollPropagation");
        function disableClickPropagation(el) {
          on2(el, "mousedown touchstart dblclick contextmenu", stopPropagation);
          el["_leaflet_disable_click"] = true;
          return this;
        }
        __name(disableClickPropagation, "disableClickPropagation");
        function preventDefault(e3) {
          if (e3.preventDefault) {
            e3.preventDefault();
          } else {
            e3.returnValue = false;
          }
          return this;
        }
        __name(preventDefault, "preventDefault");
        function stop(e3) {
          preventDefault(e3);
          stopPropagation(e3);
          return this;
        }
        __name(stop, "stop");
        function getPropagationPath(ev) {
          if (ev.composedPath) {
            return ev.composedPath();
          }
          var path = [];
          var el = ev.target;
          while (el) {
            path.push(el);
            el = el.parentNode;
          }
          return path;
        }
        __name(getPropagationPath, "getPropagationPath");
        function getMousePosition(e3, container) {
          if (!container) {
            return new Point(e3.clientX, e3.clientY);
          }
          var scale2 = getScale(container), offset = scale2.boundingClientRect;
          return new Point(
            // offset.left/top values are in page scale (like clientX/Y),
            // whereas clientLeft/Top (border width) values are the original values (before CSS scale applies).
            (e3.clientX - offset.left) / scale2.x - container.clientLeft,
            (e3.clientY - offset.top) / scale2.y - container.clientTop
          );
        }
        __name(getMousePosition, "getMousePosition");
        var wheelPxFactor = Browser.linux && Browser.chrome ? window.devicePixelRatio : Browser.mac ? window.devicePixelRatio * 3 : window.devicePixelRatio > 0 ? 2 * window.devicePixelRatio : 1;
        function getWheelDelta(e3) {
          return Browser.edge ? e3.wheelDeltaY / 2 : (
            // Don't trust window-geometry-based delta
            e3.deltaY && e3.deltaMode === 0 ? -e3.deltaY / wheelPxFactor : (
              // Pixels
              e3.deltaY && e3.deltaMode === 1 ? -e3.deltaY * 20 : (
                // Lines
                e3.deltaY && e3.deltaMode === 2 ? -e3.deltaY * 60 : (
                  // Pages
                  e3.deltaX || e3.deltaZ ? 0 : (
                    // Skip horizontal/depth wheel events
                    e3.wheelDelta ? (e3.wheelDeltaY || e3.wheelDelta) / 2 : (
                      // Legacy IE pixels
                      e3.detail && Math.abs(e3.detail) < 32765 ? -e3.detail * 20 : (
                        // Legacy Moz lines
                        e3.detail ? e3.detail / -32765 * 60 : (
                          // Legacy Moz pages
                          0
                        )
                      )
                    )
                  )
                )
              )
            )
          );
        }
        __name(getWheelDelta, "getWheelDelta");
        function isExternalTarget(el, e3) {
          var related = e3.relatedTarget;
          if (!related) {
            return true;
          }
          try {
            while (related && related !== el) {
              related = related.parentNode;
            }
          } catch (err) {
            return false;
          }
          return related !== el;
        }
        __name(isExternalTarget, "isExternalTarget");
        var DomEvent = {
          __proto__: null,
          on: on2,
          off: off2,
          stopPropagation,
          disableScrollPropagation,
          disableClickPropagation,
          preventDefault,
          stop,
          getPropagationPath,
          getMousePosition,
          getWheelDelta,
          isExternalTarget,
          addListener: on2,
          removeListener: off2
        };
        var PosAnimation = Evented.extend({
          // @method run(el: HTMLElement, newPos: Point, duration?: Number, easeLinearity?: Number)
          // Run an animation of a given element to a new position, optionally setting
          // duration in seconds (`0.25` by default) and easing linearity factor (3rd
          // argument of the [cubic bezier curve](https://cubic-bezier.com/#0,0,.5,1),
          // `0.5` by default).
          run: function(el, newPos, duration3, easeLinearity) {
            this.stop();
            this._el = el;
            this._inProgress = true;
            this._duration = duration3 || 0.25;
            this._easeOutPower = 1 / Math.max(easeLinearity || 0.5, 0.2);
            this._startPos = getPosition(el);
            this._offset = newPos.subtract(this._startPos);
            this._startTime = +/* @__PURE__ */ new Date();
            this.fire("start");
            this._animate();
          },
          // @method stop()
          // Stops the animation (if currently running).
          stop: function() {
            if (!this._inProgress) {
              return;
            }
            this._step(true);
            this._complete();
          },
          _animate: function() {
            this._animId = requestAnimFrame(this._animate, this);
            this._step();
          },
          _step: function(round) {
            var elapsed = +/* @__PURE__ */ new Date() - this._startTime, duration3 = this._duration * 1e3;
            if (elapsed < duration3) {
              this._runFrame(this._easeOut(elapsed / duration3), round);
            } else {
              this._runFrame(1);
              this._complete();
            }
          },
          _runFrame: function(progress, round) {
            var pos = this._startPos.add(this._offset.multiplyBy(progress));
            if (round) {
              pos._round();
            }
            setPosition(this._el, pos);
            this.fire("step");
          },
          _complete: function() {
            cancelAnimFrame(this._animId);
            this._inProgress = false;
            this.fire("end");
          },
          _easeOut: function(t3) {
            return 1 - Math.pow(1 - t3, this._easeOutPower);
          }
        });
        var Map3 = Evented.extend({
          options: {
            // @section Map State Options
            // @option crs: CRS = L.CRS.EPSG3857
            // The [Coordinate Reference System](#crs) to use. Don't change this if you're not
            // sure what it means.
            crs: EPSG3857,
            // @option center: LatLng = undefined
            // Initial geographic center of the map
            center: void 0,
            // @option zoom: Number = undefined
            // Initial map zoom level
            zoom: void 0,
            // @option minZoom: Number = *
            // Minimum zoom level of the map.
            // If not specified and at least one `GridLayer` or `TileLayer` is in the map,
            // the lowest of their `minZoom` options will be used instead.
            minZoom: void 0,
            // @option maxZoom: Number = *
            // Maximum zoom level of the map.
            // If not specified and at least one `GridLayer` or `TileLayer` is in the map,
            // the highest of their `maxZoom` options will be used instead.
            maxZoom: void 0,
            // @option layers: Layer[] = []
            // Array of layers that will be added to the map initially
            layers: [],
            // @option maxBounds: LatLngBounds = null
            // When this option is set, the map restricts the view to the given
            // geographical bounds, bouncing the user back if the user tries to pan
            // outside the view. To set the restriction dynamically, use
            // [`setMaxBounds`](#map-setmaxbounds) method.
            maxBounds: void 0,
            // @option renderer: Renderer = *
            // The default method for drawing vector layers on the map. `L.SVG`
            // or `L.Canvas` by default depending on browser support.
            renderer: void 0,
            // @section Animation Options
            // @option zoomAnimation: Boolean = true
            // Whether the map zoom animation is enabled. By default it's enabled
            // in all browsers that support CSS3 Transitions except Android.
            zoomAnimation: true,
            // @option zoomAnimationThreshold: Number = 4
            // Won't animate zoom if the zoom difference exceeds this value.
            zoomAnimationThreshold: 4,
            // @option fadeAnimation: Boolean = true
            // Whether the tile fade animation is enabled. By default it's enabled
            // in all browsers that support CSS3 Transitions except Android.
            fadeAnimation: true,
            // @option markerZoomAnimation: Boolean = true
            // Whether markers animate their zoom with the zoom animation, if disabled
            // they will disappear for the length of the animation. By default it's
            // enabled in all browsers that support CSS3 Transitions except Android.
            markerZoomAnimation: true,
            // @option transform3DLimit: Number = 2^23
            // Defines the maximum size of a CSS translation transform. The default
            // value should not be changed unless a web browser positions layers in
            // the wrong place after doing a large `panBy`.
            transform3DLimit: 8388608,
            // Precision limit of a 32-bit float
            // @section Interaction Options
            // @option zoomSnap: Number = 1
            // Forces the map's zoom level to always be a multiple of this, particularly
            // right after a [`fitBounds()`](#map-fitbounds) or a pinch-zoom.
            // By default, the zoom level snaps to the nearest integer; lower values
            // (e.g. `0.5` or `0.1`) allow for greater granularity. A value of `0`
            // means the zoom level will not be snapped after `fitBounds` or a pinch-zoom.
            zoomSnap: 1,
            // @option zoomDelta: Number = 1
            // Controls how much the map's zoom level will change after a
            // [`zoomIn()`](#map-zoomin), [`zoomOut()`](#map-zoomout), pressing `+`
            // or `-` on the keyboard, or using the [zoom controls](#control-zoom).
            // Values smaller than `1` (e.g. `0.5`) allow for greater granularity.
            zoomDelta: 1,
            // @option trackResize: Boolean = true
            // Whether the map automatically handles browser window resize to update itself.
            trackResize: true
          },
          initialize: function(id, options) {
            options = setOptions(this, options);
            this._handlers = [];
            this._layers = {};
            this._zoomBoundLayers = {};
            this._sizeChanged = true;
            this._initContainer(id);
            this._initLayout();
            this._onResize = bind(this._onResize, this);
            this._initEvents();
            if (options.maxBounds) {
              this.setMaxBounds(options.maxBounds);
            }
            if (options.zoom !== void 0) {
              this._zoom = this._limitZoom(options.zoom);
            }
            if (options.center && options.zoom !== void 0) {
              this.setView(toLatLng(options.center), options.zoom, { reset: true });
            }
            this.callInitHooks();
            this._zoomAnimated = TRANSITION && Browser.any3d && !Browser.mobileOpera && this.options.zoomAnimation;
            if (this._zoomAnimated) {
              this._createAnimProxy();
              on2(this._proxy, TRANSITION_END, this._catchTransitionEnd, this);
            }
            this._addLayers(this.options.layers);
          },
          // @section Methods for modifying map state
          // @method setView(center: LatLng, zoom: Number, options?: Zoom/pan options): this
          // Sets the view of the map (geographical center and zoom) with the given
          // animation options.
          setView: function(center, zoom2, options) {
            zoom2 = zoom2 === void 0 ? this._zoom : this._limitZoom(zoom2);
            center = this._limitCenter(toLatLng(center), zoom2, this.options.maxBounds);
            options = options || {};
            this._stop();
            if (this._loaded && !options.reset && options !== true) {
              if (options.animate !== void 0) {
                options.zoom = extend3({ animate: options.animate }, options.zoom);
                options.pan = extend3({ animate: options.animate, duration: options.duration }, options.pan);
              }
              var moved2 = this._zoom !== zoom2 ? this._tryAnimatedZoom && this._tryAnimatedZoom(center, zoom2, options.zoom) : this._tryAnimatedPan(center, options.pan);
              if (moved2) {
                clearTimeout(this._sizeTimer);
                return this;
              }
            }
            this._resetView(center, zoom2, options.pan && options.pan.noMoveStart);
            return this;
          },
          // @method setZoom(zoom: Number, options?: Zoom/pan options): this
          // Sets the zoom of the map.
          setZoom: function(zoom2, options) {
            if (!this._loaded) {
              this._zoom = zoom2;
              return this;
            }
            return this.setView(this.getCenter(), zoom2, { zoom: options });
          },
          // @method zoomIn(delta?: Number, options?: Zoom options): this
          // Increases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).
          zoomIn: function(delta, options) {
            delta = delta || (Browser.any3d ? this.options.zoomDelta : 1);
            return this.setZoom(this._zoom + delta, options);
          },
          // @method zoomOut(delta?: Number, options?: Zoom options): this
          // Decreases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).
          zoomOut: function(delta, options) {
            delta = delta || (Browser.any3d ? this.options.zoomDelta : 1);
            return this.setZoom(this._zoom - delta, options);
          },
          // @method setZoomAround(latlng: LatLng, zoom: Number, options: Zoom options): this
          // Zooms the map while keeping a specified geographical point on the map
          // stationary (e.g. used internally for scroll zoom and double-click zoom).
          // @alternative
          // @method setZoomAround(offset: Point, zoom: Number, options: Zoom options): this
          // Zooms the map while keeping a specified pixel on the map (relative to the top-left corner) stationary.
          setZoomAround: function(latlng, zoom2, options) {
            var scale2 = this.getZoomScale(zoom2), viewHalf = this.getSize().divideBy(2), containerPoint = latlng instanceof Point ? latlng : this.latLngToContainerPoint(latlng), centerOffset = containerPoint.subtract(viewHalf).multiplyBy(1 - 1 / scale2), newCenter = this.containerPointToLatLng(viewHalf.add(centerOffset));
            return this.setView(newCenter, zoom2, { zoom: options });
          },
          _getBoundsCenterZoom: function(bounds, options) {
            options = options || {};
            bounds = bounds.getBounds ? bounds.getBounds() : toLatLngBounds(bounds);
            var paddingTL = toPoint(options.paddingTopLeft || options.padding || [0, 0]), paddingBR = toPoint(options.paddingBottomRight || options.padding || [0, 0]), zoom2 = this.getBoundsZoom(bounds, false, paddingTL.add(paddingBR));
            zoom2 = typeof options.maxZoom === "number" ? Math.min(options.maxZoom, zoom2) : zoom2;
            if (zoom2 === Infinity) {
              return {
                center: bounds.getCenter(),
                zoom: zoom2
              };
            }
            var paddingOffset = paddingBR.subtract(paddingTL).divideBy(2), swPoint = this.project(bounds.getSouthWest(), zoom2), nePoint = this.project(bounds.getNorthEast(), zoom2), center = this.unproject(swPoint.add(nePoint).divideBy(2).add(paddingOffset), zoom2);
            return {
              center,
              zoom: zoom2
            };
          },
          // @method fitBounds(bounds: LatLngBounds, options?: fitBounds options): this
          // Sets a map view that contains the given geographical bounds with the
          // maximum zoom level possible.
          fitBounds: function(bounds, options) {
            bounds = toLatLngBounds(bounds);
            if (!bounds.isValid()) {
              throw new Error("Bounds are not valid.");
            }
            var target = this._getBoundsCenterZoom(bounds, options);
            return this.setView(target.center, target.zoom, options);
          },
          // @method fitWorld(options?: fitBounds options): this
          // Sets a map view that mostly contains the whole world with the maximum
          // zoom level possible.
          fitWorld: function(options) {
            return this.fitBounds([[-90, -180], [90, 180]], options);
          },
          // @method panTo(latlng: LatLng, options?: Pan options): this
          // Pans the map to a given center.
          panTo: function(center, options) {
            return this.setView(center, this._zoom, { pan: options });
          },
          // @method panBy(offset: Point, options?: Pan options): this
          // Pans the map by a given number of pixels (animated).
          panBy: function(offset, options) {
            offset = toPoint(offset).round();
            options = options || {};
            if (!offset.x && !offset.y) {
              return this.fire("moveend");
            }
            if (options.animate !== true && !this.getSize().contains(offset)) {
              this._resetView(this.unproject(this.project(this.getCenter()).add(offset)), this.getZoom());
              return this;
            }
            if (!this._panAnim) {
              this._panAnim = new PosAnimation();
              this._panAnim.on({
                "step": this._onPanTransitionStep,
                "end": this._onPanTransitionEnd
              }, this);
            }
            if (!options.noMoveStart) {
              this.fire("movestart");
            }
            if (options.animate !== false) {
              addClass(this._mapPane, "leaflet-pan-anim");
              var newPos = this._getMapPanePos().subtract(offset).round();
              this._panAnim.run(this._mapPane, newPos, options.duration || 0.25, options.easeLinearity);
            } else {
              this._rawPanBy(offset);
              this.fire("move").fire("moveend");
            }
            return this;
          },
          // @method flyTo(latlng: LatLng, zoom?: Number, options?: Zoom/pan options): this
          // Sets the view of the map (geographical center and zoom) performing a smooth
          // pan-zoom animation.
          flyTo: function(targetCenter, targetZoom, options) {
            options = options || {};
            if (options.animate === false || !Browser.any3d) {
              return this.setView(targetCenter, targetZoom, options);
            }
            this._stop();
            var from = this.project(this.getCenter()), to = this.project(targetCenter), size = this.getSize(), startZoom = this._zoom;
            targetCenter = toLatLng(targetCenter);
            targetZoom = targetZoom === void 0 ? startZoom : targetZoom;
            var w0 = Math.max(size.x, size.y), w1 = w0 * this.getZoomScale(startZoom, targetZoom), u1 = to.distanceTo(from) || 1, rho = 1.42, rho2 = rho * rho;
            function r3(i3) {
              var s1 = i3 ? -1 : 1, s22 = i3 ? w1 : w0, t1 = w1 * w1 - w0 * w0 + s1 * rho2 * rho2 * u1 * u1, b1 = 2 * s22 * rho2 * u1, b3 = t1 / b1, sq = Math.sqrt(b3 * b3 + 1) - b3;
              var log = sq < 1e-9 ? -18 : Math.log(sq);
              return log;
            }
            __name(r3, "r");
            function sinh(n3) {
              return (Math.exp(n3) - Math.exp(-n3)) / 2;
            }
            __name(sinh, "sinh");
            function cosh(n3) {
              return (Math.exp(n3) + Math.exp(-n3)) / 2;
            }
            __name(cosh, "cosh");
            function tanh(n3) {
              return sinh(n3) / cosh(n3);
            }
            __name(tanh, "tanh");
            var r0 = r3(0);
            function w3(s3) {
              return w0 * (cosh(r0) / cosh(r0 + rho * s3));
            }
            __name(w3, "w");
            function u3(s3) {
              return w0 * (cosh(r0) * tanh(r0 + rho * s3) - sinh(r0)) / rho2;
            }
            __name(u3, "u");
            function easeOut(t3) {
              return 1 - Math.pow(1 - t3, 1.5);
            }
            __name(easeOut, "easeOut");
            var start2 = Date.now(), S3 = (r3(1) - r0) / rho, duration3 = options.duration ? 1e3 * options.duration : 1e3 * S3 * 0.8;
            function frame() {
              var t3 = (Date.now() - start2) / duration3, s3 = easeOut(t3) * S3;
              if (t3 <= 1) {
                this._flyToFrame = requestAnimFrame(frame, this);
                this._move(
                  this.unproject(from.add(to.subtract(from).multiplyBy(u3(s3) / u1)), startZoom),
                  this.getScaleZoom(w0 / w3(s3), startZoom),
                  { flyTo: true }
                );
              } else {
                this._move(targetCenter, targetZoom)._moveEnd(true);
              }
            }
            __name(frame, "frame");
            this._moveStart(true, options.noMoveStart);
            frame.call(this);
            return this;
          },
          // @method flyToBounds(bounds: LatLngBounds, options?: fitBounds options): this
          // Sets the view of the map with a smooth animation like [`flyTo`](#map-flyto),
          // but takes a bounds parameter like [`fitBounds`](#map-fitbounds).
          flyToBounds: function(bounds, options) {
            var target = this._getBoundsCenterZoom(bounds, options);
            return this.flyTo(target.center, target.zoom, options);
          },
          // @method setMaxBounds(bounds: LatLngBounds): this
          // Restricts the map view to the given bounds (see the [maxBounds](#map-maxbounds) option).
          setMaxBounds: function(bounds) {
            bounds = toLatLngBounds(bounds);
            if (this.listens("moveend", this._panInsideMaxBounds)) {
              this.off("moveend", this._panInsideMaxBounds);
            }
            if (!bounds.isValid()) {
              this.options.maxBounds = null;
              return this;
            }
            this.options.maxBounds = bounds;
            if (this._loaded) {
              this._panInsideMaxBounds();
            }
            return this.on("moveend", this._panInsideMaxBounds);
          },
          // @method setMinZoom(zoom: Number): this
          // Sets the lower limit for the available zoom levels (see the [minZoom](#map-minzoom) option).
          setMinZoom: function(zoom2) {
            var oldZoom = this.options.minZoom;
            this.options.minZoom = zoom2;
            if (this._loaded && oldZoom !== zoom2) {
              this.fire("zoomlevelschange");
              if (this.getZoom() < this.options.minZoom) {
                return this.setZoom(zoom2);
              }
            }
            return this;
          },
          // @method setMaxZoom(zoom: Number): this
          // Sets the upper limit for the available zoom levels (see the [maxZoom](#map-maxzoom) option).
          setMaxZoom: function(zoom2) {
            var oldZoom = this.options.maxZoom;
            this.options.maxZoom = zoom2;
            if (this._loaded && oldZoom !== zoom2) {
              this.fire("zoomlevelschange");
              if (this.getZoom() > this.options.maxZoom) {
                return this.setZoom(zoom2);
              }
            }
            return this;
          },
          // @method panInsideBounds(bounds: LatLngBounds, options?: Pan options): this
          // Pans the map to the closest view that would lie inside the given bounds (if it's not already), controlling the animation using the options specific, if any.
          panInsideBounds: function(bounds, options) {
            this._enforcingBounds = true;
            var center = this.getCenter(), newCenter = this._limitCenter(center, this._zoom, toLatLngBounds(bounds));
            if (!center.equals(newCenter)) {
              this.panTo(newCenter, options);
            }
            this._enforcingBounds = false;
            return this;
          },
          // @method panInside(latlng: LatLng, options?: padding options): this
          // Pans the map the minimum amount to make the `latlng` visible. Use
          // padding options to fit the display to more restricted bounds.
          // If `latlng` is already within the (optionally padded) display bounds,
          // the map will not be panned.
          panInside: function(latlng, options) {
            options = options || {};
            var paddingTL = toPoint(options.paddingTopLeft || options.padding || [0, 0]), paddingBR = toPoint(options.paddingBottomRight || options.padding || [0, 0]), pixelCenter = this.project(this.getCenter()), pixelPoint = this.project(latlng), pixelBounds = this.getPixelBounds(), paddedBounds = toBounds([pixelBounds.min.add(paddingTL), pixelBounds.max.subtract(paddingBR)]), paddedSize = paddedBounds.getSize();
            if (!paddedBounds.contains(pixelPoint)) {
              this._enforcingBounds = true;
              var centerOffset = pixelPoint.subtract(paddedBounds.getCenter());
              var offset = paddedBounds.extend(pixelPoint).getSize().subtract(paddedSize);
              pixelCenter.x += centerOffset.x < 0 ? -offset.x : offset.x;
              pixelCenter.y += centerOffset.y < 0 ? -offset.y : offset.y;
              this.panTo(this.unproject(pixelCenter), options);
              this._enforcingBounds = false;
            }
            return this;
          },
          // @method invalidateSize(options: Zoom/pan options): this
          // Checks if the map container size changed and updates the map if so —
          // call it after you've changed the map size dynamically, also animating
          // pan by default. If `options.pan` is `false`, panning will not occur.
          // If `options.debounceMoveend` is `true`, it will delay `moveend` event so
          // that it doesn't happen often even if the method is called many
          // times in a row.
          // @alternative
          // @method invalidateSize(animate: Boolean): this
          // Checks if the map container size changed and updates the map if so —
          // call it after you've changed the map size dynamically, also animating
          // pan by default.
          invalidateSize: function(options) {
            if (!this._loaded) {
              return this;
            }
            options = extend3({
              animate: false,
              pan: true
            }, options === true ? { animate: true } : options);
            var oldSize = this.getSize();
            this._sizeChanged = true;
            this._lastCenter = null;
            var newSize = this.getSize(), oldCenter = oldSize.divideBy(2).round(), newCenter = newSize.divideBy(2).round(), offset = oldCenter.subtract(newCenter);
            if (!offset.x && !offset.y) {
              return this;
            }
            if (options.animate && options.pan) {
              this.panBy(offset);
            } else {
              if (options.pan) {
                this._rawPanBy(offset);
              }
              this.fire("move");
              if (options.debounceMoveend) {
                clearTimeout(this._sizeTimer);
                this._sizeTimer = setTimeout(bind(this.fire, this, "moveend"), 200);
              } else {
                this.fire("moveend");
              }
            }
            return this.fire("resize", {
              oldSize,
              newSize
            });
          },
          // @section Methods for modifying map state
          // @method stop(): this
          // Stops the currently running `panTo` or `flyTo` animation, if any.
          stop: function() {
            this.setZoom(this._limitZoom(this._zoom));
            if (!this.options.zoomSnap) {
              this.fire("viewreset");
            }
            return this._stop();
          },
          // @section Geolocation methods
          // @method locate(options?: Locate options): this
          // Tries to locate the user using the Geolocation API, firing a [`locationfound`](#map-locationfound)
          // event with location data on success or a [`locationerror`](#map-locationerror) event on failure,
          // and optionally sets the map view to the user's location with respect to
          // detection accuracy (or to the world view if geolocation failed).
          // Note that, if your page doesn't use HTTPS, this method will fail in
          // modern browsers ([Chrome 50 and newer](https://sites.google.com/a/chromium.org/dev/Home/chromium-security/deprecating-powerful-features-on-insecure-origins))
          // See `Locate options` for more details.
          locate: function(options) {
            options = this._locateOptions = extend3({
              timeout: 1e4,
              watch: false
              // setView: false
              // maxZoom: <Number>
              // maximumAge: 0
              // enableHighAccuracy: false
            }, options);
            if (!("geolocation" in navigator)) {
              this._handleGeolocationError({
                code: 0,
                message: "Geolocation not supported."
              });
              return this;
            }
            var onResponse = bind(this._handleGeolocationResponse, this), onError = bind(this._handleGeolocationError, this);
            if (options.watch) {
              this._locationWatchId = navigator.geolocation.watchPosition(onResponse, onError, options);
            } else {
              navigator.geolocation.getCurrentPosition(onResponse, onError, options);
            }
            return this;
          },
          // @method stopLocate(): this
          // Stops watching location previously initiated by `map.locate({watch: true})`
          // and aborts resetting the map view if map.locate was called with
          // `{setView: true}`.
          stopLocate: function() {
            if (navigator.geolocation && navigator.geolocation.clearWatch) {
              navigator.geolocation.clearWatch(this._locationWatchId);
            }
            if (this._locateOptions) {
              this._locateOptions.setView = false;
            }
            return this;
          },
          _handleGeolocationError: function(error) {
            if (!this._container._leaflet_id) {
              return;
            }
            var c3 = error.code, message = error.message || (c3 === 1 ? "permission denied" : c3 === 2 ? "position unavailable" : "timeout");
            if (this._locateOptions.setView && !this._loaded) {
              this.fitWorld();
            }
            this.fire("locationerror", {
              code: c3,
              message: "Geolocation error: " + message + "."
            });
          },
          _handleGeolocationResponse: function(pos) {
            if (!this._container._leaflet_id) {
              return;
            }
            var lat = pos.coords.latitude, lng = pos.coords.longitude, latlng = new LatLng(lat, lng), bounds = latlng.toBounds(pos.coords.accuracy * 2), options = this._locateOptions;
            if (options.setView) {
              var zoom2 = this.getBoundsZoom(bounds);
              this.setView(latlng, options.maxZoom ? Math.min(zoom2, options.maxZoom) : zoom2);
            }
            var data = {
              latlng,
              bounds,
              timestamp: pos.timestamp
            };
            for (var i3 in pos.coords) {
              if (typeof pos.coords[i3] === "number") {
                data[i3] = pos.coords[i3];
              }
            }
            this.fire("locationfound", data);
          },
          // TODO Appropriate docs section?
          // @section Other Methods
          // @method addHandler(name: String, HandlerClass: Function): this
          // Adds a new `Handler` to the map, given its name and constructor function.
          addHandler: function(name, HandlerClass) {
            if (!HandlerClass) {
              return this;
            }
            var handler = this[name] = new HandlerClass(this);
            this._handlers.push(handler);
            if (this.options[name]) {
              handler.enable();
            }
            return this;
          },
          // @method remove(): this
          // Destroys the map and clears all related event listeners.
          remove: function() {
            this._initEvents(true);
            if (this.options.maxBounds) {
              this.off("moveend", this._panInsideMaxBounds);
            }
            if (this._containerId !== this._container._leaflet_id) {
              throw new Error("Map container is being reused by another instance");
            }
            try {
              delete this._container._leaflet_id;
              delete this._containerId;
            } catch (e3) {
              this._container._leaflet_id = void 0;
              this._containerId = void 0;
            }
            if (this._locationWatchId !== void 0) {
              this.stopLocate();
            }
            this._stop();
            remove(this._mapPane);
            if (this._clearControlPos) {
              this._clearControlPos();
            }
            if (this._resizeRequest) {
              cancelAnimFrame(this._resizeRequest);
              this._resizeRequest = null;
            }
            this._clearHandlers();
            if (this._loaded) {
              this.fire("unload");
            }
            var i3;
            for (i3 in this._layers) {
              this._layers[i3].remove();
            }
            for (i3 in this._panes) {
              remove(this._panes[i3]);
            }
            this._layers = [];
            this._panes = [];
            delete this._mapPane;
            delete this._renderer;
            return this;
          },
          // @section Other Methods
          // @method createPane(name: String, container?: HTMLElement): HTMLElement
          // Creates a new [map pane](#map-pane) with the given name if it doesn't exist already,
          // then returns it. The pane is created as a child of `container`, or
          // as a child of the main map pane if not set.
          createPane: function(name, container) {
            var className = "leaflet-pane" + (name ? " leaflet-" + name.replace("Pane", "") + "-pane" : ""), pane = create$1("div", className, container || this._mapPane);
            if (name) {
              this._panes[name] = pane;
            }
            return pane;
          },
          // @section Methods for Getting Map State
          // @method getCenter(): LatLng
          // Returns the geographical center of the map view
          getCenter: function() {
            this._checkIfLoaded();
            if (this._lastCenter && !this._moved()) {
              return this._lastCenter.clone();
            }
            return this.layerPointToLatLng(this._getCenterLayerPoint());
          },
          // @method getZoom(): Number
          // Returns the current zoom level of the map view
          getZoom: function() {
            return this._zoom;
          },
          // @method getBounds(): LatLngBounds
          // Returns the geographical bounds visible in the current map view
          getBounds: function() {
            var bounds = this.getPixelBounds(), sw = this.unproject(bounds.getBottomLeft()), ne = this.unproject(bounds.getTopRight());
            return new LatLngBounds(sw, ne);
          },
          // @method getMinZoom(): Number
          // Returns the minimum zoom level of the map (if set in the `minZoom` option of the map or of any layers), or `0` by default.
          getMinZoom: function() {
            return this.options.minZoom === void 0 ? this._layersMinZoom || 0 : this.options.minZoom;
          },
          // @method getMaxZoom(): Number
          // Returns the maximum zoom level of the map (if set in the `maxZoom` option of the map or of any layers).
          getMaxZoom: function() {
            return this.options.maxZoom === void 0 ? this._layersMaxZoom === void 0 ? Infinity : this._layersMaxZoom : this.options.maxZoom;
          },
          // @method getBoundsZoom(bounds: LatLngBounds, inside?: Boolean, padding?: Point): Number
          // Returns the maximum zoom level on which the given bounds fit to the map
          // view in its entirety. If `inside` (optional) is set to `true`, the method
          // instead returns the minimum zoom level on which the map view fits into
          // the given bounds in its entirety.
          getBoundsZoom: function(bounds, inside, padding) {
            bounds = toLatLngBounds(bounds);
            padding = toPoint(padding || [0, 0]);
            var zoom2 = this.getZoom() || 0, min = this.getMinZoom(), max = this.getMaxZoom(), nw = bounds.getNorthWest(), se = bounds.getSouthEast(), size = this.getSize().subtract(padding), boundsSize = toBounds(this.project(se, zoom2), this.project(nw, zoom2)).getSize(), snap = Browser.any3d ? this.options.zoomSnap : 1, scalex = size.x / boundsSize.x, scaley = size.y / boundsSize.y, scale2 = inside ? Math.max(scalex, scaley) : Math.min(scalex, scaley);
            zoom2 = this.getScaleZoom(scale2, zoom2);
            if (snap) {
              zoom2 = Math.round(zoom2 / (snap / 100)) * (snap / 100);
              zoom2 = inside ? Math.ceil(zoom2 / snap) * snap : Math.floor(zoom2 / snap) * snap;
            }
            return Math.max(min, Math.min(max, zoom2));
          },
          // @method getSize(): Point
          // Returns the current size of the map container (in pixels).
          getSize: function() {
            if (!this._size || this._sizeChanged) {
              this._size = new Point(
                this._container.clientWidth || 0,
                this._container.clientHeight || 0
              );
              this._sizeChanged = false;
            }
            return this._size.clone();
          },
          // @method getPixelBounds(): Bounds
          // Returns the bounds of the current map view in projected pixel
          // coordinates (sometimes useful in layer and overlay implementations).
          getPixelBounds: function(center, zoom2) {
            var topLeftPoint = this._getTopLeftPoint(center, zoom2);
            return new Bounds(topLeftPoint, topLeftPoint.add(this.getSize()));
          },
          // TODO: Check semantics - isn't the pixel origin the 0,0 coord relative to
          // the map pane? "left point of the map layer" can be confusing, specially
          // since there can be negative offsets.
          // @method getPixelOrigin(): Point
          // Returns the projected pixel coordinates of the top left point of
          // the map layer (useful in custom layer and overlay implementations).
          getPixelOrigin: function() {
            this._checkIfLoaded();
            return this._pixelOrigin;
          },
          // @method getPixelWorldBounds(zoom?: Number): Bounds
          // Returns the world's bounds in pixel coordinates for zoom level `zoom`.
          // If `zoom` is omitted, the map's current zoom level is used.
          getPixelWorldBounds: function(zoom2) {
            return this.options.crs.getProjectedBounds(zoom2 === void 0 ? this.getZoom() : zoom2);
          },
          // @section Other Methods
          // @method getPane(pane: String|HTMLElement): HTMLElement
          // Returns a [map pane](#map-pane), given its name or its HTML element (its identity).
          getPane: function(pane) {
            return typeof pane === "string" ? this._panes[pane] : pane;
          },
          // @method getPanes(): Object
          // Returns a plain object containing the names of all [panes](#map-pane) as keys and
          // the panes as values.
          getPanes: function() {
            return this._panes;
          },
          // @method getContainer: HTMLElement
          // Returns the HTML element that contains the map.
          getContainer: function() {
            return this._container;
          },
          // @section Conversion Methods
          // @method getZoomScale(toZoom: Number, fromZoom: Number): Number
          // Returns the scale factor to be applied to a map transition from zoom level
          // `fromZoom` to `toZoom`. Used internally to help with zoom animations.
          getZoomScale: function(toZoom, fromZoom) {
            var crs = this.options.crs;
            fromZoom = fromZoom === void 0 ? this._zoom : fromZoom;
            return crs.scale(toZoom) / crs.scale(fromZoom);
          },
          // @method getScaleZoom(scale: Number, fromZoom: Number): Number
          // Returns the zoom level that the map would end up at, if it is at `fromZoom`
          // level and everything is scaled by a factor of `scale`. Inverse of
          // [`getZoomScale`](#map-getZoomScale).
          getScaleZoom: function(scale2, fromZoom) {
            var crs = this.options.crs;
            fromZoom = fromZoom === void 0 ? this._zoom : fromZoom;
            var zoom2 = crs.zoom(scale2 * crs.scale(fromZoom));
            return isNaN(zoom2) ? Infinity : zoom2;
          },
          // @method project(latlng: LatLng, zoom: Number): Point
          // Projects a geographical coordinate `LatLng` according to the projection
          // of the map's CRS, then scales it according to `zoom` and the CRS's
          // `Transformation`. The result is pixel coordinate relative to
          // the CRS origin.
          project: function(latlng, zoom2) {
            zoom2 = zoom2 === void 0 ? this._zoom : zoom2;
            return this.options.crs.latLngToPoint(toLatLng(latlng), zoom2);
          },
          // @method unproject(point: Point, zoom: Number): LatLng
          // Inverse of [`project`](#map-project).
          unproject: function(point, zoom2) {
            zoom2 = zoom2 === void 0 ? this._zoom : zoom2;
            return this.options.crs.pointToLatLng(toPoint(point), zoom2);
          },
          // @method layerPointToLatLng(point: Point): LatLng
          // Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),
          // returns the corresponding geographical coordinate (for the current zoom level).
          layerPointToLatLng: function(point) {
            var projectedPoint = toPoint(point).add(this.getPixelOrigin());
            return this.unproject(projectedPoint);
          },
          // @method latLngToLayerPoint(latlng: LatLng): Point
          // Given a geographical coordinate, returns the corresponding pixel coordinate
          // relative to the [origin pixel](#map-getpixelorigin).
          latLngToLayerPoint: function(latlng) {
            var projectedPoint = this.project(toLatLng(latlng))._round();
            return projectedPoint._subtract(this.getPixelOrigin());
          },
          // @method wrapLatLng(latlng: LatLng): LatLng
          // Returns a `LatLng` where `lat` and `lng` has been wrapped according to the
          // map's CRS's `wrapLat` and `wrapLng` properties, if they are outside the
          // CRS's bounds.
          // By default this means longitude is wrapped around the dateline so its
          // value is between -180 and +180 degrees.
          wrapLatLng: function(latlng) {
            return this.options.crs.wrapLatLng(toLatLng(latlng));
          },
          // @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds
          // Returns a `LatLngBounds` with the same size as the given one, ensuring that
          // its center is within the CRS's bounds.
          // By default this means the center longitude is wrapped around the dateline so its
          // value is between -180 and +180 degrees, and the majority of the bounds
          // overlaps the CRS's bounds.
          wrapLatLngBounds: function(latlng) {
            return this.options.crs.wrapLatLngBounds(toLatLngBounds(latlng));
          },
          // @method distance(latlng1: LatLng, latlng2: LatLng): Number
          // Returns the distance between two geographical coordinates according to
          // the map's CRS. By default this measures distance in meters.
          distance: function(latlng1, latlng2) {
            return this.options.crs.distance(toLatLng(latlng1), toLatLng(latlng2));
          },
          // @method containerPointToLayerPoint(point: Point): Point
          // Given a pixel coordinate relative to the map container, returns the corresponding
          // pixel coordinate relative to the [origin pixel](#map-getpixelorigin).
          containerPointToLayerPoint: function(point) {
            return toPoint(point).subtract(this._getMapPanePos());
          },
          // @method layerPointToContainerPoint(point: Point): Point
          // Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),
          // returns the corresponding pixel coordinate relative to the map container.
          layerPointToContainerPoint: function(point) {
            return toPoint(point).add(this._getMapPanePos());
          },
          // @method containerPointToLatLng(point: Point): LatLng
          // Given a pixel coordinate relative to the map container, returns
          // the corresponding geographical coordinate (for the current zoom level).
          containerPointToLatLng: function(point) {
            var layerPoint = this.containerPointToLayerPoint(toPoint(point));
            return this.layerPointToLatLng(layerPoint);
          },
          // @method latLngToContainerPoint(latlng: LatLng): Point
          // Given a geographical coordinate, returns the corresponding pixel coordinate
          // relative to the map container.
          latLngToContainerPoint: function(latlng) {
            return this.layerPointToContainerPoint(this.latLngToLayerPoint(toLatLng(latlng)));
          },
          // @method mouseEventToContainerPoint(ev: MouseEvent): Point
          // Given a MouseEvent object, returns the pixel coordinate relative to the
          // map container where the event took place.
          mouseEventToContainerPoint: function(e3) {
            return getMousePosition(e3, this._container);
          },
          // @method mouseEventToLayerPoint(ev: MouseEvent): Point
          // Given a MouseEvent object, returns the pixel coordinate relative to
          // the [origin pixel](#map-getpixelorigin) where the event took place.
          mouseEventToLayerPoint: function(e3) {
            return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(e3));
          },
          // @method mouseEventToLatLng(ev: MouseEvent): LatLng
          // Given a MouseEvent object, returns geographical coordinate where the
          // event took place.
          mouseEventToLatLng: function(e3) {
            return this.layerPointToLatLng(this.mouseEventToLayerPoint(e3));
          },
          // map initialization methods
          _initContainer: function(id) {
            var container = this._container = get(id);
            if (!container) {
              throw new Error("Map container not found.");
            } else if (container._leaflet_id) {
              throw new Error("Map container is already initialized.");
            }
            on2(container, "scroll", this._onScroll, this);
            this._containerId = stamp(container);
          },
          _initLayout: function() {
            var container = this._container;
            this._fadeAnimated = this.options.fadeAnimation && Browser.any3d;
            addClass(container, "leaflet-container" + (Browser.touch ? " leaflet-touch" : "") + (Browser.retina ? " leaflet-retina" : "") + (Browser.ielt9 ? " leaflet-oldie" : "") + (Browser.safari ? " leaflet-safari" : "") + (this._fadeAnimated ? " leaflet-fade-anim" : ""));
            var position = getStyle(container, "position");
            if (position !== "absolute" && position !== "relative" && position !== "fixed" && position !== "sticky") {
              container.style.position = "relative";
            }
            this._initPanes();
            if (this._initControlPos) {
              this._initControlPos();
            }
          },
          _initPanes: function() {
            var panes = this._panes = {};
            this._paneRenderers = {};
            this._mapPane = this.createPane("mapPane", this._container);
            setPosition(this._mapPane, new Point(0, 0));
            this.createPane("tilePane");
            this.createPane("overlayPane");
            this.createPane("shadowPane");
            this.createPane("markerPane");
            this.createPane("tooltipPane");
            this.createPane("popupPane");
            if (!this.options.markerZoomAnimation) {
              addClass(panes.markerPane, "leaflet-zoom-hide");
              addClass(panes.shadowPane, "leaflet-zoom-hide");
            }
          },
          // private methods that modify map state
          // @section Map state change events
          _resetView: function(center, zoom2, noMoveStart) {
            setPosition(this._mapPane, new Point(0, 0));
            var loading = !this._loaded;
            this._loaded = true;
            zoom2 = this._limitZoom(zoom2);
            this.fire("viewprereset");
            var zoomChanged = this._zoom !== zoom2;
            this._moveStart(zoomChanged, noMoveStart)._move(center, zoom2)._moveEnd(zoomChanged);
            this.fire("viewreset");
            if (loading) {
              this.fire("load");
            }
          },
          _moveStart: function(zoomChanged, noMoveStart) {
            if (zoomChanged) {
              this.fire("zoomstart");
            }
            if (!noMoveStart) {
              this.fire("movestart");
            }
            return this;
          },
          _move: function(center, zoom2, data, supressEvent) {
            if (zoom2 === void 0) {
              zoom2 = this._zoom;
            }
            var zoomChanged = this._zoom !== zoom2;
            this._zoom = zoom2;
            this._lastCenter = center;
            this._pixelOrigin = this._getNewPixelOrigin(center);
            if (!supressEvent) {
              if (zoomChanged || data && data.pinch) {
                this.fire("zoom", data);
              }
              this.fire("move", data);
            } else if (data && data.pinch) {
              this.fire("zoom", data);
            }
            return this;
          },
          _moveEnd: function(zoomChanged) {
            if (zoomChanged) {
              this.fire("zoomend");
            }
            return this.fire("moveend");
          },
          _stop: function() {
            cancelAnimFrame(this._flyToFrame);
            if (this._panAnim) {
              this._panAnim.stop();
            }
            return this;
          },
          _rawPanBy: function(offset) {
            setPosition(this._mapPane, this._getMapPanePos().subtract(offset));
          },
          _getZoomSpan: function() {
            return this.getMaxZoom() - this.getMinZoom();
          },
          _panInsideMaxBounds: function() {
            if (!this._enforcingBounds) {
              this.panInsideBounds(this.options.maxBounds);
            }
          },
          _checkIfLoaded: function() {
            if (!this._loaded) {
              throw new Error("Set map center and zoom first.");
            }
          },
          // DOM event handling
          // @section Interaction events
          _initEvents: function(remove2) {
            this._targets = {};
            this._targets[stamp(this._container)] = this;
            var onOff = remove2 ? off2 : on2;
            onOff(this._container, "click dblclick mousedown mouseup mouseover mouseout mousemove contextmenu keypress keydown keyup", this._handleDOMEvent, this);
            if (this.options.trackResize) {
              onOff(window, "resize", this._onResize, this);
            }
            if (Browser.any3d && this.options.transform3DLimit) {
              (remove2 ? this.off : this.on).call(this, "moveend", this._onMoveEnd);
            }
          },
          _onResize: function() {
            cancelAnimFrame(this._resizeRequest);
            this._resizeRequest = requestAnimFrame(
              function() {
                this.invalidateSize({ debounceMoveend: true });
              },
              this
            );
          },
          _onScroll: function() {
            this._container.scrollTop = 0;
            this._container.scrollLeft = 0;
          },
          _onMoveEnd: function() {
            var pos = this._getMapPanePos();
            if (Math.max(Math.abs(pos.x), Math.abs(pos.y)) >= this.options.transform3DLimit) {
              this._resetView(this.getCenter(), this.getZoom());
            }
          },
          _findEventTargets: function(e3, type) {
            var targets = [], target, isHover = type === "mouseout" || type === "mouseover", src = e3.target || e3.srcElement, dragging = false;
            while (src) {
              target = this._targets[stamp(src)];
              if (target && (type === "click" || type === "preclick") && this._draggableMoved(target)) {
                dragging = true;
                break;
              }
              if (target && target.listens(type, true)) {
                if (isHover && !isExternalTarget(src, e3)) {
                  break;
                }
                targets.push(target);
                if (isHover) {
                  break;
                }
              }
              if (src === this._container) {
                break;
              }
              src = src.parentNode;
            }
            if (!targets.length && !dragging && !isHover && this.listens(type, true)) {
              targets = [this];
            }
            return targets;
          },
          _isClickDisabled: function(el) {
            while (el && el !== this._container) {
              if (el["_leaflet_disable_click"]) {
                return true;
              }
              el = el.parentNode;
            }
          },
          _handleDOMEvent: function(e3) {
            var el = e3.target || e3.srcElement;
            if (!this._loaded || el["_leaflet_disable_events"] || e3.type === "click" && this._isClickDisabled(el)) {
              return;
            }
            var type = e3.type;
            if (type === "mousedown") {
              preventOutline(el);
            }
            this._fireDOMEvent(e3, type);
          },
          _mouseEvents: ["click", "dblclick", "mouseover", "mouseout", "contextmenu"],
          _fireDOMEvent: function(e3, type, canvasTargets) {
            if (e3.type === "click") {
              var synth = extend3({}, e3);
              synth.type = "preclick";
              this._fireDOMEvent(synth, synth.type, canvasTargets);
            }
            var targets = this._findEventTargets(e3, type);
            if (canvasTargets) {
              var filtered = [];
              for (var i3 = 0; i3 < canvasTargets.length; i3++) {
                if (canvasTargets[i3].listens(type, true)) {
                  filtered.push(canvasTargets[i3]);
                }
              }
              targets = filtered.concat(targets);
            }
            if (!targets.length) {
              return;
            }
            if (type === "contextmenu") {
              preventDefault(e3);
            }
            var target = targets[0];
            var data = {
              originalEvent: e3
            };
            if (e3.type !== "keypress" && e3.type !== "keydown" && e3.type !== "keyup") {
              var isMarker = target.getLatLng && (!target._radius || target._radius <= 10);
              data.containerPoint = isMarker ? this.latLngToContainerPoint(target.getLatLng()) : this.mouseEventToContainerPoint(e3);
              data.layerPoint = this.containerPointToLayerPoint(data.containerPoint);
              data.latlng = isMarker ? target.getLatLng() : this.layerPointToLatLng(data.layerPoint);
            }
            for (i3 = 0; i3 < targets.length; i3++) {
              targets[i3].fire(type, data, true);
              if (data.originalEvent._stopped || targets[i3].options.bubblingMouseEvents === false && indexOf2(this._mouseEvents, type) !== -1) {
                return;
              }
            }
          },
          _draggableMoved: function(obj) {
            obj = obj.dragging && obj.dragging.enabled() ? obj : this;
            return obj.dragging && obj.dragging.moved() || this.boxZoom && this.boxZoom.moved();
          },
          _clearHandlers: function() {
            for (var i3 = 0, len = this._handlers.length; i3 < len; i3++) {
              this._handlers[i3].disable();
            }
          },
          // @section Other Methods
          // @method whenReady(fn: Function, context?: Object): this
          // Runs the given function `fn` when the map gets initialized with
          // a view (center and zoom) and at least one layer, or immediately
          // if it's already initialized, optionally passing a function context.
          whenReady: function(callback, context) {
            if (this._loaded) {
              callback.call(context || this, { target: this });
            } else {
              this.on("load", callback, context);
            }
            return this;
          },
          // private methods for getting map state
          _getMapPanePos: function() {
            return getPosition(this._mapPane) || new Point(0, 0);
          },
          _moved: function() {
            var pos = this._getMapPanePos();
            return pos && !pos.equals([0, 0]);
          },
          _getTopLeftPoint: function(center, zoom2) {
            var pixelOrigin = center && zoom2 !== void 0 ? this._getNewPixelOrigin(center, zoom2) : this.getPixelOrigin();
            return pixelOrigin.subtract(this._getMapPanePos());
          },
          _getNewPixelOrigin: function(center, zoom2) {
            var viewHalf = this.getSize()._divideBy(2);
            return this.project(center, zoom2)._subtract(viewHalf)._add(this._getMapPanePos())._round();
          },
          _latLngToNewLayerPoint: function(latlng, zoom2, center) {
            var topLeft = this._getNewPixelOrigin(center, zoom2);
            return this.project(latlng, zoom2)._subtract(topLeft);
          },
          _latLngBoundsToNewLayerBounds: function(latLngBounds, zoom2, center) {
            var topLeft = this._getNewPixelOrigin(center, zoom2);
            return toBounds([
              this.project(latLngBounds.getSouthWest(), zoom2)._subtract(topLeft),
              this.project(latLngBounds.getNorthWest(), zoom2)._subtract(topLeft),
              this.project(latLngBounds.getSouthEast(), zoom2)._subtract(topLeft),
              this.project(latLngBounds.getNorthEast(), zoom2)._subtract(topLeft)
            ]);
          },
          // layer point of the current center
          _getCenterLayerPoint: function() {
            return this.containerPointToLayerPoint(this.getSize()._divideBy(2));
          },
          // offset of the specified place to the current center in pixels
          _getCenterOffset: function(latlng) {
            return this.latLngToLayerPoint(latlng).subtract(this._getCenterLayerPoint());
          },
          // adjust center for view to get inside bounds
          _limitCenter: function(center, zoom2, bounds) {
            if (!bounds) {
              return center;
            }
            var centerPoint = this.project(center, zoom2), viewHalf = this.getSize().divideBy(2), viewBounds = new Bounds(centerPoint.subtract(viewHalf), centerPoint.add(viewHalf)), offset = this._getBoundsOffset(viewBounds, bounds, zoom2);
            if (Math.abs(offset.x) <= 1 && Math.abs(offset.y) <= 1) {
              return center;
            }
            return this.unproject(centerPoint.add(offset), zoom2);
          },
          // adjust offset for view to get inside bounds
          _limitOffset: function(offset, bounds) {
            if (!bounds) {
              return offset;
            }
            var viewBounds = this.getPixelBounds(), newBounds = new Bounds(viewBounds.min.add(offset), viewBounds.max.add(offset));
            return offset.add(this._getBoundsOffset(newBounds, bounds));
          },
          // returns offset needed for pxBounds to get inside maxBounds at a specified zoom
          _getBoundsOffset: function(pxBounds, maxBounds, zoom2) {
            var projectedMaxBounds = toBounds(
              this.project(maxBounds.getNorthEast(), zoom2),
              this.project(maxBounds.getSouthWest(), zoom2)
            ), minOffset = projectedMaxBounds.min.subtract(pxBounds.min), maxOffset = projectedMaxBounds.max.subtract(pxBounds.max), dx = this._rebound(minOffset.x, -maxOffset.x), dy = this._rebound(minOffset.y, -maxOffset.y);
            return new Point(dx, dy);
          },
          _rebound: function(left, right) {
            return left + right > 0 ? Math.round(left - right) / 2 : Math.max(0, Math.ceil(left)) - Math.max(0, Math.floor(right));
          },
          _limitZoom: function(zoom2) {
            var min = this.getMinZoom(), max = this.getMaxZoom(), snap = Browser.any3d ? this.options.zoomSnap : 1;
            if (snap) {
              zoom2 = Math.round(zoom2 / snap) * snap;
            }
            return Math.max(min, Math.min(max, zoom2));
          },
          _onPanTransitionStep: function() {
            this.fire("move");
          },
          _onPanTransitionEnd: function() {
            removeClass(this._mapPane, "leaflet-pan-anim");
            this.fire("moveend");
          },
          _tryAnimatedPan: function(center, options) {
            var offset = this._getCenterOffset(center)._trunc();
            if ((options && options.animate) !== true && !this.getSize().contains(offset)) {
              return false;
            }
            this.panBy(offset, options);
            return true;
          },
          _createAnimProxy: function() {
            var proxy = this._proxy = create$1("div", "leaflet-proxy leaflet-zoom-animated");
            this._panes.mapPane.appendChild(proxy);
            this.on("zoomanim", function(e3) {
              var prop = TRANSFORM, transform = this._proxy.style[prop];
              setTransform(this._proxy, this.project(e3.center, e3.zoom), this.getZoomScale(e3.zoom, 1));
              if (transform === this._proxy.style[prop] && this._animatingZoom) {
                this._onZoomTransitionEnd();
              }
            }, this);
            this.on("load moveend", this._animMoveEnd, this);
            this._on("unload", this._destroyAnimProxy, this);
          },
          _destroyAnimProxy: function() {
            remove(this._proxy);
            this.off("load moveend", this._animMoveEnd, this);
            delete this._proxy;
          },
          _animMoveEnd: function() {
            var c3 = this.getCenter(), z3 = this.getZoom();
            setTransform(this._proxy, this.project(c3, z3), this.getZoomScale(z3, 1));
          },
          _catchTransitionEnd: function(e3) {
            if (this._animatingZoom && e3.propertyName.indexOf("transform") >= 0) {
              this._onZoomTransitionEnd();
            }
          },
          _nothingToAnimate: function() {
            return !this._container.getElementsByClassName("leaflet-zoom-animated").length;
          },
          _tryAnimatedZoom: function(center, zoom2, options) {
            if (this._animatingZoom) {
              return true;
            }
            options = options || {};
            if (!this._zoomAnimated || options.animate === false || this._nothingToAnimate() || Math.abs(zoom2 - this._zoom) > this.options.zoomAnimationThreshold) {
              return false;
            }
            var scale2 = this.getZoomScale(zoom2), offset = this._getCenterOffset(center)._divideBy(1 - 1 / scale2);
            if (options.animate !== true && !this.getSize().contains(offset)) {
              return false;
            }
            requestAnimFrame(function() {
              this._moveStart(true, options.noMoveStart || false)._animateZoom(center, zoom2, true);
            }, this);
            return true;
          },
          _animateZoom: function(center, zoom2, startAnim, noUpdate) {
            if (!this._mapPane) {
              return;
            }
            if (startAnim) {
              this._animatingZoom = true;
              this._animateToCenter = center;
              this._animateToZoom = zoom2;
              addClass(this._mapPane, "leaflet-zoom-anim");
            }
            this.fire("zoomanim", {
              center,
              zoom: zoom2,
              noUpdate
            });
            if (!this._tempFireZoomEvent) {
              this._tempFireZoomEvent = this._zoom !== this._animateToZoom;
            }
            this._move(this._animateToCenter, this._animateToZoom, void 0, true);
            setTimeout(bind(this._onZoomTransitionEnd, this), 250);
          },
          _onZoomTransitionEnd: function() {
            if (!this._animatingZoom) {
              return;
            }
            if (this._mapPane) {
              removeClass(this._mapPane, "leaflet-zoom-anim");
            }
            this._animatingZoom = false;
            this._move(this._animateToCenter, this._animateToZoom, void 0, true);
            if (this._tempFireZoomEvent) {
              this.fire("zoom");
            }
            delete this._tempFireZoomEvent;
            this.fire("move");
            this._moveEnd(true);
          }
        });
        function createMap(id, options) {
          return new Map3(id, options);
        }
        __name(createMap, "createMap");
        var Control = Class.extend({
          // @section
          // @aka Control Options
          options: {
            // @option position: String = 'topright'
            // The position of the control (one of the map corners). Possible values are `'topleft'`,
            // `'topright'`, `'bottomleft'` or `'bottomright'`
            position: "topright"
          },
          initialize: function(options) {
            setOptions(this, options);
          },
          /* @section
           * Classes extending L.Control will inherit the following methods:
           *
           * @method getPosition: string
           * Returns the position of the control.
           */
          getPosition: function() {
            return this.options.position;
          },
          // @method setPosition(position: string): this
          // Sets the position of the control.
          setPosition: function(position) {
            var map2 = this._map;
            if (map2) {
              map2.removeControl(this);
            }
            this.options.position = position;
            if (map2) {
              map2.addControl(this);
            }
            return this;
          },
          // @method getContainer: HTMLElement
          // Returns the HTMLElement that contains the control.
          getContainer: function() {
            return this._container;
          },
          // @method addTo(map: Map): this
          // Adds the control to the given map.
          addTo: function(map2) {
            this.remove();
            this._map = map2;
            var container = this._container = this.onAdd(map2), pos = this.getPosition(), corner = map2._controlCorners[pos];
            addClass(container, "leaflet-control");
            if (pos.indexOf("bottom") !== -1) {
              corner.insertBefore(container, corner.firstChild);
            } else {
              corner.appendChild(container);
            }
            this._map.on("unload", this.remove, this);
            return this;
          },
          // @method remove: this
          // Removes the control from the map it is currently active on.
          remove: function() {
            if (!this._map) {
              return this;
            }
            remove(this._container);
            if (this.onRemove) {
              this.onRemove(this._map);
            }
            this._map.off("unload", this.remove, this);
            this._map = null;
            return this;
          },
          _refocusOnMap: function(e3) {
            if (this._map && e3 && e3.screenX > 0 && e3.screenY > 0) {
              this._map.getContainer().focus();
            }
          }
        });
        var control = /* @__PURE__ */ __name(function(options) {
          return new Control(options);
        }, "control");
        Map3.include({
          // @method addControl(control: Control): this
          // Adds the given control to the map
          addControl: function(control2) {
            control2.addTo(this);
            return this;
          },
          // @method removeControl(control: Control): this
          // Removes the given control from the map
          removeControl: function(control2) {
            control2.remove();
            return this;
          },
          _initControlPos: function() {
            var corners = this._controlCorners = {}, l3 = "leaflet-", container = this._controlContainer = create$1("div", l3 + "control-container", this._container);
            function createCorner(vSide, hSide) {
              var className = l3 + vSide + " " + l3 + hSide;
              corners[vSide + hSide] = create$1("div", className, container);
            }
            __name(createCorner, "createCorner");
            createCorner("top", "left");
            createCorner("top", "right");
            createCorner("bottom", "left");
            createCorner("bottom", "right");
          },
          _clearControlPos: function() {
            for (var i3 in this._controlCorners) {
              remove(this._controlCorners[i3]);
            }
            remove(this._controlContainer);
            delete this._controlCorners;
            delete this._controlContainer;
          }
        });
        var Layers = Control.extend({
          // @section
          // @aka Control.Layers options
          options: {
            // @option collapsed: Boolean = true
            // If `true`, the control will be collapsed into an icon and expanded on mouse hover, touch, or keyboard activation.
            collapsed: true,
            position: "topright",
            // @option autoZIndex: Boolean = true
            // If `true`, the control will assign zIndexes in increasing order to all of its layers so that the order is preserved when switching them on/off.
            autoZIndex: true,
            // @option hideSingleBase: Boolean = false
            // If `true`, the base layers in the control will be hidden when there is only one.
            hideSingleBase: false,
            // @option sortLayers: Boolean = false
            // Whether to sort the layers. When `false`, layers will keep the order
            // in which they were added to the control.
            sortLayers: false,
            // @option sortFunction: Function = *
            // A [compare function](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/sort)
            // that will be used for sorting the layers, when `sortLayers` is `true`.
            // The function receives both the `L.Layer` instances and their names, as in
            // `sortFunction(layerA, layerB, nameA, nameB)`.
            // By default, it sorts layers alphabetically by their name.
            sortFunction: function(layerA, layerB, nameA, nameB) {
              return nameA < nameB ? -1 : nameB < nameA ? 1 : 0;
            }
          },
          initialize: function(baseLayers, overlays, options) {
            setOptions(this, options);
            this._layerControlInputs = [];
            this._layers = [];
            this._lastZIndex = 0;
            this._handlingClick = false;
            this._preventClick = false;
            for (var i3 in baseLayers) {
              this._addLayer(baseLayers[i3], i3);
            }
            for (i3 in overlays) {
              this._addLayer(overlays[i3], i3, true);
            }
          },
          onAdd: function(map2) {
            this._initLayout();
            this._update();
            this._map = map2;
            map2.on("zoomend", this._checkDisabledLayers, this);
            for (var i3 = 0; i3 < this._layers.length; i3++) {
              this._layers[i3].layer.on("add remove", this._onLayerChange, this);
            }
            return this._container;
          },
          addTo: function(map2) {
            Control.prototype.addTo.call(this, map2);
            return this._expandIfNotCollapsed();
          },
          onRemove: function() {
            this._map.off("zoomend", this._checkDisabledLayers, this);
            for (var i3 = 0; i3 < this._layers.length; i3++) {
              this._layers[i3].layer.off("add remove", this._onLayerChange, this);
            }
          },
          // @method addBaseLayer(layer: Layer, name: String): this
          // Adds a base layer (radio button entry) with the given name to the control.
          addBaseLayer: function(layer, name) {
            this._addLayer(layer, name);
            return this._map ? this._update() : this;
          },
          // @method addOverlay(layer: Layer, name: String): this
          // Adds an overlay (checkbox entry) with the given name to the control.
          addOverlay: function(layer, name) {
            this._addLayer(layer, name, true);
            return this._map ? this._update() : this;
          },
          // @method removeLayer(layer: Layer): this
          // Remove the given layer from the control.
          removeLayer: function(layer) {
            layer.off("add remove", this._onLayerChange, this);
            var obj = this._getLayer(stamp(layer));
            if (obj) {
              this._layers.splice(this._layers.indexOf(obj), 1);
            }
            return this._map ? this._update() : this;
          },
          // @method expand(): this
          // Expand the control container if collapsed.
          expand: function() {
            addClass(this._container, "leaflet-control-layers-expanded");
            this._section.style.height = null;
            var acceptableHeight = this._map.getSize().y - (this._container.offsetTop + 50);
            if (acceptableHeight < this._section.clientHeight) {
              addClass(this._section, "leaflet-control-layers-scrollbar");
              this._section.style.height = acceptableHeight + "px";
            } else {
              removeClass(this._section, "leaflet-control-layers-scrollbar");
            }
            this._checkDisabledLayers();
            return this;
          },
          // @method collapse(): this
          // Collapse the control container if expanded.
          collapse: function() {
            removeClass(this._container, "leaflet-control-layers-expanded");
            return this;
          },
          _initLayout: function() {
            var className = "leaflet-control-layers", container = this._container = create$1("div", className), collapsed = this.options.collapsed;
            container.setAttribute("aria-haspopup", true);
            disableClickPropagation(container);
            disableScrollPropagation(container);
            var section = this._section = create$1("section", className + "-list");
            if (collapsed) {
              this._map.on("click", this.collapse, this);
              on2(container, {
                mouseenter: this._expandSafely,
                mouseleave: this.collapse
              }, this);
            }
            var link = this._layersLink = create$1("a", className + "-toggle", container);
            link.href = "#";
            link.title = "Layers";
            link.setAttribute("role", "button");
            on2(link, {
              keydown: function(e3) {
                if (e3.keyCode === 13) {
                  this._expandSafely();
                }
              },
              // Certain screen readers intercept the key event and instead send a click event
              click: function(e3) {
                preventDefault(e3);
                this._expandSafely();
              }
            }, this);
            if (!collapsed) {
              this.expand();
            }
            this._baseLayersList = create$1("div", className + "-base", section);
            this._separator = create$1("div", className + "-separator", section);
            this._overlaysList = create$1("div", className + "-overlays", section);
            container.appendChild(section);
          },
          _getLayer: function(id) {
            for (var i3 = 0; i3 < this._layers.length; i3++) {
              if (this._layers[i3] && stamp(this._layers[i3].layer) === id) {
                return this._layers[i3];
              }
            }
          },
          _addLayer: function(layer, name, overlay) {
            if (this._map) {
              layer.on("add remove", this._onLayerChange, this);
            }
            this._layers.push({
              layer,
              name,
              overlay
            });
            if (this.options.sortLayers) {
              this._layers.sort(bind(function(a3, b3) {
                return this.options.sortFunction(a3.layer, b3.layer, a3.name, b3.name);
              }, this));
            }
            if (this.options.autoZIndex && layer.setZIndex) {
              this._lastZIndex++;
              layer.setZIndex(this._lastZIndex);
            }
            this._expandIfNotCollapsed();
          },
          _update: function() {
            if (!this._container) {
              return this;
            }
            empty(this._baseLayersList);
            empty(this._overlaysList);
            this._layerControlInputs = [];
            var baseLayersPresent, overlaysPresent, i3, obj, baseLayersCount = 0;
            for (i3 = 0; i3 < this._layers.length; i3++) {
              obj = this._layers[i3];
              this._addItem(obj);
              overlaysPresent = overlaysPresent || obj.overlay;
              baseLayersPresent = baseLayersPresent || !obj.overlay;
              baseLayersCount += !obj.overlay ? 1 : 0;
            }
            if (this.options.hideSingleBase) {
              baseLayersPresent = baseLayersPresent && baseLayersCount > 1;
              this._baseLayersList.style.display = baseLayersPresent ? "" : "none";
            }
            this._separator.style.display = overlaysPresent && baseLayersPresent ? "" : "none";
            return this;
          },
          _onLayerChange: function(e3) {
            if (!this._handlingClick) {
              this._update();
            }
            var obj = this._getLayer(stamp(e3.target));
            var type = obj.overlay ? e3.type === "add" ? "overlayadd" : "overlayremove" : e3.type === "add" ? "baselayerchange" : null;
            if (type) {
              this._map.fire(type, obj);
            }
          },
          // IE7 bugs out if you create a radio dynamically, so you have to do it this hacky way (see https://stackoverflow.com/a/119079)
          _createRadioElement: function(name, checked) {
            var radioHtml = '<input type="radio" class="leaflet-control-layers-selector" name="' + name + '"' + (checked ? ' checked="checked"' : "") + "/>";
            var radioFragment = document.createElement("div");
            radioFragment.innerHTML = radioHtml;
            return radioFragment.firstChild;
          },
          _addItem: function(obj) {
            var label = document.createElement("label"), checked = this._map.hasLayer(obj.layer), input;
            if (obj.overlay) {
              input = document.createElement("input");
              input.type = "checkbox";
              input.className = "leaflet-control-layers-selector";
              input.defaultChecked = checked;
            } else {
              input = this._createRadioElement("leaflet-base-layers_" + stamp(this), checked);
            }
            this._layerControlInputs.push(input);
            input.layerId = stamp(obj.layer);
            on2(input, "click", this._onInputClick, this);
            var name = document.createElement("span");
            name.innerHTML = " " + obj.name;
            var holder = document.createElement("span");
            label.appendChild(holder);
            holder.appendChild(input);
            holder.appendChild(name);
            var container = obj.overlay ? this._overlaysList : this._baseLayersList;
            container.appendChild(label);
            this._checkDisabledLayers();
            return label;
          },
          _onInputClick: function() {
            if (this._preventClick) {
              return;
            }
            var inputs = this._layerControlInputs, input, layer;
            var addedLayers = [], removedLayers = [];
            this._handlingClick = true;
            for (var i3 = inputs.length - 1; i3 >= 0; i3--) {
              input = inputs[i3];
              layer = this._getLayer(input.layerId).layer;
              if (input.checked) {
                addedLayers.push(layer);
              } else if (!input.checked) {
                removedLayers.push(layer);
              }
            }
            for (i3 = 0; i3 < removedLayers.length; i3++) {
              if (this._map.hasLayer(removedLayers[i3])) {
                this._map.removeLayer(removedLayers[i3]);
              }
            }
            for (i3 = 0; i3 < addedLayers.length; i3++) {
              if (!this._map.hasLayer(addedLayers[i3])) {
                this._map.addLayer(addedLayers[i3]);
              }
            }
            this._handlingClick = false;
            this._refocusOnMap();
          },
          _checkDisabledLayers: function() {
            var inputs = this._layerControlInputs, input, layer, zoom2 = this._map.getZoom();
            for (var i3 = inputs.length - 1; i3 >= 0; i3--) {
              input = inputs[i3];
              layer = this._getLayer(input.layerId).layer;
              input.disabled = layer.options.minZoom !== void 0 && zoom2 < layer.options.minZoom || layer.options.maxZoom !== void 0 && zoom2 > layer.options.maxZoom;
            }
          },
          _expandIfNotCollapsed: function() {
            if (this._map && !this.options.collapsed) {
              this.expand();
            }
            return this;
          },
          _expandSafely: function() {
            var section = this._section;
            this._preventClick = true;
            on2(section, "click", preventDefault);
            this.expand();
            var that = this;
            setTimeout(function() {
              off2(section, "click", preventDefault);
              that._preventClick = false;
            });
          }
        });
        var layers = /* @__PURE__ */ __name(function(baseLayers, overlays, options) {
          return new Layers(baseLayers, overlays, options);
        }, "layers");
        var Zoom = Control.extend({
          // @section
          // @aka Control.Zoom options
          options: {
            position: "topleft",
            // @option zoomInText: String = '<span aria-hidden="true">+</span>'
            // The text set on the 'zoom in' button.
            zoomInText: '<span aria-hidden="true">+</span>',
            // @option zoomInTitle: String = 'Zoom in'
            // The title set on the 'zoom in' button.
            zoomInTitle: "Zoom in",
            // @option zoomOutText: String = '<span aria-hidden="true">&#x2212;</span>'
            // The text set on the 'zoom out' button.
            zoomOutText: '<span aria-hidden="true">&#x2212;</span>',
            // @option zoomOutTitle: String = 'Zoom out'
            // The title set on the 'zoom out' button.
            zoomOutTitle: "Zoom out"
          },
          onAdd: function(map2) {
            var zoomName = "leaflet-control-zoom", container = create$1("div", zoomName + " leaflet-bar"), options = this.options;
            this._zoomInButton = this._createButton(
              options.zoomInText,
              options.zoomInTitle,
              zoomName + "-in",
              container,
              this._zoomIn
            );
            this._zoomOutButton = this._createButton(
              options.zoomOutText,
              options.zoomOutTitle,
              zoomName + "-out",
              container,
              this._zoomOut
            );
            this._updateDisabled();
            map2.on("zoomend zoomlevelschange", this._updateDisabled, this);
            return container;
          },
          onRemove: function(map2) {
            map2.off("zoomend zoomlevelschange", this._updateDisabled, this);
          },
          disable: function() {
            this._disabled = true;
            this._updateDisabled();
            return this;
          },
          enable: function() {
            this._disabled = false;
            this._updateDisabled();
            return this;
          },
          _zoomIn: function(e3) {
            if (!this._disabled && this._map._zoom < this._map.getMaxZoom()) {
              this._map.zoomIn(this._map.options.zoomDelta * (e3.shiftKey ? 3 : 1));
            }
          },
          _zoomOut: function(e3) {
            if (!this._disabled && this._map._zoom > this._map.getMinZoom()) {
              this._map.zoomOut(this._map.options.zoomDelta * (e3.shiftKey ? 3 : 1));
            }
          },
          _createButton: function(html, title, className, container, fn) {
            var link = create$1("a", className, container);
            link.innerHTML = html;
            link.href = "#";
            link.title = title;
            link.setAttribute("role", "button");
            link.setAttribute("aria-label", title);
            disableClickPropagation(link);
            on2(link, "click", stop);
            on2(link, "click", fn, this);
            on2(link, "click", this._refocusOnMap, this);
            return link;
          },
          _updateDisabled: function() {
            var map2 = this._map, className = "leaflet-disabled";
            removeClass(this._zoomInButton, className);
            removeClass(this._zoomOutButton, className);
            this._zoomInButton.setAttribute("aria-disabled", "false");
            this._zoomOutButton.setAttribute("aria-disabled", "false");
            if (this._disabled || map2._zoom === map2.getMinZoom()) {
              addClass(this._zoomOutButton, className);
              this._zoomOutButton.setAttribute("aria-disabled", "true");
            }
            if (this._disabled || map2._zoom === map2.getMaxZoom()) {
              addClass(this._zoomInButton, className);
              this._zoomInButton.setAttribute("aria-disabled", "true");
            }
          }
        });
        Map3.mergeOptions({
          zoomControl: true
        });
        Map3.addInitHook(function() {
          if (this.options.zoomControl) {
            this.zoomControl = new Zoom();
            this.addControl(this.zoomControl);
          }
        });
        var zoom = /* @__PURE__ */ __name(function(options) {
          return new Zoom(options);
        }, "zoom");
        var Scale = Control.extend({
          // @section
          // @aka Control.Scale options
          options: {
            position: "bottomleft",
            // @option maxWidth: Number = 100
            // Maximum width of the control in pixels. The width is set dynamically to show round values (e.g. 100, 200, 500).
            maxWidth: 100,
            // @option metric: Boolean = True
            // Whether to show the metric scale line (m/km).
            metric: true,
            // @option imperial: Boolean = True
            // Whether to show the imperial scale line (mi/ft).
            imperial: true
            // @option updateWhenIdle: Boolean = false
            // If `true`, the control is updated on [`moveend`](#map-moveend), otherwise it's always up-to-date (updated on [`move`](#map-move)).
          },
          onAdd: function(map2) {
            var className = "leaflet-control-scale", container = create$1("div", className), options = this.options;
            this._addScales(options, className + "-line", container);
            map2.on(options.updateWhenIdle ? "moveend" : "move", this._update, this);
            map2.whenReady(this._update, this);
            return container;
          },
          onRemove: function(map2) {
            map2.off(this.options.updateWhenIdle ? "moveend" : "move", this._update, this);
          },
          _addScales: function(options, className, container) {
            if (options.metric) {
              this._mScale = create$1("div", className, container);
            }
            if (options.imperial) {
              this._iScale = create$1("div", className, container);
            }
          },
          _update: function() {
            var map2 = this._map, y3 = map2.getSize().y / 2;
            var maxMeters = map2.distance(
              map2.containerPointToLatLng([0, y3]),
              map2.containerPointToLatLng([this.options.maxWidth, y3])
            );
            this._updateScales(maxMeters);
          },
          _updateScales: function(maxMeters) {
            if (this.options.metric && maxMeters) {
              this._updateMetric(maxMeters);
            }
            if (this.options.imperial && maxMeters) {
              this._updateImperial(maxMeters);
            }
          },
          _updateMetric: function(maxMeters) {
            var meters = this._getRoundNum(maxMeters), label = meters < 1e3 ? meters + " m" : meters / 1e3 + " km";
            this._updateScale(this._mScale, label, meters / maxMeters);
          },
          _updateImperial: function(maxMeters) {
            var maxFeet = maxMeters * 3.2808399, maxMiles, miles, feet;
            if (maxFeet > 5280) {
              maxMiles = maxFeet / 5280;
              miles = this._getRoundNum(maxMiles);
              this._updateScale(this._iScale, miles + " mi", miles / maxMiles);
            } else {
              feet = this._getRoundNum(maxFeet);
              this._updateScale(this._iScale, feet + " ft", feet / maxFeet);
            }
          },
          _updateScale: function(scale2, text, ratio) {
            scale2.style.width = Math.round(this.options.maxWidth * ratio) + "px";
            scale2.innerHTML = text;
          },
          _getRoundNum: function(num) {
            var pow10 = Math.pow(10, (Math.floor(num) + "").length - 1), d3 = num / pow10;
            d3 = d3 >= 10 ? 10 : d3 >= 5 ? 5 : d3 >= 3 ? 3 : d3 >= 2 ? 2 : 1;
            return pow10 * d3;
          }
        });
        var scale = /* @__PURE__ */ __name(function(options) {
          return new Scale(options);
        }, "scale");
        var ukrainianFlag = '<svg aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width="12" height="8" viewBox="0 0 12 8" class="leaflet-attribution-flag"><path fill="#4C7BE1" d="M0 0h12v4H0z"/><path fill="#FFD500" d="M0 4h12v3H0z"/><path fill="#E0BC00" d="M0 7h12v1H0z"/></svg>';
        var Attribution = Control.extend({
          // @section
          // @aka Control.Attribution options
          options: {
            position: "bottomright",
            // @option prefix: String|false = 'Leaflet'
            // The HTML text shown before the attributions. Pass `false` to disable.
            prefix: '<a href="https://leafletjs.com" title="A JavaScript library for interactive maps">' + (Browser.inlineSvg ? ukrainianFlag + " " : "") + "Leaflet</a>"
          },
          initialize: function(options) {
            setOptions(this, options);
            this._attributions = {};
          },
          onAdd: function(map2) {
            map2.attributionControl = this;
            this._container = create$1("div", "leaflet-control-attribution");
            disableClickPropagation(this._container);
            for (var i3 in map2._layers) {
              if (map2._layers[i3].getAttribution) {
                this.addAttribution(map2._layers[i3].getAttribution());
              }
            }
            this._update();
            map2.on("layeradd", this._addAttribution, this);
            return this._container;
          },
          onRemove: function(map2) {
            map2.off("layeradd", this._addAttribution, this);
          },
          _addAttribution: function(ev) {
            if (ev.layer.getAttribution) {
              this.addAttribution(ev.layer.getAttribution());
              ev.layer.once("remove", function() {
                this.removeAttribution(ev.layer.getAttribution());
              }, this);
            }
          },
          // @method setPrefix(prefix: String|false): this
          // The HTML text shown before the attributions. Pass `false` to disable.
          setPrefix: function(prefix) {
            this.options.prefix = prefix;
            this._update();
            return this;
          },
          // @method addAttribution(text: String): this
          // Adds an attribution text (e.g. `'&copy; OpenStreetMap contributors'`).
          addAttribution: function(text) {
            if (!text) {
              return this;
            }
            if (!this._attributions[text]) {
              this._attributions[text] = 0;
            }
            this._attributions[text]++;
            this._update();
            return this;
          },
          // @method removeAttribution(text: String): this
          // Removes an attribution text.
          removeAttribution: function(text) {
            if (!text) {
              return this;
            }
            if (this._attributions[text]) {
              this._attributions[text]--;
              this._update();
            }
            return this;
          },
          _update: function() {
            if (!this._map) {
              return;
            }
            var attribs = [];
            for (var i3 in this._attributions) {
              if (this._attributions[i3]) {
                attribs.push(i3);
              }
            }
            var prefixAndAttribs = [];
            if (this.options.prefix) {
              prefixAndAttribs.push(this.options.prefix);
            }
            if (attribs.length) {
              prefixAndAttribs.push(attribs.join(", "));
            }
            this._container.innerHTML = prefixAndAttribs.join(' <span aria-hidden="true">|</span> ');
          }
        });
        Map3.mergeOptions({
          attributionControl: true
        });
        Map3.addInitHook(function() {
          if (this.options.attributionControl) {
            new Attribution().addTo(this);
          }
        });
        var attribution = /* @__PURE__ */ __name(function(options) {
          return new Attribution(options);
        }, "attribution");
        Control.Layers = Layers;
        Control.Zoom = Zoom;
        Control.Scale = Scale;
        Control.Attribution = Attribution;
        control.layers = layers;
        control.zoom = zoom;
        control.scale = scale;
        control.attribution = attribution;
        var Handler = Class.extend({
          initialize: function(map2) {
            this._map = map2;
          },
          // @method enable(): this
          // Enables the handler
          enable: function() {
            if (this._enabled) {
              return this;
            }
            this._enabled = true;
            this.addHooks();
            return this;
          },
          // @method disable(): this
          // Disables the handler
          disable: function() {
            if (!this._enabled) {
              return this;
            }
            this._enabled = false;
            this.removeHooks();
            return this;
          },
          // @method enabled(): Boolean
          // Returns `true` if the handler is enabled
          enabled: function() {
            return !!this._enabled;
          }
          // @section Extension methods
          // Classes inheriting from `Handler` must implement the two following methods:
          // @method addHooks()
          // Called when the handler is enabled, should add event hooks.
          // @method removeHooks()
          // Called when the handler is disabled, should remove the event hooks added previously.
        });
        Handler.addTo = function(map2, name) {
          map2.addHandler(name, this);
          return this;
        };
        var Mixin = { Events };
        var START = Browser.touch ? "touchstart mousedown" : "mousedown";
        var Draggable = Evented.extend({
          options: {
            // @section
            // @aka Draggable options
            // @option clickTolerance: Number = 3
            // The max number of pixels a user can shift the mouse pointer during a click
            // for it to be considered a valid click (as opposed to a mouse drag).
            clickTolerance: 3
          },
          // @constructor L.Draggable(el: HTMLElement, dragHandle?: HTMLElement, preventOutline?: Boolean, options?: Draggable options)
          // Creates a `Draggable` object for moving `el` when you start dragging the `dragHandle` element (equals `el` itself by default).
          initialize: function(element, dragStartTarget, preventOutline2, options) {
            setOptions(this, options);
            this._element = element;
            this._dragStartTarget = dragStartTarget || element;
            this._preventOutline = preventOutline2;
          },
          // @method enable()
          // Enables the dragging ability
          enable: function() {
            if (this._enabled) {
              return;
            }
            on2(this._dragStartTarget, START, this._onDown, this);
            this._enabled = true;
          },
          // @method disable()
          // Disables the dragging ability
          disable: function() {
            if (!this._enabled) {
              return;
            }
            if (Draggable._dragging === this) {
              this.finishDrag(true);
            }
            off2(this._dragStartTarget, START, this._onDown, this);
            this._enabled = false;
            this._moved = false;
          },
          _onDown: function(e3) {
            if (!this._enabled) {
              return;
            }
            this._moved = false;
            if (hasClass(this._element, "leaflet-zoom-anim")) {
              return;
            }
            if (e3.touches && e3.touches.length !== 1) {
              if (Draggable._dragging === this) {
                this.finishDrag();
              }
              return;
            }
            if (Draggable._dragging || e3.shiftKey || e3.which !== 1 && e3.button !== 1 && !e3.touches) {
              return;
            }
            Draggable._dragging = this;
            if (this._preventOutline) {
              preventOutline(this._element);
            }
            disableImageDrag();
            disableTextSelection();
            if (this._moving) {
              return;
            }
            this.fire("down");
            var first = e3.touches ? e3.touches[0] : e3, sizedParent = getSizedParentNode(this._element);
            this._startPoint = new Point(first.clientX, first.clientY);
            this._startPos = getPosition(this._element);
            this._parentScale = getScale(sizedParent);
            var mouseevent = e3.type === "mousedown";
            on2(document, mouseevent ? "mousemove" : "touchmove", this._onMove, this);
            on2(document, mouseevent ? "mouseup" : "touchend touchcancel", this._onUp, this);
          },
          _onMove: function(e3) {
            if (!this._enabled) {
              return;
            }
            if (e3.touches && e3.touches.length > 1) {
              this._moved = true;
              return;
            }
            var first = e3.touches && e3.touches.length === 1 ? e3.touches[0] : e3, offset = new Point(first.clientX, first.clientY)._subtract(this._startPoint);
            if (!offset.x && !offset.y) {
              return;
            }
            if (Math.abs(offset.x) + Math.abs(offset.y) < this.options.clickTolerance) {
              return;
            }
            offset.x /= this._parentScale.x;
            offset.y /= this._parentScale.y;
            preventDefault(e3);
            if (!this._moved) {
              this.fire("dragstart");
              this._moved = true;
              addClass(document.body, "leaflet-dragging");
              this._lastTarget = e3.target || e3.srcElement;
              if (window.SVGElementInstance && this._lastTarget instanceof window.SVGElementInstance) {
                this._lastTarget = this._lastTarget.correspondingUseElement;
              }
              addClass(this._lastTarget, "leaflet-drag-target");
            }
            this._newPos = this._startPos.add(offset);
            this._moving = true;
            this._lastEvent = e3;
            this._updatePosition();
          },
          _updatePosition: function() {
            var e3 = { originalEvent: this._lastEvent };
            this.fire("predrag", e3);
            setPosition(this._element, this._newPos);
            this.fire("drag", e3);
          },
          _onUp: function() {
            if (!this._enabled) {
              return;
            }
            this.finishDrag();
          },
          finishDrag: function(noInertia) {
            removeClass(document.body, "leaflet-dragging");
            if (this._lastTarget) {
              removeClass(this._lastTarget, "leaflet-drag-target");
              this._lastTarget = null;
            }
            off2(document, "mousemove touchmove", this._onMove, this);
            off2(document, "mouseup touchend touchcancel", this._onUp, this);
            enableImageDrag();
            enableTextSelection();
            var fireDragend = this._moved && this._moving;
            this._moving = false;
            Draggable._dragging = false;
            if (fireDragend) {
              this.fire("dragend", {
                noInertia,
                distance: this._newPos.distanceTo(this._startPos)
              });
            }
          }
        });
        function clipPolygon(points, bounds, round) {
          var clippedPoints, edges = [1, 4, 2, 8], i3, j3, k3, a3, b3, len, edge2, p3;
          for (i3 = 0, len = points.length; i3 < len; i3++) {
            points[i3]._code = _getBitCode(points[i3], bounds);
          }
          for (k3 = 0; k3 < 4; k3++) {
            edge2 = edges[k3];
            clippedPoints = [];
            for (i3 = 0, len = points.length, j3 = len - 1; i3 < len; j3 = i3++) {
              a3 = points[i3];
              b3 = points[j3];
              if (!(a3._code & edge2)) {
                if (b3._code & edge2) {
                  p3 = _getEdgeIntersection(b3, a3, edge2, bounds, round);
                  p3._code = _getBitCode(p3, bounds);
                  clippedPoints.push(p3);
                }
                clippedPoints.push(a3);
              } else if (!(b3._code & edge2)) {
                p3 = _getEdgeIntersection(b3, a3, edge2, bounds, round);
                p3._code = _getBitCode(p3, bounds);
                clippedPoints.push(p3);
              }
            }
            points = clippedPoints;
          }
          return points;
        }
        __name(clipPolygon, "clipPolygon");
        function polygonCenter(latlngs, crs) {
          var i3, j3, p1, p22, f3, area, x3, y3, center;
          if (!latlngs || latlngs.length === 0) {
            throw new Error("latlngs not passed");
          }
          if (!isFlat(latlngs)) {
            console.warn("latlngs are not flat! Only the first ring will be used");
            latlngs = latlngs[0];
          }
          var centroidLatLng = toLatLng([0, 0]);
          var bounds = toLatLngBounds(latlngs);
          var areaBounds = bounds.getNorthWest().distanceTo(bounds.getSouthWest()) * bounds.getNorthEast().distanceTo(bounds.getNorthWest());
          if (areaBounds < 1700) {
            centroidLatLng = centroid(latlngs);
          }
          var len = latlngs.length;
          var points = [];
          for (i3 = 0; i3 < len; i3++) {
            var latlng = toLatLng(latlngs[i3]);
            points.push(crs.project(toLatLng([latlng.lat - centroidLatLng.lat, latlng.lng - centroidLatLng.lng])));
          }
          area = x3 = y3 = 0;
          for (i3 = 0, j3 = len - 1; i3 < len; j3 = i3++) {
            p1 = points[i3];
            p22 = points[j3];
            f3 = p1.y * p22.x - p22.y * p1.x;
            x3 += (p1.x + p22.x) * f3;
            y3 += (p1.y + p22.y) * f3;
            area += f3 * 3;
          }
          if (area === 0) {
            center = points[0];
          } else {
            center = [x3 / area, y3 / area];
          }
          var latlngCenter = crs.unproject(toPoint(center));
          return toLatLng([latlngCenter.lat + centroidLatLng.lat, latlngCenter.lng + centroidLatLng.lng]);
        }
        __name(polygonCenter, "polygonCenter");
        function centroid(coords) {
          var latSum = 0;
          var lngSum = 0;
          var len = 0;
          for (var i3 = 0; i3 < coords.length; i3++) {
            var latlng = toLatLng(coords[i3]);
            latSum += latlng.lat;
            lngSum += latlng.lng;
            len++;
          }
          return toLatLng([latSum / len, lngSum / len]);
        }
        __name(centroid, "centroid");
        var PolyUtil = {
          __proto__: null,
          clipPolygon,
          polygonCenter,
          centroid
        };
        function simplify(points, tolerance) {
          if (!tolerance || !points.length) {
            return points.slice();
          }
          var sqTolerance = tolerance * tolerance;
          points = _reducePoints(points, sqTolerance);
          points = _simplifyDP(points, sqTolerance);
          return points;
        }
        __name(simplify, "simplify");
        function pointToSegmentDistance(p3, p1, p22) {
          return Math.sqrt(_sqClosestPointOnSegment(p3, p1, p22, true));
        }
        __name(pointToSegmentDistance, "pointToSegmentDistance");
        function closestPointOnSegment(p3, p1, p22) {
          return _sqClosestPointOnSegment(p3, p1, p22);
        }
        __name(closestPointOnSegment, "closestPointOnSegment");
        function _simplifyDP(points, sqTolerance) {
          var len = points.length, ArrayConstructor = typeof Uint8Array !== "undefined" ? Uint8Array : Array, markers = new ArrayConstructor(len);
          markers[0] = markers[len - 1] = 1;
          _simplifyDPStep(points, markers, sqTolerance, 0, len - 1);
          var i3, newPoints = [];
          for (i3 = 0; i3 < len; i3++) {
            if (markers[i3]) {
              newPoints.push(points[i3]);
            }
          }
          return newPoints;
        }
        __name(_simplifyDP, "_simplifyDP");
        function _simplifyDPStep(points, markers, sqTolerance, first, last) {
          var maxSqDist = 0, index3, i3, sqDist;
          for (i3 = first + 1; i3 <= last - 1; i3++) {
            sqDist = _sqClosestPointOnSegment(points[i3], points[first], points[last], true);
            if (sqDist > maxSqDist) {
              index3 = i3;
              maxSqDist = sqDist;
            }
          }
          if (maxSqDist > sqTolerance) {
            markers[index3] = 1;
            _simplifyDPStep(points, markers, sqTolerance, first, index3);
            _simplifyDPStep(points, markers, sqTolerance, index3, last);
          }
        }
        __name(_simplifyDPStep, "_simplifyDPStep");
        function _reducePoints(points, sqTolerance) {
          var reducedPoints = [points[0]];
          for (var i3 = 1, prev = 0, len = points.length; i3 < len; i3++) {
            if (_sqDist(points[i3], points[prev]) > sqTolerance) {
              reducedPoints.push(points[i3]);
              prev = i3;
            }
          }
          if (prev < len - 1) {
            reducedPoints.push(points[len - 1]);
          }
          return reducedPoints;
        }
        __name(_reducePoints, "_reducePoints");
        var _lastCode;
        function clipSegment(a3, b3, bounds, useLastCode, round) {
          var codeA = useLastCode ? _lastCode : _getBitCode(a3, bounds), codeB = _getBitCode(b3, bounds), codeOut, p3, newCode;
          _lastCode = codeB;
          while (true) {
            if (!(codeA | codeB)) {
              return [a3, b3];
            }
            if (codeA & codeB) {
              return false;
            }
            codeOut = codeA || codeB;
            p3 = _getEdgeIntersection(a3, b3, codeOut, bounds, round);
            newCode = _getBitCode(p3, bounds);
            if (codeOut === codeA) {
              a3 = p3;
              codeA = newCode;
            } else {
              b3 = p3;
              codeB = newCode;
            }
          }
        }
        __name(clipSegment, "clipSegment");
        function _getEdgeIntersection(a3, b3, code, bounds, round) {
          var dx = b3.x - a3.x, dy = b3.y - a3.y, min = bounds.min, max = bounds.max, x3, y3;
          if (code & 8) {
            x3 = a3.x + dx * (max.y - a3.y) / dy;
            y3 = max.y;
          } else if (code & 4) {
            x3 = a3.x + dx * (min.y - a3.y) / dy;
            y3 = min.y;
          } else if (code & 2) {
            x3 = max.x;
            y3 = a3.y + dy * (max.x - a3.x) / dx;
          } else if (code & 1) {
            x3 = min.x;
            y3 = a3.y + dy * (min.x - a3.x) / dx;
          }
          return new Point(x3, y3, round);
        }
        __name(_getEdgeIntersection, "_getEdgeIntersection");
        function _getBitCode(p3, bounds) {
          var code = 0;
          if (p3.x < bounds.min.x) {
            code |= 1;
          } else if (p3.x > bounds.max.x) {
            code |= 2;
          }
          if (p3.y < bounds.min.y) {
            code |= 4;
          } else if (p3.y > bounds.max.y) {
            code |= 8;
          }
          return code;
        }
        __name(_getBitCode, "_getBitCode");
        function _sqDist(p1, p22) {
          var dx = p22.x - p1.x, dy = p22.y - p1.y;
          return dx * dx + dy * dy;
        }
        __name(_sqDist, "_sqDist");
        function _sqClosestPointOnSegment(p3, p1, p22, sqDist) {
          var x3 = p1.x, y3 = p1.y, dx = p22.x - x3, dy = p22.y - y3, dot = dx * dx + dy * dy, t3;
          if (dot > 0) {
            t3 = ((p3.x - x3) * dx + (p3.y - y3) * dy) / dot;
            if (t3 > 1) {
              x3 = p22.x;
              y3 = p22.y;
            } else if (t3 > 0) {
              x3 += dx * t3;
              y3 += dy * t3;
            }
          }
          dx = p3.x - x3;
          dy = p3.y - y3;
          return sqDist ? dx * dx + dy * dy : new Point(x3, y3);
        }
        __name(_sqClosestPointOnSegment, "_sqClosestPointOnSegment");
        function isFlat(latlngs) {
          return !isArray2(latlngs[0]) || typeof latlngs[0][0] !== "object" && typeof latlngs[0][0] !== "undefined";
        }
        __name(isFlat, "isFlat");
        function _flat(latlngs) {
          console.warn("Deprecated use of _flat, please use L.LineUtil.isFlat instead.");
          return isFlat(latlngs);
        }
        __name(_flat, "_flat");
        function polylineCenter(latlngs, crs) {
          var i3, halfDist, segDist, dist, p1, p22, ratio, center;
          if (!latlngs || latlngs.length === 0) {
            throw new Error("latlngs not passed");
          }
          if (!isFlat(latlngs)) {
            console.warn("latlngs are not flat! Only the first ring will be used");
            latlngs = latlngs[0];
          }
          var centroidLatLng = toLatLng([0, 0]);
          var bounds = toLatLngBounds(latlngs);
          var areaBounds = bounds.getNorthWest().distanceTo(bounds.getSouthWest()) * bounds.getNorthEast().distanceTo(bounds.getNorthWest());
          if (areaBounds < 1700) {
            centroidLatLng = centroid(latlngs);
          }
          var len = latlngs.length;
          var points = [];
          for (i3 = 0; i3 < len; i3++) {
            var latlng = toLatLng(latlngs[i3]);
            points.push(crs.project(toLatLng([latlng.lat - centroidLatLng.lat, latlng.lng - centroidLatLng.lng])));
          }
          for (i3 = 0, halfDist = 0; i3 < len - 1; i3++) {
            halfDist += points[i3].distanceTo(points[i3 + 1]) / 2;
          }
          if (halfDist === 0) {
            center = points[0];
          } else {
            for (i3 = 0, dist = 0; i3 < len - 1; i3++) {
              p1 = points[i3];
              p22 = points[i3 + 1];
              segDist = p1.distanceTo(p22);
              dist += segDist;
              if (dist > halfDist) {
                ratio = (dist - halfDist) / segDist;
                center = [
                  p22.x - ratio * (p22.x - p1.x),
                  p22.y - ratio * (p22.y - p1.y)
                ];
                break;
              }
            }
          }
          var latlngCenter = crs.unproject(toPoint(center));
          return toLatLng([latlngCenter.lat + centroidLatLng.lat, latlngCenter.lng + centroidLatLng.lng]);
        }
        __name(polylineCenter, "polylineCenter");
        var LineUtil = {
          __proto__: null,
          simplify,
          pointToSegmentDistance,
          closestPointOnSegment,
          clipSegment,
          _getEdgeIntersection,
          _getBitCode,
          _sqClosestPointOnSegment,
          isFlat,
          _flat,
          polylineCenter
        };
        var LonLat = {
          project: function(latlng) {
            return new Point(latlng.lng, latlng.lat);
          },
          unproject: function(point) {
            return new LatLng(point.y, point.x);
          },
          bounds: new Bounds([-180, -90], [180, 90])
        };
        var Mercator = {
          R: 6378137,
          R_MINOR: 6356752314245179e-9,
          bounds: new Bounds([-2003750834279e-5, -1549657073972e-5], [2003750834279e-5, 1876465623138e-5]),
          project: function(latlng) {
            var d3 = Math.PI / 180, r3 = this.R, y3 = latlng.lat * d3, tmp = this.R_MINOR / r3, e3 = Math.sqrt(1 - tmp * tmp), con = e3 * Math.sin(y3);
            var ts = Math.tan(Math.PI / 4 - y3 / 2) / Math.pow((1 - con) / (1 + con), e3 / 2);
            y3 = -r3 * Math.log(Math.max(ts, 1e-10));
            return new Point(latlng.lng * d3 * r3, y3);
          },
          unproject: function(point) {
            var d3 = 180 / Math.PI, r3 = this.R, tmp = this.R_MINOR / r3, e3 = Math.sqrt(1 - tmp * tmp), ts = Math.exp(-point.y / r3), phi = Math.PI / 2 - 2 * Math.atan(ts);
            for (var i3 = 0, dphi = 0.1, con; i3 < 15 && Math.abs(dphi) > 1e-7; i3++) {
              con = e3 * Math.sin(phi);
              con = Math.pow((1 - con) / (1 + con), e3 / 2);
              dphi = Math.PI / 2 - 2 * Math.atan(ts * con) - phi;
              phi += dphi;
            }
            return new LatLng(phi * d3, point.x * d3 / r3);
          }
        };
        var index2 = {
          __proto__: null,
          LonLat,
          Mercator,
          SphericalMercator
        };
        var EPSG3395 = extend3({}, Earth, {
          code: "EPSG:3395",
          projection: Mercator,
          transformation: function() {
            var scale2 = 0.5 / (Math.PI * Mercator.R);
            return toTransformation(scale2, 0.5, -scale2, 0.5);
          }()
        });
        var EPSG4326 = extend3({}, Earth, {
          code: "EPSG:4326",
          projection: LonLat,
          transformation: toTransformation(1 / 180, 1, -1 / 180, 0.5)
        });
        var Simple = extend3({}, CRS, {
          projection: LonLat,
          transformation: toTransformation(1, 0, -1, 0),
          scale: function(zoom2) {
            return Math.pow(2, zoom2);
          },
          zoom: function(scale2) {
            return Math.log(scale2) / Math.LN2;
          },
          distance: function(latlng1, latlng2) {
            var dx = latlng2.lng - latlng1.lng, dy = latlng2.lat - latlng1.lat;
            return Math.sqrt(dx * dx + dy * dy);
          },
          infinite: true
        });
        CRS.Earth = Earth;
        CRS.EPSG3395 = EPSG3395;
        CRS.EPSG3857 = EPSG3857;
        CRS.EPSG900913 = EPSG900913;
        CRS.EPSG4326 = EPSG4326;
        CRS.Simple = Simple;
        var Layer = Evented.extend({
          // Classes extending `L.Layer` will inherit the following options:
          options: {
            // @option pane: String = 'overlayPane'
            // By default the layer will be added to the map's [overlay pane](#map-overlaypane). Overriding this option will cause the layer to be placed on another pane by default.
            pane: "overlayPane",
            // @option attribution: String = null
            // String to be shown in the attribution control, e.g. "© OpenStreetMap contributors". It describes the layer data and is often a legal obligation towards copyright holders and tile providers.
            attribution: null,
            bubblingMouseEvents: true
          },
          /* @section
           * Classes extending `L.Layer` will inherit the following methods:
           *
           * @method addTo(map: Map|LayerGroup): this
           * Adds the layer to the given map or layer group.
           */
          addTo: function(map2) {
            map2.addLayer(this);
            return this;
          },
          // @method remove: this
          // Removes the layer from the map it is currently active on.
          remove: function() {
            return this.removeFrom(this._map || this._mapToAdd);
          },
          // @method removeFrom(map: Map): this
          // Removes the layer from the given map
          //
          // @alternative
          // @method removeFrom(group: LayerGroup): this
          // Removes the layer from the given `LayerGroup`
          removeFrom: function(obj) {
            if (obj) {
              obj.removeLayer(this);
            }
            return this;
          },
          // @method getPane(name? : String): HTMLElement
          // Returns the `HTMLElement` representing the named pane on the map. If `name` is omitted, returns the pane for this layer.
          getPane: function(name) {
            return this._map.getPane(name ? this.options[name] || name : this.options.pane);
          },
          addInteractiveTarget: function(targetEl) {
            this._map._targets[stamp(targetEl)] = this;
            return this;
          },
          removeInteractiveTarget: function(targetEl) {
            delete this._map._targets[stamp(targetEl)];
            return this;
          },
          // @method getAttribution: String
          // Used by the `attribution control`, returns the [attribution option](#gridlayer-attribution).
          getAttribution: function() {
            return this.options.attribution;
          },
          _layerAdd: function(e3) {
            var map2 = e3.target;
            if (!map2.hasLayer(this)) {
              return;
            }
            this._map = map2;
            this._zoomAnimated = map2._zoomAnimated;
            if (this.getEvents) {
              var events = this.getEvents();
              map2.on(events, this);
              this.once("remove", function() {
                map2.off(events, this);
              }, this);
            }
            this.onAdd(map2);
            this.fire("add");
            map2.fire("layeradd", { layer: this });
          }
        });
        Map3.include({
          // @method addLayer(layer: Layer): this
          // Adds the given layer to the map
          addLayer: function(layer) {
            if (!layer._layerAdd) {
              throw new Error("The provided object is not a Layer.");
            }
            var id = stamp(layer);
            if (this._layers[id]) {
              return this;
            }
            this._layers[id] = layer;
            layer._mapToAdd = this;
            if (layer.beforeAdd) {
              layer.beforeAdd(this);
            }
            this.whenReady(layer._layerAdd, layer);
            return this;
          },
          // @method removeLayer(layer: Layer): this
          // Removes the given layer from the map.
          removeLayer: function(layer) {
            var id = stamp(layer);
            if (!this._layers[id]) {
              return this;
            }
            if (this._loaded) {
              layer.onRemove(this);
            }
            delete this._layers[id];
            if (this._loaded) {
              this.fire("layerremove", { layer });
              layer.fire("remove");
            }
            layer._map = layer._mapToAdd = null;
            return this;
          },
          // @method hasLayer(layer: Layer): Boolean
          // Returns `true` if the given layer is currently added to the map
          hasLayer: function(layer) {
            return stamp(layer) in this._layers;
          },
          /* @method eachLayer(fn: Function, context?: Object): this
           * Iterates over the layers of the map, optionally specifying context of the iterator function.
           * ```
           * map.eachLayer(function(layer){
           *     layer.bindPopup('Hello');
           * });
           * ```
           */
          eachLayer: function(method, context) {
            for (var i3 in this._layers) {
              method.call(context, this._layers[i3]);
            }
            return this;
          },
          _addLayers: function(layers2) {
            layers2 = layers2 ? isArray2(layers2) ? layers2 : [layers2] : [];
            for (var i3 = 0, len = layers2.length; i3 < len; i3++) {
              this.addLayer(layers2[i3]);
            }
          },
          _addZoomLimit: function(layer) {
            if (!isNaN(layer.options.maxZoom) || !isNaN(layer.options.minZoom)) {
              this._zoomBoundLayers[stamp(layer)] = layer;
              this._updateZoomLevels();
            }
          },
          _removeZoomLimit: function(layer) {
            var id = stamp(layer);
            if (this._zoomBoundLayers[id]) {
              delete this._zoomBoundLayers[id];
              this._updateZoomLevels();
            }
          },
          _updateZoomLevels: function() {
            var minZoom = Infinity, maxZoom = -Infinity, oldZoomSpan = this._getZoomSpan();
            for (var i3 in this._zoomBoundLayers) {
              var options = this._zoomBoundLayers[i3].options;
              minZoom = options.minZoom === void 0 ? minZoom : Math.min(minZoom, options.minZoom);
              maxZoom = options.maxZoom === void 0 ? maxZoom : Math.max(maxZoom, options.maxZoom);
            }
            this._layersMaxZoom = maxZoom === -Infinity ? void 0 : maxZoom;
            this._layersMinZoom = minZoom === Infinity ? void 0 : minZoom;
            if (oldZoomSpan !== this._getZoomSpan()) {
              this.fire("zoomlevelschange");
            }
            if (this.options.maxZoom === void 0 && this._layersMaxZoom && this.getZoom() > this._layersMaxZoom) {
              this.setZoom(this._layersMaxZoom);
            }
            if (this.options.minZoom === void 0 && this._layersMinZoom && this.getZoom() < this._layersMinZoom) {
              this.setZoom(this._layersMinZoom);
            }
          }
        });
        var LayerGroup = Layer.extend({
          initialize: function(layers2, options) {
            setOptions(this, options);
            this._layers = {};
            var i3, len;
            if (layers2) {
              for (i3 = 0, len = layers2.length; i3 < len; i3++) {
                this.addLayer(layers2[i3]);
              }
            }
          },
          // @method addLayer(layer: Layer): this
          // Adds the given layer to the group.
          addLayer: function(layer) {
            var id = this.getLayerId(layer);
            this._layers[id] = layer;
            if (this._map) {
              this._map.addLayer(layer);
            }
            return this;
          },
          // @method removeLayer(layer: Layer): this
          // Removes the given layer from the group.
          // @alternative
          // @method removeLayer(id: Number): this
          // Removes the layer with the given internal ID from the group.
          removeLayer: function(layer) {
            var id = layer in this._layers ? layer : this.getLayerId(layer);
            if (this._map && this._layers[id]) {
              this._map.removeLayer(this._layers[id]);
            }
            delete this._layers[id];
            return this;
          },
          // @method hasLayer(layer: Layer): Boolean
          // Returns `true` if the given layer is currently added to the group.
          // @alternative
          // @method hasLayer(id: Number): Boolean
          // Returns `true` if the given internal ID is currently added to the group.
          hasLayer: function(layer) {
            var layerId = typeof layer === "number" ? layer : this.getLayerId(layer);
            return layerId in this._layers;
          },
          // @method clearLayers(): this
          // Removes all the layers from the group.
          clearLayers: function() {
            return this.eachLayer(this.removeLayer, this);
          },
          // @method invoke(methodName: String, …): this
          // Calls `methodName` on every layer contained in this group, passing any
          // additional parameters. Has no effect if the layers contained do not
          // implement `methodName`.
          invoke: function(methodName) {
            var args = Array.prototype.slice.call(arguments, 1), i3, layer;
            for (i3 in this._layers) {
              layer = this._layers[i3];
              if (layer[methodName]) {
                layer[methodName].apply(layer, args);
              }
            }
            return this;
          },
          onAdd: function(map2) {
            this.eachLayer(map2.addLayer, map2);
          },
          onRemove: function(map2) {
            this.eachLayer(map2.removeLayer, map2);
          },
          // @method eachLayer(fn: Function, context?: Object): this
          // Iterates over the layers of the group, optionally specifying context of the iterator function.
          // ```js
          // group.eachLayer(function (layer) {
          // 	layer.bindPopup('Hello');
          // });
          // ```
          eachLayer: function(method, context) {
            for (var i3 in this._layers) {
              method.call(context, this._layers[i3]);
            }
            return this;
          },
          // @method getLayer(id: Number): Layer
          // Returns the layer with the given internal ID.
          getLayer: function(id) {
            return this._layers[id];
          },
          // @method getLayers(): Layer[]
          // Returns an array of all the layers added to the group.
          getLayers: function() {
            var layers2 = [];
            this.eachLayer(layers2.push, layers2);
            return layers2;
          },
          // @method setZIndex(zIndex: Number): this
          // Calls `setZIndex` on every layer contained in this group, passing the z-index.
          setZIndex: function(zIndex) {
            return this.invoke("setZIndex", zIndex);
          },
          // @method getLayerId(layer: Layer): Number
          // Returns the internal ID for a layer
          getLayerId: function(layer) {
            return stamp(layer);
          }
        });
        var layerGroup = /* @__PURE__ */ __name(function(layers2, options) {
          return new LayerGroup(layers2, options);
        }, "layerGroup");
        var FeatureGroup = LayerGroup.extend({
          addLayer: function(layer) {
            if (this.hasLayer(layer)) {
              return this;
            }
            layer.addEventParent(this);
            LayerGroup.prototype.addLayer.call(this, layer);
            return this.fire("layeradd", { layer });
          },
          removeLayer: function(layer) {
            if (!this.hasLayer(layer)) {
              return this;
            }
            if (layer in this._layers) {
              layer = this._layers[layer];
            }
            layer.removeEventParent(this);
            LayerGroup.prototype.removeLayer.call(this, layer);
            return this.fire("layerremove", { layer });
          },
          // @method setStyle(style: Path options): this
          // Sets the given path options to each layer of the group that has a `setStyle` method.
          setStyle: function(style2) {
            return this.invoke("setStyle", style2);
          },
          // @method bringToFront(): this
          // Brings the layer group to the top of all other layers
          bringToFront: function() {
            return this.invoke("bringToFront");
          },
          // @method bringToBack(): this
          // Brings the layer group to the back of all other layers
          bringToBack: function() {
            return this.invoke("bringToBack");
          },
          // @method getBounds(): LatLngBounds
          // Returns the LatLngBounds of the Feature Group (created from bounds and coordinates of its children).
          getBounds: function() {
            var bounds = new LatLngBounds();
            for (var id in this._layers) {
              var layer = this._layers[id];
              bounds.extend(layer.getBounds ? layer.getBounds() : layer.getLatLng());
            }
            return bounds;
          }
        });
        var featureGroup = /* @__PURE__ */ __name(function(layers2, options) {
          return new FeatureGroup(layers2, options);
        }, "featureGroup");
        var Icon = Class.extend({
          /* @section
           * @aka Icon options
           *
           * @option iconUrl: String = null
           * **(required)** The URL to the icon image (absolute or relative to your script path).
           *
           * @option iconRetinaUrl: String = null
           * The URL to a retina sized version of the icon image (absolute or relative to your
           * script path). Used for Retina screen devices.
           *
           * @option iconSize: Point = null
           * Size of the icon image in pixels.
           *
           * @option iconAnchor: Point = null
           * The coordinates of the "tip" of the icon (relative to its top left corner). The icon
           * will be aligned so that this point is at the marker's geographical location. Centered
           * by default if size is specified, also can be set in CSS with negative margins.
           *
           * @option popupAnchor: Point = [0, 0]
           * The coordinates of the point from which popups will "open", relative to the icon anchor.
           *
           * @option tooltipAnchor: Point = [0, 0]
           * The coordinates of the point from which tooltips will "open", relative to the icon anchor.
           *
           * @option shadowUrl: String = null
           * The URL to the icon shadow image. If not specified, no shadow image will be created.
           *
           * @option shadowRetinaUrl: String = null
           *
           * @option shadowSize: Point = null
           * Size of the shadow image in pixels.
           *
           * @option shadowAnchor: Point = null
           * The coordinates of the "tip" of the shadow (relative to its top left corner) (the same
           * as iconAnchor if not specified).
           *
           * @option className: String = ''
           * A custom class name to assign to both icon and shadow images. Empty by default.
           */
          options: {
            popupAnchor: [0, 0],
            tooltipAnchor: [0, 0],
            // @option crossOrigin: Boolean|String = false
            // Whether the crossOrigin attribute will be added to the tiles.
            // If a String is provided, all tiles will have their crossOrigin attribute set to the String provided. This is needed if you want to access tile pixel data.
            // Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.
            crossOrigin: false
          },
          initialize: function(options) {
            setOptions(this, options);
          },
          // @method createIcon(oldIcon?: HTMLElement): HTMLElement
          // Called internally when the icon has to be shown, returns a `<img>` HTML element
          // styled according to the options.
          createIcon: function(oldIcon) {
            return this._createIcon("icon", oldIcon);
          },
          // @method createShadow(oldIcon?: HTMLElement): HTMLElement
          // As `createIcon`, but for the shadow beneath it.
          createShadow: function(oldIcon) {
            return this._createIcon("shadow", oldIcon);
          },
          _createIcon: function(name, oldIcon) {
            var src = this._getIconUrl(name);
            if (!src) {
              if (name === "icon") {
                throw new Error("iconUrl not set in Icon options (see the docs).");
              }
              return null;
            }
            var img = this._createImg(src, oldIcon && oldIcon.tagName === "IMG" ? oldIcon : null);
            this._setIconStyles(img, name);
            if (this.options.crossOrigin || this.options.crossOrigin === "") {
              img.crossOrigin = this.options.crossOrigin === true ? "" : this.options.crossOrigin;
            }
            return img;
          },
          _setIconStyles: function(img, name) {
            var options = this.options;
            var sizeOption = options[name + "Size"];
            if (typeof sizeOption === "number") {
              sizeOption = [sizeOption, sizeOption];
            }
            var size = toPoint(sizeOption), anchor = toPoint(name === "shadow" && options.shadowAnchor || options.iconAnchor || size && size.divideBy(2, true));
            img.className = "leaflet-marker-" + name + " " + (options.className || "");
            if (anchor) {
              img.style.marginLeft = -anchor.x + "px";
              img.style.marginTop = -anchor.y + "px";
            }
            if (size) {
              img.style.width = size.x + "px";
              img.style.height = size.y + "px";
            }
          },
          _createImg: function(src, el) {
            el = el || document.createElement("img");
            el.src = src;
            return el;
          },
          _getIconUrl: function(name) {
            return Browser.retina && this.options[name + "RetinaUrl"] || this.options[name + "Url"];
          }
        });
        function icon(options) {
          return new Icon(options);
        }
        __name(icon, "icon");
        var IconDefault = Icon.extend({
          options: {
            iconUrl: "marker-icon.png",
            iconRetinaUrl: "marker-icon-2x.png",
            shadowUrl: "marker-shadow.png",
            iconSize: [25, 41],
            iconAnchor: [12, 41],
            popupAnchor: [1, -34],
            tooltipAnchor: [16, -28],
            shadowSize: [41, 41]
          },
          _getIconUrl: function(name) {
            if (typeof IconDefault.imagePath !== "string") {
              IconDefault.imagePath = this._detectIconPath();
            }
            return (this.options.imagePath || IconDefault.imagePath) + Icon.prototype._getIconUrl.call(this, name);
          },
          _stripUrl: function(path) {
            var strip = /* @__PURE__ */ __name(function(str, re, idx) {
              var match2 = re.exec(str);
              return match2 && match2[idx];
            }, "strip");
            path = strip(path, /^url\((['"])?(.+)\1\)$/, 2);
            return path && strip(path, /^(.*)marker-icon\.png$/, 1);
          },
          _detectIconPath: function() {
            var el = create$1("div", "leaflet-default-icon-path", document.body);
            var path = getStyle(el, "background-image") || getStyle(el, "backgroundImage");
            document.body.removeChild(el);
            path = this._stripUrl(path);
            if (path) {
              return path;
            }
            var link = document.querySelector('link[href$="leaflet.css"]');
            if (!link) {
              return "";
            }
            return link.href.substring(0, link.href.length - "leaflet.css".length - 1);
          }
        });
        var MarkerDrag = Handler.extend({
          initialize: function(marker2) {
            this._marker = marker2;
          },
          addHooks: function() {
            var icon2 = this._marker._icon;
            if (!this._draggable) {
              this._draggable = new Draggable(icon2, icon2, true);
            }
            this._draggable.on({
              dragstart: this._onDragStart,
              predrag: this._onPreDrag,
              drag: this._onDrag,
              dragend: this._onDragEnd
            }, this).enable();
            addClass(icon2, "leaflet-marker-draggable");
          },
          removeHooks: function() {
            this._draggable.off({
              dragstart: this._onDragStart,
              predrag: this._onPreDrag,
              drag: this._onDrag,
              dragend: this._onDragEnd
            }, this).disable();
            if (this._marker._icon) {
              removeClass(this._marker._icon, "leaflet-marker-draggable");
            }
          },
          moved: function() {
            return this._draggable && this._draggable._moved;
          },
          _adjustPan: function(e3) {
            var marker2 = this._marker, map2 = marker2._map, speed = this._marker.options.autoPanSpeed, padding = this._marker.options.autoPanPadding, iconPos = getPosition(marker2._icon), bounds = map2.getPixelBounds(), origin = map2.getPixelOrigin();
            var panBounds = toBounds(
              bounds.min._subtract(origin).add(padding),
              bounds.max._subtract(origin).subtract(padding)
            );
            if (!panBounds.contains(iconPos)) {
              var movement = toPoint(
                (Math.max(panBounds.max.x, iconPos.x) - panBounds.max.x) / (bounds.max.x - panBounds.max.x) - (Math.min(panBounds.min.x, iconPos.x) - panBounds.min.x) / (bounds.min.x - panBounds.min.x),
                (Math.max(panBounds.max.y, iconPos.y) - panBounds.max.y) / (bounds.max.y - panBounds.max.y) - (Math.min(panBounds.min.y, iconPos.y) - panBounds.min.y) / (bounds.min.y - panBounds.min.y)
              ).multiplyBy(speed);
              map2.panBy(movement, { animate: false });
              this._draggable._newPos._add(movement);
              this._draggable._startPos._add(movement);
              setPosition(marker2._icon, this._draggable._newPos);
              this._onDrag(e3);
              this._panRequest = requestAnimFrame(this._adjustPan.bind(this, e3));
            }
          },
          _onDragStart: function() {
            this._oldLatLng = this._marker.getLatLng();
            this._marker.closePopup && this._marker.closePopup();
            this._marker.fire("movestart").fire("dragstart");
          },
          _onPreDrag: function(e3) {
            if (this._marker.options.autoPan) {
              cancelAnimFrame(this._panRequest);
              this._panRequest = requestAnimFrame(this._adjustPan.bind(this, e3));
            }
          },
          _onDrag: function(e3) {
            var marker2 = this._marker, shadow = marker2._shadow, iconPos = getPosition(marker2._icon), latlng = marker2._map.layerPointToLatLng(iconPos);
            if (shadow) {
              setPosition(shadow, iconPos);
            }
            marker2._latlng = latlng;
            e3.latlng = latlng;
            e3.oldLatLng = this._oldLatLng;
            marker2.fire("move", e3).fire("drag", e3);
          },
          _onDragEnd: function(e3) {
            cancelAnimFrame(this._panRequest);
            delete this._oldLatLng;
            this._marker.fire("moveend").fire("dragend", e3);
          }
        });
        var Marker = Layer.extend({
          // @section
          // @aka Marker options
          options: {
            // @option icon: Icon = *
            // Icon instance to use for rendering the marker.
            // See [Icon documentation](#L.Icon) for details on how to customize the marker icon.
            // If not specified, a common instance of `L.Icon.Default` is used.
            icon: new IconDefault(),
            // Option inherited from "Interactive layer" abstract class
            interactive: true,
            // @option keyboard: Boolean = true
            // Whether the marker can be tabbed to with a keyboard and clicked by pressing enter.
            keyboard: true,
            // @option title: String = ''
            // Text for the browser tooltip that appear on marker hover (no tooltip by default).
            // [Useful for accessibility](https://leafletjs.com/examples/accessibility/#markers-must-be-labelled).
            title: "",
            // @option alt: String = 'Marker'
            // Text for the `alt` attribute of the icon image.
            // [Useful for accessibility](https://leafletjs.com/examples/accessibility/#markers-must-be-labelled).
            alt: "Marker",
            // @option zIndexOffset: Number = 0
            // By default, marker images zIndex is set automatically based on its latitude. Use this option if you want to put the marker on top of all others (or below), specifying a high value like `1000` (or high negative value, respectively).
            zIndexOffset: 0,
            // @option opacity: Number = 1.0
            // The opacity of the marker.
            opacity: 1,
            // @option riseOnHover: Boolean = false
            // If `true`, the marker will get on top of others when you hover the mouse over it.
            riseOnHover: false,
            // @option riseOffset: Number = 250
            // The z-index offset used for the `riseOnHover` feature.
            riseOffset: 250,
            // @option pane: String = 'markerPane'
            // `Map pane` where the markers icon will be added.
            pane: "markerPane",
            // @option shadowPane: String = 'shadowPane'
            // `Map pane` where the markers shadow will be added.
            shadowPane: "shadowPane",
            // @option bubblingMouseEvents: Boolean = false
            // When `true`, a mouse event on this marker will trigger the same event on the map
            // (unless [`L.DomEvent.stopPropagation`](#domevent-stoppropagation) is used).
            bubblingMouseEvents: false,
            // @option autoPanOnFocus: Boolean = true
            // When `true`, the map will pan whenever the marker is focused (via
            // e.g. pressing `tab` on the keyboard) to ensure the marker is
            // visible within the map's bounds
            autoPanOnFocus: true,
            // @section Draggable marker options
            // @option draggable: Boolean = false
            // Whether the marker is draggable with mouse/touch or not.
            draggable: false,
            // @option autoPan: Boolean = false
            // Whether to pan the map when dragging this marker near its edge or not.
            autoPan: false,
            // @option autoPanPadding: Point = Point(50, 50)
            // Distance (in pixels to the left/right and to the top/bottom) of the
            // map edge to start panning the map.
            autoPanPadding: [50, 50],
            // @option autoPanSpeed: Number = 10
            // Number of pixels the map should pan by.
            autoPanSpeed: 10
          },
          /* @section
           *
           * In addition to [shared layer methods](#Layer) like `addTo()` and `remove()` and [popup methods](#Popup) like bindPopup() you can also use the following methods:
           */
          initialize: function(latlng, options) {
            setOptions(this, options);
            this._latlng = toLatLng(latlng);
          },
          onAdd: function(map2) {
            this._zoomAnimated = this._zoomAnimated && map2.options.markerZoomAnimation;
            if (this._zoomAnimated) {
              map2.on("zoomanim", this._animateZoom, this);
            }
            this._initIcon();
            this.update();
          },
          onRemove: function(map2) {
            if (this.dragging && this.dragging.enabled()) {
              this.options.draggable = true;
              this.dragging.removeHooks();
            }
            delete this.dragging;
            if (this._zoomAnimated) {
              map2.off("zoomanim", this._animateZoom, this);
            }
            this._removeIcon();
            this._removeShadow();
          },
          getEvents: function() {
            return {
              zoom: this.update,
              viewreset: this.update
            };
          },
          // @method getLatLng: LatLng
          // Returns the current geographical position of the marker.
          getLatLng: function() {
            return this._latlng;
          },
          // @method setLatLng(latlng: LatLng): this
          // Changes the marker position to the given point.
          setLatLng: function(latlng) {
            var oldLatLng = this._latlng;
            this._latlng = toLatLng(latlng);
            this.update();
            return this.fire("move", { oldLatLng, latlng: this._latlng });
          },
          // @method setZIndexOffset(offset: Number): this
          // Changes the [zIndex offset](#marker-zindexoffset) of the marker.
          setZIndexOffset: function(offset) {
            this.options.zIndexOffset = offset;
            return this.update();
          },
          // @method getIcon: Icon
          // Returns the current icon used by the marker
          getIcon: function() {
            return this.options.icon;
          },
          // @method setIcon(icon: Icon): this
          // Changes the marker icon.
          setIcon: function(icon2) {
            this.options.icon = icon2;
            if (this._map) {
              this._initIcon();
              this.update();
            }
            if (this._popup) {
              this.bindPopup(this._popup, this._popup.options);
            }
            return this;
          },
          getElement: function() {
            return this._icon;
          },
          update: function() {
            if (this._icon && this._map) {
              var pos = this._map.latLngToLayerPoint(this._latlng).round();
              this._setPos(pos);
            }
            return this;
          },
          _initIcon: function() {
            var options = this.options, classToAdd = "leaflet-zoom-" + (this._zoomAnimated ? "animated" : "hide");
            var icon2 = options.icon.createIcon(this._icon), addIcon = false;
            if (icon2 !== this._icon) {
              if (this._icon) {
                this._removeIcon();
              }
              addIcon = true;
              if (options.title) {
                icon2.title = options.title;
              }
              if (icon2.tagName === "IMG") {
                icon2.alt = options.alt || "";
              }
            }
            addClass(icon2, classToAdd);
            if (options.keyboard) {
              icon2.tabIndex = "0";
              icon2.setAttribute("role", "button");
            }
            this._icon = icon2;
            if (options.riseOnHover) {
              this.on({
                mouseover: this._bringToFront,
                mouseout: this._resetZIndex
              });
            }
            if (this.options.autoPanOnFocus) {
              on2(icon2, "focus", this._panOnFocus, this);
            }
            var newShadow = options.icon.createShadow(this._shadow), addShadow = false;
            if (newShadow !== this._shadow) {
              this._removeShadow();
              addShadow = true;
            }
            if (newShadow) {
              addClass(newShadow, classToAdd);
              newShadow.alt = "";
            }
            this._shadow = newShadow;
            if (options.opacity < 1) {
              this._updateOpacity();
            }
            if (addIcon) {
              this.getPane().appendChild(this._icon);
            }
            this._initInteraction();
            if (newShadow && addShadow) {
              this.getPane(options.shadowPane).appendChild(this._shadow);
            }
          },
          _removeIcon: function() {
            if (this.options.riseOnHover) {
              this.off({
                mouseover: this._bringToFront,
                mouseout: this._resetZIndex
              });
            }
            if (this.options.autoPanOnFocus) {
              off2(this._icon, "focus", this._panOnFocus, this);
            }
            remove(this._icon);
            this.removeInteractiveTarget(this._icon);
            this._icon = null;
          },
          _removeShadow: function() {
            if (this._shadow) {
              remove(this._shadow);
            }
            this._shadow = null;
          },
          _setPos: function(pos) {
            if (this._icon) {
              setPosition(this._icon, pos);
            }
            if (this._shadow) {
              setPosition(this._shadow, pos);
            }
            this._zIndex = pos.y + this.options.zIndexOffset;
            this._resetZIndex();
          },
          _updateZIndex: function(offset) {
            if (this._icon) {
              this._icon.style.zIndex = this._zIndex + offset;
            }
          },
          _animateZoom: function(opt) {
            var pos = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center).round();
            this._setPos(pos);
          },
          _initInteraction: function() {
            if (!this.options.interactive) {
              return;
            }
            addClass(this._icon, "leaflet-interactive");
            this.addInteractiveTarget(this._icon);
            if (MarkerDrag) {
              var draggable = this.options.draggable;
              if (this.dragging) {
                draggable = this.dragging.enabled();
                this.dragging.disable();
              }
              this.dragging = new MarkerDrag(this);
              if (draggable) {
                this.dragging.enable();
              }
            }
          },
          // @method setOpacity(opacity: Number): this
          // Changes the opacity of the marker.
          setOpacity: function(opacity) {
            this.options.opacity = opacity;
            if (this._map) {
              this._updateOpacity();
            }
            return this;
          },
          _updateOpacity: function() {
            var opacity = this.options.opacity;
            if (this._icon) {
              setOpacity(this._icon, opacity);
            }
            if (this._shadow) {
              setOpacity(this._shadow, opacity);
            }
          },
          _bringToFront: function() {
            this._updateZIndex(this.options.riseOffset);
          },
          _resetZIndex: function() {
            this._updateZIndex(0);
          },
          _panOnFocus: function() {
            var map2 = this._map;
            if (!map2) {
              return;
            }
            var iconOpts = this.options.icon.options;
            var size = iconOpts.iconSize ? toPoint(iconOpts.iconSize) : toPoint(0, 0);
            var anchor = iconOpts.iconAnchor ? toPoint(iconOpts.iconAnchor) : toPoint(0, 0);
            map2.panInside(this._latlng, {
              paddingTopLeft: anchor,
              paddingBottomRight: size.subtract(anchor)
            });
          },
          _getPopupAnchor: function() {
            return this.options.icon.options.popupAnchor;
          },
          _getTooltipAnchor: function() {
            return this.options.icon.options.tooltipAnchor;
          }
        });
        function marker(latlng, options) {
          return new Marker(latlng, options);
        }
        __name(marker, "marker");
        var Path = Layer.extend({
          // @section
          // @aka Path options
          options: {
            // @option stroke: Boolean = true
            // Whether to draw stroke along the path. Set it to `false` to disable borders on polygons or circles.
            stroke: true,
            // @option color: String = '#3388ff'
            // Stroke color
            color: "#3388ff",
            // @option weight: Number = 3
            // Stroke width in pixels
            weight: 3,
            // @option opacity: Number = 1.0
            // Stroke opacity
            opacity: 1,
            // @option lineCap: String= 'round'
            // A string that defines [shape to be used at the end](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linecap) of the stroke.
            lineCap: "round",
            // @option lineJoin: String = 'round'
            // A string that defines [shape to be used at the corners](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linejoin) of the stroke.
            lineJoin: "round",
            // @option dashArray: String = null
            // A string that defines the stroke [dash pattern](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dasharray). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).
            dashArray: null,
            // @option dashOffset: String = null
            // A string that defines the [distance into the dash pattern to start the dash](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dashoffset). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).
            dashOffset: null,
            // @option fill: Boolean = depends
            // Whether to fill the path with color. Set it to `false` to disable filling on polygons or circles.
            fill: false,
            // @option fillColor: String = *
            // Fill color. Defaults to the value of the [`color`](#path-color) option
            fillColor: null,
            // @option fillOpacity: Number = 0.2
            // Fill opacity.
            fillOpacity: 0.2,
            // @option fillRule: String = 'evenodd'
            // A string that defines [how the inside of a shape](https://developer.mozilla.org/docs/Web/SVG/Attribute/fill-rule) is determined.
            fillRule: "evenodd",
            // className: '',
            // Option inherited from "Interactive layer" abstract class
            interactive: true,
            // @option bubblingMouseEvents: Boolean = true
            // When `true`, a mouse event on this path will trigger the same event on the map
            // (unless [`L.DomEvent.stopPropagation`](#domevent-stoppropagation) is used).
            bubblingMouseEvents: true
          },
          beforeAdd: function(map2) {
            this._renderer = map2.getRenderer(this);
          },
          onAdd: function() {
            this._renderer._initPath(this);
            this._reset();
            this._renderer._addPath(this);
          },
          onRemove: function() {
            this._renderer._removePath(this);
          },
          // @method redraw(): this
          // Redraws the layer. Sometimes useful after you changed the coordinates that the path uses.
          redraw: function() {
            if (this._map) {
              this._renderer._updatePath(this);
            }
            return this;
          },
          // @method setStyle(style: Path options): this
          // Changes the appearance of a Path based on the options in the `Path options` object.
          setStyle: function(style2) {
            setOptions(this, style2);
            if (this._renderer) {
              this._renderer._updateStyle(this);
              if (this.options.stroke && style2 && Object.prototype.hasOwnProperty.call(style2, "weight")) {
                this._updateBounds();
              }
            }
            return this;
          },
          // @method bringToFront(): this
          // Brings the layer to the top of all path layers.
          bringToFront: function() {
            if (this._renderer) {
              this._renderer._bringToFront(this);
            }
            return this;
          },
          // @method bringToBack(): this
          // Brings the layer to the bottom of all path layers.
          bringToBack: function() {
            if (this._renderer) {
              this._renderer._bringToBack(this);
            }
            return this;
          },
          getElement: function() {
            return this._path;
          },
          _reset: function() {
            this._project();
            this._update();
          },
          _clickTolerance: function() {
            return (this.options.stroke ? this.options.weight / 2 : 0) + (this._renderer.options.tolerance || 0);
          }
        });
        var CircleMarker = Path.extend({
          // @section
          // @aka CircleMarker options
          options: {
            fill: true,
            // @option radius: Number = 10
            // Radius of the circle marker, in pixels
            radius: 10
          },
          initialize: function(latlng, options) {
            setOptions(this, options);
            this._latlng = toLatLng(latlng);
            this._radius = this.options.radius;
          },
          // @method setLatLng(latLng: LatLng): this
          // Sets the position of a circle marker to a new location.
          setLatLng: function(latlng) {
            var oldLatLng = this._latlng;
            this._latlng = toLatLng(latlng);
            this.redraw();
            return this.fire("move", { oldLatLng, latlng: this._latlng });
          },
          // @method getLatLng(): LatLng
          // Returns the current geographical position of the circle marker
          getLatLng: function() {
            return this._latlng;
          },
          // @method setRadius(radius: Number): this
          // Sets the radius of a circle marker. Units are in pixels.
          setRadius: function(radius) {
            this.options.radius = this._radius = radius;
            return this.redraw();
          },
          // @method getRadius(): Number
          // Returns the current radius of the circle
          getRadius: function() {
            return this._radius;
          },
          setStyle: function(options) {
            var radius = options && options.radius || this._radius;
            Path.prototype.setStyle.call(this, options);
            this.setRadius(radius);
            return this;
          },
          _project: function() {
            this._point = this._map.latLngToLayerPoint(this._latlng);
            this._updateBounds();
          },
          _updateBounds: function() {
            var r3 = this._radius, r22 = this._radiusY || r3, w3 = this._clickTolerance(), p3 = [r3 + w3, r22 + w3];
            this._pxBounds = new Bounds(this._point.subtract(p3), this._point.add(p3));
          },
          _update: function() {
            if (this._map) {
              this._updatePath();
            }
          },
          _updatePath: function() {
            this._renderer._updateCircle(this);
          },
          _empty: function() {
            return this._radius && !this._renderer._bounds.intersects(this._pxBounds);
          },
          // Needed by the `Canvas` renderer for interactivity
          _containsPoint: function(p3) {
            return p3.distanceTo(this._point) <= this._radius + this._clickTolerance();
          }
        });
        function circleMarker(latlng, options) {
          return new CircleMarker(latlng, options);
        }
        __name(circleMarker, "circleMarker");
        var Circle = CircleMarker.extend({
          initialize: function(latlng, options, legacyOptions) {
            if (typeof options === "number") {
              options = extend3({}, legacyOptions, { radius: options });
            }
            setOptions(this, options);
            this._latlng = toLatLng(latlng);
            if (isNaN(this.options.radius)) {
              throw new Error("Circle radius cannot be NaN");
            }
            this._mRadius = this.options.radius;
          },
          // @method setRadius(radius: Number): this
          // Sets the radius of a circle. Units are in meters.
          setRadius: function(radius) {
            this._mRadius = radius;
            return this.redraw();
          },
          // @method getRadius(): Number
          // Returns the current radius of a circle. Units are in meters.
          getRadius: function() {
            return this._mRadius;
          },
          // @method getBounds(): LatLngBounds
          // Returns the `LatLngBounds` of the path.
          getBounds: function() {
            var half = [this._radius, this._radiusY || this._radius];
            return new LatLngBounds(
              this._map.layerPointToLatLng(this._point.subtract(half)),
              this._map.layerPointToLatLng(this._point.add(half))
            );
          },
          setStyle: Path.prototype.setStyle,
          _project: function() {
            var lng = this._latlng.lng, lat = this._latlng.lat, map2 = this._map, crs = map2.options.crs;
            if (crs.distance === Earth.distance) {
              var d3 = Math.PI / 180, latR = this._mRadius / Earth.R / d3, top = map2.project([lat + latR, lng]), bottom = map2.project([lat - latR, lng]), p3 = top.add(bottom).divideBy(2), lat2 = map2.unproject(p3).lat, lngR = Math.acos((Math.cos(latR * d3) - Math.sin(lat * d3) * Math.sin(lat2 * d3)) / (Math.cos(lat * d3) * Math.cos(lat2 * d3))) / d3;
              if (isNaN(lngR) || lngR === 0) {
                lngR = latR / Math.cos(Math.PI / 180 * lat);
              }
              this._point = p3.subtract(map2.getPixelOrigin());
              this._radius = isNaN(lngR) ? 0 : p3.x - map2.project([lat2, lng - lngR]).x;
              this._radiusY = p3.y - top.y;
            } else {
              var latlng2 = crs.unproject(crs.project(this._latlng).subtract([this._mRadius, 0]));
              this._point = map2.latLngToLayerPoint(this._latlng);
              this._radius = this._point.x - map2.latLngToLayerPoint(latlng2).x;
            }
            this._updateBounds();
          }
        });
        function circle(latlng, options, legacyOptions) {
          return new Circle(latlng, options, legacyOptions);
        }
        __name(circle, "circle");
        var Polyline = Path.extend({
          // @section
          // @aka Polyline options
          options: {
            // @option smoothFactor: Number = 1.0
            // How much to simplify the polyline on each zoom level. More means
            // better performance and smoother look, and less means more accurate representation.
            smoothFactor: 1,
            // @option noClip: Boolean = false
            // Disable polyline clipping.
            noClip: false
          },
          initialize: function(latlngs, options) {
            setOptions(this, options);
            this._setLatLngs(latlngs);
          },
          // @method getLatLngs(): LatLng[]
          // Returns an array of the points in the path, or nested arrays of points in case of multi-polyline.
          getLatLngs: function() {
            return this._latlngs;
          },
          // @method setLatLngs(latlngs: LatLng[]): this
          // Replaces all the points in the polyline with the given array of geographical points.
          setLatLngs: function(latlngs) {
            this._setLatLngs(latlngs);
            return this.redraw();
          },
          // @method isEmpty(): Boolean
          // Returns `true` if the Polyline has no LatLngs.
          isEmpty: function() {
            return !this._latlngs.length;
          },
          // @method closestLayerPoint(p: Point): Point
          // Returns the point closest to `p` on the Polyline.
          closestLayerPoint: function(p3) {
            var minDistance = Infinity, minPoint = null, closest2 = _sqClosestPointOnSegment, p1, p22;
            for (var j3 = 0, jLen = this._parts.length; j3 < jLen; j3++) {
              var points = this._parts[j3];
              for (var i3 = 1, len = points.length; i3 < len; i3++) {
                p1 = points[i3 - 1];
                p22 = points[i3];
                var sqDist = closest2(p3, p1, p22, true);
                if (sqDist < minDistance) {
                  minDistance = sqDist;
                  minPoint = closest2(p3, p1, p22);
                }
              }
            }
            if (minPoint) {
              minPoint.distance = Math.sqrt(minDistance);
            }
            return minPoint;
          },
          // @method getCenter(): LatLng
          // Returns the center ([centroid](https://en.wikipedia.org/wiki/Centroid)) of the polyline.
          getCenter: function() {
            if (!this._map) {
              throw new Error("Must add layer to map before using getCenter()");
            }
            return polylineCenter(this._defaultShape(), this._map.options.crs);
          },
          // @method getBounds(): LatLngBounds
          // Returns the `LatLngBounds` of the path.
          getBounds: function() {
            return this._bounds;
          },
          // @method addLatLng(latlng: LatLng, latlngs?: LatLng[]): this
          // Adds a given point to the polyline. By default, adds to the first ring of
          // the polyline in case of a multi-polyline, but can be overridden by passing
          // a specific ring as a LatLng array (that you can earlier access with [`getLatLngs`](#polyline-getlatlngs)).
          addLatLng: function(latlng, latlngs) {
            latlngs = latlngs || this._defaultShape();
            latlng = toLatLng(latlng);
            latlngs.push(latlng);
            this._bounds.extend(latlng);
            return this.redraw();
          },
          _setLatLngs: function(latlngs) {
            this._bounds = new LatLngBounds();
            this._latlngs = this._convertLatLngs(latlngs);
          },
          _defaultShape: function() {
            return isFlat(this._latlngs) ? this._latlngs : this._latlngs[0];
          },
          // recursively convert latlngs input into actual LatLng instances; calculate bounds along the way
          _convertLatLngs: function(latlngs) {
            var result = [], flat = isFlat(latlngs);
            for (var i3 = 0, len = latlngs.length; i3 < len; i3++) {
              if (flat) {
                result[i3] = toLatLng(latlngs[i3]);
                this._bounds.extend(result[i3]);
              } else {
                result[i3] = this._convertLatLngs(latlngs[i3]);
              }
            }
            return result;
          },
          _project: function() {
            var pxBounds = new Bounds();
            this._rings = [];
            this._projectLatlngs(this._latlngs, this._rings, pxBounds);
            if (this._bounds.isValid() && pxBounds.isValid()) {
              this._rawPxBounds = pxBounds;
              this._updateBounds();
            }
          },
          _updateBounds: function() {
            var w3 = this._clickTolerance(), p3 = new Point(w3, w3);
            if (!this._rawPxBounds) {
              return;
            }
            this._pxBounds = new Bounds([
              this._rawPxBounds.min.subtract(p3),
              this._rawPxBounds.max.add(p3)
            ]);
          },
          // recursively turns latlngs into a set of rings with projected coordinates
          _projectLatlngs: function(latlngs, result, projectedBounds) {
            var flat = latlngs[0] instanceof LatLng, len = latlngs.length, i3, ring;
            if (flat) {
              ring = [];
              for (i3 = 0; i3 < len; i3++) {
                ring[i3] = this._map.latLngToLayerPoint(latlngs[i3]);
                projectedBounds.extend(ring[i3]);
              }
              result.push(ring);
            } else {
              for (i3 = 0; i3 < len; i3++) {
                this._projectLatlngs(latlngs[i3], result, projectedBounds);
              }
            }
          },
          // clip polyline by renderer bounds so that we have less to render for performance
          _clipPoints: function() {
            var bounds = this._renderer._bounds;
            this._parts = [];
            if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {
              return;
            }
            if (this.options.noClip) {
              this._parts = this._rings;
              return;
            }
            var parts = this._parts, i3, j3, k3, len, len2, segment, points;
            for (i3 = 0, k3 = 0, len = this._rings.length; i3 < len; i3++) {
              points = this._rings[i3];
              for (j3 = 0, len2 = points.length; j3 < len2 - 1; j3++) {
                segment = clipSegment(points[j3], points[j3 + 1], bounds, j3, true);
                if (!segment) {
                  continue;
                }
                parts[k3] = parts[k3] || [];
                parts[k3].push(segment[0]);
                if (segment[1] !== points[j3 + 1] || j3 === len2 - 2) {
                  parts[k3].push(segment[1]);
                  k3++;
                }
              }
            }
          },
          // simplify each clipped part of the polyline for performance
          _simplifyPoints: function() {
            var parts = this._parts, tolerance = this.options.smoothFactor;
            for (var i3 = 0, len = parts.length; i3 < len; i3++) {
              parts[i3] = simplify(parts[i3], tolerance);
            }
          },
          _update: function() {
            if (!this._map) {
              return;
            }
            this._clipPoints();
            this._simplifyPoints();
            this._updatePath();
          },
          _updatePath: function() {
            this._renderer._updatePoly(this);
          },
          // Needed by the `Canvas` renderer for interactivity
          _containsPoint: function(p3, closed) {
            var i3, j3, k3, len, len2, part, w3 = this._clickTolerance();
            if (!this._pxBounds || !this._pxBounds.contains(p3)) {
              return false;
            }
            for (i3 = 0, len = this._parts.length; i3 < len; i3++) {
              part = this._parts[i3];
              for (j3 = 0, len2 = part.length, k3 = len2 - 1; j3 < len2; k3 = j3++) {
                if (!closed && j3 === 0) {
                  continue;
                }
                if (pointToSegmentDistance(p3, part[k3], part[j3]) <= w3) {
                  return true;
                }
              }
            }
            return false;
          }
        });
        function polyline(latlngs, options) {
          return new Polyline(latlngs, options);
        }
        __name(polyline, "polyline");
        Polyline._flat = _flat;
        var Polygon = Polyline.extend({
          options: {
            fill: true
          },
          isEmpty: function() {
            return !this._latlngs.length || !this._latlngs[0].length;
          },
          // @method getCenter(): LatLng
          // Returns the center ([centroid](http://en.wikipedia.org/wiki/Centroid)) of the Polygon.
          getCenter: function() {
            if (!this._map) {
              throw new Error("Must add layer to map before using getCenter()");
            }
            return polygonCenter(this._defaultShape(), this._map.options.crs);
          },
          _convertLatLngs: function(latlngs) {
            var result = Polyline.prototype._convertLatLngs.call(this, latlngs), len = result.length;
            if (len >= 2 && result[0] instanceof LatLng && result[0].equals(result[len - 1])) {
              result.pop();
            }
            return result;
          },
          _setLatLngs: function(latlngs) {
            Polyline.prototype._setLatLngs.call(this, latlngs);
            if (isFlat(this._latlngs)) {
              this._latlngs = [this._latlngs];
            }
          },
          _defaultShape: function() {
            return isFlat(this._latlngs[0]) ? this._latlngs[0] : this._latlngs[0][0];
          },
          _clipPoints: function() {
            var bounds = this._renderer._bounds, w3 = this.options.weight, p3 = new Point(w3, w3);
            bounds = new Bounds(bounds.min.subtract(p3), bounds.max.add(p3));
            this._parts = [];
            if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {
              return;
            }
            if (this.options.noClip) {
              this._parts = this._rings;
              return;
            }
            for (var i3 = 0, len = this._rings.length, clipped; i3 < len; i3++) {
              clipped = clipPolygon(this._rings[i3], bounds, true);
              if (clipped.length) {
                this._parts.push(clipped);
              }
            }
          },
          _updatePath: function() {
            this._renderer._updatePoly(this, true);
          },
          // Needed by the `Canvas` renderer for interactivity
          _containsPoint: function(p3) {
            var inside = false, part, p1, p22, i3, j3, k3, len, len2;
            if (!this._pxBounds || !this._pxBounds.contains(p3)) {
              return false;
            }
            for (i3 = 0, len = this._parts.length; i3 < len; i3++) {
              part = this._parts[i3];
              for (j3 = 0, len2 = part.length, k3 = len2 - 1; j3 < len2; k3 = j3++) {
                p1 = part[j3];
                p22 = part[k3];
                if (p1.y > p3.y !== p22.y > p3.y && p3.x < (p22.x - p1.x) * (p3.y - p1.y) / (p22.y - p1.y) + p1.x) {
                  inside = !inside;
                }
              }
            }
            return inside || Polyline.prototype._containsPoint.call(this, p3, true);
          }
        });
        function polygon(latlngs, options) {
          return new Polygon(latlngs, options);
        }
        __name(polygon, "polygon");
        var GeoJSON = FeatureGroup.extend({
          /* @section
           * @aka GeoJSON options
           *
           * @option pointToLayer: Function = *
           * A `Function` defining how GeoJSON points spawn Leaflet layers. It is internally
           * called when data is added, passing the GeoJSON point feature and its `LatLng`.
           * The default is to spawn a default `Marker`:
           * ```js
           * function(geoJsonPoint, latlng) {
           * 	return L.marker(latlng);
           * }
           * ```
           *
           * @option style: Function = *
           * A `Function` defining the `Path options` for styling GeoJSON lines and polygons,
           * called internally when data is added.
           * The default value is to not override any defaults:
           * ```js
           * function (geoJsonFeature) {
           * 	return {}
           * }
           * ```
           *
           * @option onEachFeature: Function = *
           * A `Function` that will be called once for each created `Feature`, after it has
           * been created and styled. Useful for attaching events and popups to features.
           * The default is to do nothing with the newly created layers:
           * ```js
           * function (feature, layer) {}
           * ```
           *
           * @option filter: Function = *
           * A `Function` that will be used to decide whether to include a feature or not.
           * The default is to include all features:
           * ```js
           * function (geoJsonFeature) {
           * 	return true;
           * }
           * ```
           * Note: dynamically changing the `filter` option will have effect only on newly
           * added data. It will _not_ re-evaluate already included features.
           *
           * @option coordsToLatLng: Function = *
           * A `Function` that will be used for converting GeoJSON coordinates to `LatLng`s.
           * The default is the `coordsToLatLng` static method.
           *
           * @option markersInheritOptions: Boolean = false
           * Whether default Markers for "Point" type Features inherit from group options.
           */
          initialize: function(geojson, options) {
            setOptions(this, options);
            this._layers = {};
            if (geojson) {
              this.addData(geojson);
            }
          },
          // @method addData( <GeoJSON> data ): this
          // Adds a GeoJSON object to the layer.
          addData: function(geojson) {
            var features = isArray2(geojson) ? geojson : geojson.features, i3, len, feature;
            if (features) {
              for (i3 = 0, len = features.length; i3 < len; i3++) {
                feature = features[i3];
                if (feature.geometries || feature.geometry || feature.features || feature.coordinates) {
                  this.addData(feature);
                }
              }
              return this;
            }
            var options = this.options;
            if (options.filter && !options.filter(geojson)) {
              return this;
            }
            var layer = geometryToLayer(geojson, options);
            if (!layer) {
              return this;
            }
            layer.feature = asFeature(geojson);
            layer.defaultOptions = layer.options;
            this.resetStyle(layer);
            if (options.onEachFeature) {
              options.onEachFeature(geojson, layer);
            }
            return this.addLayer(layer);
          },
          // @method resetStyle( <Path> layer? ): this
          // Resets the given vector layer's style to the original GeoJSON style, useful for resetting style after hover events.
          // If `layer` is omitted, the style of all features in the current layer is reset.
          resetStyle: function(layer) {
            if (layer === void 0) {
              return this.eachLayer(this.resetStyle, this);
            }
            layer.options = extend3({}, layer.defaultOptions);
            this._setLayerStyle(layer, this.options.style);
            return this;
          },
          // @method setStyle( <Function> style ): this
          // Changes styles of GeoJSON vector layers with the given style function.
          setStyle: function(style2) {
            return this.eachLayer(function(layer) {
              this._setLayerStyle(layer, style2);
            }, this);
          },
          _setLayerStyle: function(layer, style2) {
            if (layer.setStyle) {
              if (typeof style2 === "function") {
                style2 = style2(layer.feature);
              }
              layer.setStyle(style2);
            }
          }
        });
        function geometryToLayer(geojson, options) {
          var geometry = geojson.type === "Feature" ? geojson.geometry : geojson, coords = geometry ? geometry.coordinates : null, layers2 = [], pointToLayer = options && options.pointToLayer, _coordsToLatLng = options && options.coordsToLatLng || coordsToLatLng, latlng, latlngs, i3, len;
          if (!coords && !geometry) {
            return null;
          }
          switch (geometry.type) {
            case "Point":
              latlng = _coordsToLatLng(coords);
              return _pointToLayer(pointToLayer, geojson, latlng, options);
            case "MultiPoint":
              for (i3 = 0, len = coords.length; i3 < len; i3++) {
                latlng = _coordsToLatLng(coords[i3]);
                layers2.push(_pointToLayer(pointToLayer, geojson, latlng, options));
              }
              return new FeatureGroup(layers2);
            case "LineString":
            case "MultiLineString":
              latlngs = coordsToLatLngs(coords, geometry.type === "LineString" ? 0 : 1, _coordsToLatLng);
              return new Polyline(latlngs, options);
            case "Polygon":
            case "MultiPolygon":
              latlngs = coordsToLatLngs(coords, geometry.type === "Polygon" ? 1 : 2, _coordsToLatLng);
              return new Polygon(latlngs, options);
            case "GeometryCollection":
              for (i3 = 0, len = geometry.geometries.length; i3 < len; i3++) {
                var geoLayer = geometryToLayer({
                  geometry: geometry.geometries[i3],
                  type: "Feature",
                  properties: geojson.properties
                }, options);
                if (geoLayer) {
                  layers2.push(geoLayer);
                }
              }
              return new FeatureGroup(layers2);
            case "FeatureCollection":
              for (i3 = 0, len = geometry.features.length; i3 < len; i3++) {
                var featureLayer = geometryToLayer(geometry.features[i3], options);
                if (featureLayer) {
                  layers2.push(featureLayer);
                }
              }
              return new FeatureGroup(layers2);
            default:
              throw new Error("Invalid GeoJSON object.");
          }
        }
        __name(geometryToLayer, "geometryToLayer");
        function _pointToLayer(pointToLayerFn, geojson, latlng, options) {
          return pointToLayerFn ? pointToLayerFn(geojson, latlng) : new Marker(latlng, options && options.markersInheritOptions && options);
        }
        __name(_pointToLayer, "_pointToLayer");
        function coordsToLatLng(coords) {
          return new LatLng(coords[1], coords[0], coords[2]);
        }
        __name(coordsToLatLng, "coordsToLatLng");
        function coordsToLatLngs(coords, levelsDeep, _coordsToLatLng) {
          var latlngs = [];
          for (var i3 = 0, len = coords.length, latlng; i3 < len; i3++) {
            latlng = levelsDeep ? coordsToLatLngs(coords[i3], levelsDeep - 1, _coordsToLatLng) : (_coordsToLatLng || coordsToLatLng)(coords[i3]);
            latlngs.push(latlng);
          }
          return latlngs;
        }
        __name(coordsToLatLngs, "coordsToLatLngs");
        function latLngToCoords(latlng, precision) {
          latlng = toLatLng(latlng);
          return latlng.alt !== void 0 ? [formatNum(latlng.lng, precision), formatNum(latlng.lat, precision), formatNum(latlng.alt, precision)] : [formatNum(latlng.lng, precision), formatNum(latlng.lat, precision)];
        }
        __name(latLngToCoords, "latLngToCoords");
        function latLngsToCoords(latlngs, levelsDeep, closed, precision) {
          var coords = [];
          for (var i3 = 0, len = latlngs.length; i3 < len; i3++) {
            coords.push(levelsDeep ? latLngsToCoords(latlngs[i3], isFlat(latlngs[i3]) ? 0 : levelsDeep - 1, closed, precision) : latLngToCoords(latlngs[i3], precision));
          }
          if (!levelsDeep && closed && coords.length > 0) {
            coords.push(coords[0].slice());
          }
          return coords;
        }
        __name(latLngsToCoords, "latLngsToCoords");
        function getFeature(layer, newGeometry) {
          return layer.feature ? extend3({}, layer.feature, { geometry: newGeometry }) : asFeature(newGeometry);
        }
        __name(getFeature, "getFeature");
        function asFeature(geojson) {
          if (geojson.type === "Feature" || geojson.type === "FeatureCollection") {
            return geojson;
          }
          return {
            type: "Feature",
            properties: {},
            geometry: geojson
          };
        }
        __name(asFeature, "asFeature");
        var PointToGeoJSON = {
          toGeoJSON: function(precision) {
            return getFeature(this, {
              type: "Point",
              coordinates: latLngToCoords(this.getLatLng(), precision)
            });
          }
        };
        Marker.include(PointToGeoJSON);
        Circle.include(PointToGeoJSON);
        CircleMarker.include(PointToGeoJSON);
        Polyline.include({
          toGeoJSON: function(precision) {
            var multi = !isFlat(this._latlngs);
            var coords = latLngsToCoords(this._latlngs, multi ? 1 : 0, false, precision);
            return getFeature(this, {
              type: (multi ? "Multi" : "") + "LineString",
              coordinates: coords
            });
          }
        });
        Polygon.include({
          toGeoJSON: function(precision) {
            var holes = !isFlat(this._latlngs), multi = holes && !isFlat(this._latlngs[0]);
            var coords = latLngsToCoords(this._latlngs, multi ? 2 : holes ? 1 : 0, true, precision);
            if (!holes) {
              coords = [coords];
            }
            return getFeature(this, {
              type: (multi ? "Multi" : "") + "Polygon",
              coordinates: coords
            });
          }
        });
        LayerGroup.include({
          toMultiPoint: function(precision) {
            var coords = [];
            this.eachLayer(function(layer) {
              coords.push(layer.toGeoJSON(precision).geometry.coordinates);
            });
            return getFeature(this, {
              type: "MultiPoint",
              coordinates: coords
            });
          },
          // @method toGeoJSON(precision?: Number|false): Object
          // Coordinates values are rounded with [`formatNum`](#util-formatnum) function with given `precision`.
          // Returns a [`GeoJSON`](https://en.wikipedia.org/wiki/GeoJSON) representation of the layer group (as a GeoJSON `FeatureCollection`, `GeometryCollection`, or `MultiPoint`).
          toGeoJSON: function(precision) {
            var type = this.feature && this.feature.geometry && this.feature.geometry.type;
            if (type === "MultiPoint") {
              return this.toMultiPoint(precision);
            }
            var isGeometryCollection = type === "GeometryCollection", jsons = [];
            this.eachLayer(function(layer) {
              if (layer.toGeoJSON) {
                var json = layer.toGeoJSON(precision);
                if (isGeometryCollection) {
                  jsons.push(json.geometry);
                } else {
                  var feature = asFeature(json);
                  if (feature.type === "FeatureCollection") {
                    jsons.push.apply(jsons, feature.features);
                  } else {
                    jsons.push(feature);
                  }
                }
              }
            });
            if (isGeometryCollection) {
              return getFeature(this, {
                geometries: jsons,
                type: "GeometryCollection"
              });
            }
            return {
              type: "FeatureCollection",
              features: jsons
            };
          }
        });
        function geoJSON(geojson, options) {
          return new GeoJSON(geojson, options);
        }
        __name(geoJSON, "geoJSON");
        var geoJson = geoJSON;
        var ImageOverlay = Layer.extend({
          // @section
          // @aka ImageOverlay options
          options: {
            // @option opacity: Number = 1.0
            // The opacity of the image overlay.
            opacity: 1,
            // @option alt: String = ''
            // Text for the `alt` attribute of the image (useful for accessibility).
            alt: "",
            // @option interactive: Boolean = false
            // If `true`, the image overlay will emit [mouse events](#interactive-layer) when clicked or hovered.
            interactive: false,
            // @option crossOrigin: Boolean|String = false
            // Whether the crossOrigin attribute will be added to the image.
            // If a String is provided, the image will have its crossOrigin attribute set to the String provided. This is needed if you want to access image pixel data.
            // Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.
            crossOrigin: false,
            // @option errorOverlayUrl: String = ''
            // URL to the overlay image to show in place of the overlay that failed to load.
            errorOverlayUrl: "",
            // @option zIndex: Number = 1
            // The explicit [zIndex](https://developer.mozilla.org/docs/Web/CSS/CSS_Positioning/Understanding_z_index) of the overlay layer.
            zIndex: 1,
            // @option className: String = ''
            // A custom class name to assign to the image. Empty by default.
            className: ""
          },
          initialize: function(url, bounds, options) {
            this._url = url;
            this._bounds = toLatLngBounds(bounds);
            setOptions(this, options);
          },
          onAdd: function() {
            if (!this._image) {
              this._initImage();
              if (this.options.opacity < 1) {
                this._updateOpacity();
              }
            }
            if (this.options.interactive) {
              addClass(this._image, "leaflet-interactive");
              this.addInteractiveTarget(this._image);
            }
            this.getPane().appendChild(this._image);
            this._reset();
          },
          onRemove: function() {
            remove(this._image);
            if (this.options.interactive) {
              this.removeInteractiveTarget(this._image);
            }
          },
          // @method setOpacity(opacity: Number): this
          // Sets the opacity of the overlay.
          setOpacity: function(opacity) {
            this.options.opacity = opacity;
            if (this._image) {
              this._updateOpacity();
            }
            return this;
          },
          setStyle: function(styleOpts) {
            if (styleOpts.opacity) {
              this.setOpacity(styleOpts.opacity);
            }
            return this;
          },
          // @method bringToFront(): this
          // Brings the layer to the top of all overlays.
          bringToFront: function() {
            if (this._map) {
              toFront(this._image);
            }
            return this;
          },
          // @method bringToBack(): this
          // Brings the layer to the bottom of all overlays.
          bringToBack: function() {
            if (this._map) {
              toBack(this._image);
            }
            return this;
          },
          // @method setUrl(url: String): this
          // Changes the URL of the image.
          setUrl: function(url) {
            this._url = url;
            if (this._image) {
              this._image.src = url;
            }
            return this;
          },
          // @method setBounds(bounds: LatLngBounds): this
          // Update the bounds that this ImageOverlay covers
          setBounds: function(bounds) {
            this._bounds = toLatLngBounds(bounds);
            if (this._map) {
              this._reset();
            }
            return this;
          },
          getEvents: function() {
            var events = {
              zoom: this._reset,
              viewreset: this._reset
            };
            if (this._zoomAnimated) {
              events.zoomanim = this._animateZoom;
            }
            return events;
          },
          // @method setZIndex(value: Number): this
          // Changes the [zIndex](#imageoverlay-zindex) of the image overlay.
          setZIndex: function(value) {
            this.options.zIndex = value;
            this._updateZIndex();
            return this;
          },
          // @method getBounds(): LatLngBounds
          // Get the bounds that this ImageOverlay covers
          getBounds: function() {
            return this._bounds;
          },
          // @method getElement(): HTMLElement
          // Returns the instance of [`HTMLImageElement`](https://developer.mozilla.org/docs/Web/API/HTMLImageElement)
          // used by this overlay.
          getElement: function() {
            return this._image;
          },
          _initImage: function() {
            var wasElementSupplied = this._url.tagName === "IMG";
            var img = this._image = wasElementSupplied ? this._url : create$1("img");
            addClass(img, "leaflet-image-layer");
            if (this._zoomAnimated) {
              addClass(img, "leaflet-zoom-animated");
            }
            if (this.options.className) {
              addClass(img, this.options.className);
            }
            img.onselectstart = falseFn;
            img.onmousemove = falseFn;
            img.onload = bind(this.fire, this, "load");
            img.onerror = bind(this._overlayOnError, this, "error");
            if (this.options.crossOrigin || this.options.crossOrigin === "") {
              img.crossOrigin = this.options.crossOrigin === true ? "" : this.options.crossOrigin;
            }
            if (this.options.zIndex) {
              this._updateZIndex();
            }
            if (wasElementSupplied) {
              this._url = img.src;
              return;
            }
            img.src = this._url;
            img.alt = this.options.alt;
          },
          _animateZoom: function(e3) {
            var scale2 = this._map.getZoomScale(e3.zoom), offset = this._map._latLngBoundsToNewLayerBounds(this._bounds, e3.zoom, e3.center).min;
            setTransform(this._image, offset, scale2);
          },
          _reset: function() {
            var image = this._image, bounds = new Bounds(
              this._map.latLngToLayerPoint(this._bounds.getNorthWest()),
              this._map.latLngToLayerPoint(this._bounds.getSouthEast())
            ), size = bounds.getSize();
            setPosition(image, bounds.min);
            image.style.width = size.x + "px";
            image.style.height = size.y + "px";
          },
          _updateOpacity: function() {
            setOpacity(this._image, this.options.opacity);
          },
          _updateZIndex: function() {
            if (this._image && this.options.zIndex !== void 0 && this.options.zIndex !== null) {
              this._image.style.zIndex = this.options.zIndex;
            }
          },
          _overlayOnError: function() {
            this.fire("error");
            var errorUrl = this.options.errorOverlayUrl;
            if (errorUrl && this._url !== errorUrl) {
              this._url = errorUrl;
              this._image.src = errorUrl;
            }
          },
          // @method getCenter(): LatLng
          // Returns the center of the ImageOverlay.
          getCenter: function() {
            return this._bounds.getCenter();
          }
        });
        var imageOverlay = /* @__PURE__ */ __name(function(url, bounds, options) {
          return new ImageOverlay(url, bounds, options);
        }, "imageOverlay");
        var VideoOverlay = ImageOverlay.extend({
          // @section
          // @aka VideoOverlay options
          options: {
            // @option autoplay: Boolean = true
            // Whether the video starts playing automatically when loaded.
            // On some browsers autoplay will only work with `muted: true`
            autoplay: true,
            // @option loop: Boolean = true
            // Whether the video will loop back to the beginning when played.
            loop: true,
            // @option keepAspectRatio: Boolean = true
            // Whether the video will save aspect ratio after the projection.
            // Relevant for supported browsers. See [browser compatibility](https://developer.mozilla.org/en-US/docs/Web/CSS/object-fit)
            keepAspectRatio: true,
            // @option muted: Boolean = false
            // Whether the video starts on mute when loaded.
            muted: false,
            // @option playsInline: Boolean = true
            // Mobile browsers will play the video right where it is instead of open it up in fullscreen mode.
            playsInline: true
          },
          _initImage: function() {
            var wasElementSupplied = this._url.tagName === "VIDEO";
            var vid = this._image = wasElementSupplied ? this._url : create$1("video");
            addClass(vid, "leaflet-image-layer");
            if (this._zoomAnimated) {
              addClass(vid, "leaflet-zoom-animated");
            }
            if (this.options.className) {
              addClass(vid, this.options.className);
            }
            vid.onselectstart = falseFn;
            vid.onmousemove = falseFn;
            vid.onloadeddata = bind(this.fire, this, "load");
            if (wasElementSupplied) {
              var sourceElements = vid.getElementsByTagName("source");
              var sources = [];
              for (var j3 = 0; j3 < sourceElements.length; j3++) {
                sources.push(sourceElements[j3].src);
              }
              this._url = sourceElements.length > 0 ? sources : [vid.src];
              return;
            }
            if (!isArray2(this._url)) {
              this._url = [this._url];
            }
            if (!this.options.keepAspectRatio && Object.prototype.hasOwnProperty.call(vid.style, "objectFit")) {
              vid.style["objectFit"] = "fill";
            }
            vid.autoplay = !!this.options.autoplay;
            vid.loop = !!this.options.loop;
            vid.muted = !!this.options.muted;
            vid.playsInline = !!this.options.playsInline;
            for (var i3 = 0; i3 < this._url.length; i3++) {
              var source = create$1("source");
              source.src = this._url[i3];
              vid.appendChild(source);
            }
          }
          // @method getElement(): HTMLVideoElement
          // Returns the instance of [`HTMLVideoElement`](https://developer.mozilla.org/docs/Web/API/HTMLVideoElement)
          // used by this overlay.
        });
        function videoOverlay(video, bounds, options) {
          return new VideoOverlay(video, bounds, options);
        }
        __name(videoOverlay, "videoOverlay");
        var SVGOverlay = ImageOverlay.extend({
          _initImage: function() {
            var el = this._image = this._url;
            addClass(el, "leaflet-image-layer");
            if (this._zoomAnimated) {
              addClass(el, "leaflet-zoom-animated");
            }
            if (this.options.className) {
              addClass(el, this.options.className);
            }
            el.onselectstart = falseFn;
            el.onmousemove = falseFn;
          }
          // @method getElement(): SVGElement
          // Returns the instance of [`SVGElement`](https://developer.mozilla.org/docs/Web/API/SVGElement)
          // used by this overlay.
        });
        function svgOverlay(el, bounds, options) {
          return new SVGOverlay(el, bounds, options);
        }
        __name(svgOverlay, "svgOverlay");
        var DivOverlay = Layer.extend({
          // @section
          // @aka DivOverlay options
          options: {
            // @option interactive: Boolean = false
            // If true, the popup/tooltip will listen to the mouse events.
            interactive: false,
            // @option offset: Point = Point(0, 0)
            // The offset of the overlay position.
            offset: [0, 0],
            // @option className: String = ''
            // A custom CSS class name to assign to the overlay.
            className: "",
            // @option pane: String = undefined
            // `Map pane` where the overlay will be added.
            pane: void 0,
            // @option content: String|HTMLElement|Function = ''
            // Sets the HTML content of the overlay while initializing. If a function is passed the source layer will be
            // passed to the function. The function should return a `String` or `HTMLElement` to be used in the overlay.
            content: ""
          },
          initialize: function(options, source) {
            if (options && (options instanceof LatLng || isArray2(options))) {
              this._latlng = toLatLng(options);
              setOptions(this, source);
            } else {
              setOptions(this, options);
              this._source = source;
            }
            if (this.options.content) {
              this._content = this.options.content;
            }
          },
          // @method openOn(map: Map): this
          // Adds the overlay to the map.
          // Alternative to `map.openPopup(popup)`/`.openTooltip(tooltip)`.
          openOn: function(map2) {
            map2 = arguments.length ? map2 : this._source._map;
            if (!map2.hasLayer(this)) {
              map2.addLayer(this);
            }
            return this;
          },
          // @method close(): this
          // Closes the overlay.
          // Alternative to `map.closePopup(popup)`/`.closeTooltip(tooltip)`
          // and `layer.closePopup()`/`.closeTooltip()`.
          close: function() {
            if (this._map) {
              this._map.removeLayer(this);
            }
            return this;
          },
          // @method toggle(layer?: Layer): this
          // Opens or closes the overlay bound to layer depending on its current state.
          // Argument may be omitted only for overlay bound to layer.
          // Alternative to `layer.togglePopup()`/`.toggleTooltip()`.
          toggle: function(layer) {
            if (this._map) {
              this.close();
            } else {
              if (arguments.length) {
                this._source = layer;
              } else {
                layer = this._source;
              }
              this._prepareOpen();
              this.openOn(layer._map);
            }
            return this;
          },
          onAdd: function(map2) {
            this._zoomAnimated = map2._zoomAnimated;
            if (!this._container) {
              this._initLayout();
            }
            if (map2._fadeAnimated) {
              setOpacity(this._container, 0);
            }
            clearTimeout(this._removeTimeout);
            this.getPane().appendChild(this._container);
            this.update();
            if (map2._fadeAnimated) {
              setOpacity(this._container, 1);
            }
            this.bringToFront();
            if (this.options.interactive) {
              addClass(this._container, "leaflet-interactive");
              this.addInteractiveTarget(this._container);
            }
          },
          onRemove: function(map2) {
            if (map2._fadeAnimated) {
              setOpacity(this._container, 0);
              this._removeTimeout = setTimeout(bind(remove, void 0, this._container), 200);
            } else {
              remove(this._container);
            }
            if (this.options.interactive) {
              removeClass(this._container, "leaflet-interactive");
              this.removeInteractiveTarget(this._container);
            }
          },
          // @namespace DivOverlay
          // @method getLatLng: LatLng
          // Returns the geographical point of the overlay.
          getLatLng: function() {
            return this._latlng;
          },
          // @method setLatLng(latlng: LatLng): this
          // Sets the geographical point where the overlay will open.
          setLatLng: function(latlng) {
            this._latlng = toLatLng(latlng);
            if (this._map) {
              this._updatePosition();
              this._adjustPan();
            }
            return this;
          },
          // @method getContent: String|HTMLElement
          // Returns the content of the overlay.
          getContent: function() {
            return this._content;
          },
          // @method setContent(htmlContent: String|HTMLElement|Function): this
          // Sets the HTML content of the overlay. If a function is passed the source layer will be passed to the function.
          // The function should return a `String` or `HTMLElement` to be used in the overlay.
          setContent: function(content) {
            this._content = content;
            this.update();
            return this;
          },
          // @method getElement: String|HTMLElement
          // Returns the HTML container of the overlay.
          getElement: function() {
            return this._container;
          },
          // @method update: null
          // Updates the overlay content, layout and position. Useful for updating the overlay after something inside changed, e.g. image loaded.
          update: function() {
            if (!this._map) {
              return;
            }
            this._container.style.visibility = "hidden";
            this._updateContent();
            this._updateLayout();
            this._updatePosition();
            this._container.style.visibility = "";
            this._adjustPan();
          },
          getEvents: function() {
            var events = {
              zoom: this._updatePosition,
              viewreset: this._updatePosition
            };
            if (this._zoomAnimated) {
              events.zoomanim = this._animateZoom;
            }
            return events;
          },
          // @method isOpen: Boolean
          // Returns `true` when the overlay is visible on the map.
          isOpen: function() {
            return !!this._map && this._map.hasLayer(this);
          },
          // @method bringToFront: this
          // Brings this overlay in front of other overlays (in the same map pane).
          bringToFront: function() {
            if (this._map) {
              toFront(this._container);
            }
            return this;
          },
          // @method bringToBack: this
          // Brings this overlay to the back of other overlays (in the same map pane).
          bringToBack: function() {
            if (this._map) {
              toBack(this._container);
            }
            return this;
          },
          // prepare bound overlay to open: update latlng pos / content source (for FeatureGroup)
          _prepareOpen: function(latlng) {
            var source = this._source;
            if (!source._map) {
              return false;
            }
            if (source instanceof FeatureGroup) {
              source = null;
              var layers2 = this._source._layers;
              for (var id in layers2) {
                if (layers2[id]._map) {
                  source = layers2[id];
                  break;
                }
              }
              if (!source) {
                return false;
              }
              this._source = source;
            }
            if (!latlng) {
              if (source.getCenter) {
                latlng = source.getCenter();
              } else if (source.getLatLng) {
                latlng = source.getLatLng();
              } else if (source.getBounds) {
                latlng = source.getBounds().getCenter();
              } else {
                throw new Error("Unable to get source layer LatLng.");
              }
            }
            this.setLatLng(latlng);
            if (this._map) {
              this.update();
            }
            return true;
          },
          _updateContent: function() {
            if (!this._content) {
              return;
            }
            var node = this._contentNode;
            var content = typeof this._content === "function" ? this._content(this._source || this) : this._content;
            if (typeof content === "string") {
              node.innerHTML = content;
            } else {
              while (node.hasChildNodes()) {
                node.removeChild(node.firstChild);
              }
              node.appendChild(content);
            }
            this.fire("contentupdate");
          },
          _updatePosition: function() {
            if (!this._map) {
              return;
            }
            var pos = this._map.latLngToLayerPoint(this._latlng), offset = toPoint(this.options.offset), anchor = this._getAnchor();
            if (this._zoomAnimated) {
              setPosition(this._container, pos.add(anchor));
            } else {
              offset = offset.add(pos).add(anchor);
            }
            var bottom = this._containerBottom = -offset.y, left = this._containerLeft = -Math.round(this._containerWidth / 2) + offset.x;
            this._container.style.bottom = bottom + "px";
            this._container.style.left = left + "px";
          },
          _getAnchor: function() {
            return [0, 0];
          }
        });
        Map3.include({
          _initOverlay: function(OverlayClass, content, latlng, options) {
            var overlay = content;
            if (!(overlay instanceof OverlayClass)) {
              overlay = new OverlayClass(options).setContent(content);
            }
            if (latlng) {
              overlay.setLatLng(latlng);
            }
            return overlay;
          }
        });
        Layer.include({
          _initOverlay: function(OverlayClass, old, content, options) {
            var overlay = content;
            if (overlay instanceof OverlayClass) {
              setOptions(overlay, options);
              overlay._source = this;
            } else {
              overlay = old && !options ? old : new OverlayClass(options, this);
              overlay.setContent(content);
            }
            return overlay;
          }
        });
        var Popup = DivOverlay.extend({
          // @section
          // @aka Popup options
          options: {
            // @option pane: String = 'popupPane'
            // `Map pane` where the popup will be added.
            pane: "popupPane",
            // @option offset: Point = Point(0, 7)
            // The offset of the popup position.
            offset: [0, 7],
            // @option maxWidth: Number = 300
            // Max width of the popup, in pixels.
            maxWidth: 300,
            // @option minWidth: Number = 50
            // Min width of the popup, in pixels.
            minWidth: 50,
            // @option maxHeight: Number = null
            // If set, creates a scrollable container of the given height
            // inside a popup if its content exceeds it.
            // The scrollable container can be styled using the
            // `leaflet-popup-scrolled` CSS class selector.
            maxHeight: null,
            // @option autoPan: Boolean = true
            // Set it to `false` if you don't want the map to do panning animation
            // to fit the opened popup.
            autoPan: true,
            // @option autoPanPaddingTopLeft: Point = null
            // The margin between the popup and the top left corner of the map
            // view after autopanning was performed.
            autoPanPaddingTopLeft: null,
            // @option autoPanPaddingBottomRight: Point = null
            // The margin between the popup and the bottom right corner of the map
            // view after autopanning was performed.
            autoPanPaddingBottomRight: null,
            // @option autoPanPadding: Point = Point(5, 5)
            // Equivalent of setting both top left and bottom right autopan padding to the same value.
            autoPanPadding: [5, 5],
            // @option keepInView: Boolean = false
            // Set it to `true` if you want to prevent users from panning the popup
            // off of the screen while it is open.
            keepInView: false,
            // @option closeButton: Boolean = true
            // Controls the presence of a close button in the popup.
            closeButton: true,
            // @option autoClose: Boolean = true
            // Set it to `false` if you want to override the default behavior of
            // the popup closing when another popup is opened.
            autoClose: true,
            // @option closeOnEscapeKey: Boolean = true
            // Set it to `false` if you want to override the default behavior of
            // the ESC key for closing of the popup.
            closeOnEscapeKey: true,
            // @option closeOnClick: Boolean = *
            // Set it if you want to override the default behavior of the popup closing when user clicks
            // on the map. Defaults to the map's [`closePopupOnClick`](#map-closepopuponclick) option.
            // @option className: String = ''
            // A custom CSS class name to assign to the popup.
            className: ""
          },
          // @namespace Popup
          // @method openOn(map: Map): this
          // Alternative to `map.openPopup(popup)`.
          // Adds the popup to the map and closes the previous one.
          openOn: function(map2) {
            map2 = arguments.length ? map2 : this._source._map;
            if (!map2.hasLayer(this) && map2._popup && map2._popup.options.autoClose) {
              map2.removeLayer(map2._popup);
            }
            map2._popup = this;
            return DivOverlay.prototype.openOn.call(this, map2);
          },
          onAdd: function(map2) {
            DivOverlay.prototype.onAdd.call(this, map2);
            map2.fire("popupopen", { popup: this });
            if (this._source) {
              this._source.fire("popupopen", { popup: this }, true);
              if (!(this._source instanceof Path)) {
                this._source.on("preclick", stopPropagation);
              }
            }
          },
          onRemove: function(map2) {
            DivOverlay.prototype.onRemove.call(this, map2);
            map2.fire("popupclose", { popup: this });
            if (this._source) {
              this._source.fire("popupclose", { popup: this }, true);
              if (!(this._source instanceof Path)) {
                this._source.off("preclick", stopPropagation);
              }
            }
          },
          getEvents: function() {
            var events = DivOverlay.prototype.getEvents.call(this);
            if (this.options.closeOnClick !== void 0 ? this.options.closeOnClick : this._map.options.closePopupOnClick) {
              events.preclick = this.close;
            }
            if (this.options.keepInView) {
              events.moveend = this._adjustPan;
            }
            return events;
          },
          _initLayout: function() {
            var prefix = "leaflet-popup", container = this._container = create$1(
              "div",
              prefix + " " + (this.options.className || "") + " leaflet-zoom-animated"
            );
            var wrapper = this._wrapper = create$1("div", prefix + "-content-wrapper", container);
            this._contentNode = create$1("div", prefix + "-content", wrapper);
            disableClickPropagation(container);
            disableScrollPropagation(this._contentNode);
            on2(container, "contextmenu", stopPropagation);
            this._tipContainer = create$1("div", prefix + "-tip-container", container);
            this._tip = create$1("div", prefix + "-tip", this._tipContainer);
            if (this.options.closeButton) {
              var closeButton = this._closeButton = create$1("a", prefix + "-close-button", container);
              closeButton.setAttribute("role", "button");
              closeButton.setAttribute("aria-label", "Close popup");
              closeButton.href = "#close";
              closeButton.innerHTML = '<span aria-hidden="true">&#215;</span>';
              on2(closeButton, "click", function(ev) {
                preventDefault(ev);
                this.close();
              }, this);
            }
          },
          _updateLayout: function() {
            var container = this._contentNode, style2 = container.style;
            style2.width = "";
            style2.whiteSpace = "nowrap";
            var width = container.offsetWidth;
            width = Math.min(width, this.options.maxWidth);
            width = Math.max(width, this.options.minWidth);
            style2.width = width + 1 + "px";
            style2.whiteSpace = "";
            style2.height = "";
            var height = container.offsetHeight, maxHeight = this.options.maxHeight, scrolledClass = "leaflet-popup-scrolled";
            if (maxHeight && height > maxHeight) {
              style2.height = maxHeight + "px";
              addClass(container, scrolledClass);
            } else {
              removeClass(container, scrolledClass);
            }
            this._containerWidth = this._container.offsetWidth;
          },
          _animateZoom: function(e3) {
            var pos = this._map._latLngToNewLayerPoint(this._latlng, e3.zoom, e3.center), anchor = this._getAnchor();
            setPosition(this._container, pos.add(anchor));
          },
          _adjustPan: function() {
            if (!this.options.autoPan) {
              return;
            }
            if (this._map._panAnim) {
              this._map._panAnim.stop();
            }
            if (this._autopanning) {
              this._autopanning = false;
              return;
            }
            var map2 = this._map, marginBottom = parseInt(getStyle(this._container, "marginBottom"), 10) || 0, containerHeight = this._container.offsetHeight + marginBottom, containerWidth = this._containerWidth, layerPos = new Point(this._containerLeft, -containerHeight - this._containerBottom);
            layerPos._add(getPosition(this._container));
            var containerPos = map2.layerPointToContainerPoint(layerPos), padding = toPoint(this.options.autoPanPadding), paddingTL = toPoint(this.options.autoPanPaddingTopLeft || padding), paddingBR = toPoint(this.options.autoPanPaddingBottomRight || padding), size = map2.getSize(), dx = 0, dy = 0;
            if (containerPos.x + containerWidth + paddingBR.x > size.x) {
              dx = containerPos.x + containerWidth - size.x + paddingBR.x;
            }
            if (containerPos.x - dx - paddingTL.x < 0) {
              dx = containerPos.x - paddingTL.x;
            }
            if (containerPos.y + containerHeight + paddingBR.y > size.y) {
              dy = containerPos.y + containerHeight - size.y + paddingBR.y;
            }
            if (containerPos.y - dy - paddingTL.y < 0) {
              dy = containerPos.y - paddingTL.y;
            }
            if (dx || dy) {
              if (this.options.keepInView) {
                this._autopanning = true;
              }
              map2.fire("autopanstart").panBy([dx, dy]);
            }
          },
          _getAnchor: function() {
            return toPoint(this._source && this._source._getPopupAnchor ? this._source._getPopupAnchor() : [0, 0]);
          }
        });
        var popup = /* @__PURE__ */ __name(function(options, source) {
          return new Popup(options, source);
        }, "popup");
        Map3.mergeOptions({
          closePopupOnClick: true
        });
        Map3.include({
          // @method openPopup(popup: Popup): this
          // Opens the specified popup while closing the previously opened (to make sure only one is opened at one time for usability).
          // @alternative
          // @method openPopup(content: String|HTMLElement, latlng: LatLng, options?: Popup options): this
          // Creates a popup with the specified content and options and opens it in the given point on a map.
          openPopup: function(popup2, latlng, options) {
            this._initOverlay(Popup, popup2, latlng, options).openOn(this);
            return this;
          },
          // @method closePopup(popup?: Popup): this
          // Closes the popup previously opened with [openPopup](#map-openpopup) (or the given one).
          closePopup: function(popup2) {
            popup2 = arguments.length ? popup2 : this._popup;
            if (popup2) {
              popup2.close();
            }
            return this;
          }
        });
        Layer.include({
          // @method bindPopup(content: String|HTMLElement|Function|Popup, options?: Popup options): this
          // Binds a popup to the layer with the passed `content` and sets up the
          // necessary event listeners. If a `Function` is passed it will receive
          // the layer as the first argument and should return a `String` or `HTMLElement`.
          bindPopup: function(content, options) {
            this._popup = this._initOverlay(Popup, this._popup, content, options);
            if (!this._popupHandlersAdded) {
              this.on({
                click: this._openPopup,
                keypress: this._onKeyPress,
                remove: this.closePopup,
                move: this._movePopup
              });
              this._popupHandlersAdded = true;
            }
            return this;
          },
          // @method unbindPopup(): this
          // Removes the popup previously bound with `bindPopup`.
          unbindPopup: function() {
            if (this._popup) {
              this.off({
                click: this._openPopup,
                keypress: this._onKeyPress,
                remove: this.closePopup,
                move: this._movePopup
              });
              this._popupHandlersAdded = false;
              this._popup = null;
            }
            return this;
          },
          // @method openPopup(latlng?: LatLng): this
          // Opens the bound popup at the specified `latlng` or at the default popup anchor if no `latlng` is passed.
          openPopup: function(latlng) {
            if (this._popup) {
              if (!(this instanceof FeatureGroup)) {
                this._popup._source = this;
              }
              if (this._popup._prepareOpen(latlng || this._latlng)) {
                this._popup.openOn(this._map);
              }
            }
            return this;
          },
          // @method closePopup(): this
          // Closes the popup bound to this layer if it is open.
          closePopup: function() {
            if (this._popup) {
              this._popup.close();
            }
            return this;
          },
          // @method togglePopup(): this
          // Opens or closes the popup bound to this layer depending on its current state.
          togglePopup: function() {
            if (this._popup) {
              this._popup.toggle(this);
            }
            return this;
          },
          // @method isPopupOpen(): boolean
          // Returns `true` if the popup bound to this layer is currently open.
          isPopupOpen: function() {
            return this._popup ? this._popup.isOpen() : false;
          },
          // @method setPopupContent(content: String|HTMLElement|Popup): this
          // Sets the content of the popup bound to this layer.
          setPopupContent: function(content) {
            if (this._popup) {
              this._popup.setContent(content);
            }
            return this;
          },
          // @method getPopup(): Popup
          // Returns the popup bound to this layer.
          getPopup: function() {
            return this._popup;
          },
          _openPopup: function(e3) {
            if (!this._popup || !this._map) {
              return;
            }
            stop(e3);
            var target = e3.layer || e3.target;
            if (this._popup._source === target && !(target instanceof Path)) {
              if (this._map.hasLayer(this._popup)) {
                this.closePopup();
              } else {
                this.openPopup(e3.latlng);
              }
              return;
            }
            this._popup._source = target;
            this.openPopup(e3.latlng);
          },
          _movePopup: function(e3) {
            this._popup.setLatLng(e3.latlng);
          },
          _onKeyPress: function(e3) {
            if (e3.originalEvent.keyCode === 13) {
              this._openPopup(e3);
            }
          }
        });
        var Tooltip2 = DivOverlay.extend({
          // @section
          // @aka Tooltip options
          options: {
            // @option pane: String = 'tooltipPane'
            // `Map pane` where the tooltip will be added.
            pane: "tooltipPane",
            // @option offset: Point = Point(0, 0)
            // Optional offset of the tooltip position.
            offset: [0, 0],
            // @option direction: String = 'auto'
            // Direction where to open the tooltip. Possible values are: `right`, `left`,
            // `top`, `bottom`, `center`, `auto`.
            // `auto` will dynamically switch between `right` and `left` according to the tooltip
            // position on the map.
            direction: "auto",
            // @option permanent: Boolean = false
            // Whether to open the tooltip permanently or only on mouseover.
            permanent: false,
            // @option sticky: Boolean = false
            // If true, the tooltip will follow the mouse instead of being fixed at the feature center.
            sticky: false,
            // @option opacity: Number = 0.9
            // Tooltip container opacity.
            opacity: 0.9
          },
          onAdd: function(map2) {
            DivOverlay.prototype.onAdd.call(this, map2);
            this.setOpacity(this.options.opacity);
            map2.fire("tooltipopen", { tooltip: this });
            if (this._source) {
              this.addEventParent(this._source);
              this._source.fire("tooltipopen", { tooltip: this }, true);
            }
          },
          onRemove: function(map2) {
            DivOverlay.prototype.onRemove.call(this, map2);
            map2.fire("tooltipclose", { tooltip: this });
            if (this._source) {
              this.removeEventParent(this._source);
              this._source.fire("tooltipclose", { tooltip: this }, true);
            }
          },
          getEvents: function() {
            var events = DivOverlay.prototype.getEvents.call(this);
            if (!this.options.permanent) {
              events.preclick = this.close;
            }
            return events;
          },
          _initLayout: function() {
            var prefix = "leaflet-tooltip", className = prefix + " " + (this.options.className || "") + " leaflet-zoom-" + (this._zoomAnimated ? "animated" : "hide");
            this._contentNode = this._container = create$1("div", className);
            this._container.setAttribute("role", "tooltip");
            this._container.setAttribute("id", "leaflet-tooltip-" + stamp(this));
          },
          _updateLayout: function() {
          },
          _adjustPan: function() {
          },
          _setPosition: function(pos) {
            var subX, subY, map2 = this._map, container = this._container, centerPoint = map2.latLngToContainerPoint(map2.getCenter()), tooltipPoint = map2.layerPointToContainerPoint(pos), direction = this.options.direction, tooltipWidth = container.offsetWidth, tooltipHeight = container.offsetHeight, offset = toPoint(this.options.offset), anchor = this._getAnchor();
            if (direction === "top") {
              subX = tooltipWidth / 2;
              subY = tooltipHeight;
            } else if (direction === "bottom") {
              subX = tooltipWidth / 2;
              subY = 0;
            } else if (direction === "center") {
              subX = tooltipWidth / 2;
              subY = tooltipHeight / 2;
            } else if (direction === "right") {
              subX = 0;
              subY = tooltipHeight / 2;
            } else if (direction === "left") {
              subX = tooltipWidth;
              subY = tooltipHeight / 2;
            } else if (tooltipPoint.x < centerPoint.x) {
              direction = "right";
              subX = 0;
              subY = tooltipHeight / 2;
            } else {
              direction = "left";
              subX = tooltipWidth + (offset.x + anchor.x) * 2;
              subY = tooltipHeight / 2;
            }
            pos = pos.subtract(toPoint(subX, subY, true)).add(offset).add(anchor);
            removeClass(container, "leaflet-tooltip-right");
            removeClass(container, "leaflet-tooltip-left");
            removeClass(container, "leaflet-tooltip-top");
            removeClass(container, "leaflet-tooltip-bottom");
            addClass(container, "leaflet-tooltip-" + direction);
            setPosition(container, pos);
          },
          _updatePosition: function() {
            var pos = this._map.latLngToLayerPoint(this._latlng);
            this._setPosition(pos);
          },
          setOpacity: function(opacity) {
            this.options.opacity = opacity;
            if (this._container) {
              setOpacity(this._container, opacity);
            }
          },
          _animateZoom: function(e3) {
            var pos = this._map._latLngToNewLayerPoint(this._latlng, e3.zoom, e3.center);
            this._setPosition(pos);
          },
          _getAnchor: function() {
            return toPoint(this._source && this._source._getTooltipAnchor && !this.options.sticky ? this._source._getTooltipAnchor() : [0, 0]);
          }
        });
        var tooltip = /* @__PURE__ */ __name(function(options, source) {
          return new Tooltip2(options, source);
        }, "tooltip");
        Map3.include({
          // @method openTooltip(tooltip: Tooltip): this
          // Opens the specified tooltip.
          // @alternative
          // @method openTooltip(content: String|HTMLElement, latlng: LatLng, options?: Tooltip options): this
          // Creates a tooltip with the specified content and options and open it.
          openTooltip: function(tooltip2, latlng, options) {
            this._initOverlay(Tooltip2, tooltip2, latlng, options).openOn(this);
            return this;
          },
          // @method closeTooltip(tooltip: Tooltip): this
          // Closes the tooltip given as parameter.
          closeTooltip: function(tooltip2) {
            tooltip2.close();
            return this;
          }
        });
        Layer.include({
          // @method bindTooltip(content: String|HTMLElement|Function|Tooltip, options?: Tooltip options): this
          // Binds a tooltip to the layer with the passed `content` and sets up the
          // necessary event listeners. If a `Function` is passed it will receive
          // the layer as the first argument and should return a `String` or `HTMLElement`.
          bindTooltip: function(content, options) {
            if (this._tooltip && this.isTooltipOpen()) {
              this.unbindTooltip();
            }
            this._tooltip = this._initOverlay(Tooltip2, this._tooltip, content, options);
            this._initTooltipInteractions();
            if (this._tooltip.options.permanent && this._map && this._map.hasLayer(this)) {
              this.openTooltip();
            }
            return this;
          },
          // @method unbindTooltip(): this
          // Removes the tooltip previously bound with `bindTooltip`.
          unbindTooltip: function() {
            if (this._tooltip) {
              this._initTooltipInteractions(true);
              this.closeTooltip();
              this._tooltip = null;
            }
            return this;
          },
          _initTooltipInteractions: function(remove2) {
            if (!remove2 && this._tooltipHandlersAdded) {
              return;
            }
            var onOff = remove2 ? "off" : "on", events = {
              remove: this.closeTooltip,
              move: this._moveTooltip
            };
            if (!this._tooltip.options.permanent) {
              events.mouseover = this._openTooltip;
              events.mouseout = this.closeTooltip;
              events.click = this._openTooltip;
              if (this._map) {
                this._addFocusListeners();
              } else {
                events.add = this._addFocusListeners;
              }
            } else {
              events.add = this._openTooltip;
            }
            if (this._tooltip.options.sticky) {
              events.mousemove = this._moveTooltip;
            }
            this[onOff](events);
            this._tooltipHandlersAdded = !remove2;
          },
          // @method openTooltip(latlng?: LatLng): this
          // Opens the bound tooltip at the specified `latlng` or at the default tooltip anchor if no `latlng` is passed.
          openTooltip: function(latlng) {
            if (this._tooltip) {
              if (!(this instanceof FeatureGroup)) {
                this._tooltip._source = this;
              }
              if (this._tooltip._prepareOpen(latlng)) {
                this._tooltip.openOn(this._map);
                if (this.getElement) {
                  this._setAriaDescribedByOnLayer(this);
                } else if (this.eachLayer) {
                  this.eachLayer(this._setAriaDescribedByOnLayer, this);
                }
              }
            }
            return this;
          },
          // @method closeTooltip(): this
          // Closes the tooltip bound to this layer if it is open.
          closeTooltip: function() {
            if (this._tooltip) {
              return this._tooltip.close();
            }
          },
          // @method toggleTooltip(): this
          // Opens or closes the tooltip bound to this layer depending on its current state.
          toggleTooltip: function() {
            if (this._tooltip) {
              this._tooltip.toggle(this);
            }
            return this;
          },
          // @method isTooltipOpen(): boolean
          // Returns `true` if the tooltip bound to this layer is currently open.
          isTooltipOpen: function() {
            return this._tooltip.isOpen();
          },
          // @method setTooltipContent(content: String|HTMLElement|Tooltip): this
          // Sets the content of the tooltip bound to this layer.
          setTooltipContent: function(content) {
            if (this._tooltip) {
              this._tooltip.setContent(content);
            }
            return this;
          },
          // @method getTooltip(): Tooltip
          // Returns the tooltip bound to this layer.
          getTooltip: function() {
            return this._tooltip;
          },
          _addFocusListeners: function() {
            if (this.getElement) {
              this._addFocusListenersOnLayer(this);
            } else if (this.eachLayer) {
              this.eachLayer(this._addFocusListenersOnLayer, this);
            }
          },
          _addFocusListenersOnLayer: function(layer) {
            var el = typeof layer.getElement === "function" && layer.getElement();
            if (el) {
              on2(el, "focus", function() {
                this._tooltip._source = layer;
                this.openTooltip();
              }, this);
              on2(el, "blur", this.closeTooltip, this);
            }
          },
          _setAriaDescribedByOnLayer: function(layer) {
            var el = typeof layer.getElement === "function" && layer.getElement();
            if (el) {
              el.setAttribute("aria-describedby", this._tooltip._container.id);
            }
          },
          _openTooltip: function(e3) {
            if (!this._tooltip || !this._map) {
              return;
            }
            if (this._map.dragging && this._map.dragging.moving() && !this._openOnceFlag) {
              this._openOnceFlag = true;
              var that = this;
              this._map.once("moveend", function() {
                that._openOnceFlag = false;
                that._openTooltip(e3);
              });
              return;
            }
            this._tooltip._source = e3.layer || e3.target;
            this.openTooltip(this._tooltip.options.sticky ? e3.latlng : void 0);
          },
          _moveTooltip: function(e3) {
            var latlng = e3.latlng, containerPoint, layerPoint;
            if (this._tooltip.options.sticky && e3.originalEvent) {
              containerPoint = this._map.mouseEventToContainerPoint(e3.originalEvent);
              layerPoint = this._map.containerPointToLayerPoint(containerPoint);
              latlng = this._map.layerPointToLatLng(layerPoint);
            }
            this._tooltip.setLatLng(latlng);
          }
        });
        var DivIcon = Icon.extend({
          options: {
            // @section
            // @aka DivIcon options
            iconSize: [12, 12],
            // also can be set through CSS
            // iconAnchor: (Point),
            // popupAnchor: (Point),
            // @option html: String|HTMLElement = ''
            // Custom HTML code to put inside the div element, empty by default. Alternatively,
            // an instance of `HTMLElement`.
            html: false,
            // @option bgPos: Point = [0, 0]
            // Optional relative position of the background, in pixels
            bgPos: null,
            className: "leaflet-div-icon"
          },
          createIcon: function(oldIcon) {
            var div = oldIcon && oldIcon.tagName === "DIV" ? oldIcon : document.createElement("div"), options = this.options;
            if (options.html instanceof Element) {
              empty(div);
              div.appendChild(options.html);
            } else {
              div.innerHTML = options.html !== false ? options.html : "";
            }
            if (options.bgPos) {
              var bgPos = toPoint(options.bgPos);
              div.style.backgroundPosition = -bgPos.x + "px " + -bgPos.y + "px";
            }
            this._setIconStyles(div, "icon");
            return div;
          },
          createShadow: function() {
            return null;
          }
        });
        function divIcon(options) {
          return new DivIcon(options);
        }
        __name(divIcon, "divIcon");
        Icon.Default = IconDefault;
        var GridLayer = Layer.extend({
          // @section
          // @aka GridLayer options
          options: {
            // @option tileSize: Number|Point = 256
            // Width and height of tiles in the grid. Use a number if width and height are equal, or `L.point(width, height)` otherwise.
            tileSize: 256,
            // @option opacity: Number = 1.0
            // Opacity of the tiles. Can be used in the `createTile()` function.
            opacity: 1,
            // @option updateWhenIdle: Boolean = (depends)
            // Load new tiles only when panning ends.
            // `true` by default on mobile browsers, in order to avoid too many requests and keep smooth navigation.
            // `false` otherwise in order to display new tiles _during_ panning, since it is easy to pan outside the
            // [`keepBuffer`](#gridlayer-keepbuffer) option in desktop browsers.
            updateWhenIdle: Browser.mobile,
            // @option updateWhenZooming: Boolean = true
            // By default, a smooth zoom animation (during a [touch zoom](#map-touchzoom) or a [`flyTo()`](#map-flyto)) will update grid layers every integer zoom level. Setting this option to `false` will update the grid layer only when the smooth animation ends.
            updateWhenZooming: true,
            // @option updateInterval: Number = 200
            // Tiles will not update more than once every `updateInterval` milliseconds when panning.
            updateInterval: 200,
            // @option zIndex: Number = 1
            // The explicit zIndex of the tile layer.
            zIndex: 1,
            // @option bounds: LatLngBounds = undefined
            // If set, tiles will only be loaded inside the set `LatLngBounds`.
            bounds: null,
            // @option minZoom: Number = 0
            // The minimum zoom level down to which this layer will be displayed (inclusive).
            minZoom: 0,
            // @option maxZoom: Number = undefined
            // The maximum zoom level up to which this layer will be displayed (inclusive).
            maxZoom: void 0,
            // @option maxNativeZoom: Number = undefined
            // Maximum zoom number the tile source has available. If it is specified,
            // the tiles on all zoom levels higher than `maxNativeZoom` will be loaded
            // from `maxNativeZoom` level and auto-scaled.
            maxNativeZoom: void 0,
            // @option minNativeZoom: Number = undefined
            // Minimum zoom number the tile source has available. If it is specified,
            // the tiles on all zoom levels lower than `minNativeZoom` will be loaded
            // from `minNativeZoom` level and auto-scaled.
            minNativeZoom: void 0,
            // @option noWrap: Boolean = false
            // Whether the layer is wrapped around the antimeridian. If `true`, the
            // GridLayer will only be displayed once at low zoom levels. Has no
            // effect when the [map CRS](#map-crs) doesn't wrap around. Can be used
            // in combination with [`bounds`](#gridlayer-bounds) to prevent requesting
            // tiles outside the CRS limits.
            noWrap: false,
            // @option pane: String = 'tilePane'
            // `Map pane` where the grid layer will be added.
            pane: "tilePane",
            // @option className: String = ''
            // A custom class name to assign to the tile layer. Empty by default.
            className: "",
            // @option keepBuffer: Number = 2
            // When panning the map, keep this many rows and columns of tiles before unloading them.
            keepBuffer: 2
          },
          initialize: function(options) {
            setOptions(this, options);
          },
          onAdd: function() {
            this._initContainer();
            this._levels = {};
            this._tiles = {};
            this._resetView();
          },
          beforeAdd: function(map2) {
            map2._addZoomLimit(this);
          },
          onRemove: function(map2) {
            this._removeAllTiles();
            remove(this._container);
            map2._removeZoomLimit(this);
            this._container = null;
            this._tileZoom = void 0;
          },
          // @method bringToFront: this
          // Brings the tile layer to the top of all tile layers.
          bringToFront: function() {
            if (this._map) {
              toFront(this._container);
              this._setAutoZIndex(Math.max);
            }
            return this;
          },
          // @method bringToBack: this
          // Brings the tile layer to the bottom of all tile layers.
          bringToBack: function() {
            if (this._map) {
              toBack(this._container);
              this._setAutoZIndex(Math.min);
            }
            return this;
          },
          // @method getContainer: HTMLElement
          // Returns the HTML element that contains the tiles for this layer.
          getContainer: function() {
            return this._container;
          },
          // @method setOpacity(opacity: Number): this
          // Changes the [opacity](#gridlayer-opacity) of the grid layer.
          setOpacity: function(opacity) {
            this.options.opacity = opacity;
            this._updateOpacity();
            return this;
          },
          // @method setZIndex(zIndex: Number): this
          // Changes the [zIndex](#gridlayer-zindex) of the grid layer.
          setZIndex: function(zIndex) {
            this.options.zIndex = zIndex;
            this._updateZIndex();
            return this;
          },
          // @method isLoading: Boolean
          // Returns `true` if any tile in the grid layer has not finished loading.
          isLoading: function() {
            return this._loading;
          },
          // @method redraw: this
          // Causes the layer to clear all the tiles and request them again.
          redraw: function() {
            if (this._map) {
              this._removeAllTiles();
              var tileZoom = this._clampZoom(this._map.getZoom());
              if (tileZoom !== this._tileZoom) {
                this._tileZoom = tileZoom;
                this._updateLevels();
              }
              this._update();
            }
            return this;
          },
          getEvents: function() {
            var events = {
              viewprereset: this._invalidateAll,
              viewreset: this._resetView,
              zoom: this._resetView,
              moveend: this._onMoveEnd
            };
            if (!this.options.updateWhenIdle) {
              if (!this._onMove) {
                this._onMove = throttle2(this._onMoveEnd, this.options.updateInterval, this);
              }
              events.move = this._onMove;
            }
            if (this._zoomAnimated) {
              events.zoomanim = this._animateZoom;
            }
            return events;
          },
          // @section Extension methods
          // Layers extending `GridLayer` shall reimplement the following method.
          // @method createTile(coords: Object, done?: Function): HTMLElement
          // Called only internally, must be overridden by classes extending `GridLayer`.
          // Returns the `HTMLElement` corresponding to the given `coords`. If the `done` callback
          // is specified, it must be called when the tile has finished loading and drawing.
          createTile: function() {
            return document.createElement("div");
          },
          // @section
          // @method getTileSize: Point
          // Normalizes the [tileSize option](#gridlayer-tilesize) into a point. Used by the `createTile()` method.
          getTileSize: function() {
            var s3 = this.options.tileSize;
            return s3 instanceof Point ? s3 : new Point(s3, s3);
          },
          _updateZIndex: function() {
            if (this._container && this.options.zIndex !== void 0 && this.options.zIndex !== null) {
              this._container.style.zIndex = this.options.zIndex;
            }
          },
          _setAutoZIndex: function(compare) {
            var layers2 = this.getPane().children, edgeZIndex = -compare(-Infinity, Infinity);
            for (var i3 = 0, len = layers2.length, zIndex; i3 < len; i3++) {
              zIndex = layers2[i3].style.zIndex;
              if (layers2[i3] !== this._container && zIndex) {
                edgeZIndex = compare(edgeZIndex, +zIndex);
              }
            }
            if (isFinite(edgeZIndex)) {
              this.options.zIndex = edgeZIndex + compare(-1, 1);
              this._updateZIndex();
            }
          },
          _updateOpacity: function() {
            if (!this._map) {
              return;
            }
            if (Browser.ielt9) {
              return;
            }
            setOpacity(this._container, this.options.opacity);
            var now2 = +/* @__PURE__ */ new Date(), nextFrame = false, willPrune = false;
            for (var key in this._tiles) {
              var tile = this._tiles[key];
              if (!tile.current || !tile.loaded) {
                continue;
              }
              var fade = Math.min(1, (now2 - tile.loaded) / 200);
              setOpacity(tile.el, fade);
              if (fade < 1) {
                nextFrame = true;
              } else {
                if (tile.active) {
                  willPrune = true;
                } else {
                  this._onOpaqueTile(tile);
                }
                tile.active = true;
              }
            }
            if (willPrune && !this._noPrune) {
              this._pruneTiles();
            }
            if (nextFrame) {
              cancelAnimFrame(this._fadeFrame);
              this._fadeFrame = requestAnimFrame(this._updateOpacity, this);
            }
          },
          _onOpaqueTile: falseFn,
          _initContainer: function() {
            if (this._container) {
              return;
            }
            this._container = create$1("div", "leaflet-layer " + (this.options.className || ""));
            this._updateZIndex();
            if (this.options.opacity < 1) {
              this._updateOpacity();
            }
            this.getPane().appendChild(this._container);
          },
          _updateLevels: function() {
            var zoom2 = this._tileZoom, maxZoom = this.options.maxZoom;
            if (zoom2 === void 0) {
              return void 0;
            }
            for (var z3 in this._levels) {
              z3 = Number(z3);
              if (this._levels[z3].el.children.length || z3 === zoom2) {
                this._levels[z3].el.style.zIndex = maxZoom - Math.abs(zoom2 - z3);
                this._onUpdateLevel(z3);
              } else {
                remove(this._levels[z3].el);
                this._removeTilesAtZoom(z3);
                this._onRemoveLevel(z3);
                delete this._levels[z3];
              }
            }
            var level2 = this._levels[zoom2], map2 = this._map;
            if (!level2) {
              level2 = this._levels[zoom2] = {};
              level2.el = create$1("div", "leaflet-tile-container leaflet-zoom-animated", this._container);
              level2.el.style.zIndex = maxZoom;
              level2.origin = map2.project(map2.unproject(map2.getPixelOrigin()), zoom2).round();
              level2.zoom = zoom2;
              this._setZoomTransform(level2, map2.getCenter(), map2.getZoom());
              falseFn(level2.el.offsetWidth);
              this._onCreateLevel(level2);
            }
            this._level = level2;
            return level2;
          },
          _onUpdateLevel: falseFn,
          _onRemoveLevel: falseFn,
          _onCreateLevel: falseFn,
          _pruneTiles: function() {
            if (!this._map) {
              return;
            }
            var key, tile;
            var zoom2 = this._map.getZoom();
            if (zoom2 > this.options.maxZoom || zoom2 < this.options.minZoom) {
              this._removeAllTiles();
              return;
            }
            for (key in this._tiles) {
              tile = this._tiles[key];
              tile.retain = tile.current;
            }
            for (key in this._tiles) {
              tile = this._tiles[key];
              if (tile.current && !tile.active) {
                var coords = tile.coords;
                if (!this._retainParent(coords.x, coords.y, coords.z, coords.z - 5)) {
                  this._retainChildren(coords.x, coords.y, coords.z, coords.z + 2);
                }
              }
            }
            for (key in this._tiles) {
              if (!this._tiles[key].retain) {
                this._removeTile(key);
              }
            }
          },
          _removeTilesAtZoom: function(zoom2) {
            for (var key in this._tiles) {
              if (this._tiles[key].coords.z !== zoom2) {
                continue;
              }
              this._removeTile(key);
            }
          },
          _removeAllTiles: function() {
            for (var key in this._tiles) {
              this._removeTile(key);
            }
          },
          _invalidateAll: function() {
            for (var z3 in this._levels) {
              remove(this._levels[z3].el);
              this._onRemoveLevel(Number(z3));
              delete this._levels[z3];
            }
            this._removeAllTiles();
            this._tileZoom = void 0;
          },
          _retainParent: function(x3, y3, z3, minZoom) {
            var x22 = Math.floor(x3 / 2), y22 = Math.floor(y3 / 2), z22 = z3 - 1, coords2 = new Point(+x22, +y22);
            coords2.z = +z22;
            var key = this._tileCoordsToKey(coords2), tile = this._tiles[key];
            if (tile && tile.active) {
              tile.retain = true;
              return true;
            } else if (tile && tile.loaded) {
              tile.retain = true;
            }
            if (z22 > minZoom) {
              return this._retainParent(x22, y22, z22, minZoom);
            }
            return false;
          },
          _retainChildren: function(x3, y3, z3, maxZoom) {
            for (var i3 = 2 * x3; i3 < 2 * x3 + 2; i3++) {
              for (var j3 = 2 * y3; j3 < 2 * y3 + 2; j3++) {
                var coords = new Point(i3, j3);
                coords.z = z3 + 1;
                var key = this._tileCoordsToKey(coords), tile = this._tiles[key];
                if (tile && tile.active) {
                  tile.retain = true;
                  continue;
                } else if (tile && tile.loaded) {
                  tile.retain = true;
                }
                if (z3 + 1 < maxZoom) {
                  this._retainChildren(i3, j3, z3 + 1, maxZoom);
                }
              }
            }
          },
          _resetView: function(e3) {
            var animating = e3 && (e3.pinch || e3.flyTo);
            this._setView(this._map.getCenter(), this._map.getZoom(), animating, animating);
          },
          _animateZoom: function(e3) {
            this._setView(e3.center, e3.zoom, true, e3.noUpdate);
          },
          _clampZoom: function(zoom2) {
            var options = this.options;
            if (void 0 !== options.minNativeZoom && zoom2 < options.minNativeZoom) {
              return options.minNativeZoom;
            }
            if (void 0 !== options.maxNativeZoom && options.maxNativeZoom < zoom2) {
              return options.maxNativeZoom;
            }
            return zoom2;
          },
          _setView: function(center, zoom2, noPrune, noUpdate) {
            var tileZoom = Math.round(zoom2);
            if (this.options.maxZoom !== void 0 && tileZoom > this.options.maxZoom || this.options.minZoom !== void 0 && tileZoom < this.options.minZoom) {
              tileZoom = void 0;
            } else {
              tileZoom = this._clampZoom(tileZoom);
            }
            var tileZoomChanged = this.options.updateWhenZooming && tileZoom !== this._tileZoom;
            if (!noUpdate || tileZoomChanged) {
              this._tileZoom = tileZoom;
              if (this._abortLoading) {
                this._abortLoading();
              }
              this._updateLevels();
              this._resetGrid();
              if (tileZoom !== void 0) {
                this._update(center);
              }
              if (!noPrune) {
                this._pruneTiles();
              }
              this._noPrune = !!noPrune;
            }
            this._setZoomTransforms(center, zoom2);
          },
          _setZoomTransforms: function(center, zoom2) {
            for (var i3 in this._levels) {
              this._setZoomTransform(this._levels[i3], center, zoom2);
            }
          },
          _setZoomTransform: function(level2, center, zoom2) {
            var scale2 = this._map.getZoomScale(zoom2, level2.zoom), translate = level2.origin.multiplyBy(scale2).subtract(this._map._getNewPixelOrigin(center, zoom2)).round();
            if (Browser.any3d) {
              setTransform(level2.el, translate, scale2);
            } else {
              setPosition(level2.el, translate);
            }
          },
          _resetGrid: function() {
            var map2 = this._map, crs = map2.options.crs, tileSize = this._tileSize = this.getTileSize(), tileZoom = this._tileZoom;
            var bounds = this._map.getPixelWorldBounds(this._tileZoom);
            if (bounds) {
              this._globalTileRange = this._pxBoundsToTileRange(bounds);
            }
            this._wrapX = crs.wrapLng && !this.options.noWrap && [
              Math.floor(map2.project([0, crs.wrapLng[0]], tileZoom).x / tileSize.x),
              Math.ceil(map2.project([0, crs.wrapLng[1]], tileZoom).x / tileSize.y)
            ];
            this._wrapY = crs.wrapLat && !this.options.noWrap && [
              Math.floor(map2.project([crs.wrapLat[0], 0], tileZoom).y / tileSize.x),
              Math.ceil(map2.project([crs.wrapLat[1], 0], tileZoom).y / tileSize.y)
            ];
          },
          _onMoveEnd: function() {
            if (!this._map || this._map._animatingZoom) {
              return;
            }
            this._update();
          },
          _getTiledPixelBounds: function(center) {
            var map2 = this._map, mapZoom = map2._animatingZoom ? Math.max(map2._animateToZoom, map2.getZoom()) : map2.getZoom(), scale2 = map2.getZoomScale(mapZoom, this._tileZoom), pixelCenter = map2.project(center, this._tileZoom).floor(), halfSize = map2.getSize().divideBy(scale2 * 2);
            return new Bounds(pixelCenter.subtract(halfSize), pixelCenter.add(halfSize));
          },
          // Private method to load tiles in the grid's active zoom level according to map bounds
          _update: function(center) {
            var map2 = this._map;
            if (!map2) {
              return;
            }
            var zoom2 = this._clampZoom(map2.getZoom());
            if (center === void 0) {
              center = map2.getCenter();
            }
            if (this._tileZoom === void 0) {
              return;
            }
            var pixelBounds = this._getTiledPixelBounds(center), tileRange = this._pxBoundsToTileRange(pixelBounds), tileCenter = tileRange.getCenter(), queue = [], margin = this.options.keepBuffer, noPruneRange = new Bounds(
              tileRange.getBottomLeft().subtract([margin, -margin]),
              tileRange.getTopRight().add([margin, -margin])
            );
            if (!(isFinite(tileRange.min.x) && isFinite(tileRange.min.y) && isFinite(tileRange.max.x) && isFinite(tileRange.max.y))) {
              throw new Error("Attempted to load an infinite number of tiles");
            }
            for (var key in this._tiles) {
              var c3 = this._tiles[key].coords;
              if (c3.z !== this._tileZoom || !noPruneRange.contains(new Point(c3.x, c3.y))) {
                this._tiles[key].current = false;
              }
            }
            if (Math.abs(zoom2 - this._tileZoom) > 1) {
              this._setView(center, zoom2);
              return;
            }
            for (var j3 = tileRange.min.y; j3 <= tileRange.max.y; j3++) {
              for (var i3 = tileRange.min.x; i3 <= tileRange.max.x; i3++) {
                var coords = new Point(i3, j3);
                coords.z = this._tileZoom;
                if (!this._isValidTile(coords)) {
                  continue;
                }
                var tile = this._tiles[this._tileCoordsToKey(coords)];
                if (tile) {
                  tile.current = true;
                } else {
                  queue.push(coords);
                }
              }
            }
            queue.sort(function(a3, b3) {
              return a3.distanceTo(tileCenter) - b3.distanceTo(tileCenter);
            });
            if (queue.length !== 0) {
              if (!this._loading) {
                this._loading = true;
                this.fire("loading");
              }
              var fragment = document.createDocumentFragment();
              for (i3 = 0; i3 < queue.length; i3++) {
                this._addTile(queue[i3], fragment);
              }
              this._level.el.appendChild(fragment);
            }
          },
          _isValidTile: function(coords) {
            var crs = this._map.options.crs;
            if (!crs.infinite) {
              var bounds = this._globalTileRange;
              if (!crs.wrapLng && (coords.x < bounds.min.x || coords.x > bounds.max.x) || !crs.wrapLat && (coords.y < bounds.min.y || coords.y > bounds.max.y)) {
                return false;
              }
            }
            if (!this.options.bounds) {
              return true;
            }
            var tileBounds = this._tileCoordsToBounds(coords);
            return toLatLngBounds(this.options.bounds).overlaps(tileBounds);
          },
          _keyToBounds: function(key) {
            return this._tileCoordsToBounds(this._keyToTileCoords(key));
          },
          _tileCoordsToNwSe: function(coords) {
            var map2 = this._map, tileSize = this.getTileSize(), nwPoint = coords.scaleBy(tileSize), sePoint = nwPoint.add(tileSize), nw = map2.unproject(nwPoint, coords.z), se = map2.unproject(sePoint, coords.z);
            return [nw, se];
          },
          // converts tile coordinates to its geographical bounds
          _tileCoordsToBounds: function(coords) {
            var bp2 = this._tileCoordsToNwSe(coords), bounds = new LatLngBounds(bp2[0], bp2[1]);
            if (!this.options.noWrap) {
              bounds = this._map.wrapLatLngBounds(bounds);
            }
            return bounds;
          },
          // converts tile coordinates to key for the tile cache
          _tileCoordsToKey: function(coords) {
            return coords.x + ":" + coords.y + ":" + coords.z;
          },
          // converts tile cache key to coordinates
          _keyToTileCoords: function(key) {
            var k3 = key.split(":"), coords = new Point(+k3[0], +k3[1]);
            coords.z = +k3[2];
            return coords;
          },
          _removeTile: function(key) {
            var tile = this._tiles[key];
            if (!tile) {
              return;
            }
            remove(tile.el);
            delete this._tiles[key];
            this.fire("tileunload", {
              tile: tile.el,
              coords: this._keyToTileCoords(key)
            });
          },
          _initTile: function(tile) {
            addClass(tile, "leaflet-tile");
            var tileSize = this.getTileSize();
            tile.style.width = tileSize.x + "px";
            tile.style.height = tileSize.y + "px";
            tile.onselectstart = falseFn;
            tile.onmousemove = falseFn;
            if (Browser.ielt9 && this.options.opacity < 1) {
              setOpacity(tile, this.options.opacity);
            }
          },
          _addTile: function(coords, container) {
            var tilePos = this._getTilePos(coords), key = this._tileCoordsToKey(coords);
            var tile = this.createTile(this._wrapCoords(coords), bind(this._tileReady, this, coords));
            this._initTile(tile);
            if (this.createTile.length < 2) {
              requestAnimFrame(bind(this._tileReady, this, coords, null, tile));
            }
            setPosition(tile, tilePos);
            this._tiles[key] = {
              el: tile,
              coords,
              current: true
            };
            container.appendChild(tile);
            this.fire("tileloadstart", {
              tile,
              coords
            });
          },
          _tileReady: function(coords, err, tile) {
            if (err) {
              this.fire("tileerror", {
                error: err,
                tile,
                coords
              });
            }
            var key = this._tileCoordsToKey(coords);
            tile = this._tiles[key];
            if (!tile) {
              return;
            }
            tile.loaded = +/* @__PURE__ */ new Date();
            if (this._map._fadeAnimated) {
              setOpacity(tile.el, 0);
              cancelAnimFrame(this._fadeFrame);
              this._fadeFrame = requestAnimFrame(this._updateOpacity, this);
            } else {
              tile.active = true;
              this._pruneTiles();
            }
            if (!err) {
              addClass(tile.el, "leaflet-tile-loaded");
              this.fire("tileload", {
                tile: tile.el,
                coords
              });
            }
            if (this._noTilesToLoad()) {
              this._loading = false;
              this.fire("load");
              if (Browser.ielt9 || !this._map._fadeAnimated) {
                requestAnimFrame(this._pruneTiles, this);
              } else {
                setTimeout(bind(this._pruneTiles, this), 250);
              }
            }
          },
          _getTilePos: function(coords) {
            return coords.scaleBy(this.getTileSize()).subtract(this._level.origin);
          },
          _wrapCoords: function(coords) {
            var newCoords = new Point(
              this._wrapX ? wrapNum(coords.x, this._wrapX) : coords.x,
              this._wrapY ? wrapNum(coords.y, this._wrapY) : coords.y
            );
            newCoords.z = coords.z;
            return newCoords;
          },
          _pxBoundsToTileRange: function(bounds) {
            var tileSize = this.getTileSize();
            return new Bounds(
              bounds.min.unscaleBy(tileSize).floor(),
              bounds.max.unscaleBy(tileSize).ceil().subtract([1, 1])
            );
          },
          _noTilesToLoad: function() {
            for (var key in this._tiles) {
              if (!this._tiles[key].loaded) {
                return false;
              }
            }
            return true;
          }
        });
        function gridLayer(options) {
          return new GridLayer(options);
        }
        __name(gridLayer, "gridLayer");
        var TileLayer = GridLayer.extend({
          // @section
          // @aka TileLayer options
          options: {
            // @option minZoom: Number = 0
            // The minimum zoom level down to which this layer will be displayed (inclusive).
            minZoom: 0,
            // @option maxZoom: Number = 18
            // The maximum zoom level up to which this layer will be displayed (inclusive).
            maxZoom: 18,
            // @option subdomains: String|String[] = 'abc'
            // Subdomains of the tile service. Can be passed in the form of one string (where each letter is a subdomain name) or an array of strings.
            subdomains: "abc",
            // @option errorTileUrl: String = ''
            // URL to the tile image to show in place of the tile that failed to load.
            errorTileUrl: "",
            // @option zoomOffset: Number = 0
            // The zoom number used in tile URLs will be offset with this value.
            zoomOffset: 0,
            // @option tms: Boolean = false
            // If `true`, inverses Y axis numbering for tiles (turn this on for [TMS](https://en.wikipedia.org/wiki/Tile_Map_Service) services).
            tms: false,
            // @option zoomReverse: Boolean = false
            // If set to true, the zoom number used in tile URLs will be reversed (`maxZoom - zoom` instead of `zoom`)
            zoomReverse: false,
            // @option detectRetina: Boolean = false
            // If `true` and user is on a retina display, it will request four tiles of half the specified size and a bigger zoom level in place of one to utilize the high resolution.
            detectRetina: false,
            // @option crossOrigin: Boolean|String = false
            // Whether the crossOrigin attribute will be added to the tiles.
            // If a String is provided, all tiles will have their crossOrigin attribute set to the String provided. This is needed if you want to access tile pixel data.
            // Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.
            crossOrigin: false,
            // @option referrerPolicy: Boolean|String = false
            // Whether the referrerPolicy attribute will be added to the tiles.
            // If a String is provided, all tiles will have their referrerPolicy attribute set to the String provided.
            // This may be needed if your map's rendering context has a strict default but your tile provider expects a valid referrer
            // (e.g. to validate an API token).
            // Refer to [HTMLImageElement.referrerPolicy](https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/referrerPolicy) for valid String values.
            referrerPolicy: false
          },
          initialize: function(url, options) {
            this._url = url;
            options = setOptions(this, options);
            if (options.detectRetina && Browser.retina && options.maxZoom > 0) {
              options.tileSize = Math.floor(options.tileSize / 2);
              if (!options.zoomReverse) {
                options.zoomOffset++;
                options.maxZoom = Math.max(options.minZoom, options.maxZoom - 1);
              } else {
                options.zoomOffset--;
                options.minZoom = Math.min(options.maxZoom, options.minZoom + 1);
              }
              options.minZoom = Math.max(0, options.minZoom);
            } else if (!options.zoomReverse) {
              options.maxZoom = Math.max(options.minZoom, options.maxZoom);
            } else {
              options.minZoom = Math.min(options.maxZoom, options.minZoom);
            }
            if (typeof options.subdomains === "string") {
              options.subdomains = options.subdomains.split("");
            }
            this.on("tileunload", this._onTileRemove);
          },
          // @method setUrl(url: String, noRedraw?: Boolean): this
          // Updates the layer's URL template and redraws it (unless `noRedraw` is set to `true`).
          // If the URL does not change, the layer will not be redrawn unless
          // the noRedraw parameter is set to false.
          setUrl: function(url, noRedraw) {
            if (this._url === url && noRedraw === void 0) {
              noRedraw = true;
            }
            this._url = url;
            if (!noRedraw) {
              this.redraw();
            }
            return this;
          },
          // @method createTile(coords: Object, done?: Function): HTMLElement
          // Called only internally, overrides GridLayer's [`createTile()`](#gridlayer-createtile)
          // to return an `<img>` HTML element with the appropriate image URL given `coords`. The `done`
          // callback is called when the tile has been loaded.
          createTile: function(coords, done) {
            var tile = document.createElement("img");
            on2(tile, "load", bind(this._tileOnLoad, this, done, tile));
            on2(tile, "error", bind(this._tileOnError, this, done, tile));
            if (this.options.crossOrigin || this.options.crossOrigin === "") {
              tile.crossOrigin = this.options.crossOrigin === true ? "" : this.options.crossOrigin;
            }
            if (typeof this.options.referrerPolicy === "string") {
              tile.referrerPolicy = this.options.referrerPolicy;
            }
            tile.alt = "";
            tile.src = this.getTileUrl(coords);
            return tile;
          },
          // @section Extension methods
          // @uninheritable
          // Layers extending `TileLayer` might reimplement the following method.
          // @method getTileUrl(coords: Object): String
          // Called only internally, returns the URL for a tile given its coordinates.
          // Classes extending `TileLayer` can override this function to provide custom tile URL naming schemes.
          getTileUrl: function(coords) {
            var data = {
              r: Browser.retina ? "@2x" : "",
              s: this._getSubdomain(coords),
              x: coords.x,
              y: coords.y,
              z: this._getZoomForUrl()
            };
            if (this._map && !this._map.options.crs.infinite) {
              var invertedY = this._globalTileRange.max.y - coords.y;
              if (this.options.tms) {
                data["y"] = invertedY;
              }
              data["-y"] = invertedY;
            }
            return template(this._url, extend3(data, this.options));
          },
          _tileOnLoad: function(done, tile) {
            if (Browser.ielt9) {
              setTimeout(bind(done, this, null, tile), 0);
            } else {
              done(null, tile);
            }
          },
          _tileOnError: function(done, tile, e3) {
            var errorUrl = this.options.errorTileUrl;
            if (errorUrl && tile.getAttribute("src") !== errorUrl) {
              tile.src = errorUrl;
            }
            done(e3, tile);
          },
          _onTileRemove: function(e3) {
            e3.tile.onload = null;
          },
          _getZoomForUrl: function() {
            var zoom2 = this._tileZoom, maxZoom = this.options.maxZoom, zoomReverse = this.options.zoomReverse, zoomOffset = this.options.zoomOffset;
            if (zoomReverse) {
              zoom2 = maxZoom - zoom2;
            }
            return zoom2 + zoomOffset;
          },
          _getSubdomain: function(tilePoint) {
            var index3 = Math.abs(tilePoint.x + tilePoint.y) % this.options.subdomains.length;
            return this.options.subdomains[index3];
          },
          // stops loading all tiles in the background layer
          _abortLoading: function() {
            var i3, tile;
            for (i3 in this._tiles) {
              if (this._tiles[i3].coords.z !== this._tileZoom) {
                tile = this._tiles[i3].el;
                tile.onload = falseFn;
                tile.onerror = falseFn;
                if (!tile.complete) {
                  tile.src = emptyImageUrl;
                  var coords = this._tiles[i3].coords;
                  remove(tile);
                  delete this._tiles[i3];
                  this.fire("tileabort", {
                    tile,
                    coords
                  });
                }
              }
            }
          },
          _removeTile: function(key) {
            var tile = this._tiles[key];
            if (!tile) {
              return;
            }
            tile.el.setAttribute("src", emptyImageUrl);
            return GridLayer.prototype._removeTile.call(this, key);
          },
          _tileReady: function(coords, err, tile) {
            if (!this._map || tile && tile.getAttribute("src") === emptyImageUrl) {
              return;
            }
            return GridLayer.prototype._tileReady.call(this, coords, err, tile);
          }
        });
        function tileLayer(url, options) {
          return new TileLayer(url, options);
        }
        __name(tileLayer, "tileLayer");
        var TileLayerWMS = TileLayer.extend({
          // @section
          // @aka TileLayer.WMS options
          // If any custom options not documented here are used, they will be sent to the
          // WMS server as extra parameters in each request URL. This can be useful for
          // [non-standard vendor WMS parameters](https://docs.geoserver.org/stable/en/user/services/wms/vendor.html).
          defaultWmsParams: {
            service: "WMS",
            request: "GetMap",
            // @option layers: String = ''
            // **(required)** Comma-separated list of WMS layers to show.
            layers: "",
            // @option styles: String = ''
            // Comma-separated list of WMS styles.
            styles: "",
            // @option format: String = 'image/jpeg'
            // WMS image format (use `'image/png'` for layers with transparency).
            format: "image/jpeg",
            // @option transparent: Boolean = false
            // If `true`, the WMS service will return images with transparency.
            transparent: false,
            // @option version: String = '1.1.1'
            // Version of the WMS service to use
            version: "1.1.1"
          },
          options: {
            // @option crs: CRS = null
            // Coordinate Reference System to use for the WMS requests, defaults to
            // map CRS. Don't change this if you're not sure what it means.
            crs: null,
            // @option uppercase: Boolean = false
            // If `true`, WMS request parameter keys will be uppercase.
            uppercase: false
          },
          initialize: function(url, options) {
            this._url = url;
            var wmsParams = extend3({}, this.defaultWmsParams);
            for (var i3 in options) {
              if (!(i3 in this.options)) {
                wmsParams[i3] = options[i3];
              }
            }
            options = setOptions(this, options);
            var realRetina = options.detectRetina && Browser.retina ? 2 : 1;
            var tileSize = this.getTileSize();
            wmsParams.width = tileSize.x * realRetina;
            wmsParams.height = tileSize.y * realRetina;
            this.wmsParams = wmsParams;
          },
          onAdd: function(map2) {
            this._crs = this.options.crs || map2.options.crs;
            this._wmsVersion = parseFloat(this.wmsParams.version);
            var projectionKey = this._wmsVersion >= 1.3 ? "crs" : "srs";
            this.wmsParams[projectionKey] = this._crs.code;
            TileLayer.prototype.onAdd.call(this, map2);
          },
          getTileUrl: function(coords) {
            var tileBounds = this._tileCoordsToNwSe(coords), crs = this._crs, bounds = toBounds(crs.project(tileBounds[0]), crs.project(tileBounds[1])), min = bounds.min, max = bounds.max, bbox = (this._wmsVersion >= 1.3 && this._crs === EPSG4326 ? [min.y, min.x, max.y, max.x] : [min.x, min.y, max.x, max.y]).join(","), url = TileLayer.prototype.getTileUrl.call(this, coords);
            return url + getParamString(this.wmsParams, url, this.options.uppercase) + (this.options.uppercase ? "&BBOX=" : "&bbox=") + bbox;
          },
          // @method setParams(params: Object, noRedraw?: Boolean): this
          // Merges an object with the new parameters and re-requests tiles on the current screen (unless `noRedraw` was set to true).
          setParams: function(params, noRedraw) {
            extend3(this.wmsParams, params);
            if (!noRedraw) {
              this.redraw();
            }
            return this;
          }
        });
        function tileLayerWMS(url, options) {
          return new TileLayerWMS(url, options);
        }
        __name(tileLayerWMS, "tileLayerWMS");
        TileLayer.WMS = TileLayerWMS;
        tileLayer.wms = tileLayerWMS;
        var Renderer2 = Layer.extend({
          // @section
          // @aka Renderer options
          options: {
            // @option padding: Number = 0.1
            // How much to extend the clip area around the map view (relative to its size)
            // e.g. 0.1 would be 10% of map view in each direction
            padding: 0.1
          },
          initialize: function(options) {
            setOptions(this, options);
            stamp(this);
            this._layers = this._layers || {};
          },
          onAdd: function() {
            if (!this._container) {
              this._initContainer();
              addClass(this._container, "leaflet-zoom-animated");
            }
            this.getPane().appendChild(this._container);
            this._update();
            this.on("update", this._updatePaths, this);
          },
          onRemove: function() {
            this.off("update", this._updatePaths, this);
            this._destroyContainer();
          },
          getEvents: function() {
            var events = {
              viewreset: this._reset,
              zoom: this._onZoom,
              moveend: this._update,
              zoomend: this._onZoomEnd
            };
            if (this._zoomAnimated) {
              events.zoomanim = this._onAnimZoom;
            }
            return events;
          },
          _onAnimZoom: function(ev) {
            this._updateTransform(ev.center, ev.zoom);
          },
          _onZoom: function() {
            this._updateTransform(this._map.getCenter(), this._map.getZoom());
          },
          _updateTransform: function(center, zoom2) {
            var scale2 = this._map.getZoomScale(zoom2, this._zoom), viewHalf = this._map.getSize().multiplyBy(0.5 + this.options.padding), currentCenterPoint = this._map.project(this._center, zoom2), topLeftOffset = viewHalf.multiplyBy(-scale2).add(currentCenterPoint).subtract(this._map._getNewPixelOrigin(center, zoom2));
            if (Browser.any3d) {
              setTransform(this._container, topLeftOffset, scale2);
            } else {
              setPosition(this._container, topLeftOffset);
            }
          },
          _reset: function() {
            this._update();
            this._updateTransform(this._center, this._zoom);
            for (var id in this._layers) {
              this._layers[id]._reset();
            }
          },
          _onZoomEnd: function() {
            for (var id in this._layers) {
              this._layers[id]._project();
            }
          },
          _updatePaths: function() {
            for (var id in this._layers) {
              this._layers[id]._update();
            }
          },
          _update: function() {
            var p3 = this.options.padding, size = this._map.getSize(), min = this._map.containerPointToLayerPoint(size.multiplyBy(-p3)).round();
            this._bounds = new Bounds(min, min.add(size.multiplyBy(1 + p3 * 2)).round());
            this._center = this._map.getCenter();
            this._zoom = this._map.getZoom();
          }
        });
        var Canvas = Renderer2.extend({
          // @section
          // @aka Canvas options
          options: {
            // @option tolerance: Number = 0
            // How much to extend the click tolerance around a path/object on the map.
            tolerance: 0
          },
          getEvents: function() {
            var events = Renderer2.prototype.getEvents.call(this);
            events.viewprereset = this._onViewPreReset;
            return events;
          },
          _onViewPreReset: function() {
            this._postponeUpdatePaths = true;
          },
          onAdd: function() {
            Renderer2.prototype.onAdd.call(this);
            this._draw();
          },
          _initContainer: function() {
            var container = this._container = document.createElement("canvas");
            on2(container, "mousemove", this._onMouseMove, this);
            on2(container, "click dblclick mousedown mouseup contextmenu", this._onClick, this);
            on2(container, "mouseout", this._handleMouseOut, this);
            container["_leaflet_disable_events"] = true;
            this._ctx = container.getContext("2d");
          },
          _destroyContainer: function() {
            cancelAnimFrame(this._redrawRequest);
            delete this._ctx;
            remove(this._container);
            off2(this._container);
            delete this._container;
          },
          _updatePaths: function() {
            if (this._postponeUpdatePaths) {
              return;
            }
            var layer;
            this._redrawBounds = null;
            for (var id in this._layers) {
              layer = this._layers[id];
              layer._update();
            }
            this._redraw();
          },
          _update: function() {
            if (this._map._animatingZoom && this._bounds) {
              return;
            }
            Renderer2.prototype._update.call(this);
            var b3 = this._bounds, container = this._container, size = b3.getSize(), m3 = Browser.retina ? 2 : 1;
            setPosition(container, b3.min);
            container.width = m3 * size.x;
            container.height = m3 * size.y;
            container.style.width = size.x + "px";
            container.style.height = size.y + "px";
            if (Browser.retina) {
              this._ctx.scale(2, 2);
            }
            this._ctx.translate(-b3.min.x, -b3.min.y);
            this.fire("update");
          },
          _reset: function() {
            Renderer2.prototype._reset.call(this);
            if (this._postponeUpdatePaths) {
              this._postponeUpdatePaths = false;
              this._updatePaths();
            }
          },
          _initPath: function(layer) {
            this._updateDashArray(layer);
            this._layers[stamp(layer)] = layer;
            var order = layer._order = {
              layer,
              prev: this._drawLast,
              next: null
            };
            if (this._drawLast) {
              this._drawLast.next = order;
            }
            this._drawLast = order;
            this._drawFirst = this._drawFirst || this._drawLast;
          },
          _addPath: function(layer) {
            this._requestRedraw(layer);
          },
          _removePath: function(layer) {
            var order = layer._order;
            var next = order.next;
            var prev = order.prev;
            if (next) {
              next.prev = prev;
            } else {
              this._drawLast = prev;
            }
            if (prev) {
              prev.next = next;
            } else {
              this._drawFirst = next;
            }
            delete layer._order;
            delete this._layers[stamp(layer)];
            this._requestRedraw(layer);
          },
          _updatePath: function(layer) {
            this._extendRedrawBounds(layer);
            layer._project();
            layer._update();
            this._requestRedraw(layer);
          },
          _updateStyle: function(layer) {
            this._updateDashArray(layer);
            this._requestRedraw(layer);
          },
          _updateDashArray: function(layer) {
            if (typeof layer.options.dashArray === "string") {
              var parts = layer.options.dashArray.split(/[, ]+/), dashArray = [], dashValue, i3;
              for (i3 = 0; i3 < parts.length; i3++) {
                dashValue = Number(parts[i3]);
                if (isNaN(dashValue)) {
                  return;
                }
                dashArray.push(dashValue);
              }
              layer.options._dashArray = dashArray;
            } else {
              layer.options._dashArray = layer.options.dashArray;
            }
          },
          _requestRedraw: function(layer) {
            if (!this._map) {
              return;
            }
            this._extendRedrawBounds(layer);
            this._redrawRequest = this._redrawRequest || requestAnimFrame(this._redraw, this);
          },
          _extendRedrawBounds: function(layer) {
            if (layer._pxBounds) {
              var padding = (layer.options.weight || 0) + 1;
              this._redrawBounds = this._redrawBounds || new Bounds();
              this._redrawBounds.extend(layer._pxBounds.min.subtract([padding, padding]));
              this._redrawBounds.extend(layer._pxBounds.max.add([padding, padding]));
            }
          },
          _redraw: function() {
            this._redrawRequest = null;
            if (this._redrawBounds) {
              this._redrawBounds.min._floor();
              this._redrawBounds.max._ceil();
            }
            this._clear();
            this._draw();
            this._redrawBounds = null;
          },
          _clear: function() {
            var bounds = this._redrawBounds;
            if (bounds) {
              var size = bounds.getSize();
              this._ctx.clearRect(bounds.min.x, bounds.min.y, size.x, size.y);
            } else {
              this._ctx.save();
              this._ctx.setTransform(1, 0, 0, 1, 0, 0);
              this._ctx.clearRect(0, 0, this._container.width, this._container.height);
              this._ctx.restore();
            }
          },
          _draw: function() {
            var layer, bounds = this._redrawBounds;
            this._ctx.save();
            if (bounds) {
              var size = bounds.getSize();
              this._ctx.beginPath();
              this._ctx.rect(bounds.min.x, bounds.min.y, size.x, size.y);
              this._ctx.clip();
            }
            this._drawing = true;
            for (var order = this._drawFirst; order; order = order.next) {
              layer = order.layer;
              if (!bounds || layer._pxBounds && layer._pxBounds.intersects(bounds)) {
                layer._updatePath();
              }
            }
            this._drawing = false;
            this._ctx.restore();
          },
          _updatePoly: function(layer, closed) {
            if (!this._drawing) {
              return;
            }
            var i3, j3, len2, p3, parts = layer._parts, len = parts.length, ctx = this._ctx;
            if (!len) {
              return;
            }
            ctx.beginPath();
            for (i3 = 0; i3 < len; i3++) {
              for (j3 = 0, len2 = parts[i3].length; j3 < len2; j3++) {
                p3 = parts[i3][j3];
                ctx[j3 ? "lineTo" : "moveTo"](p3.x, p3.y);
              }
              if (closed) {
                ctx.closePath();
              }
            }
            this._fillStroke(ctx, layer);
          },
          _updateCircle: function(layer) {
            if (!this._drawing || layer._empty()) {
              return;
            }
            var p3 = layer._point, ctx = this._ctx, r3 = Math.max(Math.round(layer._radius), 1), s3 = (Math.max(Math.round(layer._radiusY), 1) || r3) / r3;
            if (s3 !== 1) {
              ctx.save();
              ctx.scale(1, s3);
            }
            ctx.beginPath();
            ctx.arc(p3.x, p3.y / s3, r3, 0, Math.PI * 2, false);
            if (s3 !== 1) {
              ctx.restore();
            }
            this._fillStroke(ctx, layer);
          },
          _fillStroke: function(ctx, layer) {
            var options = layer.options;
            if (options.fill) {
              ctx.globalAlpha = options.fillOpacity;
              ctx.fillStyle = options.fillColor || options.color;
              ctx.fill(options.fillRule || "evenodd");
            }
            if (options.stroke && options.weight !== 0) {
              if (ctx.setLineDash) {
                ctx.setLineDash(layer.options && layer.options._dashArray || []);
              }
              ctx.globalAlpha = options.opacity;
              ctx.lineWidth = options.weight;
              ctx.strokeStyle = options.color;
              ctx.lineCap = options.lineCap;
              ctx.lineJoin = options.lineJoin;
              ctx.stroke();
            }
          },
          // Canvas obviously doesn't have mouse events for individual drawn objects,
          // so we emulate that by calculating what's under the mouse on mousemove/click manually
          _onClick: function(e3) {
            var point = this._map.mouseEventToLayerPoint(e3), layer, clickedLayer;
            for (var order = this._drawFirst; order; order = order.next) {
              layer = order.layer;
              if (layer.options.interactive && layer._containsPoint(point)) {
                if (!(e3.type === "click" || e3.type === "preclick") || !this._map._draggableMoved(layer)) {
                  clickedLayer = layer;
                }
              }
            }
            this._fireEvent(clickedLayer ? [clickedLayer] : false, e3);
          },
          _onMouseMove: function(e3) {
            if (!this._map || this._map.dragging.moving() || this._map._animatingZoom) {
              return;
            }
            var point = this._map.mouseEventToLayerPoint(e3);
            this._handleMouseHover(e3, point);
          },
          _handleMouseOut: function(e3) {
            var layer = this._hoveredLayer;
            if (layer) {
              removeClass(this._container, "leaflet-interactive");
              this._fireEvent([layer], e3, "mouseout");
              this._hoveredLayer = null;
              this._mouseHoverThrottled = false;
            }
          },
          _handleMouseHover: function(e3, point) {
            if (this._mouseHoverThrottled) {
              return;
            }
            var layer, candidateHoveredLayer;
            for (var order = this._drawFirst; order; order = order.next) {
              layer = order.layer;
              if (layer.options.interactive && layer._containsPoint(point)) {
                candidateHoveredLayer = layer;
              }
            }
            if (candidateHoveredLayer !== this._hoveredLayer) {
              this._handleMouseOut(e3);
              if (candidateHoveredLayer) {
                addClass(this._container, "leaflet-interactive");
                this._fireEvent([candidateHoveredLayer], e3, "mouseover");
                this._hoveredLayer = candidateHoveredLayer;
              }
            }
            this._fireEvent(this._hoveredLayer ? [this._hoveredLayer] : false, e3);
            this._mouseHoverThrottled = true;
            setTimeout(bind(function() {
              this._mouseHoverThrottled = false;
            }, this), 32);
          },
          _fireEvent: function(layers2, e3, type) {
            this._map._fireDOMEvent(e3, type || e3.type, layers2);
          },
          _bringToFront: function(layer) {
            var order = layer._order;
            if (!order) {
              return;
            }
            var next = order.next;
            var prev = order.prev;
            if (next) {
              next.prev = prev;
            } else {
              return;
            }
            if (prev) {
              prev.next = next;
            } else if (next) {
              this._drawFirst = next;
            }
            order.prev = this._drawLast;
            this._drawLast.next = order;
            order.next = null;
            this._drawLast = order;
            this._requestRedraw(layer);
          },
          _bringToBack: function(layer) {
            var order = layer._order;
            if (!order) {
              return;
            }
            var next = order.next;
            var prev = order.prev;
            if (prev) {
              prev.next = next;
            } else {
              return;
            }
            if (next) {
              next.prev = prev;
            } else if (prev) {
              this._drawLast = prev;
            }
            order.prev = null;
            order.next = this._drawFirst;
            this._drawFirst.prev = order;
            this._drawFirst = order;
            this._requestRedraw(layer);
          }
        });
        function canvas(options) {
          return Browser.canvas ? new Canvas(options) : null;
        }
        __name(canvas, "canvas");
        var vmlCreate = function() {
          try {
            document.namespaces.add("lvml", "urn:schemas-microsoft-com:vml");
            return function(name) {
              return document.createElement("<lvml:" + name + ' class="lvml">');
            };
          } catch (e3) {
          }
          return function(name) {
            return document.createElement("<" + name + ' xmlns="urn:schemas-microsoft.com:vml" class="lvml">');
          };
        }();
        var vmlMixin = {
          _initContainer: function() {
            this._container = create$1("div", "leaflet-vml-container");
          },
          _update: function() {
            if (this._map._animatingZoom) {
              return;
            }
            Renderer2.prototype._update.call(this);
            this.fire("update");
          },
          _initPath: function(layer) {
            var container = layer._container = vmlCreate("shape");
            addClass(container, "leaflet-vml-shape " + (this.options.className || ""));
            container.coordsize = "1 1";
            layer._path = vmlCreate("path");
            container.appendChild(layer._path);
            this._updateStyle(layer);
            this._layers[stamp(layer)] = layer;
          },
          _addPath: function(layer) {
            var container = layer._container;
            this._container.appendChild(container);
            if (layer.options.interactive) {
              layer.addInteractiveTarget(container);
            }
          },
          _removePath: function(layer) {
            var container = layer._container;
            remove(container);
            layer.removeInteractiveTarget(container);
            delete this._layers[stamp(layer)];
          },
          _updateStyle: function(layer) {
            var stroke = layer._stroke, fill = layer._fill, options = layer.options, container = layer._container;
            container.stroked = !!options.stroke;
            container.filled = !!options.fill;
            if (options.stroke) {
              if (!stroke) {
                stroke = layer._stroke = vmlCreate("stroke");
              }
              container.appendChild(stroke);
              stroke.weight = options.weight + "px";
              stroke.color = options.color;
              stroke.opacity = options.opacity;
              if (options.dashArray) {
                stroke.dashStyle = isArray2(options.dashArray) ? options.dashArray.join(" ") : options.dashArray.replace(/( *, *)/g, " ");
              } else {
                stroke.dashStyle = "";
              }
              stroke.endcap = options.lineCap.replace("butt", "flat");
              stroke.joinstyle = options.lineJoin;
            } else if (stroke) {
              container.removeChild(stroke);
              layer._stroke = null;
            }
            if (options.fill) {
              if (!fill) {
                fill = layer._fill = vmlCreate("fill");
              }
              container.appendChild(fill);
              fill.color = options.fillColor || options.color;
              fill.opacity = options.fillOpacity;
            } else if (fill) {
              container.removeChild(fill);
              layer._fill = null;
            }
          },
          _updateCircle: function(layer) {
            var p3 = layer._point.round(), r3 = Math.round(layer._radius), r22 = Math.round(layer._radiusY || r3);
            this._setPath(layer, layer._empty() ? "M0 0" : "AL " + p3.x + "," + p3.y + " " + r3 + "," + r22 + " 0," + 65535 * 360);
          },
          _setPath: function(layer, path) {
            layer._path.v = path;
          },
          _bringToFront: function(layer) {
            toFront(layer._container);
          },
          _bringToBack: function(layer) {
            toBack(layer._container);
          }
        };
        var create = Browser.vml ? vmlCreate : svgCreate;
        var SVG = Renderer2.extend({
          _initContainer: function() {
            this._container = create("svg");
            this._container.setAttribute("pointer-events", "none");
            this._rootGroup = create("g");
            this._container.appendChild(this._rootGroup);
          },
          _destroyContainer: function() {
            remove(this._container);
            off2(this._container);
            delete this._container;
            delete this._rootGroup;
            delete this._svgSize;
          },
          _update: function() {
            if (this._map._animatingZoom && this._bounds) {
              return;
            }
            Renderer2.prototype._update.call(this);
            var b3 = this._bounds, size = b3.getSize(), container = this._container;
            if (!this._svgSize || !this._svgSize.equals(size)) {
              this._svgSize = size;
              container.setAttribute("width", size.x);
              container.setAttribute("height", size.y);
            }
            setPosition(container, b3.min);
            container.setAttribute("viewBox", [b3.min.x, b3.min.y, size.x, size.y].join(" "));
            this.fire("update");
          },
          // methods below are called by vector layers implementations
          _initPath: function(layer) {
            var path = layer._path = create("path");
            if (layer.options.className) {
              addClass(path, layer.options.className);
            }
            if (layer.options.interactive) {
              addClass(path, "leaflet-interactive");
            }
            this._updateStyle(layer);
            this._layers[stamp(layer)] = layer;
          },
          _addPath: function(layer) {
            if (!this._rootGroup) {
              this._initContainer();
            }
            this._rootGroup.appendChild(layer._path);
            layer.addInteractiveTarget(layer._path);
          },
          _removePath: function(layer) {
            remove(layer._path);
            layer.removeInteractiveTarget(layer._path);
            delete this._layers[stamp(layer)];
          },
          _updatePath: function(layer) {
            layer._project();
            layer._update();
          },
          _updateStyle: function(layer) {
            var path = layer._path, options = layer.options;
            if (!path) {
              return;
            }
            if (options.stroke) {
              path.setAttribute("stroke", options.color);
              path.setAttribute("stroke-opacity", options.opacity);
              path.setAttribute("stroke-width", options.weight);
              path.setAttribute("stroke-linecap", options.lineCap);
              path.setAttribute("stroke-linejoin", options.lineJoin);
              if (options.dashArray) {
                path.setAttribute("stroke-dasharray", options.dashArray);
              } else {
                path.removeAttribute("stroke-dasharray");
              }
              if (options.dashOffset) {
                path.setAttribute("stroke-dashoffset", options.dashOffset);
              } else {
                path.removeAttribute("stroke-dashoffset");
              }
            } else {
              path.setAttribute("stroke", "none");
            }
            if (options.fill) {
              path.setAttribute("fill", options.fillColor || options.color);
              path.setAttribute("fill-opacity", options.fillOpacity);
              path.setAttribute("fill-rule", options.fillRule || "evenodd");
            } else {
              path.setAttribute("fill", "none");
            }
          },
          _updatePoly: function(layer, closed) {
            this._setPath(layer, pointsToPath(layer._parts, closed));
          },
          _updateCircle: function(layer) {
            var p3 = layer._point, r3 = Math.max(Math.round(layer._radius), 1), r22 = Math.max(Math.round(layer._radiusY), 1) || r3, arc = "a" + r3 + "," + r22 + " 0 1,0 ";
            var d3 = layer._empty() ? "M0 0" : "M" + (p3.x - r3) + "," + p3.y + arc + r3 * 2 + ",0 " + arc + -r3 * 2 + ",0 ";
            this._setPath(layer, d3);
          },
          _setPath: function(layer, path) {
            layer._path.setAttribute("d", path);
          },
          // SVG does not have the concept of zIndex so we resort to changing the DOM order of elements
          _bringToFront: function(layer) {
            toFront(layer._path);
          },
          _bringToBack: function(layer) {
            toBack(layer._path);
          }
        });
        if (Browser.vml) {
          SVG.include(vmlMixin);
        }
        function svg(options) {
          return Browser.svg || Browser.vml ? new SVG(options) : null;
        }
        __name(svg, "svg");
        Map3.include({
          // @namespace Map; @method getRenderer(layer: Path): Renderer
          // Returns the instance of `Renderer` that should be used to render the given
          // `Path`. It will ensure that the `renderer` options of the map and paths
          // are respected, and that the renderers do exist on the map.
          getRenderer: function(layer) {
            var renderer = layer.options.renderer || this._getPaneRenderer(layer.options.pane) || this.options.renderer || this._renderer;
            if (!renderer) {
              renderer = this._renderer = this._createRenderer();
            }
            if (!this.hasLayer(renderer)) {
              this.addLayer(renderer);
            }
            return renderer;
          },
          _getPaneRenderer: function(name) {
            if (name === "overlayPane" || name === void 0) {
              return false;
            }
            var renderer = this._paneRenderers[name];
            if (renderer === void 0) {
              renderer = this._createRenderer({ pane: name });
              this._paneRenderers[name] = renderer;
            }
            return renderer;
          },
          _createRenderer: function(options) {
            return this.options.preferCanvas && canvas(options) || svg(options);
          }
        });
        var Rectangle = Polygon.extend({
          initialize: function(latLngBounds, options) {
            Polygon.prototype.initialize.call(this, this._boundsToLatLngs(latLngBounds), options);
          },
          // @method setBounds(latLngBounds: LatLngBounds): this
          // Redraws the rectangle with the passed bounds.
          setBounds: function(latLngBounds) {
            return this.setLatLngs(this._boundsToLatLngs(latLngBounds));
          },
          _boundsToLatLngs: function(latLngBounds) {
            latLngBounds = toLatLngBounds(latLngBounds);
            return [
              latLngBounds.getSouthWest(),
              latLngBounds.getNorthWest(),
              latLngBounds.getNorthEast(),
              latLngBounds.getSouthEast()
            ];
          }
        });
        function rectangle(latLngBounds, options) {
          return new Rectangle(latLngBounds, options);
        }
        __name(rectangle, "rectangle");
        SVG.create = create;
        SVG.pointsToPath = pointsToPath;
        GeoJSON.geometryToLayer = geometryToLayer;
        GeoJSON.coordsToLatLng = coordsToLatLng;
        GeoJSON.coordsToLatLngs = coordsToLatLngs;
        GeoJSON.latLngToCoords = latLngToCoords;
        GeoJSON.latLngsToCoords = latLngsToCoords;
        GeoJSON.getFeature = getFeature;
        GeoJSON.asFeature = asFeature;
        Map3.mergeOptions({
          // @option boxZoom: Boolean = true
          // Whether the map can be zoomed to a rectangular area specified by
          // dragging the mouse while pressing the shift key.
          boxZoom: true
        });
        var BoxZoom = Handler.extend({
          initialize: function(map2) {
            this._map = map2;
            this._container = map2._container;
            this._pane = map2._panes.overlayPane;
            this._resetStateTimeout = 0;
            map2.on("unload", this._destroy, this);
          },
          addHooks: function() {
            on2(this._container, "mousedown", this._onMouseDown, this);
          },
          removeHooks: function() {
            off2(this._container, "mousedown", this._onMouseDown, this);
          },
          moved: function() {
            return this._moved;
          },
          _destroy: function() {
            remove(this._pane);
            delete this._pane;
          },
          _resetState: function() {
            this._resetStateTimeout = 0;
            this._moved = false;
          },
          _clearDeferredResetState: function() {
            if (this._resetStateTimeout !== 0) {
              clearTimeout(this._resetStateTimeout);
              this._resetStateTimeout = 0;
            }
          },
          _onMouseDown: function(e3) {
            if (!e3.shiftKey || e3.which !== 1 && e3.button !== 1) {
              return false;
            }
            this._clearDeferredResetState();
            this._resetState();
            disableTextSelection();
            disableImageDrag();
            this._startPoint = this._map.mouseEventToContainerPoint(e3);
            on2(document, {
              contextmenu: stop,
              mousemove: this._onMouseMove,
              mouseup: this._onMouseUp,
              keydown: this._onKeyDown
            }, this);
          },
          _onMouseMove: function(e3) {
            if (!this._moved) {
              this._moved = true;
              this._box = create$1("div", "leaflet-zoom-box", this._container);
              addClass(this._container, "leaflet-crosshair");
              this._map.fire("boxzoomstart");
            }
            this._point = this._map.mouseEventToContainerPoint(e3);
            var bounds = new Bounds(this._point, this._startPoint), size = bounds.getSize();
            setPosition(this._box, bounds.min);
            this._box.style.width = size.x + "px";
            this._box.style.height = size.y + "px";
          },
          _finish: function() {
            if (this._moved) {
              remove(this._box);
              removeClass(this._container, "leaflet-crosshair");
            }
            enableTextSelection();
            enableImageDrag();
            off2(document, {
              contextmenu: stop,
              mousemove: this._onMouseMove,
              mouseup: this._onMouseUp,
              keydown: this._onKeyDown
            }, this);
          },
          _onMouseUp: function(e3) {
            if (e3.which !== 1 && e3.button !== 1) {
              return;
            }
            this._finish();
            if (!this._moved) {
              return;
            }
            this._clearDeferredResetState();
            this._resetStateTimeout = setTimeout(bind(this._resetState, this), 0);
            var bounds = new LatLngBounds(
              this._map.containerPointToLatLng(this._startPoint),
              this._map.containerPointToLatLng(this._point)
            );
            this._map.fitBounds(bounds).fire("boxzoomend", { boxZoomBounds: bounds });
          },
          _onKeyDown: function(e3) {
            if (e3.keyCode === 27) {
              this._finish();
              this._clearDeferredResetState();
              this._resetState();
            }
          }
        });
        Map3.addInitHook("addHandler", "boxZoom", BoxZoom);
        Map3.mergeOptions({
          // @option doubleClickZoom: Boolean|String = true
          // Whether the map can be zoomed in by double clicking on it and
          // zoomed out by double clicking while holding shift. If passed
          // `'center'`, double-click zoom will zoom to the center of the
          //  view regardless of where the mouse was.
          doubleClickZoom: true
        });
        var DoubleClickZoom = Handler.extend({
          addHooks: function() {
            this._map.on("dblclick", this._onDoubleClick, this);
          },
          removeHooks: function() {
            this._map.off("dblclick", this._onDoubleClick, this);
          },
          _onDoubleClick: function(e3) {
            var map2 = this._map, oldZoom = map2.getZoom(), delta = map2.options.zoomDelta, zoom2 = e3.originalEvent.shiftKey ? oldZoom - delta : oldZoom + delta;
            if (map2.options.doubleClickZoom === "center") {
              map2.setZoom(zoom2);
            } else {
              map2.setZoomAround(e3.containerPoint, zoom2);
            }
          }
        });
        Map3.addInitHook("addHandler", "doubleClickZoom", DoubleClickZoom);
        Map3.mergeOptions({
          // @option dragging: Boolean = true
          // Whether the map is draggable with mouse/touch or not.
          dragging: true,
          // @section Panning Inertia Options
          // @option inertia: Boolean = *
          // If enabled, panning of the map will have an inertia effect where
          // the map builds momentum while dragging and continues moving in
          // the same direction for some time. Feels especially nice on touch
          // devices. Enabled by default.
          inertia: true,
          // @option inertiaDeceleration: Number = 3000
          // The rate with which the inertial movement slows down, in pixels/second².
          inertiaDeceleration: 3400,
          // px/s^2
          // @option inertiaMaxSpeed: Number = Infinity
          // Max speed of the inertial movement, in pixels/second.
          inertiaMaxSpeed: Infinity,
          // px/s
          // @option easeLinearity: Number = 0.2
          easeLinearity: 0.2,
          // TODO refactor, move to CRS
          // @option worldCopyJump: Boolean = false
          // With this option enabled, the map tracks when you pan to another "copy"
          // of the world and seamlessly jumps to the original one so that all overlays
          // like markers and vector layers are still visible.
          worldCopyJump: false,
          // @option maxBoundsViscosity: Number = 0.0
          // If `maxBounds` is set, this option will control how solid the bounds
          // are when dragging the map around. The default value of `0.0` allows the
          // user to drag outside the bounds at normal speed, higher values will
          // slow down map dragging outside bounds, and `1.0` makes the bounds fully
          // solid, preventing the user from dragging outside the bounds.
          maxBoundsViscosity: 0
        });
        var Drag = Handler.extend({
          addHooks: function() {
            if (!this._draggable) {
              var map2 = this._map;
              this._draggable = new Draggable(map2._mapPane, map2._container);
              this._draggable.on({
                dragstart: this._onDragStart,
                drag: this._onDrag,
                dragend: this._onDragEnd
              }, this);
              this._draggable.on("predrag", this._onPreDragLimit, this);
              if (map2.options.worldCopyJump) {
                this._draggable.on("predrag", this._onPreDragWrap, this);
                map2.on("zoomend", this._onZoomEnd, this);
                map2.whenReady(this._onZoomEnd, this);
              }
            }
            addClass(this._map._container, "leaflet-grab leaflet-touch-drag");
            this._draggable.enable();
            this._positions = [];
            this._times = [];
          },
          removeHooks: function() {
            removeClass(this._map._container, "leaflet-grab");
            removeClass(this._map._container, "leaflet-touch-drag");
            this._draggable.disable();
          },
          moved: function() {
            return this._draggable && this._draggable._moved;
          },
          moving: function() {
            return this._draggable && this._draggable._moving;
          },
          _onDragStart: function() {
            var map2 = this._map;
            map2._stop();
            if (this._map.options.maxBounds && this._map.options.maxBoundsViscosity) {
              var bounds = toLatLngBounds(this._map.options.maxBounds);
              this._offsetLimit = toBounds(
                this._map.latLngToContainerPoint(bounds.getNorthWest()).multiplyBy(-1),
                this._map.latLngToContainerPoint(bounds.getSouthEast()).multiplyBy(-1).add(this._map.getSize())
              );
              this._viscosity = Math.min(1, Math.max(0, this._map.options.maxBoundsViscosity));
            } else {
              this._offsetLimit = null;
            }
            map2.fire("movestart").fire("dragstart");
            if (map2.options.inertia) {
              this._positions = [];
              this._times = [];
            }
          },
          _onDrag: function(e3) {
            if (this._map.options.inertia) {
              var time = this._lastTime = +/* @__PURE__ */ new Date(), pos = this._lastPos = this._draggable._absPos || this._draggable._newPos;
              this._positions.push(pos);
              this._times.push(time);
              this._prunePositions(time);
            }
            this._map.fire("move", e3).fire("drag", e3);
          },
          _prunePositions: function(time) {
            while (this._positions.length > 1 && time - this._times[0] > 50) {
              this._positions.shift();
              this._times.shift();
            }
          },
          _onZoomEnd: function() {
            var pxCenter = this._map.getSize().divideBy(2), pxWorldCenter = this._map.latLngToLayerPoint([0, 0]);
            this._initialWorldOffset = pxWorldCenter.subtract(pxCenter).x;
            this._worldWidth = this._map.getPixelWorldBounds().getSize().x;
          },
          _viscousLimit: function(value, threshold) {
            return value - (value - threshold) * this._viscosity;
          },
          _onPreDragLimit: function() {
            if (!this._viscosity || !this._offsetLimit) {
              return;
            }
            var offset = this._draggable._newPos.subtract(this._draggable._startPos);
            var limit = this._offsetLimit;
            if (offset.x < limit.min.x) {
              offset.x = this._viscousLimit(offset.x, limit.min.x);
            }
            if (offset.y < limit.min.y) {
              offset.y = this._viscousLimit(offset.y, limit.min.y);
            }
            if (offset.x > limit.max.x) {
              offset.x = this._viscousLimit(offset.x, limit.max.x);
            }
            if (offset.y > limit.max.y) {
              offset.y = this._viscousLimit(offset.y, limit.max.y);
            }
            this._draggable._newPos = this._draggable._startPos.add(offset);
          },
          _onPreDragWrap: function() {
            var worldWidth = this._worldWidth, halfWidth = Math.round(worldWidth / 2), dx = this._initialWorldOffset, x3 = this._draggable._newPos.x, newX1 = (x3 - halfWidth + dx) % worldWidth + halfWidth - dx, newX2 = (x3 + halfWidth + dx) % worldWidth - halfWidth - dx, newX = Math.abs(newX1 + dx) < Math.abs(newX2 + dx) ? newX1 : newX2;
            this._draggable._absPos = this._draggable._newPos.clone();
            this._draggable._newPos.x = newX;
          },
          _onDragEnd: function(e3) {
            var map2 = this._map, options = map2.options, noInertia = !options.inertia || e3.noInertia || this._times.length < 2;
            map2.fire("dragend", e3);
            if (noInertia) {
              map2.fire("moveend");
            } else {
              this._prunePositions(+/* @__PURE__ */ new Date());
              var direction = this._lastPos.subtract(this._positions[0]), duration3 = (this._lastTime - this._times[0]) / 1e3, ease = options.easeLinearity, speedVector = direction.multiplyBy(ease / duration3), speed = speedVector.distanceTo([0, 0]), limitedSpeed = Math.min(options.inertiaMaxSpeed, speed), limitedSpeedVector = speedVector.multiplyBy(limitedSpeed / speed), decelerationDuration = limitedSpeed / (options.inertiaDeceleration * ease), offset = limitedSpeedVector.multiplyBy(-decelerationDuration / 2).round();
              if (!offset.x && !offset.y) {
                map2.fire("moveend");
              } else {
                offset = map2._limitOffset(offset, map2.options.maxBounds);
                requestAnimFrame(function() {
                  map2.panBy(offset, {
                    duration: decelerationDuration,
                    easeLinearity: ease,
                    noMoveStart: true,
                    animate: true
                  });
                });
              }
            }
          }
        });
        Map3.addInitHook("addHandler", "dragging", Drag);
        Map3.mergeOptions({
          // @option keyboard: Boolean = true
          // Makes the map focusable and allows users to navigate the map with keyboard
          // arrows and `+`/`-` keys.
          keyboard: true,
          // @option keyboardPanDelta: Number = 80
          // Amount of pixels to pan when pressing an arrow key.
          keyboardPanDelta: 80
        });
        var Keyboard2 = Handler.extend({
          keyCodes: {
            left: [37],
            right: [39],
            down: [40],
            up: [38],
            zoomIn: [187, 107, 61, 171],
            zoomOut: [189, 109, 54, 173]
          },
          initialize: function(map2) {
            this._map = map2;
            this._setPanDelta(map2.options.keyboardPanDelta);
            this._setZoomDelta(map2.options.zoomDelta);
          },
          addHooks: function() {
            var container = this._map._container;
            if (container.tabIndex <= 0) {
              container.tabIndex = "0";
            }
            on2(container, {
              focus: this._onFocus,
              blur: this._onBlur,
              mousedown: this._onMouseDown
            }, this);
            this._map.on({
              focus: this._addHooks,
              blur: this._removeHooks
            }, this);
          },
          removeHooks: function() {
            this._removeHooks();
            off2(this._map._container, {
              focus: this._onFocus,
              blur: this._onBlur,
              mousedown: this._onMouseDown
            }, this);
            this._map.off({
              focus: this._addHooks,
              blur: this._removeHooks
            }, this);
          },
          _onMouseDown: function() {
            if (this._focused) {
              return;
            }
            var body = document.body, docEl = document.documentElement, top = body.scrollTop || docEl.scrollTop, left = body.scrollLeft || docEl.scrollLeft;
            this._map._container.focus();
            window.scrollTo(left, top);
          },
          _onFocus: function() {
            this._focused = true;
            this._map.fire("focus");
          },
          _onBlur: function() {
            this._focused = false;
            this._map.fire("blur");
          },
          _setPanDelta: function(panDelta) {
            var keys2 = this._panKeys = {}, codes = this.keyCodes, i3, len;
            for (i3 = 0, len = codes.left.length; i3 < len; i3++) {
              keys2[codes.left[i3]] = [-1 * panDelta, 0];
            }
            for (i3 = 0, len = codes.right.length; i3 < len; i3++) {
              keys2[codes.right[i3]] = [panDelta, 0];
            }
            for (i3 = 0, len = codes.down.length; i3 < len; i3++) {
              keys2[codes.down[i3]] = [0, panDelta];
            }
            for (i3 = 0, len = codes.up.length; i3 < len; i3++) {
              keys2[codes.up[i3]] = [0, -1 * panDelta];
            }
          },
          _setZoomDelta: function(zoomDelta) {
            var keys2 = this._zoomKeys = {}, codes = this.keyCodes, i3, len;
            for (i3 = 0, len = codes.zoomIn.length; i3 < len; i3++) {
              keys2[codes.zoomIn[i3]] = zoomDelta;
            }
            for (i3 = 0, len = codes.zoomOut.length; i3 < len; i3++) {
              keys2[codes.zoomOut[i3]] = -zoomDelta;
            }
          },
          _addHooks: function() {
            on2(document, "keydown", this._onKeyDown, this);
          },
          _removeHooks: function() {
            off2(document, "keydown", this._onKeyDown, this);
          },
          _onKeyDown: function(e3) {
            if (e3.altKey || e3.ctrlKey || e3.metaKey) {
              return;
            }
            var key = e3.keyCode, map2 = this._map, offset;
            if (key in this._panKeys) {
              if (!map2._panAnim || !map2._panAnim._inProgress) {
                offset = this._panKeys[key];
                if (e3.shiftKey) {
                  offset = toPoint(offset).multiplyBy(3);
                }
                if (map2.options.maxBounds) {
                  offset = map2._limitOffset(toPoint(offset), map2.options.maxBounds);
                }
                if (map2.options.worldCopyJump) {
                  var newLatLng = map2.wrapLatLng(map2.unproject(map2.project(map2.getCenter()).add(offset)));
                  map2.panTo(newLatLng);
                } else {
                  map2.panBy(offset);
                }
              }
            } else if (key in this._zoomKeys) {
              map2.setZoom(map2.getZoom() + (e3.shiftKey ? 3 : 1) * this._zoomKeys[key]);
            } else if (key === 27 && map2._popup && map2._popup.options.closeOnEscapeKey) {
              map2.closePopup();
            } else {
              return;
            }
            stop(e3);
          }
        });
        Map3.addInitHook("addHandler", "keyboard", Keyboard2);
        Map3.mergeOptions({
          // @section Mouse wheel options
          // @option scrollWheelZoom: Boolean|String = true
          // Whether the map can be zoomed by using the mouse wheel. If passed `'center'`,
          // it will zoom to the center of the view regardless of where the mouse was.
          scrollWheelZoom: true,
          // @option wheelDebounceTime: Number = 40
          // Limits the rate at which a wheel can fire (in milliseconds). By default
          // user can't zoom via wheel more often than once per 40 ms.
          wheelDebounceTime: 40,
          // @option wheelPxPerZoomLevel: Number = 60
          // How many scroll pixels (as reported by [L.DomEvent.getWheelDelta](#domevent-getwheeldelta))
          // mean a change of one full zoom level. Smaller values will make wheel-zooming
          // faster (and vice versa).
          wheelPxPerZoomLevel: 60
        });
        var ScrollWheelZoom = Handler.extend({
          addHooks: function() {
            on2(this._map._container, "wheel", this._onWheelScroll, this);
            this._delta = 0;
          },
          removeHooks: function() {
            off2(this._map._container, "wheel", this._onWheelScroll, this);
          },
          _onWheelScroll: function(e3) {
            var delta = getWheelDelta(e3);
            var debounce7 = this._map.options.wheelDebounceTime;
            this._delta += delta;
            this._lastMousePos = this._map.mouseEventToContainerPoint(e3);
            if (!this._startTime) {
              this._startTime = +/* @__PURE__ */ new Date();
            }
            var left = Math.max(debounce7 - (+/* @__PURE__ */ new Date() - this._startTime), 0);
            clearTimeout(this._timer);
            this._timer = setTimeout(bind(this._performZoom, this), left);
            stop(e3);
          },
          _performZoom: function() {
            var map2 = this._map, zoom2 = map2.getZoom(), snap = this._map.options.zoomSnap || 0;
            map2._stop();
            var d22 = this._delta / (this._map.options.wheelPxPerZoomLevel * 4), d3 = 4 * Math.log(2 / (1 + Math.exp(-Math.abs(d22)))) / Math.LN2, d4 = snap ? Math.ceil(d3 / snap) * snap : d3, delta = map2._limitZoom(zoom2 + (this._delta > 0 ? d4 : -d4)) - zoom2;
            this._delta = 0;
            this._startTime = null;
            if (!delta) {
              return;
            }
            if (map2.options.scrollWheelZoom === "center") {
              map2.setZoom(zoom2 + delta);
            } else {
              map2.setZoomAround(this._lastMousePos, zoom2 + delta);
            }
          }
        });
        Map3.addInitHook("addHandler", "scrollWheelZoom", ScrollWheelZoom);
        var tapHoldDelay = 600;
        Map3.mergeOptions({
          // @section Touch interaction options
          // @option tapHold: Boolean
          // Enables simulation of `contextmenu` event, default is `true` for mobile Safari.
          tapHold: Browser.touchNative && Browser.safari && Browser.mobile,
          // @option tapTolerance: Number = 15
          // The max number of pixels a user can shift his finger during touch
          // for it to be considered a valid tap.
          tapTolerance: 15
        });
        var TapHold = Handler.extend({
          addHooks: function() {
            on2(this._map._container, "touchstart", this._onDown, this);
          },
          removeHooks: function() {
            off2(this._map._container, "touchstart", this._onDown, this);
          },
          _onDown: function(e3) {
            clearTimeout(this._holdTimeout);
            if (e3.touches.length !== 1) {
              return;
            }
            var first = e3.touches[0];
            this._startPos = this._newPos = new Point(first.clientX, first.clientY);
            this._holdTimeout = setTimeout(bind(function() {
              this._cancel();
              if (!this._isTapValid()) {
                return;
              }
              on2(document, "touchend", preventDefault);
              on2(document, "touchend touchcancel", this._cancelClickPrevent);
              this._simulateEvent("contextmenu", first);
            }, this), tapHoldDelay);
            on2(document, "touchend touchcancel contextmenu", this._cancel, this);
            on2(document, "touchmove", this._onMove, this);
          },
          _cancelClickPrevent: /* @__PURE__ */ __name(function cancelClickPrevent() {
            off2(document, "touchend", preventDefault);
            off2(document, "touchend touchcancel", cancelClickPrevent);
          }, "cancelClickPrevent"),
          _cancel: function() {
            clearTimeout(this._holdTimeout);
            off2(document, "touchend touchcancel contextmenu", this._cancel, this);
            off2(document, "touchmove", this._onMove, this);
          },
          _onMove: function(e3) {
            var first = e3.touches[0];
            this._newPos = new Point(first.clientX, first.clientY);
          },
          _isTapValid: function() {
            return this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance;
          },
          _simulateEvent: function(type, e3) {
            var simulatedEvent = new MouseEvent(type, {
              bubbles: true,
              cancelable: true,
              view: window,
              // detail: 1,
              screenX: e3.screenX,
              screenY: e3.screenY,
              clientX: e3.clientX,
              clientY: e3.clientY
              // button: 2,
              // buttons: 2
            });
            simulatedEvent._simulated = true;
            e3.target.dispatchEvent(simulatedEvent);
          }
        });
        Map3.addInitHook("addHandler", "tapHold", TapHold);
        Map3.mergeOptions({
          // @section Touch interaction options
          // @option touchZoom: Boolean|String = *
          // Whether the map can be zoomed by touch-dragging with two fingers. If
          // passed `'center'`, it will zoom to the center of the view regardless of
          // where the touch events (fingers) were. Enabled for touch-capable web
          // browsers.
          touchZoom: Browser.touch,
          // @option bounceAtZoomLimits: Boolean = true
          // Set it to false if you don't want the map to zoom beyond min/max zoom
          // and then bounce back when pinch-zooming.
          bounceAtZoomLimits: true
        });
        var TouchZoom = Handler.extend({
          addHooks: function() {
            addClass(this._map._container, "leaflet-touch-zoom");
            on2(this._map._container, "touchstart", this._onTouchStart, this);
          },
          removeHooks: function() {
            removeClass(this._map._container, "leaflet-touch-zoom");
            off2(this._map._container, "touchstart", this._onTouchStart, this);
          },
          _onTouchStart: function(e3) {
            var map2 = this._map;
            if (!e3.touches || e3.touches.length !== 2 || map2._animatingZoom || this._zooming) {
              return;
            }
            var p1 = map2.mouseEventToContainerPoint(e3.touches[0]), p22 = map2.mouseEventToContainerPoint(e3.touches[1]);
            this._centerPoint = map2.getSize()._divideBy(2);
            this._startLatLng = map2.containerPointToLatLng(this._centerPoint);
            if (map2.options.touchZoom !== "center") {
              this._pinchStartLatLng = map2.containerPointToLatLng(p1.add(p22)._divideBy(2));
            }
            this._startDist = p1.distanceTo(p22);
            this._startZoom = map2.getZoom();
            this._moved = false;
            this._zooming = true;
            map2._stop();
            on2(document, "touchmove", this._onTouchMove, this);
            on2(document, "touchend touchcancel", this._onTouchEnd, this);
            preventDefault(e3);
          },
          _onTouchMove: function(e3) {
            if (!e3.touches || e3.touches.length !== 2 || !this._zooming) {
              return;
            }
            var map2 = this._map, p1 = map2.mouseEventToContainerPoint(e3.touches[0]), p22 = map2.mouseEventToContainerPoint(e3.touches[1]), scale2 = p1.distanceTo(p22) / this._startDist;
            this._zoom = map2.getScaleZoom(scale2, this._startZoom);
            if (!map2.options.bounceAtZoomLimits && (this._zoom < map2.getMinZoom() && scale2 < 1 || this._zoom > map2.getMaxZoom() && scale2 > 1)) {
              this._zoom = map2._limitZoom(this._zoom);
            }
            if (map2.options.touchZoom === "center") {
              this._center = this._startLatLng;
              if (scale2 === 1) {
                return;
              }
            } else {
              var delta = p1._add(p22)._divideBy(2)._subtract(this._centerPoint);
              if (scale2 === 1 && delta.x === 0 && delta.y === 0) {
                return;
              }
              this._center = map2.unproject(map2.project(this._pinchStartLatLng, this._zoom).subtract(delta), this._zoom);
            }
            if (!this._moved) {
              map2._moveStart(true, false);
              this._moved = true;
            }
            cancelAnimFrame(this._animRequest);
            var moveFn = bind(map2._move, map2, this._center, this._zoom, { pinch: true, round: false }, void 0);
            this._animRequest = requestAnimFrame(moveFn, this, true);
            preventDefault(e3);
          },
          _onTouchEnd: function() {
            if (!this._moved || !this._zooming) {
              this._zooming = false;
              return;
            }
            this._zooming = false;
            cancelAnimFrame(this._animRequest);
            off2(document, "touchmove", this._onTouchMove, this);
            off2(document, "touchend touchcancel", this._onTouchEnd, this);
            if (this._map.options.zoomAnimation) {
              this._map._animateZoom(this._center, this._map._limitZoom(this._zoom), true, this._map.options.zoomSnap);
            } else {
              this._map._resetView(this._center, this._map._limitZoom(this._zoom));
            }
          }
        });
        Map3.addInitHook("addHandler", "touchZoom", TouchZoom);
        Map3.BoxZoom = BoxZoom;
        Map3.DoubleClickZoom = DoubleClickZoom;
        Map3.Drag = Drag;
        Map3.Keyboard = Keyboard2;
        Map3.ScrollWheelZoom = ScrollWheelZoom;
        Map3.TapHold = TapHold;
        Map3.TouchZoom = TouchZoom;
        exports3.Bounds = Bounds;
        exports3.Browser = Browser;
        exports3.CRS = CRS;
        exports3.Canvas = Canvas;
        exports3.Circle = Circle;
        exports3.CircleMarker = CircleMarker;
        exports3.Class = Class;
        exports3.Control = Control;
        exports3.DivIcon = DivIcon;
        exports3.DivOverlay = DivOverlay;
        exports3.DomEvent = DomEvent;
        exports3.DomUtil = DomUtil;
        exports3.Draggable = Draggable;
        exports3.Evented = Evented;
        exports3.FeatureGroup = FeatureGroup;
        exports3.GeoJSON = GeoJSON;
        exports3.GridLayer = GridLayer;
        exports3.Handler = Handler;
        exports3.Icon = Icon;
        exports3.ImageOverlay = ImageOverlay;
        exports3.LatLng = LatLng;
        exports3.LatLngBounds = LatLngBounds;
        exports3.Layer = Layer;
        exports3.LayerGroup = LayerGroup;
        exports3.LineUtil = LineUtil;
        exports3.Map = Map3;
        exports3.Marker = Marker;
        exports3.Mixin = Mixin;
        exports3.Path = Path;
        exports3.Point = Point;
        exports3.PolyUtil = PolyUtil;
        exports3.Polygon = Polygon;
        exports3.Polyline = Polyline;
        exports3.Popup = Popup;
        exports3.PosAnimation = PosAnimation;
        exports3.Projection = index2;
        exports3.Rectangle = Rectangle;
        exports3.Renderer = Renderer2;
        exports3.SVG = SVG;
        exports3.SVGOverlay = SVGOverlay;
        exports3.TileLayer = TileLayer;
        exports3.Tooltip = Tooltip2;
        exports3.Transformation = Transformation;
        exports3.Util = Util;
        exports3.VideoOverlay = VideoOverlay;
        exports3.bind = bind;
        exports3.bounds = toBounds;
        exports3.canvas = canvas;
        exports3.circle = circle;
        exports3.circleMarker = circleMarker;
        exports3.control = control;
        exports3.divIcon = divIcon;
        exports3.extend = extend3;
        exports3.featureGroup = featureGroup;
        exports3.geoJSON = geoJSON;
        exports3.geoJson = geoJson;
        exports3.gridLayer = gridLayer;
        exports3.icon = icon;
        exports3.imageOverlay = imageOverlay;
        exports3.latLng = toLatLng;
        exports3.latLngBounds = toLatLngBounds;
        exports3.layerGroup = layerGroup;
        exports3.map = createMap;
        exports3.marker = marker;
        exports3.point = toPoint;
        exports3.polygon = polygon;
        exports3.polyline = polyline;
        exports3.popup = popup;
        exports3.rectangle = rectangle;
        exports3.setOptions = setOptions;
        exports3.stamp = stamp;
        exports3.svg = svg;
        exports3.svgOverlay = svgOverlay;
        exports3.tileLayer = tileLayer;
        exports3.tooltip = tooltip;
        exports3.transformation = toTransformation;
        exports3.version = version2;
        exports3.videoOverlay = videoOverlay;
        var oldL = window.L;
        exports3.noConflict = function() {
          window.L = oldL;
          return this;
        };
        window.L = exports3;
      });
    }
  });

  // node_modules/fast-diff/diff.js
  var require_diff = __commonJS({
    "node_modules/fast-diff/diff.js"(exports2, module2) {
      var DIFF_DELETE = -1;
      var DIFF_INSERT = 1;
      var DIFF_EQUAL = 0;
      function diff_main(text1, text2, cursor_pos, cleanup, _fix_unicode) {
        if (text1 === text2) {
          if (text1) {
            return [[DIFF_EQUAL, text1]];
          }
          return [];
        }
        if (cursor_pos != null) {
          var editdiff = find_cursor_edit_diff(text1, text2, cursor_pos);
          if (editdiff) {
            return editdiff;
          }
        }
        var commonlength = diff_commonPrefix(text1, text2);
        var commonprefix = text1.substring(0, commonlength);
        text1 = text1.substring(commonlength);
        text2 = text2.substring(commonlength);
        commonlength = diff_commonSuffix(text1, text2);
        var commonsuffix = text1.substring(text1.length - commonlength);
        text1 = text1.substring(0, text1.length - commonlength);
        text2 = text2.substring(0, text2.length - commonlength);
        var diffs = diff_compute_(text1, text2);
        if (commonprefix) {
          diffs.unshift([DIFF_EQUAL, commonprefix]);
        }
        if (commonsuffix) {
          diffs.push([DIFF_EQUAL, commonsuffix]);
        }
        diff_cleanupMerge(diffs, _fix_unicode);
        if (cleanup) {
          diff_cleanupSemantic(diffs);
        }
        return diffs;
      }
      __name(diff_main, "diff_main");
      function diff_compute_(text1, text2) {
        var diffs;
        if (!text1) {
          return [[DIFF_INSERT, text2]];
        }
        if (!text2) {
          return [[DIFF_DELETE, text1]];
        }
        var longtext = text1.length > text2.length ? text1 : text2;
        var shorttext = text1.length > text2.length ? text2 : text1;
        var i3 = longtext.indexOf(shorttext);
        if (i3 !== -1) {
          diffs = [
            [DIFF_INSERT, longtext.substring(0, i3)],
            [DIFF_EQUAL, shorttext],
            [DIFF_INSERT, longtext.substring(i3 + shorttext.length)]
          ];
          if (text1.length > text2.length) {
            diffs[0][0] = diffs[2][0] = DIFF_DELETE;
          }
          return diffs;
        }
        if (shorttext.length === 1) {
          return [
            [DIFF_DELETE, text1],
            [DIFF_INSERT, text2]
          ];
        }
        var hm = diff_halfMatch_(text1, text2);
        if (hm) {
          var text1_a = hm[0];
          var text1_b = hm[1];
          var text2_a = hm[2];
          var text2_b = hm[3];
          var mid_common = hm[4];
          var diffs_a = diff_main(text1_a, text2_a);
          var diffs_b = diff_main(text1_b, text2_b);
          return diffs_a.concat([[DIFF_EQUAL, mid_common]], diffs_b);
        }
        return diff_bisect_(text1, text2);
      }
      __name(diff_compute_, "diff_compute_");
      function diff_bisect_(text1, text2) {
        var text1_length = text1.length;
        var text2_length = text2.length;
        var max_d = Math.ceil((text1_length + text2_length) / 2);
        var v_offset = max_d;
        var v_length = 2 * max_d;
        var v1 = new Array(v_length);
        var v22 = new Array(v_length);
        for (var x3 = 0; x3 < v_length; x3++) {
          v1[x3] = -1;
          v22[x3] = -1;
        }
        v1[v_offset + 1] = 0;
        v22[v_offset + 1] = 0;
        var delta = text1_length - text2_length;
        var front = delta % 2 !== 0;
        var k1start = 0;
        var k1end = 0;
        var k2start = 0;
        var k2end = 0;
        for (var d3 = 0; d3 < max_d; d3++) {
          for (var k1 = -d3 + k1start; k1 <= d3 - k1end; k1 += 2) {
            var k1_offset = v_offset + k1;
            var x1;
            if (k1 === -d3 || k1 !== d3 && v1[k1_offset - 1] < v1[k1_offset + 1]) {
              x1 = v1[k1_offset + 1];
            } else {
              x1 = v1[k1_offset - 1] + 1;
            }
            var y1 = x1 - k1;
            while (x1 < text1_length && y1 < text2_length && text1.charAt(x1) === text2.charAt(y1)) {
              x1++;
              y1++;
            }
            v1[k1_offset] = x1;
            if (x1 > text1_length) {
              k1end += 2;
            } else if (y1 > text2_length) {
              k1start += 2;
            } else if (front) {
              var k2_offset = v_offset + delta - k1;
              if (k2_offset >= 0 && k2_offset < v_length && v22[k2_offset] !== -1) {
                var x22 = text1_length - v22[k2_offset];
                if (x1 >= x22) {
                  return diff_bisectSplit_(text1, text2, x1, y1);
                }
              }
            }
          }
          for (var k22 = -d3 + k2start; k22 <= d3 - k2end; k22 += 2) {
            var k2_offset = v_offset + k22;
            var x22;
            if (k22 === -d3 || k22 !== d3 && v22[k2_offset - 1] < v22[k2_offset + 1]) {
              x22 = v22[k2_offset + 1];
            } else {
              x22 = v22[k2_offset - 1] + 1;
            }
            var y22 = x22 - k22;
            while (x22 < text1_length && y22 < text2_length && text1.charAt(text1_length - x22 - 1) === text2.charAt(text2_length - y22 - 1)) {
              x22++;
              y22++;
            }
            v22[k2_offset] = x22;
            if (x22 > text1_length) {
              k2end += 2;
            } else if (y22 > text2_length) {
              k2start += 2;
            } else if (!front) {
              var k1_offset = v_offset + delta - k22;
              if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] !== -1) {
                var x1 = v1[k1_offset];
                var y1 = v_offset + x1 - k1_offset;
                x22 = text1_length - x22;
                if (x1 >= x22) {
                  return diff_bisectSplit_(text1, text2, x1, y1);
                }
              }
            }
          }
        }
        return [
          [DIFF_DELETE, text1],
          [DIFF_INSERT, text2]
        ];
      }
      __name(diff_bisect_, "diff_bisect_");
      function diff_bisectSplit_(text1, text2, x3, y3) {
        var text1a = text1.substring(0, x3);
        var text2a = text2.substring(0, y3);
        var text1b = text1.substring(x3);
        var text2b = text2.substring(y3);
        var diffs = diff_main(text1a, text2a);
        var diffsb = diff_main(text1b, text2b);
        return diffs.concat(diffsb);
      }
      __name(diff_bisectSplit_, "diff_bisectSplit_");
      function diff_commonPrefix(text1, text2) {
        if (!text1 || !text2 || text1.charAt(0) !== text2.charAt(0)) {
          return 0;
        }
        var pointermin = 0;
        var pointermax = Math.min(text1.length, text2.length);
        var pointermid = pointermax;
        var pointerstart = 0;
        while (pointermin < pointermid) {
          if (text1.substring(pointerstart, pointermid) == text2.substring(pointerstart, pointermid)) {
            pointermin = pointermid;
            pointerstart = pointermin;
          } else {
            pointermax = pointermid;
          }
          pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
        }
        if (is_surrogate_pair_start(text1.charCodeAt(pointermid - 1))) {
          pointermid--;
        }
        return pointermid;
      }
      __name(diff_commonPrefix, "diff_commonPrefix");
      function diff_commonOverlap_(text1, text2) {
        var text1_length = text1.length;
        var text2_length = text2.length;
        if (text1_length == 0 || text2_length == 0) {
          return 0;
        }
        if (text1_length > text2_length) {
          text1 = text1.substring(text1_length - text2_length);
        } else if (text1_length < text2_length) {
          text2 = text2.substring(0, text1_length);
        }
        var text_length = Math.min(text1_length, text2_length);
        if (text1 == text2) {
          return text_length;
        }
        var best = 0;
        var length = 1;
        while (true) {
          var pattern = text1.substring(text_length - length);
          var found = text2.indexOf(pattern);
          if (found == -1) {
            return best;
          }
          length += found;
          if (found == 0 || text1.substring(text_length - length) == text2.substring(0, length)) {
            best = length;
            length++;
          }
        }
      }
      __name(diff_commonOverlap_, "diff_commonOverlap_");
      function diff_commonSuffix(text1, text2) {
        if (!text1 || !text2 || text1.slice(-1) !== text2.slice(-1)) {
          return 0;
        }
        var pointermin = 0;
        var pointermax = Math.min(text1.length, text2.length);
        var pointermid = pointermax;
        var pointerend = 0;
        while (pointermin < pointermid) {
          if (text1.substring(text1.length - pointermid, text1.length - pointerend) == text2.substring(text2.length - pointermid, text2.length - pointerend)) {
            pointermin = pointermid;
            pointerend = pointermin;
          } else {
            pointermax = pointermid;
          }
          pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
        }
        if (is_surrogate_pair_end(text1.charCodeAt(text1.length - pointermid))) {
          pointermid--;
        }
        return pointermid;
      }
      __name(diff_commonSuffix, "diff_commonSuffix");
      function diff_halfMatch_(text1, text2) {
        var longtext = text1.length > text2.length ? text1 : text2;
        var shorttext = text1.length > text2.length ? text2 : text1;
        if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {
          return null;
        }
        function diff_halfMatchI_(longtext2, shorttext2, i3) {
          var seed = longtext2.substring(i3, i3 + Math.floor(longtext2.length / 4));
          var j3 = -1;
          var best_common = "";
          var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;
          while ((j3 = shorttext2.indexOf(seed, j3 + 1)) !== -1) {
            var prefixLength = diff_commonPrefix(
              longtext2.substring(i3),
              shorttext2.substring(j3)
            );
            var suffixLength = diff_commonSuffix(
              longtext2.substring(0, i3),
              shorttext2.substring(0, j3)
            );
            if (best_common.length < suffixLength + prefixLength) {
              best_common = shorttext2.substring(j3 - suffixLength, j3) + shorttext2.substring(j3, j3 + prefixLength);
              best_longtext_a = longtext2.substring(0, i3 - suffixLength);
              best_longtext_b = longtext2.substring(i3 + prefixLength);
              best_shorttext_a = shorttext2.substring(0, j3 - suffixLength);
              best_shorttext_b = shorttext2.substring(j3 + prefixLength);
            }
          }
          if (best_common.length * 2 >= longtext2.length) {
            return [
              best_longtext_a,
              best_longtext_b,
              best_shorttext_a,
              best_shorttext_b,
              best_common
            ];
          } else {
            return null;
          }
        }
        __name(diff_halfMatchI_, "diff_halfMatchI_");
        var hm1 = diff_halfMatchI_(
          longtext,
          shorttext,
          Math.ceil(longtext.length / 4)
        );
        var hm2 = diff_halfMatchI_(
          longtext,
          shorttext,
          Math.ceil(longtext.length / 2)
        );
        var hm;
        if (!hm1 && !hm2) {
          return null;
        } else if (!hm2) {
          hm = hm1;
        } else if (!hm1) {
          hm = hm2;
        } else {
          hm = hm1[4].length > hm2[4].length ? hm1 : hm2;
        }
        var text1_a, text1_b, text2_a, text2_b;
        if (text1.length > text2.length) {
          text1_a = hm[0];
          text1_b = hm[1];
          text2_a = hm[2];
          text2_b = hm[3];
        } else {
          text2_a = hm[0];
          text2_b = hm[1];
          text1_a = hm[2];
          text1_b = hm[3];
        }
        var mid_common = hm[4];
        return [text1_a, text1_b, text2_a, text2_b, mid_common];
      }
      __name(diff_halfMatch_, "diff_halfMatch_");
      function diff_cleanupSemantic(diffs) {
        var changes = false;
        var equalities = [];
        var equalitiesLength = 0;
        var lastequality = null;
        var pointer = 0;
        var length_insertions1 = 0;
        var length_deletions1 = 0;
        var length_insertions2 = 0;
        var length_deletions2 = 0;
        while (pointer < diffs.length) {
          if (diffs[pointer][0] == DIFF_EQUAL) {
            equalities[equalitiesLength++] = pointer;
            length_insertions1 = length_insertions2;
            length_deletions1 = length_deletions2;
            length_insertions2 = 0;
            length_deletions2 = 0;
            lastequality = diffs[pointer][1];
          } else {
            if (diffs[pointer][0] == DIFF_INSERT) {
              length_insertions2 += diffs[pointer][1].length;
            } else {
              length_deletions2 += diffs[pointer][1].length;
            }
            if (lastequality && lastequality.length <= Math.max(length_insertions1, length_deletions1) && lastequality.length <= Math.max(length_insertions2, length_deletions2)) {
              diffs.splice(equalities[equalitiesLength - 1], 0, [
                DIFF_DELETE,
                lastequality
              ]);
              diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;
              equalitiesLength--;
              equalitiesLength--;
              pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;
              length_insertions1 = 0;
              length_deletions1 = 0;
              length_insertions2 = 0;
              length_deletions2 = 0;
              lastequality = null;
              changes = true;
            }
          }
          pointer++;
        }
        if (changes) {
          diff_cleanupMerge(diffs);
        }
        diff_cleanupSemanticLossless(diffs);
        pointer = 1;
        while (pointer < diffs.length) {
          if (diffs[pointer - 1][0] == DIFF_DELETE && diffs[pointer][0] == DIFF_INSERT) {
            var deletion = diffs[pointer - 1][1];
            var insertion = diffs[pointer][1];
            var overlap_length1 = diff_commonOverlap_(deletion, insertion);
            var overlap_length2 = diff_commonOverlap_(insertion, deletion);
            if (overlap_length1 >= overlap_length2) {
              if (overlap_length1 >= deletion.length / 2 || overlap_length1 >= insertion.length / 2) {
                diffs.splice(pointer, 0, [
                  DIFF_EQUAL,
                  insertion.substring(0, overlap_length1)
                ]);
                diffs[pointer - 1][1] = deletion.substring(
                  0,
                  deletion.length - overlap_length1
                );
                diffs[pointer + 1][1] = insertion.substring(overlap_length1);
                pointer++;
              }
            } else {
              if (overlap_length2 >= deletion.length / 2 || overlap_length2 >= insertion.length / 2) {
                diffs.splice(pointer, 0, [
                  DIFF_EQUAL,
                  deletion.substring(0, overlap_length2)
                ]);
                diffs[pointer - 1][0] = DIFF_INSERT;
                diffs[pointer - 1][1] = insertion.substring(
                  0,
                  insertion.length - overlap_length2
                );
                diffs[pointer + 1][0] = DIFF_DELETE;
                diffs[pointer + 1][1] = deletion.substring(overlap_length2);
                pointer++;
              }
            }
            pointer++;
          }
          pointer++;
        }
      }
      __name(diff_cleanupSemantic, "diff_cleanupSemantic");
      var nonAlphaNumericRegex_ = /[^a-zA-Z0-9]/;
      var whitespaceRegex_ = /\s/;
      var linebreakRegex_ = /[\r\n]/;
      var blanklineEndRegex_ = /\n\r?\n$/;
      var blanklineStartRegex_ = /^\r?\n\r?\n/;
      function diff_cleanupSemanticLossless(diffs) {
        function diff_cleanupSemanticScore_(one, two) {
          if (!one || !two) {
            return 6;
          }
          var char1 = one.charAt(one.length - 1);
          var char2 = two.charAt(0);
          var nonAlphaNumeric1 = char1.match(nonAlphaNumericRegex_);
          var nonAlphaNumeric2 = char2.match(nonAlphaNumericRegex_);
          var whitespace1 = nonAlphaNumeric1 && char1.match(whitespaceRegex_);
          var whitespace2 = nonAlphaNumeric2 && char2.match(whitespaceRegex_);
          var lineBreak1 = whitespace1 && char1.match(linebreakRegex_);
          var lineBreak2 = whitespace2 && char2.match(linebreakRegex_);
          var blankLine1 = lineBreak1 && one.match(blanklineEndRegex_);
          var blankLine2 = lineBreak2 && two.match(blanklineStartRegex_);
          if (blankLine1 || blankLine2) {
            return 5;
          } else if (lineBreak1 || lineBreak2) {
            return 4;
          } else if (nonAlphaNumeric1 && !whitespace1 && whitespace2) {
            return 3;
          } else if (whitespace1 || whitespace2) {
            return 2;
          } else if (nonAlphaNumeric1 || nonAlphaNumeric2) {
            return 1;
          }
          return 0;
        }
        __name(diff_cleanupSemanticScore_, "diff_cleanupSemanticScore_");
        var pointer = 1;
        while (pointer < diffs.length - 1) {
          if (diffs[pointer - 1][0] == DIFF_EQUAL && diffs[pointer + 1][0] == DIFF_EQUAL) {
            var equality1 = diffs[pointer - 1][1];
            var edit = diffs[pointer][1];
            var equality2 = diffs[pointer + 1][1];
            var commonOffset = diff_commonSuffix(equality1, edit);
            if (commonOffset) {
              var commonString = edit.substring(edit.length - commonOffset);
              equality1 = equality1.substring(0, equality1.length - commonOffset);
              edit = commonString + edit.substring(0, edit.length - commonOffset);
              equality2 = commonString + equality2;
            }
            var bestEquality1 = equality1;
            var bestEdit = edit;
            var bestEquality2 = equality2;
            var bestScore = diff_cleanupSemanticScore_(equality1, edit) + diff_cleanupSemanticScore_(edit, equality2);
            while (edit.charAt(0) === equality2.charAt(0)) {
              equality1 += edit.charAt(0);
              edit = edit.substring(1) + equality2.charAt(0);
              equality2 = equality2.substring(1);
              var score = diff_cleanupSemanticScore_(equality1, edit) + diff_cleanupSemanticScore_(edit, equality2);
              if (score >= bestScore) {
                bestScore = score;
                bestEquality1 = equality1;
                bestEdit = edit;
                bestEquality2 = equality2;
              }
            }
            if (diffs[pointer - 1][1] != bestEquality1) {
              if (bestEquality1) {
                diffs[pointer - 1][1] = bestEquality1;
              } else {
                diffs.splice(pointer - 1, 1);
                pointer--;
              }
              diffs[pointer][1] = bestEdit;
              if (bestEquality2) {
                diffs[pointer + 1][1] = bestEquality2;
              } else {
                diffs.splice(pointer + 1, 1);
                pointer--;
              }
            }
          }
          pointer++;
        }
      }
      __name(diff_cleanupSemanticLossless, "diff_cleanupSemanticLossless");
      function diff_cleanupMerge(diffs, fix_unicode) {
        diffs.push([DIFF_EQUAL, ""]);
        var pointer = 0;
        var count_delete = 0;
        var count_insert = 0;
        var text_delete = "";
        var text_insert = "";
        var commonlength;
        while (pointer < diffs.length) {
          if (pointer < diffs.length - 1 && !diffs[pointer][1]) {
            diffs.splice(pointer, 1);
            continue;
          }
          switch (diffs[pointer][0]) {
            case DIFF_INSERT:
              count_insert++;
              text_insert += diffs[pointer][1];
              pointer++;
              break;
            case DIFF_DELETE:
              count_delete++;
              text_delete += diffs[pointer][1];
              pointer++;
              break;
            case DIFF_EQUAL:
              var previous_equality = pointer - count_insert - count_delete - 1;
              if (fix_unicode) {
                if (previous_equality >= 0 && ends_with_pair_start(diffs[previous_equality][1])) {
                  var stray = diffs[previous_equality][1].slice(-1);
                  diffs[previous_equality][1] = diffs[previous_equality][1].slice(
                    0,
                    -1
                  );
                  text_delete = stray + text_delete;
                  text_insert = stray + text_insert;
                  if (!diffs[previous_equality][1]) {
                    diffs.splice(previous_equality, 1);
                    pointer--;
                    var k3 = previous_equality - 1;
                    if (diffs[k3] && diffs[k3][0] === DIFF_INSERT) {
                      count_insert++;
                      text_insert = diffs[k3][1] + text_insert;
                      k3--;
                    }
                    if (diffs[k3] && diffs[k3][0] === DIFF_DELETE) {
                      count_delete++;
                      text_delete = diffs[k3][1] + text_delete;
                      k3--;
                    }
                    previous_equality = k3;
                  }
                }
                if (starts_with_pair_end(diffs[pointer][1])) {
                  var stray = diffs[pointer][1].charAt(0);
                  diffs[pointer][1] = diffs[pointer][1].slice(1);
                  text_delete += stray;
                  text_insert += stray;
                }
              }
              if (pointer < diffs.length - 1 && !diffs[pointer][1]) {
                diffs.splice(pointer, 1);
                break;
              }
              if (text_delete.length > 0 || text_insert.length > 0) {
                if (text_delete.length > 0 && text_insert.length > 0) {
                  commonlength = diff_commonPrefix(text_insert, text_delete);
                  if (commonlength !== 0) {
                    if (previous_equality >= 0) {
                      diffs[previous_equality][1] += text_insert.substring(
                        0,
                        commonlength
                      );
                    } else {
                      diffs.splice(0, 0, [
                        DIFF_EQUAL,
                        text_insert.substring(0, commonlength)
                      ]);
                      pointer++;
                    }
                    text_insert = text_insert.substring(commonlength);
                    text_delete = text_delete.substring(commonlength);
                  }
                  commonlength = diff_commonSuffix(text_insert, text_delete);
                  if (commonlength !== 0) {
                    diffs[pointer][1] = text_insert.substring(text_insert.length - commonlength) + diffs[pointer][1];
                    text_insert = text_insert.substring(
                      0,
                      text_insert.length - commonlength
                    );
                    text_delete = text_delete.substring(
                      0,
                      text_delete.length - commonlength
                    );
                  }
                }
                var n3 = count_insert + count_delete;
                if (text_delete.length === 0 && text_insert.length === 0) {
                  diffs.splice(pointer - n3, n3);
                  pointer = pointer - n3;
                } else if (text_delete.length === 0) {
                  diffs.splice(pointer - n3, n3, [DIFF_INSERT, text_insert]);
                  pointer = pointer - n3 + 1;
                } else if (text_insert.length === 0) {
                  diffs.splice(pointer - n3, n3, [DIFF_DELETE, text_delete]);
                  pointer = pointer - n3 + 1;
                } else {
                  diffs.splice(
                    pointer - n3,
                    n3,
                    [DIFF_DELETE, text_delete],
                    [DIFF_INSERT, text_insert]
                  );
                  pointer = pointer - n3 + 2;
                }
              }
              if (pointer !== 0 && diffs[pointer - 1][0] === DIFF_EQUAL) {
                diffs[pointer - 1][1] += diffs[pointer][1];
                diffs.splice(pointer, 1);
              } else {
                pointer++;
              }
              count_insert = 0;
              count_delete = 0;
              text_delete = "";
              text_insert = "";
              break;
          }
        }
        if (diffs[diffs.length - 1][1] === "") {
          diffs.pop();
        }
        var changes = false;
        pointer = 1;
        while (pointer < diffs.length - 1) {
          if (diffs[pointer - 1][0] === DIFF_EQUAL && diffs[pointer + 1][0] === DIFF_EQUAL) {
            if (diffs[pointer][1].substring(
              diffs[pointer][1].length - diffs[pointer - 1][1].length
            ) === diffs[pointer - 1][1]) {
              diffs[pointer][1] = diffs[pointer - 1][1] + diffs[pointer][1].substring(
                0,
                diffs[pointer][1].length - diffs[pointer - 1][1].length
              );
              diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];
              diffs.splice(pointer - 1, 1);
              changes = true;
            } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) == diffs[pointer + 1][1]) {
              diffs[pointer - 1][1] += diffs[pointer + 1][1];
              diffs[pointer][1] = diffs[pointer][1].substring(diffs[pointer + 1][1].length) + diffs[pointer + 1][1];
              diffs.splice(pointer + 1, 1);
              changes = true;
            }
          }
          pointer++;
        }
        if (changes) {
          diff_cleanupMerge(diffs, fix_unicode);
        }
      }
      __name(diff_cleanupMerge, "diff_cleanupMerge");
      function is_surrogate_pair_start(charCode) {
        return charCode >= 55296 && charCode <= 56319;
      }
      __name(is_surrogate_pair_start, "is_surrogate_pair_start");
      function is_surrogate_pair_end(charCode) {
        return charCode >= 56320 && charCode <= 57343;
      }
      __name(is_surrogate_pair_end, "is_surrogate_pair_end");
      function starts_with_pair_end(str) {
        return is_surrogate_pair_end(str.charCodeAt(0));
      }
      __name(starts_with_pair_end, "starts_with_pair_end");
      function ends_with_pair_start(str) {
        return is_surrogate_pair_start(str.charCodeAt(str.length - 1));
      }
      __name(ends_with_pair_start, "ends_with_pair_start");
      function remove_empty_tuples(tuples) {
        var ret = [];
        for (var i3 = 0; i3 < tuples.length; i3++) {
          if (tuples[i3][1].length > 0) {
            ret.push(tuples[i3]);
          }
        }
        return ret;
      }
      __name(remove_empty_tuples, "remove_empty_tuples");
      function make_edit_splice(before, oldMiddle, newMiddle, after) {
        if (ends_with_pair_start(before) || starts_with_pair_end(after)) {
          return null;
        }
        return remove_empty_tuples([
          [DIFF_EQUAL, before],
          [DIFF_DELETE, oldMiddle],
          [DIFF_INSERT, newMiddle],
          [DIFF_EQUAL, after]
        ]);
      }
      __name(make_edit_splice, "make_edit_splice");
      function find_cursor_edit_diff(oldText, newText, cursor_pos) {
        var oldRange = typeof cursor_pos === "number" ? { index: cursor_pos, length: 0 } : cursor_pos.oldRange;
        var newRange = typeof cursor_pos === "number" ? null : cursor_pos.newRange;
        var oldLength = oldText.length;
        var newLength = newText.length;
        if (oldRange.length === 0 && (newRange === null || newRange.length === 0)) {
          var oldCursor = oldRange.index;
          var oldBefore = oldText.slice(0, oldCursor);
          var oldAfter = oldText.slice(oldCursor);
          var maybeNewCursor = newRange ? newRange.index : null;
          editBefore: {
            var newCursor = oldCursor + newLength - oldLength;
            if (maybeNewCursor !== null && maybeNewCursor !== newCursor) {
              break editBefore;
            }
            if (newCursor < 0 || newCursor > newLength) {
              break editBefore;
            }
            var newBefore = newText.slice(0, newCursor);
            var newAfter = newText.slice(newCursor);
            if (newAfter !== oldAfter) {
              break editBefore;
            }
            var prefixLength = Math.min(oldCursor, newCursor);
            var oldPrefix = oldBefore.slice(0, prefixLength);
            var newPrefix = newBefore.slice(0, prefixLength);
            if (oldPrefix !== newPrefix) {
              break editBefore;
            }
            var oldMiddle = oldBefore.slice(prefixLength);
            var newMiddle = newBefore.slice(prefixLength);
            return make_edit_splice(oldPrefix, oldMiddle, newMiddle, oldAfter);
          }
          editAfter: {
            if (maybeNewCursor !== null && maybeNewCursor !== oldCursor) {
              break editAfter;
            }
            var cursor = oldCursor;
            var newBefore = newText.slice(0, cursor);
            var newAfter = newText.slice(cursor);
            if (newBefore !== oldBefore) {
              break editAfter;
            }
            var suffixLength = Math.min(oldLength - cursor, newLength - cursor);
            var oldSuffix = oldAfter.slice(oldAfter.length - suffixLength);
            var newSuffix = newAfter.slice(newAfter.length - suffixLength);
            if (oldSuffix !== newSuffix) {
              break editAfter;
            }
            var oldMiddle = oldAfter.slice(0, oldAfter.length - suffixLength);
            var newMiddle = newAfter.slice(0, newAfter.length - suffixLength);
            return make_edit_splice(oldBefore, oldMiddle, newMiddle, oldSuffix);
          }
        }
        if (oldRange.length > 0 && newRange && newRange.length === 0) {
          replaceRange: {
            var oldPrefix = oldText.slice(0, oldRange.index);
            var oldSuffix = oldText.slice(oldRange.index + oldRange.length);
            var prefixLength = oldPrefix.length;
            var suffixLength = oldSuffix.length;
            if (newLength < prefixLength + suffixLength) {
              break replaceRange;
            }
            var newPrefix = newText.slice(0, prefixLength);
            var newSuffix = newText.slice(newLength - suffixLength);
            if (oldPrefix !== newPrefix || oldSuffix !== newSuffix) {
              break replaceRange;
            }
            var oldMiddle = oldText.slice(prefixLength, oldLength - suffixLength);
            var newMiddle = newText.slice(prefixLength, newLength - suffixLength);
            return make_edit_splice(oldPrefix, oldMiddle, newMiddle, oldSuffix);
          }
        }
        return null;
      }
      __name(find_cursor_edit_diff, "find_cursor_edit_diff");
      function diff(text1, text2, cursor_pos, cleanup) {
        return diff_main(text1, text2, cursor_pos, cleanup, true);
      }
      __name(diff, "diff");
      diff.INSERT = DIFF_INSERT;
      diff.DELETE = DIFF_DELETE;
      diff.EQUAL = DIFF_EQUAL;
      module2.exports = diff;
    }
  });

  // node_modules/lodash.clonedeep/index.js
  var require_lodash = __commonJS({
    "node_modules/lodash.clonedeep/index.js"(exports2, module2) {
      var LARGE_ARRAY_SIZE2 = 200;
      var HASH_UNDEFINED4 = "__lodash_hash_undefined__";
      var MAX_SAFE_INTEGER3 = 9007199254740991;
      var argsTag5 = "[object Arguments]";
      var arrayTag4 = "[object Array]";
      var boolTag5 = "[object Boolean]";
      var dateTag5 = "[object Date]";
      var errorTag4 = "[object Error]";
      var funcTag4 = "[object Function]";
      var genTag3 = "[object GeneratorFunction]";
      var mapTag7 = "[object Map]";
      var numberTag5 = "[object Number]";
      var objectTag6 = "[object Object]";
      var promiseTag2 = "[object Promise]";
      var regexpTag5 = "[object RegExp]";
      var setTag7 = "[object Set]";
      var stringTag5 = "[object String]";
      var symbolTag4 = "[object Symbol]";
      var weakMapTag4 = "[object WeakMap]";
      var arrayBufferTag5 = "[object ArrayBuffer]";
      var dataViewTag6 = "[object DataView]";
      var float32Tag4 = "[object Float32Array]";
      var float64Tag4 = "[object Float64Array]";
      var int8Tag4 = "[object Int8Array]";
      var int16Tag4 = "[object Int16Array]";
      var int32Tag4 = "[object Int32Array]";
      var uint8Tag4 = "[object Uint8Array]";
      var uint8ClampedTag4 = "[object Uint8ClampedArray]";
      var uint16Tag4 = "[object Uint16Array]";
      var uint32Tag4 = "[object Uint32Array]";
      var reRegExpChar2 = /[\\^$.*+?()[\]{}|]/g;
      var reFlags2 = /\w*$/;
      var reIsHostCtor2 = /^\[object .+?Constructor\]$/;
      var reIsUint2 = /^(?:0|[1-9]\d*)$/;
      var cloneableTags2 = {};
      cloneableTags2[argsTag5] = cloneableTags2[arrayTag4] = cloneableTags2[arrayBufferTag5] = cloneableTags2[dataViewTag6] = cloneableTags2[boolTag5] = cloneableTags2[dateTag5] = cloneableTags2[float32Tag4] = cloneableTags2[float64Tag4] = cloneableTags2[int8Tag4] = cloneableTags2[int16Tag4] = cloneableTags2[int32Tag4] = cloneableTags2[mapTag7] = cloneableTags2[numberTag5] = cloneableTags2[objectTag6] = cloneableTags2[regexpTag5] = cloneableTags2[setTag7] = cloneableTags2[stringTag5] = cloneableTags2[symbolTag4] = cloneableTags2[uint8Tag4] = cloneableTags2[uint8ClampedTag4] = cloneableTags2[uint16Tag4] = cloneableTags2[uint32Tag4] = true;
      cloneableTags2[errorTag4] = cloneableTags2[funcTag4] = cloneableTags2[weakMapTag4] = false;
      var freeGlobal2 = typeof global == "object" && global && global.Object === Object && global;
      var freeSelf2 = typeof self == "object" && self && self.Object === Object && self;
      var root2 = freeGlobal2 || freeSelf2 || Function("return this")();
      var freeExports4 = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
      var freeModule4 = freeExports4 && typeof module2 == "object" && module2 && !module2.nodeType && module2;
      var moduleExports4 = freeModule4 && freeModule4.exports === freeExports4;
      function addMapEntry(map2, pair) {
        map2.set(pair[0], pair[1]);
        return map2;
      }
      __name(addMapEntry, "addMapEntry");
      function addSetEntry(set, value) {
        set.add(value);
        return set;
      }
      __name(addSetEntry, "addSetEntry");
      function arrayEach2(array, iteratee) {
        var index2 = -1, length = array ? array.length : 0;
        while (++index2 < length) {
          if (iteratee(array[index2], index2, array) === false) {
            break;
          }
        }
        return array;
      }
      __name(arrayEach2, "arrayEach");
      function arrayPush2(array, values) {
        var index2 = -1, length = values.length, offset = array.length;
        while (++index2 < length) {
          array[offset + index2] = values[index2];
        }
        return array;
      }
      __name(arrayPush2, "arrayPush");
      function arrayReduce(array, iteratee, accumulator, initAccum) {
        var index2 = -1, length = array ? array.length : 0;
        if (initAccum && length) {
          accumulator = array[++index2];
        }
        while (++index2 < length) {
          accumulator = iteratee(accumulator, array[index2], index2, array);
        }
        return accumulator;
      }
      __name(arrayReduce, "arrayReduce");
      function baseTimes2(n3, iteratee) {
        var index2 = -1, result = Array(n3);
        while (++index2 < n3) {
          result[index2] = iteratee(index2);
        }
        return result;
      }
      __name(baseTimes2, "baseTimes");
      function getValue2(object, key) {
        return object == null ? void 0 : object[key];
      }
      __name(getValue2, "getValue");
      function isHostObject(value) {
        var result = false;
        if (value != null && typeof value.toString != "function") {
          try {
            result = !!(value + "");
          } catch (e3) {
          }
        }
        return result;
      }
      __name(isHostObject, "isHostObject");
      function mapToArray2(map2) {
        var index2 = -1, result = Array(map2.size);
        map2.forEach(function(value, key) {
          result[++index2] = [key, value];
        });
        return result;
      }
      __name(mapToArray2, "mapToArray");
      function overArg2(func, transform) {
        return function(arg) {
          return func(transform(arg));
        };
      }
      __name(overArg2, "overArg");
      function setToArray2(set) {
        var index2 = -1, result = Array(set.size);
        set.forEach(function(value) {
          result[++index2] = value;
        });
        return result;
      }
      __name(setToArray2, "setToArray");
      var arrayProto2 = Array.prototype;
      var funcProto4 = Function.prototype;
      var objectProto17 = Object.prototype;
      var coreJsData2 = root2["__core-js_shared__"];
      var maskSrcKey2 = function() {
        var uid = /[^.]+$/.exec(coreJsData2 && coreJsData2.keys && coreJsData2.keys.IE_PROTO || "");
        return uid ? "Symbol(src)_1." + uid : "";
      }();
      var funcToString4 = funcProto4.toString;
      var hasOwnProperty14 = objectProto17.hasOwnProperty;
      var objectToString2 = objectProto17.toString;
      var reIsNative2 = RegExp(
        "^" + funcToString4.call(hasOwnProperty14).replace(reRegExpChar2, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
      );
      var Buffer4 = moduleExports4 ? root2.Buffer : void 0;
      var Symbol3 = root2.Symbol;
      var Uint8Array3 = root2.Uint8Array;
      var getPrototype2 = overArg2(Object.getPrototypeOf, Object);
      var objectCreate2 = Object.create;
      var propertyIsEnumerable3 = objectProto17.propertyIsEnumerable;
      var splice2 = arrayProto2.splice;
      var nativeGetSymbols3 = Object.getOwnPropertySymbols;
      var nativeIsBuffer2 = Buffer4 ? Buffer4.isBuffer : void 0;
      var nativeKeys2 = overArg2(Object.keys, Object);
      var DataView3 = getNative2(root2, "DataView");
      var Map3 = getNative2(root2, "Map");
      var Promise3 = getNative2(root2, "Promise");
      var Set3 = getNative2(root2, "Set");
      var WeakMap3 = getNative2(root2, "WeakMap");
      var nativeCreate2 = getNative2(Object, "create");
      var dataViewCtorString2 = toSource2(DataView3);
      var mapCtorString2 = toSource2(Map3);
      var promiseCtorString2 = toSource2(Promise3);
      var setCtorString2 = toSource2(Set3);
      var weakMapCtorString2 = toSource2(WeakMap3);
      var symbolProto3 = Symbol3 ? Symbol3.prototype : void 0;
      var symbolValueOf3 = symbolProto3 ? symbolProto3.valueOf : void 0;
      function Hash2(entries) {
        var index2 = -1, length = entries ? entries.length : 0;
        this.clear();
        while (++index2 < length) {
          var entry = entries[index2];
          this.set(entry[0], entry[1]);
        }
      }
      __name(Hash2, "Hash");
      function hashClear2() {
        this.__data__ = nativeCreate2 ? nativeCreate2(null) : {};
      }
      __name(hashClear2, "hashClear");
      function hashDelete2(key) {
        return this.has(key) && delete this.__data__[key];
      }
      __name(hashDelete2, "hashDelete");
      function hashGet2(key) {
        var data = this.__data__;
        if (nativeCreate2) {
          var result = data[key];
          return result === HASH_UNDEFINED4 ? void 0 : result;
        }
        return hasOwnProperty14.call(data, key) ? data[key] : void 0;
      }
      __name(hashGet2, "hashGet");
      function hashHas2(key) {
        var data = this.__data__;
        return nativeCreate2 ? data[key] !== void 0 : hasOwnProperty14.call(data, key);
      }
      __name(hashHas2, "hashHas");
      function hashSet2(key, value) {
        var data = this.__data__;
        data[key] = nativeCreate2 && value === void 0 ? HASH_UNDEFINED4 : value;
        return this;
      }
      __name(hashSet2, "hashSet");
      Hash2.prototype.clear = hashClear2;
      Hash2.prototype["delete"] = hashDelete2;
      Hash2.prototype.get = hashGet2;
      Hash2.prototype.has = hashHas2;
      Hash2.prototype.set = hashSet2;
      function ListCache2(entries) {
        var index2 = -1, length = entries ? entries.length : 0;
        this.clear();
        while (++index2 < length) {
          var entry = entries[index2];
          this.set(entry[0], entry[1]);
        }
      }
      __name(ListCache2, "ListCache");
      function listCacheClear2() {
        this.__data__ = [];
      }
      __name(listCacheClear2, "listCacheClear");
      function listCacheDelete2(key) {
        var data = this.__data__, index2 = assocIndexOf2(data, key);
        if (index2 < 0) {
          return false;
        }
        var lastIndex = data.length - 1;
        if (index2 == lastIndex) {
          data.pop();
        } else {
          splice2.call(data, index2, 1);
        }
        return true;
      }
      __name(listCacheDelete2, "listCacheDelete");
      function listCacheGet2(key) {
        var data = this.__data__, index2 = assocIndexOf2(data, key);
        return index2 < 0 ? void 0 : data[index2][1];
      }
      __name(listCacheGet2, "listCacheGet");
      function listCacheHas2(key) {
        return assocIndexOf2(this.__data__, key) > -1;
      }
      __name(listCacheHas2, "listCacheHas");
      function listCacheSet2(key, value) {
        var data = this.__data__, index2 = assocIndexOf2(data, key);
        if (index2 < 0) {
          data.push([key, value]);
        } else {
          data[index2][1] = value;
        }
        return this;
      }
      __name(listCacheSet2, "listCacheSet");
      ListCache2.prototype.clear = listCacheClear2;
      ListCache2.prototype["delete"] = listCacheDelete2;
      ListCache2.prototype.get = listCacheGet2;
      ListCache2.prototype.has = listCacheHas2;
      ListCache2.prototype.set = listCacheSet2;
      function MapCache2(entries) {
        var index2 = -1, length = entries ? entries.length : 0;
        this.clear();
        while (++index2 < length) {
          var entry = entries[index2];
          this.set(entry[0], entry[1]);
        }
      }
      __name(MapCache2, "MapCache");
      function mapCacheClear2() {
        this.__data__ = {
          "hash": new Hash2(),
          "map": new (Map3 || ListCache2)(),
          "string": new Hash2()
        };
      }
      __name(mapCacheClear2, "mapCacheClear");
      function mapCacheDelete2(key) {
        return getMapData2(this, key)["delete"](key);
      }
      __name(mapCacheDelete2, "mapCacheDelete");
      function mapCacheGet2(key) {
        return getMapData2(this, key).get(key);
      }
      __name(mapCacheGet2, "mapCacheGet");
      function mapCacheHas2(key) {
        return getMapData2(this, key).has(key);
      }
      __name(mapCacheHas2, "mapCacheHas");
      function mapCacheSet2(key, value) {
        getMapData2(this, key).set(key, value);
        return this;
      }
      __name(mapCacheSet2, "mapCacheSet");
      MapCache2.prototype.clear = mapCacheClear2;
      MapCache2.prototype["delete"] = mapCacheDelete2;
      MapCache2.prototype.get = mapCacheGet2;
      MapCache2.prototype.has = mapCacheHas2;
      MapCache2.prototype.set = mapCacheSet2;
      function Stack2(entries) {
        this.__data__ = new ListCache2(entries);
      }
      __name(Stack2, "Stack");
      function stackClear2() {
        this.__data__ = new ListCache2();
      }
      __name(stackClear2, "stackClear");
      function stackDelete2(key) {
        return this.__data__["delete"](key);
      }
      __name(stackDelete2, "stackDelete");
      function stackGet2(key) {
        return this.__data__.get(key);
      }
      __name(stackGet2, "stackGet");
      function stackHas2(key) {
        return this.__data__.has(key);
      }
      __name(stackHas2, "stackHas");
      function stackSet2(key, value) {
        var cache3 = this.__data__;
        if (cache3 instanceof ListCache2) {
          var pairs = cache3.__data__;
          if (!Map3 || pairs.length < LARGE_ARRAY_SIZE2 - 1) {
            pairs.push([key, value]);
            return this;
          }
          cache3 = this.__data__ = new MapCache2(pairs);
        }
        cache3.set(key, value);
        return this;
      }
      __name(stackSet2, "stackSet");
      Stack2.prototype.clear = stackClear2;
      Stack2.prototype["delete"] = stackDelete2;
      Stack2.prototype.get = stackGet2;
      Stack2.prototype.has = stackHas2;
      Stack2.prototype.set = stackSet2;
      function arrayLikeKeys2(value, inherited) {
        var result = isArray2(value) || isArguments2(value) ? baseTimes2(value.length, String) : [];
        var length = result.length, skipIndexes = !!length;
        for (var key in value) {
          if ((inherited || hasOwnProperty14.call(value, key)) && !(skipIndexes && (key == "length" || isIndex2(key, length)))) {
            result.push(key);
          }
        }
        return result;
      }
      __name(arrayLikeKeys2, "arrayLikeKeys");
      function assignValue2(object, key, value) {
        var objValue = object[key];
        if (!(hasOwnProperty14.call(object, key) && eq2(objValue, value)) || value === void 0 && !(key in object)) {
          object[key] = value;
        }
      }
      __name(assignValue2, "assignValue");
      function assocIndexOf2(array, key) {
        var length = array.length;
        while (length--) {
          if (eq2(array[length][0], key)) {
            return length;
          }
        }
        return -1;
      }
      __name(assocIndexOf2, "assocIndexOf");
      function baseAssign2(object, source) {
        return object && copyObject2(source, keys2(source), object);
      }
      __name(baseAssign2, "baseAssign");
      function baseClone2(value, isDeep, isFull, customizer, key, object, stack) {
        var result;
        if (customizer) {
          result = object ? customizer(value, key, object, stack) : customizer(value);
        }
        if (result !== void 0) {
          return result;
        }
        if (!isObject2(value)) {
          return value;
        }
        var isArr = isArray2(value);
        if (isArr) {
          result = initCloneArray2(value);
          if (!isDeep) {
            return copyArray2(value, result);
          }
        } else {
          var tag = getTag2(value), isFunc = tag == funcTag4 || tag == genTag3;
          if (isBuffer2(value)) {
            return cloneBuffer2(value, isDeep);
          }
          if (tag == objectTag6 || tag == argsTag5 || isFunc && !object) {
            if (isHostObject(value)) {
              return object ? value : {};
            }
            result = initCloneObject2(isFunc ? {} : value);
            if (!isDeep) {
              return copySymbols2(value, baseAssign2(result, value));
            }
          } else {
            if (!cloneableTags2[tag]) {
              return object ? value : {};
            }
            result = initCloneByTag2(value, tag, baseClone2, isDeep);
          }
        }
        stack || (stack = new Stack2());
        var stacked = stack.get(value);
        if (stacked) {
          return stacked;
        }
        stack.set(value, result);
        if (!isArr) {
          var props = isFull ? getAllKeys2(value) : keys2(value);
        }
        arrayEach2(props || value, function(subValue, key2) {
          if (props) {
            key2 = subValue;
            subValue = value[key2];
          }
          assignValue2(result, key2, baseClone2(subValue, isDeep, isFull, customizer, key2, value, stack));
        });
        return result;
      }
      __name(baseClone2, "baseClone");
      function baseCreate2(proto) {
        return isObject2(proto) ? objectCreate2(proto) : {};
      }
      __name(baseCreate2, "baseCreate");
      function baseGetAllKeys2(object, keysFunc, symbolsFunc) {
        var result = keysFunc(object);
        return isArray2(object) ? result : arrayPush2(result, symbolsFunc(object));
      }
      __name(baseGetAllKeys2, "baseGetAllKeys");
      function baseGetTag2(value) {
        return objectToString2.call(value);
      }
      __name(baseGetTag2, "baseGetTag");
      function baseIsNative2(value) {
        if (!isObject2(value) || isMasked2(value)) {
          return false;
        }
        var pattern = isFunction2(value) || isHostObject(value) ? reIsNative2 : reIsHostCtor2;
        return pattern.test(toSource2(value));
      }
      __name(baseIsNative2, "baseIsNative");
      function baseKeys2(object) {
        if (!isPrototype2(object)) {
          return nativeKeys2(object);
        }
        var result = [];
        for (var key in Object(object)) {
          if (hasOwnProperty14.call(object, key) && key != "constructor") {
            result.push(key);
          }
        }
        return result;
      }
      __name(baseKeys2, "baseKeys");
      function cloneBuffer2(buffer, isDeep) {
        if (isDeep) {
          return buffer.slice();
        }
        var result = new buffer.constructor(buffer.length);
        buffer.copy(result);
        return result;
      }
      __name(cloneBuffer2, "cloneBuffer");
      function cloneArrayBuffer2(arrayBuffer) {
        var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
        new Uint8Array3(result).set(new Uint8Array3(arrayBuffer));
        return result;
      }
      __name(cloneArrayBuffer2, "cloneArrayBuffer");
      function cloneDataView2(dataView, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer2(dataView.buffer) : dataView.buffer;
        return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
      }
      __name(cloneDataView2, "cloneDataView");
      function cloneMap(map2, isDeep, cloneFunc) {
        var array = isDeep ? cloneFunc(mapToArray2(map2), true) : mapToArray2(map2);
        return arrayReduce(array, addMapEntry, new map2.constructor());
      }
      __name(cloneMap, "cloneMap");
      function cloneRegExp2(regexp) {
        var result = new regexp.constructor(regexp.source, reFlags2.exec(regexp));
        result.lastIndex = regexp.lastIndex;
        return result;
      }
      __name(cloneRegExp2, "cloneRegExp");
      function cloneSet(set, isDeep, cloneFunc) {
        var array = isDeep ? cloneFunc(setToArray2(set), true) : setToArray2(set);
        return arrayReduce(array, addSetEntry, new set.constructor());
      }
      __name(cloneSet, "cloneSet");
      function cloneSymbol2(symbol) {
        return symbolValueOf3 ? Object(symbolValueOf3.call(symbol)) : {};
      }
      __name(cloneSymbol2, "cloneSymbol");
      function cloneTypedArray2(typedArray, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer2(typedArray.buffer) : typedArray.buffer;
        return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
      }
      __name(cloneTypedArray2, "cloneTypedArray");
      function copyArray2(source, array) {
        var index2 = -1, length = source.length;
        array || (array = Array(length));
        while (++index2 < length) {
          array[index2] = source[index2];
        }
        return array;
      }
      __name(copyArray2, "copyArray");
      function copyObject2(source, props, object, customizer) {
        object || (object = {});
        var index2 = -1, length = props.length;
        while (++index2 < length) {
          var key = props[index2];
          var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
          assignValue2(object, key, newValue === void 0 ? source[key] : newValue);
        }
        return object;
      }
      __name(copyObject2, "copyObject");
      function copySymbols2(source, object) {
        return copyObject2(source, getSymbols2(source), object);
      }
      __name(copySymbols2, "copySymbols");
      function getAllKeys2(object) {
        return baseGetAllKeys2(object, keys2, getSymbols2);
      }
      __name(getAllKeys2, "getAllKeys");
      function getMapData2(map2, key) {
        var data = map2.__data__;
        return isKeyable2(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
      }
      __name(getMapData2, "getMapData");
      function getNative2(object, key) {
        var value = getValue2(object, key);
        return baseIsNative2(value) ? value : void 0;
      }
      __name(getNative2, "getNative");
      var getSymbols2 = nativeGetSymbols3 ? overArg2(nativeGetSymbols3, Object) : stubArray2;
      var getTag2 = baseGetTag2;
      if (DataView3 && getTag2(new DataView3(new ArrayBuffer(1))) != dataViewTag6 || Map3 && getTag2(new Map3()) != mapTag7 || Promise3 && getTag2(Promise3.resolve()) != promiseTag2 || Set3 && getTag2(new Set3()) != setTag7 || WeakMap3 && getTag2(new WeakMap3()) != weakMapTag4) {
        getTag2 = /* @__PURE__ */ __name(function(value) {
          var result = objectToString2.call(value), Ctor = result == objectTag6 ? value.constructor : void 0, ctorString = Ctor ? toSource2(Ctor) : void 0;
          if (ctorString) {
            switch (ctorString) {
              case dataViewCtorString2:
                return dataViewTag6;
              case mapCtorString2:
                return mapTag7;
              case promiseCtorString2:
                return promiseTag2;
              case setCtorString2:
                return setTag7;
              case weakMapCtorString2:
                return weakMapTag4;
            }
          }
          return result;
        }, "getTag");
      }
      function initCloneArray2(array) {
        var length = array.length, result = array.constructor(length);
        if (length && typeof array[0] == "string" && hasOwnProperty14.call(array, "index")) {
          result.index = array.index;
          result.input = array.input;
        }
        return result;
      }
      __name(initCloneArray2, "initCloneArray");
      function initCloneObject2(object) {
        return typeof object.constructor == "function" && !isPrototype2(object) ? baseCreate2(getPrototype2(object)) : {};
      }
      __name(initCloneObject2, "initCloneObject");
      function initCloneByTag2(object, tag, cloneFunc, isDeep) {
        var Ctor = object.constructor;
        switch (tag) {
          case arrayBufferTag5:
            return cloneArrayBuffer2(object);
          case boolTag5:
          case dateTag5:
            return new Ctor(+object);
          case dataViewTag6:
            return cloneDataView2(object, isDeep);
          case float32Tag4:
          case float64Tag4:
          case int8Tag4:
          case int16Tag4:
          case int32Tag4:
          case uint8Tag4:
          case uint8ClampedTag4:
          case uint16Tag4:
          case uint32Tag4:
            return cloneTypedArray2(object, isDeep);
          case mapTag7:
            return cloneMap(object, isDeep, cloneFunc);
          case numberTag5:
          case stringTag5:
            return new Ctor(object);
          case regexpTag5:
            return cloneRegExp2(object);
          case setTag7:
            return cloneSet(object, isDeep, cloneFunc);
          case symbolTag4:
            return cloneSymbol2(object);
        }
      }
      __name(initCloneByTag2, "initCloneByTag");
      function isIndex2(value, length) {
        length = length == null ? MAX_SAFE_INTEGER3 : length;
        return !!length && (typeof value == "number" || reIsUint2.test(value)) && (value > -1 && value % 1 == 0 && value < length);
      }
      __name(isIndex2, "isIndex");
      function isKeyable2(value) {
        var type = typeof value;
        return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
      }
      __name(isKeyable2, "isKeyable");
      function isMasked2(func) {
        return !!maskSrcKey2 && maskSrcKey2 in func;
      }
      __name(isMasked2, "isMasked");
      function isPrototype2(value) {
        var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto17;
        return value === proto;
      }
      __name(isPrototype2, "isPrototype");
      function toSource2(func) {
        if (func != null) {
          try {
            return funcToString4.call(func);
          } catch (e3) {
          }
          try {
            return func + "";
          } catch (e3) {
          }
        }
        return "";
      }
      __name(toSource2, "toSource");
      function cloneDeep2(value) {
        return baseClone2(value, true, true);
      }
      __name(cloneDeep2, "cloneDeep");
      function eq2(value, other) {
        return value === other || value !== value && other !== other;
      }
      __name(eq2, "eq");
      function isArguments2(value) {
        return isArrayLikeObject2(value) && hasOwnProperty14.call(value, "callee") && (!propertyIsEnumerable3.call(value, "callee") || objectToString2.call(value) == argsTag5);
      }
      __name(isArguments2, "isArguments");
      var isArray2 = Array.isArray;
      function isArrayLike2(value) {
        return value != null && isLength2(value.length) && !isFunction2(value);
      }
      __name(isArrayLike2, "isArrayLike");
      function isArrayLikeObject2(value) {
        return isObjectLike2(value) && isArrayLike2(value);
      }
      __name(isArrayLikeObject2, "isArrayLikeObject");
      var isBuffer2 = nativeIsBuffer2 || stubFalse2;
      function isFunction2(value) {
        var tag = isObject2(value) ? objectToString2.call(value) : "";
        return tag == funcTag4 || tag == genTag3;
      }
      __name(isFunction2, "isFunction");
      function isLength2(value) {
        return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER3;
      }
      __name(isLength2, "isLength");
      function isObject2(value) {
        var type = typeof value;
        return !!value && (type == "object" || type == "function");
      }
      __name(isObject2, "isObject");
      function isObjectLike2(value) {
        return !!value && typeof value == "object";
      }
      __name(isObjectLike2, "isObjectLike");
      function keys2(object) {
        return isArrayLike2(object) ? arrayLikeKeys2(object) : baseKeys2(object);
      }
      __name(keys2, "keys");
      function stubArray2() {
        return [];
      }
      __name(stubArray2, "stubArray");
      function stubFalse2() {
        return false;
      }
      __name(stubFalse2, "stubFalse");
      module2.exports = cloneDeep2;
    }
  });

  // node_modules/lodash.isequal/index.js
  var require_lodash2 = __commonJS({
    "node_modules/lodash.isequal/index.js"(exports2, module2) {
      var LARGE_ARRAY_SIZE2 = 200;
      var HASH_UNDEFINED4 = "__lodash_hash_undefined__";
      var COMPARE_PARTIAL_FLAG5 = 1;
      var COMPARE_UNORDERED_FLAG3 = 2;
      var MAX_SAFE_INTEGER3 = 9007199254740991;
      var argsTag5 = "[object Arguments]";
      var arrayTag4 = "[object Array]";
      var asyncTag2 = "[object AsyncFunction]";
      var boolTag5 = "[object Boolean]";
      var dateTag5 = "[object Date]";
      var errorTag4 = "[object Error]";
      var funcTag4 = "[object Function]";
      var genTag3 = "[object GeneratorFunction]";
      var mapTag7 = "[object Map]";
      var numberTag5 = "[object Number]";
      var nullTag2 = "[object Null]";
      var objectTag6 = "[object Object]";
      var promiseTag2 = "[object Promise]";
      var proxyTag2 = "[object Proxy]";
      var regexpTag5 = "[object RegExp]";
      var setTag7 = "[object Set]";
      var stringTag5 = "[object String]";
      var symbolTag4 = "[object Symbol]";
      var undefinedTag2 = "[object Undefined]";
      var weakMapTag4 = "[object WeakMap]";
      var arrayBufferTag5 = "[object ArrayBuffer]";
      var dataViewTag6 = "[object DataView]";
      var float32Tag4 = "[object Float32Array]";
      var float64Tag4 = "[object Float64Array]";
      var int8Tag4 = "[object Int8Array]";
      var int16Tag4 = "[object Int16Array]";
      var int32Tag4 = "[object Int32Array]";
      var uint8Tag4 = "[object Uint8Array]";
      var uint8ClampedTag4 = "[object Uint8ClampedArray]";
      var uint16Tag4 = "[object Uint16Array]";
      var uint32Tag4 = "[object Uint32Array]";
      var reRegExpChar2 = /[\\^$.*+?()[\]{}|]/g;
      var reIsHostCtor2 = /^\[object .+?Constructor\]$/;
      var reIsUint2 = /^(?:0|[1-9]\d*)$/;
      var typedArrayTags2 = {};
      typedArrayTags2[float32Tag4] = typedArrayTags2[float64Tag4] = typedArrayTags2[int8Tag4] = typedArrayTags2[int16Tag4] = typedArrayTags2[int32Tag4] = typedArrayTags2[uint8Tag4] = typedArrayTags2[uint8ClampedTag4] = typedArrayTags2[uint16Tag4] = typedArrayTags2[uint32Tag4] = true;
      typedArrayTags2[argsTag5] = typedArrayTags2[arrayTag4] = typedArrayTags2[arrayBufferTag5] = typedArrayTags2[boolTag5] = typedArrayTags2[dataViewTag6] = typedArrayTags2[dateTag5] = typedArrayTags2[errorTag4] = typedArrayTags2[funcTag4] = typedArrayTags2[mapTag7] = typedArrayTags2[numberTag5] = typedArrayTags2[objectTag6] = typedArrayTags2[regexpTag5] = typedArrayTags2[setTag7] = typedArrayTags2[stringTag5] = typedArrayTags2[weakMapTag4] = false;
      var freeGlobal2 = typeof global == "object" && global && global.Object === Object && global;
      var freeSelf2 = typeof self == "object" && self && self.Object === Object && self;
      var root2 = freeGlobal2 || freeSelf2 || Function("return this")();
      var freeExports4 = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
      var freeModule4 = freeExports4 && typeof module2 == "object" && module2 && !module2.nodeType && module2;
      var moduleExports4 = freeModule4 && freeModule4.exports === freeExports4;
      var freeProcess2 = moduleExports4 && freeGlobal2.process;
      var nodeUtil2 = function() {
        try {
          return freeProcess2 && freeProcess2.binding && freeProcess2.binding("util");
        } catch (e3) {
        }
      }();
      var nodeIsTypedArray2 = nodeUtil2 && nodeUtil2.isTypedArray;
      function arrayFilter2(array, predicate) {
        var index2 = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
        while (++index2 < length) {
          var value = array[index2];
          if (predicate(value, index2, array)) {
            result[resIndex++] = value;
          }
        }
        return result;
      }
      __name(arrayFilter2, "arrayFilter");
      function arrayPush2(array, values) {
        var index2 = -1, length = values.length, offset = array.length;
        while (++index2 < length) {
          array[offset + index2] = values[index2];
        }
        return array;
      }
      __name(arrayPush2, "arrayPush");
      function arraySome2(array, predicate) {
        var index2 = -1, length = array == null ? 0 : array.length;
        while (++index2 < length) {
          if (predicate(array[index2], index2, array)) {
            return true;
          }
        }
        return false;
      }
      __name(arraySome2, "arraySome");
      function baseTimes2(n3, iteratee) {
        var index2 = -1, result = Array(n3);
        while (++index2 < n3) {
          result[index2] = iteratee(index2);
        }
        return result;
      }
      __name(baseTimes2, "baseTimes");
      function baseUnary2(func) {
        return function(value) {
          return func(value);
        };
      }
      __name(baseUnary2, "baseUnary");
      function cacheHas2(cache3, key) {
        return cache3.has(key);
      }
      __name(cacheHas2, "cacheHas");
      function getValue2(object, key) {
        return object == null ? void 0 : object[key];
      }
      __name(getValue2, "getValue");
      function mapToArray2(map2) {
        var index2 = -1, result = Array(map2.size);
        map2.forEach(function(value, key) {
          result[++index2] = [key, value];
        });
        return result;
      }
      __name(mapToArray2, "mapToArray");
      function overArg2(func, transform) {
        return function(arg) {
          return func(transform(arg));
        };
      }
      __name(overArg2, "overArg");
      function setToArray2(set) {
        var index2 = -1, result = Array(set.size);
        set.forEach(function(value) {
          result[++index2] = value;
        });
        return result;
      }
      __name(setToArray2, "setToArray");
      var arrayProto2 = Array.prototype;
      var funcProto4 = Function.prototype;
      var objectProto17 = Object.prototype;
      var coreJsData2 = root2["__core-js_shared__"];
      var funcToString4 = funcProto4.toString;
      var hasOwnProperty14 = objectProto17.hasOwnProperty;
      var maskSrcKey2 = function() {
        var uid = /[^.]+$/.exec(coreJsData2 && coreJsData2.keys && coreJsData2.keys.IE_PROTO || "");
        return uid ? "Symbol(src)_1." + uid : "";
      }();
      var nativeObjectToString3 = objectProto17.toString;
      var reIsNative2 = RegExp(
        "^" + funcToString4.call(hasOwnProperty14).replace(reRegExpChar2, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
      );
      var Buffer4 = moduleExports4 ? root2.Buffer : void 0;
      var Symbol3 = root2.Symbol;
      var Uint8Array3 = root2.Uint8Array;
      var propertyIsEnumerable3 = objectProto17.propertyIsEnumerable;
      var splice2 = arrayProto2.splice;
      var symToStringTag3 = Symbol3 ? Symbol3.toStringTag : void 0;
      var nativeGetSymbols3 = Object.getOwnPropertySymbols;
      var nativeIsBuffer2 = Buffer4 ? Buffer4.isBuffer : void 0;
      var nativeKeys2 = overArg2(Object.keys, Object);
      var DataView3 = getNative2(root2, "DataView");
      var Map3 = getNative2(root2, "Map");
      var Promise3 = getNative2(root2, "Promise");
      var Set3 = getNative2(root2, "Set");
      var WeakMap3 = getNative2(root2, "WeakMap");
      var nativeCreate2 = getNative2(Object, "create");
      var dataViewCtorString2 = toSource2(DataView3);
      var mapCtorString2 = toSource2(Map3);
      var promiseCtorString2 = toSource2(Promise3);
      var setCtorString2 = toSource2(Set3);
      var weakMapCtorString2 = toSource2(WeakMap3);
      var symbolProto3 = Symbol3 ? Symbol3.prototype : void 0;
      var symbolValueOf3 = symbolProto3 ? symbolProto3.valueOf : void 0;
      function Hash2(entries) {
        var index2 = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index2 < length) {
          var entry = entries[index2];
          this.set(entry[0], entry[1]);
        }
      }
      __name(Hash2, "Hash");
      function hashClear2() {
        this.__data__ = nativeCreate2 ? nativeCreate2(null) : {};
        this.size = 0;
      }
      __name(hashClear2, "hashClear");
      function hashDelete2(key) {
        var result = this.has(key) && delete this.__data__[key];
        this.size -= result ? 1 : 0;
        return result;
      }
      __name(hashDelete2, "hashDelete");
      function hashGet2(key) {
        var data = this.__data__;
        if (nativeCreate2) {
          var result = data[key];
          return result === HASH_UNDEFINED4 ? void 0 : result;
        }
        return hasOwnProperty14.call(data, key) ? data[key] : void 0;
      }
      __name(hashGet2, "hashGet");
      function hashHas2(key) {
        var data = this.__data__;
        return nativeCreate2 ? data[key] !== void 0 : hasOwnProperty14.call(data, key);
      }
      __name(hashHas2, "hashHas");
      function hashSet2(key, value) {
        var data = this.__data__;
        this.size += this.has(key) ? 0 : 1;
        data[key] = nativeCreate2 && value === void 0 ? HASH_UNDEFINED4 : value;
        return this;
      }
      __name(hashSet2, "hashSet");
      Hash2.prototype.clear = hashClear2;
      Hash2.prototype["delete"] = hashDelete2;
      Hash2.prototype.get = hashGet2;
      Hash2.prototype.has = hashHas2;
      Hash2.prototype.set = hashSet2;
      function ListCache2(entries) {
        var index2 = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index2 < length) {
          var entry = entries[index2];
          this.set(entry[0], entry[1]);
        }
      }
      __name(ListCache2, "ListCache");
      function listCacheClear2() {
        this.__data__ = [];
        this.size = 0;
      }
      __name(listCacheClear2, "listCacheClear");
      function listCacheDelete2(key) {
        var data = this.__data__, index2 = assocIndexOf2(data, key);
        if (index2 < 0) {
          return false;
        }
        var lastIndex = data.length - 1;
        if (index2 == lastIndex) {
          data.pop();
        } else {
          splice2.call(data, index2, 1);
        }
        --this.size;
        return true;
      }
      __name(listCacheDelete2, "listCacheDelete");
      function listCacheGet2(key) {
        var data = this.__data__, index2 = assocIndexOf2(data, key);
        return index2 < 0 ? void 0 : data[index2][1];
      }
      __name(listCacheGet2, "listCacheGet");
      function listCacheHas2(key) {
        return assocIndexOf2(this.__data__, key) > -1;
      }
      __name(listCacheHas2, "listCacheHas");
      function listCacheSet2(key, value) {
        var data = this.__data__, index2 = assocIndexOf2(data, key);
        if (index2 < 0) {
          ++this.size;
          data.push([key, value]);
        } else {
          data[index2][1] = value;
        }
        return this;
      }
      __name(listCacheSet2, "listCacheSet");
      ListCache2.prototype.clear = listCacheClear2;
      ListCache2.prototype["delete"] = listCacheDelete2;
      ListCache2.prototype.get = listCacheGet2;
      ListCache2.prototype.has = listCacheHas2;
      ListCache2.prototype.set = listCacheSet2;
      function MapCache2(entries) {
        var index2 = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index2 < length) {
          var entry = entries[index2];
          this.set(entry[0], entry[1]);
        }
      }
      __name(MapCache2, "MapCache");
      function mapCacheClear2() {
        this.size = 0;
        this.__data__ = {
          "hash": new Hash2(),
          "map": new (Map3 || ListCache2)(),
          "string": new Hash2()
        };
      }
      __name(mapCacheClear2, "mapCacheClear");
      function mapCacheDelete2(key) {
        var result = getMapData2(this, key)["delete"](key);
        this.size -= result ? 1 : 0;
        return result;
      }
      __name(mapCacheDelete2, "mapCacheDelete");
      function mapCacheGet2(key) {
        return getMapData2(this, key).get(key);
      }
      __name(mapCacheGet2, "mapCacheGet");
      function mapCacheHas2(key) {
        return getMapData2(this, key).has(key);
      }
      __name(mapCacheHas2, "mapCacheHas");
      function mapCacheSet2(key, value) {
        var data = getMapData2(this, key), size = data.size;
        data.set(key, value);
        this.size += data.size == size ? 0 : 1;
        return this;
      }
      __name(mapCacheSet2, "mapCacheSet");
      MapCache2.prototype.clear = mapCacheClear2;
      MapCache2.prototype["delete"] = mapCacheDelete2;
      MapCache2.prototype.get = mapCacheGet2;
      MapCache2.prototype.has = mapCacheHas2;
      MapCache2.prototype.set = mapCacheSet2;
      function SetCache2(values) {
        var index2 = -1, length = values == null ? 0 : values.length;
        this.__data__ = new MapCache2();
        while (++index2 < length) {
          this.add(values[index2]);
        }
      }
      __name(SetCache2, "SetCache");
      function setCacheAdd2(value) {
        this.__data__.set(value, HASH_UNDEFINED4);
        return this;
      }
      __name(setCacheAdd2, "setCacheAdd");
      function setCacheHas2(value) {
        return this.__data__.has(value);
      }
      __name(setCacheHas2, "setCacheHas");
      SetCache2.prototype.add = SetCache2.prototype.push = setCacheAdd2;
      SetCache2.prototype.has = setCacheHas2;
      function Stack2(entries) {
        var data = this.__data__ = new ListCache2(entries);
        this.size = data.size;
      }
      __name(Stack2, "Stack");
      function stackClear2() {
        this.__data__ = new ListCache2();
        this.size = 0;
      }
      __name(stackClear2, "stackClear");
      function stackDelete2(key) {
        var data = this.__data__, result = data["delete"](key);
        this.size = data.size;
        return result;
      }
      __name(stackDelete2, "stackDelete");
      function stackGet2(key) {
        return this.__data__.get(key);
      }
      __name(stackGet2, "stackGet");
      function stackHas2(key) {
        return this.__data__.has(key);
      }
      __name(stackHas2, "stackHas");
      function stackSet2(key, value) {
        var data = this.__data__;
        if (data instanceof ListCache2) {
          var pairs = data.__data__;
          if (!Map3 || pairs.length < LARGE_ARRAY_SIZE2 - 1) {
            pairs.push([key, value]);
            this.size = ++data.size;
            return this;
          }
          data = this.__data__ = new MapCache2(pairs);
        }
        data.set(key, value);
        this.size = data.size;
        return this;
      }
      __name(stackSet2, "stackSet");
      Stack2.prototype.clear = stackClear2;
      Stack2.prototype["delete"] = stackDelete2;
      Stack2.prototype.get = stackGet2;
      Stack2.prototype.has = stackHas2;
      Stack2.prototype.set = stackSet2;
      function arrayLikeKeys2(value, inherited) {
        var isArr = isArray2(value), isArg = !isArr && isArguments2(value), isBuff = !isArr && !isArg && isBuffer2(value), isType = !isArr && !isArg && !isBuff && isTypedArray2(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes2(value.length, String) : [], length = result.length;
        for (var key in value) {
          if ((inherited || hasOwnProperty14.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
          (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
          isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
          isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
          isIndex2(key, length)))) {
            result.push(key);
          }
        }
        return result;
      }
      __name(arrayLikeKeys2, "arrayLikeKeys");
      function assocIndexOf2(array, key) {
        var length = array.length;
        while (length--) {
          if (eq2(array[length][0], key)) {
            return length;
          }
        }
        return -1;
      }
      __name(assocIndexOf2, "assocIndexOf");
      function baseGetAllKeys2(object, keysFunc, symbolsFunc) {
        var result = keysFunc(object);
        return isArray2(object) ? result : arrayPush2(result, symbolsFunc(object));
      }
      __name(baseGetAllKeys2, "baseGetAllKeys");
      function baseGetTag2(value) {
        if (value == null) {
          return value === void 0 ? undefinedTag2 : nullTag2;
        }
        return symToStringTag3 && symToStringTag3 in Object(value) ? getRawTag2(value) : objectToString2(value);
      }
      __name(baseGetTag2, "baseGetTag");
      function baseIsArguments2(value) {
        return isObjectLike2(value) && baseGetTag2(value) == argsTag5;
      }
      __name(baseIsArguments2, "baseIsArguments");
      function baseIsEqual2(value, other, bitmask, customizer, stack) {
        if (value === other) {
          return true;
        }
        if (value == null || other == null || !isObjectLike2(value) && !isObjectLike2(other)) {
          return value !== value && other !== other;
        }
        return baseIsEqualDeep2(value, other, bitmask, customizer, baseIsEqual2, stack);
      }
      __name(baseIsEqual2, "baseIsEqual");
      function baseIsEqualDeep2(object, other, bitmask, customizer, equalFunc, stack) {
        var objIsArr = isArray2(object), othIsArr = isArray2(other), objTag = objIsArr ? arrayTag4 : getTag2(object), othTag = othIsArr ? arrayTag4 : getTag2(other);
        objTag = objTag == argsTag5 ? objectTag6 : objTag;
        othTag = othTag == argsTag5 ? objectTag6 : othTag;
        var objIsObj = objTag == objectTag6, othIsObj = othTag == objectTag6, isSameTag = objTag == othTag;
        if (isSameTag && isBuffer2(object)) {
          if (!isBuffer2(other)) {
            return false;
          }
          objIsArr = true;
          objIsObj = false;
        }
        if (isSameTag && !objIsObj) {
          stack || (stack = new Stack2());
          return objIsArr || isTypedArray2(object) ? equalArrays2(object, other, bitmask, customizer, equalFunc, stack) : equalByTag2(object, other, objTag, bitmask, customizer, equalFunc, stack);
        }
        if (!(bitmask & COMPARE_PARTIAL_FLAG5)) {
          var objIsWrapped = objIsObj && hasOwnProperty14.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty14.call(other, "__wrapped__");
          if (objIsWrapped || othIsWrapped) {
            var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
            stack || (stack = new Stack2());
            return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
          }
        }
        if (!isSameTag) {
          return false;
        }
        stack || (stack = new Stack2());
        return equalObjects2(object, other, bitmask, customizer, equalFunc, stack);
      }
      __name(baseIsEqualDeep2, "baseIsEqualDeep");
      function baseIsNative2(value) {
        if (!isObject2(value) || isMasked2(value)) {
          return false;
        }
        var pattern = isFunction2(value) ? reIsNative2 : reIsHostCtor2;
        return pattern.test(toSource2(value));
      }
      __name(baseIsNative2, "baseIsNative");
      function baseIsTypedArray2(value) {
        return isObjectLike2(value) && isLength2(value.length) && !!typedArrayTags2[baseGetTag2(value)];
      }
      __name(baseIsTypedArray2, "baseIsTypedArray");
      function baseKeys2(object) {
        if (!isPrototype2(object)) {
          return nativeKeys2(object);
        }
        var result = [];
        for (var key in Object(object)) {
          if (hasOwnProperty14.call(object, key) && key != "constructor") {
            result.push(key);
          }
        }
        return result;
      }
      __name(baseKeys2, "baseKeys");
      function equalArrays2(array, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG5, arrLength = array.length, othLength = other.length;
        if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
          return false;
        }
        var stacked = stack.get(array);
        if (stacked && stack.get(other)) {
          return stacked == other;
        }
        var index2 = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG3 ? new SetCache2() : void 0;
        stack.set(array, other);
        stack.set(other, array);
        while (++index2 < arrLength) {
          var arrValue = array[index2], othValue = other[index2];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, arrValue, index2, other, array, stack) : customizer(arrValue, othValue, index2, array, other, stack);
          }
          if (compared !== void 0) {
            if (compared) {
              continue;
            }
            result = false;
            break;
          }
          if (seen) {
            if (!arraySome2(other, function(othValue2, othIndex) {
              if (!cacheHas2(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                return seen.push(othIndex);
              }
            })) {
              result = false;
              break;
            }
          } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
            result = false;
            break;
          }
        }
        stack["delete"](array);
        stack["delete"](other);
        return result;
      }
      __name(equalArrays2, "equalArrays");
      function equalByTag2(object, other, tag, bitmask, customizer, equalFunc, stack) {
        switch (tag) {
          case dataViewTag6:
            if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
              return false;
            }
            object = object.buffer;
            other = other.buffer;
          case arrayBufferTag5:
            if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array3(object), new Uint8Array3(other))) {
              return false;
            }
            return true;
          case boolTag5:
          case dateTag5:
          case numberTag5:
            return eq2(+object, +other);
          case errorTag4:
            return object.name == other.name && object.message == other.message;
          case regexpTag5:
          case stringTag5:
            return object == other + "";
          case mapTag7:
            var convert = mapToArray2;
          case setTag7:
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG5;
            convert || (convert = setToArray2);
            if (object.size != other.size && !isPartial) {
              return false;
            }
            var stacked = stack.get(object);
            if (stacked) {
              return stacked == other;
            }
            bitmask |= COMPARE_UNORDERED_FLAG3;
            stack.set(object, other);
            var result = equalArrays2(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
            stack["delete"](object);
            return result;
          case symbolTag4:
            if (symbolValueOf3) {
              return symbolValueOf3.call(object) == symbolValueOf3.call(other);
            }
        }
        return false;
      }
      __name(equalByTag2, "equalByTag");
      function equalObjects2(object, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG5, objProps = getAllKeys2(object), objLength = objProps.length, othProps = getAllKeys2(other), othLength = othProps.length;
        if (objLength != othLength && !isPartial) {
          return false;
        }
        var index2 = objLength;
        while (index2--) {
          var key = objProps[index2];
          if (!(isPartial ? key in other : hasOwnProperty14.call(other, key))) {
            return false;
          }
        }
        var stacked = stack.get(object);
        if (stacked && stack.get(other)) {
          return stacked == other;
        }
        var result = true;
        stack.set(object, other);
        stack.set(other, object);
        var skipCtor = isPartial;
        while (++index2 < objLength) {
          key = objProps[index2];
          var objValue = object[key], othValue = other[key];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
          }
          if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
            result = false;
            break;
          }
          skipCtor || (skipCtor = key == "constructor");
        }
        if (result && !skipCtor) {
          var objCtor = object.constructor, othCtor = other.constructor;
          if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
            result = false;
          }
        }
        stack["delete"](object);
        stack["delete"](other);
        return result;
      }
      __name(equalObjects2, "equalObjects");
      function getAllKeys2(object) {
        return baseGetAllKeys2(object, keys2, getSymbols2);
      }
      __name(getAllKeys2, "getAllKeys");
      function getMapData2(map2, key) {
        var data = map2.__data__;
        return isKeyable2(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
      }
      __name(getMapData2, "getMapData");
      function getNative2(object, key) {
        var value = getValue2(object, key);
        return baseIsNative2(value) ? value : void 0;
      }
      __name(getNative2, "getNative");
      function getRawTag2(value) {
        var isOwn = hasOwnProperty14.call(value, symToStringTag3), tag = value[symToStringTag3];
        try {
          value[symToStringTag3] = void 0;
          var unmasked = true;
        } catch (e3) {
        }
        var result = nativeObjectToString3.call(value);
        if (unmasked) {
          if (isOwn) {
            value[symToStringTag3] = tag;
          } else {
            delete value[symToStringTag3];
          }
        }
        return result;
      }
      __name(getRawTag2, "getRawTag");
      var getSymbols2 = !nativeGetSymbols3 ? stubArray2 : function(object) {
        if (object == null) {
          return [];
        }
        object = Object(object);
        return arrayFilter2(nativeGetSymbols3(object), function(symbol) {
          return propertyIsEnumerable3.call(object, symbol);
        });
      };
      var getTag2 = baseGetTag2;
      if (DataView3 && getTag2(new DataView3(new ArrayBuffer(1))) != dataViewTag6 || Map3 && getTag2(new Map3()) != mapTag7 || Promise3 && getTag2(Promise3.resolve()) != promiseTag2 || Set3 && getTag2(new Set3()) != setTag7 || WeakMap3 && getTag2(new WeakMap3()) != weakMapTag4) {
        getTag2 = /* @__PURE__ */ __name(function(value) {
          var result = baseGetTag2(value), Ctor = result == objectTag6 ? value.constructor : void 0, ctorString = Ctor ? toSource2(Ctor) : "";
          if (ctorString) {
            switch (ctorString) {
              case dataViewCtorString2:
                return dataViewTag6;
              case mapCtorString2:
                return mapTag7;
              case promiseCtorString2:
                return promiseTag2;
              case setCtorString2:
                return setTag7;
              case weakMapCtorString2:
                return weakMapTag4;
            }
          }
          return result;
        }, "getTag");
      }
      function isIndex2(value, length) {
        length = length == null ? MAX_SAFE_INTEGER3 : length;
        return !!length && (typeof value == "number" || reIsUint2.test(value)) && (value > -1 && value % 1 == 0 && value < length);
      }
      __name(isIndex2, "isIndex");
      function isKeyable2(value) {
        var type = typeof value;
        return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
      }
      __name(isKeyable2, "isKeyable");
      function isMasked2(func) {
        return !!maskSrcKey2 && maskSrcKey2 in func;
      }
      __name(isMasked2, "isMasked");
      function isPrototype2(value) {
        var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto17;
        return value === proto;
      }
      __name(isPrototype2, "isPrototype");
      function objectToString2(value) {
        return nativeObjectToString3.call(value);
      }
      __name(objectToString2, "objectToString");
      function toSource2(func) {
        if (func != null) {
          try {
            return funcToString4.call(func);
          } catch (e3) {
          }
          try {
            return func + "";
          } catch (e3) {
          }
        }
        return "";
      }
      __name(toSource2, "toSource");
      function eq2(value, other) {
        return value === other || value !== value && other !== other;
      }
      __name(eq2, "eq");
      var isArguments2 = baseIsArguments2(/* @__PURE__ */ function() {
        return arguments;
      }()) ? baseIsArguments2 : function(value) {
        return isObjectLike2(value) && hasOwnProperty14.call(value, "callee") && !propertyIsEnumerable3.call(value, "callee");
      };
      var isArray2 = Array.isArray;
      function isArrayLike2(value) {
        return value != null && isLength2(value.length) && !isFunction2(value);
      }
      __name(isArrayLike2, "isArrayLike");
      var isBuffer2 = nativeIsBuffer2 || stubFalse2;
      function isEqual3(value, other) {
        return baseIsEqual2(value, other);
      }
      __name(isEqual3, "isEqual");
      function isFunction2(value) {
        if (!isObject2(value)) {
          return false;
        }
        var tag = baseGetTag2(value);
        return tag == funcTag4 || tag == genTag3 || tag == asyncTag2 || tag == proxyTag2;
      }
      __name(isFunction2, "isFunction");
      function isLength2(value) {
        return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER3;
      }
      __name(isLength2, "isLength");
      function isObject2(value) {
        var type = typeof value;
        return value != null && (type == "object" || type == "function");
      }
      __name(isObject2, "isObject");
      function isObjectLike2(value) {
        return value != null && typeof value == "object";
      }
      __name(isObjectLike2, "isObjectLike");
      var isTypedArray2 = nodeIsTypedArray2 ? baseUnary2(nodeIsTypedArray2) : baseIsTypedArray2;
      function keys2(object) {
        return isArrayLike2(object) ? arrayLikeKeys2(object) : baseKeys2(object);
      }
      __name(keys2, "keys");
      function stubArray2() {
        return [];
      }
      __name(stubArray2, "stubArray");
      function stubFalse2() {
        return false;
      }
      __name(stubFalse2, "stubFalse");
      module2.exports = isEqual3;
    }
  });

  // node_modules/quill-delta/dist/AttributeMap.js
  var require_AttributeMap = __commonJS({
    "node_modules/quill-delta/dist/AttributeMap.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      var cloneDeep2 = require_lodash();
      var isEqual3 = require_lodash2();
      var AttributeMap5;
      (function(AttributeMap6) {
        function compose(a3 = {}, b3 = {}, keepNull = false) {
          if (typeof a3 !== "object") {
            a3 = {};
          }
          if (typeof b3 !== "object") {
            b3 = {};
          }
          let attributes = cloneDeep2(b3);
          if (!keepNull) {
            attributes = Object.keys(attributes).reduce((copy, key) => {
              if (attributes[key] != null) {
                copy[key] = attributes[key];
              }
              return copy;
            }, {});
          }
          for (const key in a3) {
            if (a3[key] !== void 0 && b3[key] === void 0) {
              attributes[key] = a3[key];
            }
          }
          return Object.keys(attributes).length > 0 ? attributes : void 0;
        }
        __name(compose, "compose");
        AttributeMap6.compose = compose;
        function diff(a3 = {}, b3 = {}) {
          if (typeof a3 !== "object") {
            a3 = {};
          }
          if (typeof b3 !== "object") {
            b3 = {};
          }
          const attributes = Object.keys(a3).concat(Object.keys(b3)).reduce((attrs, key) => {
            if (!isEqual3(a3[key], b3[key])) {
              attrs[key] = b3[key] === void 0 ? null : b3[key];
            }
            return attrs;
          }, {});
          return Object.keys(attributes).length > 0 ? attributes : void 0;
        }
        __name(diff, "diff");
        AttributeMap6.diff = diff;
        function invert(attr = {}, base = {}) {
          attr = attr || {};
          const baseInverted = Object.keys(base).reduce((memo, key) => {
            if (base[key] !== attr[key] && attr[key] !== void 0) {
              memo[key] = base[key];
            }
            return memo;
          }, {});
          return Object.keys(attr).reduce((memo, key) => {
            if (attr[key] !== base[key] && base[key] === void 0) {
              memo[key] = null;
            }
            return memo;
          }, baseInverted);
        }
        __name(invert, "invert");
        AttributeMap6.invert = invert;
        function transform(a3, b3, priority = false) {
          if (typeof a3 !== "object") {
            return b3;
          }
          if (typeof b3 !== "object") {
            return void 0;
          }
          if (!priority) {
            return b3;
          }
          const attributes = Object.keys(b3).reduce((attrs, key) => {
            if (a3[key] === void 0) {
              attrs[key] = b3[key];
            }
            return attrs;
          }, {});
          return Object.keys(attributes).length > 0 ? attributes : void 0;
        }
        __name(transform, "transform");
        AttributeMap6.transform = transform;
      })(AttributeMap5 || (AttributeMap5 = {}));
      exports2.default = AttributeMap5;
    }
  });

  // node_modules/quill-delta/dist/Op.js
  var require_Op = __commonJS({
    "node_modules/quill-delta/dist/Op.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      var Op4;
      (function(Op5) {
        function length(op) {
          if (typeof op.delete === "number") {
            return op.delete;
          } else if (typeof op.retain === "number") {
            return op.retain;
          } else if (typeof op.retain === "object" && op.retain !== null) {
            return 1;
          } else {
            return typeof op.insert === "string" ? op.insert.length : 1;
          }
        }
        __name(length, "length");
        Op5.length = length;
      })(Op4 || (Op4 = {}));
      exports2.default = Op4;
    }
  });

  // node_modules/quill-delta/dist/OpIterator.js
  var require_OpIterator = __commonJS({
    "node_modules/quill-delta/dist/OpIterator.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      var Op_1 = require_Op();
      var Iterator = class {
        static {
          __name(this, "Iterator");
        }
        constructor(ops) {
          this.ops = ops;
          this.index = 0;
          this.offset = 0;
        }
        hasNext() {
          return this.peekLength() < Infinity;
        }
        next(length) {
          if (!length) {
            length = Infinity;
          }
          const nextOp = this.ops[this.index];
          if (nextOp) {
            const offset = this.offset;
            const opLength = Op_1.default.length(nextOp);
            if (length >= opLength - offset) {
              length = opLength - offset;
              this.index += 1;
              this.offset = 0;
            } else {
              this.offset += length;
            }
            if (typeof nextOp.delete === "number") {
              return { delete: length };
            } else {
              const retOp = {};
              if (nextOp.attributes) {
                retOp.attributes = nextOp.attributes;
              }
              if (typeof nextOp.retain === "number") {
                retOp.retain = length;
              } else if (typeof nextOp.retain === "object" && nextOp.retain !== null) {
                retOp.retain = nextOp.retain;
              } else if (typeof nextOp.insert === "string") {
                retOp.insert = nextOp.insert.substr(offset, length);
              } else {
                retOp.insert = nextOp.insert;
              }
              return retOp;
            }
          } else {
            return { retain: Infinity };
          }
        }
        peek() {
          return this.ops[this.index];
        }
        peekLength() {
          if (this.ops[this.index]) {
            return Op_1.default.length(this.ops[this.index]) - this.offset;
          } else {
            return Infinity;
          }
        }
        peekType() {
          const op = this.ops[this.index];
          if (op) {
            if (typeof op.delete === "number") {
              return "delete";
            } else if (typeof op.retain === "number" || typeof op.retain === "object" && op.retain !== null) {
              return "retain";
            } else {
              return "insert";
            }
          }
          return "retain";
        }
        rest() {
          if (!this.hasNext()) {
            return [];
          } else if (this.offset === 0) {
            return this.ops.slice(this.index);
          } else {
            const offset = this.offset;
            const index2 = this.index;
            const next = this.next();
            const rest = this.ops.slice(this.index);
            this.offset = offset;
            this.index = index2;
            return [next].concat(rest);
          }
        }
      };
      exports2.default = Iterator;
    }
  });

  // node_modules/quill-delta/dist/Delta.js
  var require_Delta = __commonJS({
    "node_modules/quill-delta/dist/Delta.js"(exports2, module2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.AttributeMap = exports2.OpIterator = exports2.Op = void 0;
      var diff = require_diff();
      var cloneDeep2 = require_lodash();
      var isEqual3 = require_lodash2();
      var AttributeMap_1 = require_AttributeMap();
      exports2.AttributeMap = AttributeMap_1.default;
      var Op_1 = require_Op();
      exports2.Op = Op_1.default;
      var OpIterator_1 = require_OpIterator();
      exports2.OpIterator = OpIterator_1.default;
      var NULL_CHARACTER = String.fromCharCode(0);
      var getEmbedTypeAndData = /* @__PURE__ */ __name((a3, b3) => {
        if (typeof a3 !== "object" || a3 === null) {
          throw new Error(`cannot retain a ${typeof a3}`);
        }
        if (typeof b3 !== "object" || b3 === null) {
          throw new Error(`cannot retain a ${typeof b3}`);
        }
        const embedType = Object.keys(a3)[0];
        if (!embedType || embedType !== Object.keys(b3)[0]) {
          throw new Error(`embed types not matched: ${embedType} != ${Object.keys(b3)[0]}`);
        }
        return [embedType, a3[embedType], b3[embedType]];
      }, "getEmbedTypeAndData");
      var Delta13 = class _Delta {
        static {
          __name(this, "Delta");
        }
        constructor(ops) {
          if (Array.isArray(ops)) {
            this.ops = ops;
          } else if (ops != null && Array.isArray(ops.ops)) {
            this.ops = ops.ops;
          } else {
            this.ops = [];
          }
        }
        static registerEmbed(embedType, handler) {
          this.handlers[embedType] = handler;
        }
        static unregisterEmbed(embedType) {
          delete this.handlers[embedType];
        }
        static getHandler(embedType) {
          const handler = this.handlers[embedType];
          if (!handler) {
            throw new Error(`no handlers for embed type "${embedType}"`);
          }
          return handler;
        }
        insert(arg, attributes) {
          const newOp = {};
          if (typeof arg === "string" && arg.length === 0) {
            return this;
          }
          newOp.insert = arg;
          if (attributes != null && typeof attributes === "object" && Object.keys(attributes).length > 0) {
            newOp.attributes = attributes;
          }
          return this.push(newOp);
        }
        delete(length) {
          if (length <= 0) {
            return this;
          }
          return this.push({ delete: length });
        }
        retain(length, attributes) {
          if (typeof length === "number" && length <= 0) {
            return this;
          }
          const newOp = { retain: length };
          if (attributes != null && typeof attributes === "object" && Object.keys(attributes).length > 0) {
            newOp.attributes = attributes;
          }
          return this.push(newOp);
        }
        push(newOp) {
          let index2 = this.ops.length;
          let lastOp = this.ops[index2 - 1];
          newOp = cloneDeep2(newOp);
          if (typeof lastOp === "object") {
            if (typeof newOp.delete === "number" && typeof lastOp.delete === "number") {
              this.ops[index2 - 1] = { delete: lastOp.delete + newOp.delete };
              return this;
            }
            if (typeof lastOp.delete === "number" && newOp.insert != null) {
              index2 -= 1;
              lastOp = this.ops[index2 - 1];
              if (typeof lastOp !== "object") {
                this.ops.unshift(newOp);
                return this;
              }
            }
            if (isEqual3(newOp.attributes, lastOp.attributes)) {
              if (typeof newOp.insert === "string" && typeof lastOp.insert === "string") {
                this.ops[index2 - 1] = { insert: lastOp.insert + newOp.insert };
                if (typeof newOp.attributes === "object") {
                  this.ops[index2 - 1].attributes = newOp.attributes;
                }
                return this;
              } else if (typeof newOp.retain === "number" && typeof lastOp.retain === "number") {
                this.ops[index2 - 1] = { retain: lastOp.retain + newOp.retain };
                if (typeof newOp.attributes === "object") {
                  this.ops[index2 - 1].attributes = newOp.attributes;
                }
                return this;
              }
            }
          }
          if (index2 === this.ops.length) {
            this.ops.push(newOp);
          } else {
            this.ops.splice(index2, 0, newOp);
          }
          return this;
        }
        chop() {
          const lastOp = this.ops[this.ops.length - 1];
          if (lastOp && typeof lastOp.retain === "number" && !lastOp.attributes) {
            this.ops.pop();
          }
          return this;
        }
        filter(predicate) {
          return this.ops.filter(predicate);
        }
        forEach(predicate) {
          this.ops.forEach(predicate);
        }
        map(predicate) {
          return this.ops.map(predicate);
        }
        partition(predicate) {
          const passed = [];
          const failed = [];
          this.forEach((op) => {
            const target = predicate(op) ? passed : failed;
            target.push(op);
          });
          return [passed, failed];
        }
        reduce(predicate, initialValue) {
          return this.ops.reduce(predicate, initialValue);
        }
        changeLength() {
          return this.reduce((length, elem) => {
            if (elem.insert) {
              return length + Op_1.default.length(elem);
            } else if (elem.delete) {
              return length - elem.delete;
            }
            return length;
          }, 0);
        }
        length() {
          return this.reduce((length, elem) => {
            return length + Op_1.default.length(elem);
          }, 0);
        }
        slice(start2 = 0, end = Infinity) {
          const ops = [];
          const iter = new OpIterator_1.default(this.ops);
          let index2 = 0;
          while (index2 < end && iter.hasNext()) {
            let nextOp;
            if (index2 < start2) {
              nextOp = iter.next(start2 - index2);
            } else {
              nextOp = iter.next(end - index2);
              ops.push(nextOp);
            }
            index2 += Op_1.default.length(nextOp);
          }
          return new _Delta(ops);
        }
        compose(other) {
          const thisIter = new OpIterator_1.default(this.ops);
          const otherIter = new OpIterator_1.default(other.ops);
          const ops = [];
          const firstOther = otherIter.peek();
          if (firstOther != null && typeof firstOther.retain === "number" && firstOther.attributes == null) {
            let firstLeft = firstOther.retain;
            while (thisIter.peekType() === "insert" && thisIter.peekLength() <= firstLeft) {
              firstLeft -= thisIter.peekLength();
              ops.push(thisIter.next());
            }
            if (firstOther.retain - firstLeft > 0) {
              otherIter.next(firstOther.retain - firstLeft);
            }
          }
          const delta = new _Delta(ops);
          while (thisIter.hasNext() || otherIter.hasNext()) {
            if (otherIter.peekType() === "insert") {
              delta.push(otherIter.next());
            } else if (thisIter.peekType() === "delete") {
              delta.push(thisIter.next());
            } else {
              const length = Math.min(thisIter.peekLength(), otherIter.peekLength());
              const thisOp = thisIter.next(length);
              const otherOp = otherIter.next(length);
              if (otherOp.retain) {
                const newOp = {};
                if (typeof thisOp.retain === "number") {
                  newOp.retain = typeof otherOp.retain === "number" ? length : otherOp.retain;
                } else {
                  if (typeof otherOp.retain === "number") {
                    if (thisOp.retain == null) {
                      newOp.insert = thisOp.insert;
                    } else {
                      newOp.retain = thisOp.retain;
                    }
                  } else {
                    const action = thisOp.retain == null ? "insert" : "retain";
                    const [embedType, thisData, otherData] = getEmbedTypeAndData(thisOp[action], otherOp.retain);
                    const handler = _Delta.getHandler(embedType);
                    newOp[action] = {
                      [embedType]: handler.compose(thisData, otherData, action === "retain")
                    };
                  }
                }
                const attributes = AttributeMap_1.default.compose(thisOp.attributes, otherOp.attributes, typeof thisOp.retain === "number");
                if (attributes) {
                  newOp.attributes = attributes;
                }
                delta.push(newOp);
                if (!otherIter.hasNext() && isEqual3(delta.ops[delta.ops.length - 1], newOp)) {
                  const rest = new _Delta(thisIter.rest());
                  return delta.concat(rest).chop();
                }
              } else if (typeof otherOp.delete === "number" && (typeof thisOp.retain === "number" || typeof thisOp.retain === "object" && thisOp.retain !== null)) {
                delta.push(otherOp);
              }
            }
          }
          return delta.chop();
        }
        concat(other) {
          const delta = new _Delta(this.ops.slice());
          if (other.ops.length > 0) {
            delta.push(other.ops[0]);
            delta.ops = delta.ops.concat(other.ops.slice(1));
          }
          return delta;
        }
        diff(other, cursor) {
          if (this.ops === other.ops) {
            return new _Delta();
          }
          const strings = [this, other].map((delta) => {
            return delta.map((op) => {
              if (op.insert != null) {
                return typeof op.insert === "string" ? op.insert : NULL_CHARACTER;
              }
              const prep = delta === other ? "on" : "with";
              throw new Error("diff() called " + prep + " non-document");
            }).join("");
          });
          const retDelta = new _Delta();
          const diffResult = diff(strings[0], strings[1], cursor, true);
          const thisIter = new OpIterator_1.default(this.ops);
          const otherIter = new OpIterator_1.default(other.ops);
          diffResult.forEach((component) => {
            let length = component[1].length;
            while (length > 0) {
              let opLength = 0;
              switch (component[0]) {
                case diff.INSERT:
                  opLength = Math.min(otherIter.peekLength(), length);
                  retDelta.push(otherIter.next(opLength));
                  break;
                case diff.DELETE:
                  opLength = Math.min(length, thisIter.peekLength());
                  thisIter.next(opLength);
                  retDelta.delete(opLength);
                  break;
                case diff.EQUAL:
                  opLength = Math.min(thisIter.peekLength(), otherIter.peekLength(), length);
                  const thisOp = thisIter.next(opLength);
                  const otherOp = otherIter.next(opLength);
                  if (isEqual3(thisOp.insert, otherOp.insert)) {
                    retDelta.retain(opLength, AttributeMap_1.default.diff(thisOp.attributes, otherOp.attributes));
                  } else {
                    retDelta.push(otherOp).delete(opLength);
                  }
                  break;
              }
              length -= opLength;
            }
          });
          return retDelta.chop();
        }
        eachLine(predicate, newline = "\n") {
          const iter = new OpIterator_1.default(this.ops);
          let line = new _Delta();
          let i3 = 0;
          while (iter.hasNext()) {
            if (iter.peekType() !== "insert") {
              return;
            }
            const thisOp = iter.peek();
            const start2 = Op_1.default.length(thisOp) - iter.peekLength();
            const index2 = typeof thisOp.insert === "string" ? thisOp.insert.indexOf(newline, start2) - start2 : -1;
            if (index2 < 0) {
              line.push(iter.next());
            } else if (index2 > 0) {
              line.push(iter.next(index2));
            } else {
              if (predicate(line, iter.next(1).attributes || {}, i3) === false) {
                return;
              }
              i3 += 1;
              line = new _Delta();
            }
          }
          if (line.length() > 0) {
            predicate(line, {}, i3);
          }
        }
        invert(base) {
          const inverted = new _Delta();
          this.reduce((baseIndex, op) => {
            if (op.insert) {
              inverted.delete(Op_1.default.length(op));
            } else if (typeof op.retain === "number" && op.attributes == null) {
              inverted.retain(op.retain);
              return baseIndex + op.retain;
            } else if (op.delete || typeof op.retain === "number") {
              const length = op.delete || op.retain;
              const slice = base.slice(baseIndex, baseIndex + length);
              slice.forEach((baseOp) => {
                if (op.delete) {
                  inverted.push(baseOp);
                } else if (op.retain && op.attributes) {
                  inverted.retain(Op_1.default.length(baseOp), AttributeMap_1.default.invert(op.attributes, baseOp.attributes));
                }
              });
              return baseIndex + length;
            } else if (typeof op.retain === "object" && op.retain !== null) {
              const slice = base.slice(baseIndex, baseIndex + 1);
              const baseOp = new OpIterator_1.default(slice.ops).next();
              const [embedType, opData, baseOpData] = getEmbedTypeAndData(op.retain, baseOp.insert);
              const handler = _Delta.getHandler(embedType);
              inverted.retain({ [embedType]: handler.invert(opData, baseOpData) }, AttributeMap_1.default.invert(op.attributes, baseOp.attributes));
              return baseIndex + 1;
            }
            return baseIndex;
          }, 0);
          return inverted.chop();
        }
        transform(arg, priority = false) {
          priority = !!priority;
          if (typeof arg === "number") {
            return this.transformPosition(arg, priority);
          }
          const other = arg;
          const thisIter = new OpIterator_1.default(this.ops);
          const otherIter = new OpIterator_1.default(other.ops);
          const delta = new _Delta();
          while (thisIter.hasNext() || otherIter.hasNext()) {
            if (thisIter.peekType() === "insert" && (priority || otherIter.peekType() !== "insert")) {
              delta.retain(Op_1.default.length(thisIter.next()));
            } else if (otherIter.peekType() === "insert") {
              delta.push(otherIter.next());
            } else {
              const length = Math.min(thisIter.peekLength(), otherIter.peekLength());
              const thisOp = thisIter.next(length);
              const otherOp = otherIter.next(length);
              if (thisOp.delete) {
                continue;
              } else if (otherOp.delete) {
                delta.push(otherOp);
              } else {
                const thisData = thisOp.retain;
                const otherData = otherOp.retain;
                let transformedData = typeof otherData === "object" && otherData !== null ? otherData : length;
                if (typeof thisData === "object" && thisData !== null && typeof otherData === "object" && otherData !== null) {
                  const embedType = Object.keys(thisData)[0];
                  if (embedType === Object.keys(otherData)[0]) {
                    const handler = _Delta.getHandler(embedType);
                    if (handler) {
                      transformedData = {
                        [embedType]: handler.transform(thisData[embedType], otherData[embedType], priority)
                      };
                    }
                  }
                }
                delta.retain(transformedData, AttributeMap_1.default.transform(thisOp.attributes, otherOp.attributes, priority));
              }
            }
          }
          return delta.chop();
        }
        transformPosition(index2, priority = false) {
          priority = !!priority;
          const thisIter = new OpIterator_1.default(this.ops);
          let offset = 0;
          while (thisIter.hasNext() && offset <= index2) {
            const length = thisIter.peekLength();
            const nextType = thisIter.peekType();
            thisIter.next();
            if (nextType === "delete") {
              index2 -= Math.min(length, index2 - offset);
              continue;
            } else if (nextType === "insert" && (offset < index2 || !priority)) {
              index2 += length;
            }
            offset += length;
          }
          return index2;
        }
      };
      Delta13.Op = Op_1.default;
      Delta13.OpIterator = OpIterator_1.default;
      Delta13.AttributeMap = AttributeMap_1.default;
      Delta13.handlers = {};
      exports2.default = Delta13;
      if (typeof module2 === "object") {
        module2.exports = Delta13;
        module2.exports.default = Delta13;
      }
    }
  });

  // node_modules/eventemitter3/index.js
  var require_eventemitter3 = __commonJS({
    "node_modules/eventemitter3/index.js"(exports2, module2) {
      "use strict";
      var has = Object.prototype.hasOwnProperty;
      var prefix = "~";
      function Events() {
      }
      __name(Events, "Events");
      if (Object.create) {
        Events.prototype = /* @__PURE__ */ Object.create(null);
        if (!new Events().__proto__)
          prefix = false;
      }
      function EE(fn, context, once) {
        this.fn = fn;
        this.context = context;
        this.once = once || false;
      }
      __name(EE, "EE");
      function addListener(emitter, event, fn, context, once) {
        if (typeof fn !== "function") {
          throw new TypeError("The listener must be a function");
        }
        var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
        if (!emitter._events[evt])
          emitter._events[evt] = listener, emitter._eventsCount++;
        else if (!emitter._events[evt].fn)
          emitter._events[evt].push(listener);
        else
          emitter._events[evt] = [emitter._events[evt], listener];
        return emitter;
      }
      __name(addListener, "addListener");
      function clearEvent(emitter, evt) {
        if (--emitter._eventsCount === 0)
          emitter._events = new Events();
        else
          delete emitter._events[evt];
      }
      __name(clearEvent, "clearEvent");
      function EventEmitter2() {
        this._events = new Events();
        this._eventsCount = 0;
      }
      __name(EventEmitter2, "EventEmitter");
      EventEmitter2.prototype.eventNames = /* @__PURE__ */ __name(function eventNames() {
        var names = [], events, name;
        if (this._eventsCount === 0)
          return names;
        for (name in events = this._events) {
          if (has.call(events, name))
            names.push(prefix ? name.slice(1) : name);
        }
        if (Object.getOwnPropertySymbols) {
          return names.concat(Object.getOwnPropertySymbols(events));
        }
        return names;
      }, "eventNames");
      EventEmitter2.prototype.listeners = /* @__PURE__ */ __name(function listeners(event) {
        var evt = prefix ? prefix + event : event, handlers = this._events[evt];
        if (!handlers)
          return [];
        if (handlers.fn)
          return [handlers.fn];
        for (var i3 = 0, l3 = handlers.length, ee = new Array(l3); i3 < l3; i3++) {
          ee[i3] = handlers[i3].fn;
        }
        return ee;
      }, "listeners");
      EventEmitter2.prototype.listenerCount = /* @__PURE__ */ __name(function listenerCount(event) {
        var evt = prefix ? prefix + event : event, listeners = this._events[evt];
        if (!listeners)
          return 0;
        if (listeners.fn)
          return 1;
        return listeners.length;
      }, "listenerCount");
      EventEmitter2.prototype.emit = /* @__PURE__ */ __name(function emit(event, a1, a22, a3, a4, a5) {
        var evt = prefix ? prefix + event : event;
        if (!this._events[evt])
          return false;
        var listeners = this._events[evt], len = arguments.length, args, i3;
        if (listeners.fn) {
          if (listeners.once)
            this.removeListener(event, listeners.fn, void 0, true);
          switch (len) {
            case 1:
              return listeners.fn.call(listeners.context), true;
            case 2:
              return listeners.fn.call(listeners.context, a1), true;
            case 3:
              return listeners.fn.call(listeners.context, a1, a22), true;
            case 4:
              return listeners.fn.call(listeners.context, a1, a22, a3), true;
            case 5:
              return listeners.fn.call(listeners.context, a1, a22, a3, a4), true;
            case 6:
              return listeners.fn.call(listeners.context, a1, a22, a3, a4, a5), true;
          }
          for (i3 = 1, args = new Array(len - 1); i3 < len; i3++) {
            args[i3 - 1] = arguments[i3];
          }
          listeners.fn.apply(listeners.context, args);
        } else {
          var length = listeners.length, j3;
          for (i3 = 0; i3 < length; i3++) {
            if (listeners[i3].once)
              this.removeListener(event, listeners[i3].fn, void 0, true);
            switch (len) {
              case 1:
                listeners[i3].fn.call(listeners[i3].context);
                break;
              case 2:
                listeners[i3].fn.call(listeners[i3].context, a1);
                break;
              case 3:
                listeners[i3].fn.call(listeners[i3].context, a1, a22);
                break;
              case 4:
                listeners[i3].fn.call(listeners[i3].context, a1, a22, a3);
                break;
              default:
                if (!args)
                  for (j3 = 1, args = new Array(len - 1); j3 < len; j3++) {
                    args[j3 - 1] = arguments[j3];
                  }
                listeners[i3].fn.apply(listeners[i3].context, args);
            }
          }
        }
        return true;
      }, "emit");
      EventEmitter2.prototype.on = /* @__PURE__ */ __name(function on2(event, fn, context) {
        return addListener(this, event, fn, context, false);
      }, "on");
      EventEmitter2.prototype.once = /* @__PURE__ */ __name(function once(event, fn, context) {
        return addListener(this, event, fn, context, true);
      }, "once");
      EventEmitter2.prototype.removeListener = /* @__PURE__ */ __name(function removeListener(event, fn, context, once) {
        var evt = prefix ? prefix + event : event;
        if (!this._events[evt])
          return this;
        if (!fn) {
          clearEvent(this, evt);
          return this;
        }
        var listeners = this._events[evt];
        if (listeners.fn) {
          if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
            clearEvent(this, evt);
          }
        } else {
          for (var i3 = 0, events = [], length = listeners.length; i3 < length; i3++) {
            if (listeners[i3].fn !== fn || once && !listeners[i3].once || context && listeners[i3].context !== context) {
              events.push(listeners[i3]);
            }
          }
          if (events.length)
            this._events[evt] = events.length === 1 ? events[0] : events;
          else
            clearEvent(this, evt);
        }
        return this;
      }, "removeListener");
      EventEmitter2.prototype.removeAllListeners = /* @__PURE__ */ __name(function removeAllListeners(event) {
        var evt;
        if (event) {
          evt = prefix ? prefix + event : event;
          if (this._events[evt])
            clearEvent(this, evt);
        } else {
          this._events = new Events();
          this._eventsCount = 0;
        }
        return this;
      }, "removeAllListeners");
      EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
      EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
      EventEmitter2.prefixed = prefix;
      EventEmitter2.EventEmitter = EventEmitter2;
      if ("undefined" !== typeof module2) {
        module2.exports = EventEmitter2;
      }
    }
  });

  // node_modules/quill-html-edit-button/dist/quill.htmlEditButton.min.js
  var require_quill_htmlEditButton_min = __commonJS({
    "node_modules/quill-html-edit-button/dist/quill.htmlEditButton.min.js"(exports2, module2) {
      !function(t3, e3) {
        if ("object" == typeof exports2 && "object" == typeof module2)
          module2.exports = e3();
        else if ("function" == typeof define && define.amd)
          define([], e3);
        else {
          var n3 = e3();
          for (var r3 in n3)
            ("object" == typeof exports2 ? exports2 : t3)[r3] = n3[r3];
        }
      }(self, () => (() => {
        var t3 = { 64: (t4, e4, n4) => {
          (t4.exports = n4(765)(false)).push([t4.id, ".ql-html-overlayContainer {\n  background: #0000007d;\n  position: fixed;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  z-index: 9999;\n}\n\n.ql-html-popupContainer {\n  background: #ddd;\n  position: absolute;\n  top: 5%;\n  left: 5%;\n  right: 5%;\n  bottom: 5%;\n  border-radius: 10px;\n}\n\n.ql-html-textContainer {\n  position: relative;\n  height: calc(100% - 40px);\n  padding: 20px;\n}\n\n.ql-html-textArea {\n  background: #fff;\n  position: absolute;\n  left: 15px;\n  width: calc(100% - 30px);\n  height: calc(100% - 60px) !important;\n}\n\n.ql-html-textArea .ql-syntax {\n  word-break: break-all;\n  white-space: pre-wrap;\n}\n\n.ql-html-buttonCancel {\n  margin-right: 20px;\n}\n\n.ql-html-popupTitle {\n  margin: 0;\n  display: block;\n  font-style: italic;\n}\n\n.ql-html-buttonGroup {\n  position: absolute;\n  bottom: 20px;\n  transform: scale(1.5);\n  left: calc(50% - 60px);\n}\n", ""]);
        }, 765: (t4) => {
          t4.exports = function(t5) {
            var e4 = [];
            return e4.toString = function() {
              return this.map(function(e5) {
                var n4 = function(t6, e6) {
                  var n5 = t6[1] || "", r3 = t6[3];
                  if (!r3)
                    return n5;
                  if (e6 && "function" == typeof btoa) {
                    var s3 = (o3 = r3, "/*# sourceMappingURL=data:application/json;charset=utf-8;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(o3)))) + " */"), i3 = r3.sources.map(function(t7) {
                      return "/*# sourceURL=" + r3.sourceRoot + t7 + " */";
                    });
                    return [n5].concat(i3).concat([s3]).join("\n");
                  }
                  var o3;
                  return [n5].join("\n");
                }(e5, t5);
                return e5[2] ? "@media " + e5[2] + "{" + n4 + "}" : n4;
              }).join("");
            }, e4.i = function(t6, n4) {
              "string" == typeof t6 && (t6 = [[null, t6, ""]]);
              for (var r3 = {}, s3 = 0; s3 < this.length; s3++) {
                var i3 = this[s3][0];
                "number" == typeof i3 && (r3[i3] = true);
              }
              for (s3 = 0; s3 < t6.length; s3++) {
                var o3 = t6[s3];
                "number" == typeof o3[0] && r3[o3[0]] || (n4 && !o3[2] ? o3[2] = n4 : n4 && (o3[2] = "(" + o3[2] + ") and (" + n4 + ")"), e4.push(o3));
              }
            }, e4;
          };
        }, 228: (t4) => {
          "use strict";
          var e4 = Object.prototype.hasOwnProperty, n4 = "~";
          function r3() {
          }
          __name(r3, "r");
          function s3(t5, e5, n5) {
            this.fn = t5, this.context = e5, this.once = n5 || false;
          }
          __name(s3, "s");
          function i3(t5, e5, r4, i4, o4) {
            if ("function" != typeof r4)
              throw new TypeError("The listener must be a function");
            var l4 = new s3(r4, i4 || t5, o4), a3 = n4 ? n4 + e5 : e5;
            return t5._events[a3] ? t5._events[a3].fn ? t5._events[a3] = [t5._events[a3], l4] : t5._events[a3].push(l4) : (t5._events[a3] = l4, t5._eventsCount++), t5;
          }
          __name(i3, "i");
          function o3(t5, e5) {
            0 == --t5._eventsCount ? t5._events = new r3() : delete t5._events[e5];
          }
          __name(o3, "o");
          function l3() {
            this._events = new r3(), this._eventsCount = 0;
          }
          __name(l3, "l");
          Object.create && (r3.prototype = /* @__PURE__ */ Object.create(null), new r3().__proto__ || (n4 = false)), l3.prototype.eventNames = function() {
            var t5, r4, s4 = [];
            if (0 === this._eventsCount)
              return s4;
            for (r4 in t5 = this._events)
              e4.call(t5, r4) && s4.push(n4 ? r4.slice(1) : r4);
            return Object.getOwnPropertySymbols ? s4.concat(Object.getOwnPropertySymbols(t5)) : s4;
          }, l3.prototype.listeners = function(t5) {
            var e5 = n4 ? n4 + t5 : t5, r4 = this._events[e5];
            if (!r4)
              return [];
            if (r4.fn)
              return [r4.fn];
            for (var s4 = 0, i4 = r4.length, o4 = new Array(i4); s4 < i4; s4++)
              o4[s4] = r4[s4].fn;
            return o4;
          }, l3.prototype.listenerCount = function(t5) {
            var e5 = n4 ? n4 + t5 : t5, r4 = this._events[e5];
            return r4 ? r4.fn ? 1 : r4.length : 0;
          }, l3.prototype.emit = function(t5, e5, r4, s4, i4, o4) {
            var l4 = n4 ? n4 + t5 : t5;
            if (!this._events[l4])
              return false;
            var a3, c3, u3 = this._events[l4], h3 = arguments.length;
            if (u3.fn) {
              switch (u3.once && this.removeListener(t5, u3.fn, void 0, true), h3) {
                case 1:
                  return u3.fn.call(u3.context), true;
                case 2:
                  return u3.fn.call(u3.context, e5), true;
                case 3:
                  return u3.fn.call(u3.context, e5, r4), true;
                case 4:
                  return u3.fn.call(u3.context, e5, r4, s4), true;
                case 5:
                  return u3.fn.call(u3.context, e5, r4, s4, i4), true;
                case 6:
                  return u3.fn.call(u3.context, e5, r4, s4, i4, o4), true;
              }
              for (c3 = 1, a3 = new Array(h3 - 1); c3 < h3; c3++)
                a3[c3 - 1] = arguments[c3];
              u3.fn.apply(u3.context, a3);
            } else {
              var d3, f3 = u3.length;
              for (c3 = 0; c3 < f3; c3++)
                switch (u3[c3].once && this.removeListener(t5, u3[c3].fn, void 0, true), h3) {
                  case 1:
                    u3[c3].fn.call(u3[c3].context);
                    break;
                  case 2:
                    u3[c3].fn.call(u3[c3].context, e5);
                    break;
                  case 3:
                    u3[c3].fn.call(u3[c3].context, e5, r4);
                    break;
                  case 4:
                    u3[c3].fn.call(u3[c3].context, e5, r4, s4);
                    break;
                  default:
                    if (!a3)
                      for (d3 = 1, a3 = new Array(h3 - 1); d3 < h3; d3++)
                        a3[d3 - 1] = arguments[d3];
                    u3[c3].fn.apply(u3[c3].context, a3);
                }
            }
            return true;
          }, l3.prototype.on = function(t5, e5, n5) {
            return i3(this, t5, e5, n5, false);
          }, l3.prototype.once = function(t5, e5, n5) {
            return i3(this, t5, e5, n5, true);
          }, l3.prototype.removeListener = function(t5, e5, r4, s4) {
            var i4 = n4 ? n4 + t5 : t5;
            if (!this._events[i4])
              return this;
            if (!e5)
              return o3(this, i4), this;
            var l4 = this._events[i4];
            if (l4.fn)
              l4.fn !== e5 || s4 && !l4.once || r4 && l4.context !== r4 || o3(this, i4);
            else {
              for (var a3 = 0, c3 = [], u3 = l4.length; a3 < u3; a3++)
                (l4[a3].fn !== e5 || s4 && !l4[a3].once || r4 && l4[a3].context !== r4) && c3.push(l4[a3]);
              c3.length ? this._events[i4] = 1 === c3.length ? c3[0] : c3 : o3(this, i4);
            }
            return this;
          }, l3.prototype.removeAllListeners = function(t5) {
            var e5;
            return t5 ? (e5 = n4 ? n4 + t5 : t5, this._events[e5] && o3(this, e5)) : (this._events = new r3(), this._eventsCount = 0), this;
          }, l3.prototype.off = l3.prototype.removeListener, l3.prototype.addListener = l3.prototype.on, l3.prefixed = n4, l3.EventEmitter = l3, t4.exports = l3;
        }, 606: (t4) => {
          var e4 = -1, n4 = 1, r3 = 0;
          function s3(t5, g4, m4, b4, y4) {
            if (t5 === g4)
              return t5 ? [[r3, t5]] : [];
            if (null != m4) {
              var x4 = function(t6, e5, n5) {
                var r4 = "number" == typeof n5 ? { index: n5, length: 0 } : n5.oldRange, s4 = "number" == typeof n5 ? null : n5.newRange, i4 = t6.length, o4 = e5.length;
                if (0 === r4.length && (null === s4 || 0 === s4.length)) {
                  var l4 = r4.index, a4 = t6.slice(0, l4), c4 = t6.slice(l4), u4 = s4 ? s4.index : null, h4 = l4 + o4 - i4;
                  if ((null === u4 || u4 === h4) && !(h4 < 0 || h4 > o4)) {
                    var d4 = e5.slice(0, h4);
                    if ((g5 = e5.slice(h4)) === c4) {
                      var f4 = Math.min(l4, h4);
                      if ((b5 = a4.slice(0, f4)) === (x5 = d4.slice(0, f4)))
                        return v3(b5, a4.slice(f4), d4.slice(f4), c4);
                    }
                  }
                  if (null === u4 || u4 === l4) {
                    var p4 = l4, g5 = (d4 = e5.slice(0, p4), e5.slice(p4));
                    if (d4 === a4) {
                      var m5 = Math.min(i4 - p4, o4 - p4);
                      if ((y5 = c4.slice(c4.length - m5)) === (N4 = g5.slice(g5.length - m5)))
                        return v3(a4, c4.slice(0, c4.length - m5), g5.slice(0, g5.length - m5), y5);
                    }
                  }
                }
                if (r4.length > 0 && s4 && 0 === s4.length) {
                  var b5 = t6.slice(0, r4.index), y5 = t6.slice(r4.index + r4.length);
                  if (!(o4 < (f4 = b5.length) + (m5 = y5.length))) {
                    var x5 = e5.slice(0, f4), N4 = e5.slice(o4 - m5);
                    if (b5 === x5 && y5 === N4)
                      return v3(b5, t6.slice(f4, i4 - m5), e5.slice(f4, o4 - m5), y5);
                  }
                }
                return null;
              }(t5, g4, m4);
              if (x4)
                return x4;
            }
            var N3 = o3(t5, g4), w3 = t5.substring(0, N3);
            N3 = a3(t5 = t5.substring(N3), g4 = g4.substring(N3));
            var E3 = t5.substring(t5.length - N3), A3 = function(t6, l4) {
              var c4;
              if (!t6)
                return [[n4, l4]];
              if (!l4)
                return [[e4, t6]];
              var u4 = t6.length > l4.length ? t6 : l4, h4 = t6.length > l4.length ? l4 : t6, d4 = u4.indexOf(h4);
              if (-1 !== d4)
                return c4 = [[n4, u4.substring(0, d4)], [r3, h4], [n4, u4.substring(d4 + h4.length)]], t6.length > l4.length && (c4[0][0] = c4[2][0] = e4), c4;
              if (1 === h4.length)
                return [[e4, t6], [n4, l4]];
              var f4 = function(t7, e5) {
                var n5 = t7.length > e5.length ? t7 : e5, r4 = t7.length > e5.length ? e5 : t7;
                if (n5.length < 4 || 2 * r4.length < n5.length)
                  return null;
                function s4(t8, e6, n6) {
                  for (var r5, s5, i5, l6, c6 = t8.substring(n6, n6 + Math.floor(t8.length / 4)), u6 = -1, h6 = ""; -1 !== (u6 = e6.indexOf(c6, u6 + 1)); ) {
                    var d6 = o3(t8.substring(n6), e6.substring(u6)), f6 = a3(t8.substring(0, n6), e6.substring(0, u6));
                    h6.length < f6 + d6 && (h6 = e6.substring(u6 - f6, u6) + e6.substring(u6, u6 + d6), r5 = t8.substring(0, n6 - f6), s5 = t8.substring(n6 + d6), i5 = e6.substring(0, u6 - f6), l6 = e6.substring(u6 + d6));
                  }
                  return 2 * h6.length >= t8.length ? [r5, s5, i5, l6, h6] : null;
                }
                __name(s4, "s");
                var i4, l5, c5, u5, h5, d5 = s4(n5, r4, Math.ceil(n5.length / 4)), f5 = s4(n5, r4, Math.ceil(n5.length / 2));
                if (!d5 && !f5)
                  return null;
                i4 = f5 ? d5 && d5[4].length > f5[4].length ? d5 : f5 : d5;
                t7.length > e5.length ? (l5 = i4[0], c5 = i4[1], u5 = i4[2], h5 = i4[3]) : (u5 = i4[0], h5 = i4[1], l5 = i4[2], c5 = i4[3]);
                var p5 = i4[4];
                return [l5, c5, u5, h5, p5];
              }(t6, l4);
              if (f4) {
                var p4 = f4[0], g5 = f4[1], m5 = f4[2], b5 = f4[3], y5 = f4[4], v5 = s3(p4, m5), x5 = s3(g5, b5);
                return v5.concat([[r3, y5]], x5);
              }
              return function(t7, r4) {
                for (var s4 = t7.length, o4 = r4.length, l5 = Math.ceil((s4 + o4) / 2), a4 = l5, c5 = 2 * l5, u5 = new Array(c5), h5 = new Array(c5), d5 = 0; d5 < c5; d5++)
                  u5[d5] = -1, h5[d5] = -1;
                u5[a4 + 1] = 0, h5[a4 + 1] = 0;
                for (var f5 = s4 - o4, p5 = f5 % 2 != 0, g6 = 0, m6 = 0, b6 = 0, y6 = 0, v6 = 0; v6 < l5; v6++) {
                  for (var x6 = -v6 + g6; x6 <= v6 - m6; x6 += 2) {
                    for (var N4 = a4 + x6, w4 = (_2 = x6 === -v6 || x6 !== v6 && u5[N4 - 1] < u5[N4 + 1] ? u5[N4 + 1] : u5[N4 - 1] + 1) - x6; _2 < s4 && w4 < o4 && t7.charAt(_2) === r4.charAt(w4); )
                      _2++, w4++;
                    if (u5[N4] = _2, _2 > s4)
                      m6 += 2;
                    else if (w4 > o4)
                      g6 += 2;
                    else if (p5) {
                      if ((q3 = a4 + f5 - x6) >= 0 && q3 < c5 && -1 !== h5[q3]) {
                        if (_2 >= (A4 = s4 - h5[q3]))
                          return i3(t7, r4, _2, w4);
                      }
                    }
                  }
                  for (var E4 = -v6 + b6; E4 <= v6 - y6; E4 += 2) {
                    for (var A4, q3 = a4 + E4, k3 = (A4 = E4 === -v6 || E4 !== v6 && h5[q3 - 1] < h5[q3 + 1] ? h5[q3 + 1] : h5[q3 - 1] + 1) - E4; A4 < s4 && k3 < o4 && t7.charAt(s4 - A4 - 1) === r4.charAt(o4 - k3 - 1); )
                      A4++, k3++;
                    if (h5[q3] = A4, A4 > s4)
                      y6 += 2;
                    else if (k3 > o4)
                      b6 += 2;
                    else if (!p5) {
                      if ((N4 = a4 + f5 - E4) >= 0 && N4 < c5 && -1 !== u5[N4]) {
                        var _2;
                        w4 = a4 + (_2 = u5[N4]) - N4;
                        if (_2 >= (A4 = s4 - A4))
                          return i3(t7, r4, _2, w4);
                      }
                    }
                  }
                }
                return [[e4, t7], [n4, r4]];
              }(t6, l4);
            }(t5 = t5.substring(0, t5.length - N3), g4 = g4.substring(0, g4.length - N3));
            return w3 && A3.unshift([r3, w3]), E3 && A3.push([r3, E3]), p3(A3, y4), b4 && function(t6) {
              var s4 = false, i4 = [], o4 = 0, g5 = null, m5 = 0, b5 = 0, y5 = 0, v5 = 0, x5 = 0;
              for (; m5 < t6.length; )
                t6[m5][0] == r3 ? (i4[o4++] = m5, b5 = v5, y5 = x5, v5 = 0, x5 = 0, g5 = t6[m5][1]) : (t6[m5][0] == n4 ? v5 += t6[m5][1].length : x5 += t6[m5][1].length, g5 && g5.length <= Math.max(b5, y5) && g5.length <= Math.max(v5, x5) && (t6.splice(i4[o4 - 1], 0, [e4, g5]), t6[i4[o4 - 1] + 1][0] = n4, o4--, m5 = --o4 > 0 ? i4[o4 - 1] : -1, b5 = 0, y5 = 0, v5 = 0, x5 = 0, g5 = null, s4 = true)), m5++;
              s4 && p3(t6);
              (function(t7) {
                function e5(t8, e6) {
                  if (!t8 || !e6)
                    return 6;
                  var n6 = t8.charAt(t8.length - 1), r4 = e6.charAt(0), s6 = n6.match(c3), i6 = r4.match(c3), o6 = s6 && n6.match(u3), l5 = i6 && r4.match(u3), a4 = o6 && n6.match(h3), p5 = l5 && r4.match(h3), g7 = a4 && t8.match(d3), m7 = p5 && e6.match(f3);
                  return g7 || m7 ? 5 : a4 || p5 ? 4 : s6 && !o6 && l5 ? 3 : o6 || l5 ? 2 : s6 || i6 ? 1 : 0;
                }
                __name(e5, "e");
                var n5 = 1;
                for (; n5 < t7.length - 1; ) {
                  if (t7[n5 - 1][0] == r3 && t7[n5 + 1][0] == r3) {
                    var s5 = t7[n5 - 1][1], i5 = t7[n5][1], o5 = t7[n5 + 1][1], l4 = a3(s5, i5);
                    if (l4) {
                      var p4 = i5.substring(i5.length - l4);
                      s5 = s5.substring(0, s5.length - l4), i5 = p4 + i5.substring(0, i5.length - l4), o5 = p4 + o5;
                    }
                    for (var g6 = s5, m6 = i5, b6 = o5, y6 = e5(s5, i5) + e5(i5, o5); i5.charAt(0) === o5.charAt(0); ) {
                      s5 += i5.charAt(0), i5 = i5.substring(1) + o5.charAt(0), o5 = o5.substring(1);
                      var v6 = e5(s5, i5) + e5(i5, o5);
                      v6 >= y6 && (y6 = v6, g6 = s5, m6 = i5, b6 = o5);
                    }
                    t7[n5 - 1][1] != g6 && (g6 ? t7[n5 - 1][1] = g6 : (t7.splice(n5 - 1, 1), n5--), t7[n5][1] = m6, b6 ? t7[n5 + 1][1] = b6 : (t7.splice(n5 + 1, 1), n5--));
                  }
                  n5++;
                }
              })(t6), m5 = 1;
              for (; m5 < t6.length; ) {
                if (t6[m5 - 1][0] == e4 && t6[m5][0] == n4) {
                  var N4 = t6[m5 - 1][1], w4 = t6[m5][1], E4 = l3(N4, w4), A4 = l3(w4, N4);
                  E4 >= A4 ? (E4 >= N4.length / 2 || E4 >= w4.length / 2) && (t6.splice(m5, 0, [r3, w4.substring(0, E4)]), t6[m5 - 1][1] = N4.substring(0, N4.length - E4), t6[m5 + 1][1] = w4.substring(E4), m5++) : (A4 >= N4.length / 2 || A4 >= w4.length / 2) && (t6.splice(m5, 0, [r3, N4.substring(0, A4)]), t6[m5 - 1][0] = n4, t6[m5 - 1][1] = w4.substring(0, w4.length - A4), t6[m5 + 1][0] = e4, t6[m5 + 1][1] = N4.substring(A4), m5++), m5++;
                }
                m5++;
              }
            }(A3), A3;
          }
          __name(s3, "s");
          function i3(t5, e5, n5, r4) {
            var i4 = t5.substring(0, n5), o4 = e5.substring(0, r4), l4 = t5.substring(n5), a4 = e5.substring(r4), c4 = s3(i4, o4), u4 = s3(l4, a4);
            return c4.concat(u4);
          }
          __name(i3, "i");
          function o3(t5, e5) {
            if (!t5 || !e5 || t5.charAt(0) !== e5.charAt(0))
              return 0;
            for (var n5 = 0, r4 = Math.min(t5.length, e5.length), s4 = r4, i4 = 0; n5 < s4; )
              t5.substring(i4, s4) == e5.substring(i4, s4) ? i4 = n5 = s4 : r4 = s4, s4 = Math.floor((r4 - n5) / 2 + n5);
            return g3(t5.charCodeAt(s4 - 1)) && s4--, s4;
          }
          __name(o3, "o");
          function l3(t5, e5) {
            var n5 = t5.length, r4 = e5.length;
            if (0 == n5 || 0 == r4)
              return 0;
            n5 > r4 ? t5 = t5.substring(n5 - r4) : n5 < r4 && (e5 = e5.substring(0, n5));
            var s4 = Math.min(n5, r4);
            if (t5 == e5)
              return s4;
            for (var i4 = 0, o4 = 1; ; ) {
              var l4 = t5.substring(s4 - o4), a4 = e5.indexOf(l4);
              if (-1 == a4)
                return i4;
              o4 += a4, 0 != a4 && t5.substring(s4 - o4) != e5.substring(0, o4) || (i4 = o4, o4++);
            }
          }
          __name(l3, "l");
          function a3(t5, e5) {
            if (!t5 || !e5 || t5.slice(-1) !== e5.slice(-1))
              return 0;
            for (var n5 = 0, r4 = Math.min(t5.length, e5.length), s4 = r4, i4 = 0; n5 < s4; )
              t5.substring(t5.length - s4, t5.length - i4) == e5.substring(e5.length - s4, e5.length - i4) ? i4 = n5 = s4 : r4 = s4, s4 = Math.floor((r4 - n5) / 2 + n5);
            return m3(t5.charCodeAt(t5.length - s4)) && s4--, s4;
          }
          __name(a3, "a");
          var c3 = /[^a-zA-Z0-9]/, u3 = /\s/, h3 = /[\r\n]/, d3 = /\n\r?\n$/, f3 = /^\r?\n\r?\n/;
          function p3(t5, s4) {
            t5.push([r3, ""]);
            for (var i4, l4 = 0, c4 = 0, u4 = 0, h4 = "", d4 = ""; l4 < t5.length; )
              if (l4 < t5.length - 1 && !t5[l4][1])
                t5.splice(l4, 1);
              else
                switch (t5[l4][0]) {
                  case n4:
                    u4++, d4 += t5[l4][1], l4++;
                    break;
                  case e4:
                    c4++, h4 += t5[l4][1], l4++;
                    break;
                  case r3:
                    var f4 = l4 - u4 - c4 - 1;
                    if (s4) {
                      if (f4 >= 0 && y3(t5[f4][1])) {
                        var g4 = t5[f4][1].slice(-1);
                        if (t5[f4][1] = t5[f4][1].slice(0, -1), h4 = g4 + h4, d4 = g4 + d4, !t5[f4][1]) {
                          t5.splice(f4, 1), l4--;
                          var m4 = f4 - 1;
                          t5[m4] && t5[m4][0] === n4 && (u4++, d4 = t5[m4][1] + d4, m4--), t5[m4] && t5[m4][0] === e4 && (c4++, h4 = t5[m4][1] + h4, m4--), f4 = m4;
                        }
                      }
                      if (b3(t5[l4][1])) {
                        g4 = t5[l4][1].charAt(0);
                        t5[l4][1] = t5[l4][1].slice(1), h4 += g4, d4 += g4;
                      }
                    }
                    if (l4 < t5.length - 1 && !t5[l4][1]) {
                      t5.splice(l4, 1);
                      break;
                    }
                    if (h4.length > 0 || d4.length > 0) {
                      h4.length > 0 && d4.length > 0 && (0 !== (i4 = o3(d4, h4)) && (f4 >= 0 ? t5[f4][1] += d4.substring(0, i4) : (t5.splice(0, 0, [r3, d4.substring(0, i4)]), l4++), d4 = d4.substring(i4), h4 = h4.substring(i4)), 0 !== (i4 = a3(d4, h4)) && (t5[l4][1] = d4.substring(d4.length - i4) + t5[l4][1], d4 = d4.substring(0, d4.length - i4), h4 = h4.substring(0, h4.length - i4)));
                      var v5 = u4 + c4;
                      0 === h4.length && 0 === d4.length ? (t5.splice(l4 - v5, v5), l4 -= v5) : 0 === h4.length ? (t5.splice(l4 - v5, v5, [n4, d4]), l4 = l4 - v5 + 1) : 0 === d4.length ? (t5.splice(l4 - v5, v5, [e4, h4]), l4 = l4 - v5 + 1) : (t5.splice(l4 - v5, v5, [e4, h4], [n4, d4]), l4 = l4 - v5 + 2);
                    }
                    0 !== l4 && t5[l4 - 1][0] === r3 ? (t5[l4 - 1][1] += t5[l4][1], t5.splice(l4, 1)) : l4++, u4 = 0, c4 = 0, h4 = "", d4 = "";
                }
            "" === t5[t5.length - 1][1] && t5.pop();
            var x4 = false;
            for (l4 = 1; l4 < t5.length - 1; )
              t5[l4 - 1][0] === r3 && t5[l4 + 1][0] === r3 && (t5[l4][1].substring(t5[l4][1].length - t5[l4 - 1][1].length) === t5[l4 - 1][1] ? (t5[l4][1] = t5[l4 - 1][1] + t5[l4][1].substring(0, t5[l4][1].length - t5[l4 - 1][1].length), t5[l4 + 1][1] = t5[l4 - 1][1] + t5[l4 + 1][1], t5.splice(l4 - 1, 1), x4 = true) : t5[l4][1].substring(0, t5[l4 + 1][1].length) == t5[l4 + 1][1] && (t5[l4 - 1][1] += t5[l4 + 1][1], t5[l4][1] = t5[l4][1].substring(t5[l4 + 1][1].length) + t5[l4 + 1][1], t5.splice(l4 + 1, 1), x4 = true)), l4++;
            x4 && p3(t5, s4);
          }
          __name(p3, "p");
          function g3(t5) {
            return t5 >= 55296 && t5 <= 56319;
          }
          __name(g3, "g");
          function m3(t5) {
            return t5 >= 56320 && t5 <= 57343;
          }
          __name(m3, "m");
          function b3(t5) {
            return m3(t5.charCodeAt(0));
          }
          __name(b3, "b");
          function y3(t5) {
            return g3(t5.charCodeAt(t5.length - 1));
          }
          __name(y3, "y");
          function v3(t5, s4, i4, o4) {
            return y3(t5) || b3(o4) ? null : function(t6) {
              for (var e5 = [], n5 = 0; n5 < t6.length; n5++)
                t6[n5][1].length > 0 && e5.push(t6[n5]);
              return e5;
            }([[r3, t5], [e4, s4], [n4, i4], [r3, o4]]);
          }
          __name(v3, "v");
          function x3(t5, e5, n5, r4) {
            return s3(t5, e5, n5, r4, true);
          }
          __name(x3, "x");
          x3.INSERT = n4, x3.DELETE = e4, x3.EQUAL = r3, t4.exports = x3;
        }, 193: (t4, e4, n4) => {
          t4 = n4.nmd(t4);
          var r3 = "__lodash_hash_undefined__", s3 = 9007199254740991, i3 = "[object Arguments]", o3 = "[object Boolean]", l3 = "[object Date]", a3 = "[object Function]", c3 = "[object GeneratorFunction]", u3 = "[object Map]", h3 = "[object Number]", d3 = "[object Object]", f3 = "[object Promise]", p3 = "[object RegExp]", g3 = "[object Set]", m3 = "[object String]", b3 = "[object Symbol]", y3 = "[object WeakMap]", v3 = "[object ArrayBuffer]", x3 = "[object DataView]", N3 = "[object Float32Array]", w3 = "[object Float64Array]", E3 = "[object Int8Array]", A3 = "[object Int16Array]", q3 = "[object Int32Array]", k3 = "[object Uint8Array]", _2 = "[object Uint8ClampedArray]", L5 = "[object Uint16Array]", O3 = "[object Uint32Array]", T3 = /\w*$/, S3 = /^\[object .+?Constructor\]$/, C3 = /^(?:0|[1-9]\d*)$/, j3 = {};
          j3[i3] = j3["[object Array]"] = j3[v3] = j3[x3] = j3[o3] = j3[l3] = j3[N3] = j3[w3] = j3[E3] = j3[A3] = j3[q3] = j3[u3] = j3[h3] = j3[d3] = j3[p3] = j3[g3] = j3[m3] = j3[b3] = j3[k3] = j3[_2] = j3[L5] = j3[O3] = true, j3["[object Error]"] = j3[a3] = j3[y3] = false;
          var R3 = "object" == typeof n4.g && n4.g && n4.g.Object === Object && n4.g, I3 = "object" == typeof self && self && self.Object === Object && self, M3 = R3 || I3 || Function("return this")(), B3 = e4 && !e4.nodeType && e4, U3 = B3 && t4 && !t4.nodeType && t4, D3 = U3 && U3.exports === B3;
          function P3(t5, e5) {
            return t5.set(e5[0], e5[1]), t5;
          }
          __name(P3, "P");
          function z3(t5, e5) {
            return t5.add(e5), t5;
          }
          __name(z3, "z");
          function H3(t5, e5, n5, r4) {
            var s4 = -1, i4 = t5 ? t5.length : 0;
            for (r4 && i4 && (n5 = t5[++s4]); ++s4 < i4; )
              n5 = e5(n5, t5[s4], s4, t5);
            return n5;
          }
          __name(H3, "H");
          function F3(t5) {
            var e5 = false;
            if (null != t5 && "function" != typeof t5.toString)
              try {
                e5 = !!(t5 + "");
              } catch (t6) {
              }
            return e5;
          }
          __name(F3, "F");
          function $2(t5) {
            var e5 = -1, n5 = Array(t5.size);
            return t5.forEach(function(t6, r4) {
              n5[++e5] = [r4, t6];
            }), n5;
          }
          __name($2, "$");
          function V3(t5, e5) {
            return function(n5) {
              return t5(e5(n5));
            };
          }
          __name(V3, "V");
          function K3(t5) {
            var e5 = -1, n5 = Array(t5.size);
            return t5.forEach(function(t6) {
              n5[++e5] = t6;
            }), n5;
          }
          __name(K3, "K");
          var W3, Z2 = Array.prototype, G3 = Function.prototype, X3 = Object.prototype, Q3 = M3["__core-js_shared__"], Y3 = (W3 = /[^.]+$/.exec(Q3 && Q3.keys && Q3.keys.IE_PROTO || "")) ? "Symbol(src)_1." + W3 : "", J3 = G3.toString, tt = X3.hasOwnProperty, et = X3.toString, nt = RegExp("^" + J3.call(tt).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"), rt = D3 ? M3.Buffer : void 0, st = M3.Symbol, it = M3.Uint8Array, ot = V3(Object.getPrototypeOf, Object), lt = Object.create, at2 = X3.propertyIsEnumerable, ct2 = Z2.splice, ut = Object.getOwnPropertySymbols, ht = rt ? rt.isBuffer : void 0, dt = V3(Object.keys, Object), ft = Ut(M3, "DataView"), pt = Ut(M3, "Map"), gt = Ut(M3, "Promise"), mt = Ut(M3, "Set"), bt2 = Ut(M3, "WeakMap"), yt = Ut(Object, "create"), vt = Ft(ft), xt = Ft(pt), Nt = Ft(gt), wt = Ft(mt), Et = Ft(bt2), At = st ? st.prototype : void 0, qt = At ? At.valueOf : void 0;
          function kt(t5) {
            var e5 = -1, n5 = t5 ? t5.length : 0;
            for (this.clear(); ++e5 < n5; ) {
              var r4 = t5[e5];
              this.set(r4[0], r4[1]);
            }
          }
          __name(kt, "kt");
          function _t(t5) {
            var e5 = -1, n5 = t5 ? t5.length : 0;
            for (this.clear(); ++e5 < n5; ) {
              var r4 = t5[e5];
              this.set(r4[0], r4[1]);
            }
          }
          __name(_t, "_t");
          function Lt(t5) {
            var e5 = -1, n5 = t5 ? t5.length : 0;
            for (this.clear(); ++e5 < n5; ) {
              var r4 = t5[e5];
              this.set(r4[0], r4[1]);
            }
          }
          __name(Lt, "Lt");
          function Ot(t5) {
            this.__data__ = new _t(t5);
          }
          __name(Ot, "Ot");
          function Tt(t5, e5) {
            var n5 = Vt(t5) || function(t6) {
              return function(t7) {
                return /* @__PURE__ */ function(t8) {
                  return !!t8 && "object" == typeof t8;
                }(t7) && Kt(t7);
              }(t6) && tt.call(t6, "callee") && (!at2.call(t6, "callee") || et.call(t6) == i3);
            }(t5) ? function(t6, e6) {
              for (var n6 = -1, r5 = Array(t6); ++n6 < t6; )
                r5[n6] = e6(n6);
              return r5;
            }(t5.length, String) : [], r4 = n5.length, s4 = !!r4;
            for (var o4 in t5)
              !e5 && !tt.call(t5, o4) || s4 && ("length" == o4 || zt(o4, r4)) || n5.push(o4);
            return n5;
          }
          __name(Tt, "Tt");
          function St(t5, e5, n5) {
            var r4 = t5[e5];
            tt.call(t5, e5) && $t(r4, n5) && (void 0 !== n5 || e5 in t5) || (t5[e5] = n5);
          }
          __name(St, "St");
          function Ct(t5, e5) {
            for (var n5 = t5.length; n5--; )
              if ($t(t5[n5][0], e5))
                return n5;
            return -1;
          }
          __name(Ct, "Ct");
          function jt(t5, e5, n5, r4, s4, f4, y4) {
            var S4;
            if (r4 && (S4 = f4 ? r4(t5, s4, f4, y4) : r4(t5)), void 0 !== S4)
              return S4;
            if (!Gt(t5))
              return t5;
            var C4 = Vt(t5);
            if (C4) {
              if (S4 = function(t6) {
                var e6 = t6.length, n6 = t6.constructor(e6);
                e6 && "string" == typeof t6[0] && tt.call(t6, "index") && (n6.index = t6.index, n6.input = t6.input);
                return n6;
              }(t5), !e5)
                return function(t6, e6) {
                  var n6 = -1, r5 = t6.length;
                  e6 || (e6 = Array(r5));
                  for (; ++n6 < r5; )
                    e6[n6] = t6[n6];
                  return e6;
                }(t5, S4);
            } else {
              var R4 = Pt(t5), I4 = R4 == a3 || R4 == c3;
              if (Wt(t5))
                return function(t6, e6) {
                  if (e6)
                    return t6.slice();
                  var n6 = new t6.constructor(t6.length);
                  return t6.copy(n6), n6;
                }(t5, e5);
              if (R4 == d3 || R4 == i3 || I4 && !f4) {
                if (F3(t5))
                  return f4 ? t5 : {};
                if (S4 = function(t6) {
                  return "function" != typeof t6.constructor || Ht(t6) ? {} : (e6 = ot(t6), Gt(e6) ? lt(e6) : {});
                  var e6;
                }(I4 ? {} : t5), !e5)
                  return function(t6, e6) {
                    return Mt(t6, Dt(t6), e6);
                  }(t5, function(t6, e6) {
                    return t6 && Mt(e6, Xt(e6), t6);
                  }(S4, t5));
              } else {
                if (!j3[R4])
                  return f4 ? t5 : {};
                S4 = function(t6, e6, n6, r5) {
                  var s5 = t6.constructor;
                  switch (e6) {
                    case v3:
                      return It(t6);
                    case o3:
                    case l3:
                      return new s5(+t6);
                    case x3:
                      return function(t7, e7) {
                        var n7 = e7 ? It(t7.buffer) : t7.buffer;
                        return new t7.constructor(n7, t7.byteOffset, t7.byteLength);
                      }(t6, r5);
                    case N3:
                    case w3:
                    case E3:
                    case A3:
                    case q3:
                    case k3:
                    case _2:
                    case L5:
                    case O3:
                      return function(t7, e7) {
                        var n7 = e7 ? It(t7.buffer) : t7.buffer;
                        return new t7.constructor(n7, t7.byteOffset, t7.length);
                      }(t6, r5);
                    case u3:
                      return function(t7, e7, n7) {
                        var r6 = e7 ? n7($2(t7), true) : $2(t7);
                        return H3(r6, P3, new t7.constructor());
                      }(t6, r5, n6);
                    case h3:
                    case m3:
                      return new s5(t6);
                    case p3:
                      return function(t7) {
                        var e7 = new t7.constructor(t7.source, T3.exec(t7));
                        return e7.lastIndex = t7.lastIndex, e7;
                      }(t6);
                    case g3:
                      return function(t7, e7, n7) {
                        var r6 = e7 ? n7(K3(t7), true) : K3(t7);
                        return H3(r6, z3, new t7.constructor());
                      }(t6, r5, n6);
                    case b3:
                      return i4 = t6, qt ? Object(qt.call(i4)) : {};
                  }
                  var i4;
                }(t5, R4, jt, e5);
              }
            }
            y4 || (y4 = new Ot());
            var M4 = y4.get(t5);
            if (M4)
              return M4;
            if (y4.set(t5, S4), !C4)
              var B4 = n5 ? function(t6) {
                return function(t7, e6, n6) {
                  var r5 = e6(t7);
                  return Vt(t7) ? r5 : function(t8, e7) {
                    for (var n7 = -1, r6 = e7.length, s5 = t8.length; ++n7 < r6; )
                      t8[s5 + n7] = e7[n7];
                    return t8;
                  }(r5, n6(t7));
                }(t6, Xt, Dt);
              }(t5) : Xt(t5);
            return function(t6, e6) {
              for (var n6 = -1, r5 = t6 ? t6.length : 0; ++n6 < r5 && false !== e6(t6[n6], n6, t6); )
                ;
            }(B4 || t5, function(s5, i4) {
              B4 && (s5 = t5[i4 = s5]), St(S4, i4, jt(s5, e5, n5, r4, i4, t5, y4));
            }), S4;
          }
          __name(jt, "jt");
          function Rt(t5) {
            return !(!Gt(t5) || (e5 = t5, Y3 && Y3 in e5)) && (Zt(t5) || F3(t5) ? nt : S3).test(Ft(t5));
            var e5;
          }
          __name(Rt, "Rt");
          function It(t5) {
            var e5 = new t5.constructor(t5.byteLength);
            return new it(e5).set(new it(t5)), e5;
          }
          __name(It, "It");
          function Mt(t5, e5, n5, r4) {
            n5 || (n5 = {});
            for (var s4 = -1, i4 = e5.length; ++s4 < i4; ) {
              var o4 = e5[s4], l4 = r4 ? r4(n5[o4], t5[o4], o4, n5, t5) : void 0;
              St(n5, o4, void 0 === l4 ? t5[o4] : l4);
            }
            return n5;
          }
          __name(Mt, "Mt");
          function Bt(t5, e5) {
            var n5, r4, s4 = t5.__data__;
            return ("string" == (r4 = typeof (n5 = e5)) || "number" == r4 || "symbol" == r4 || "boolean" == r4 ? "__proto__" !== n5 : null === n5) ? s4["string" == typeof e5 ? "string" : "hash"] : s4.map;
          }
          __name(Bt, "Bt");
          function Ut(t5, e5) {
            var n5 = function(t6, e6) {
              return null == t6 ? void 0 : t6[e6];
            }(t5, e5);
            return Rt(n5) ? n5 : void 0;
          }
          __name(Ut, "Ut");
          kt.prototype.clear = function() {
            this.__data__ = yt ? yt(null) : {};
          }, kt.prototype.delete = function(t5) {
            return this.has(t5) && delete this.__data__[t5];
          }, kt.prototype.get = function(t5) {
            var e5 = this.__data__;
            if (yt) {
              var n5 = e5[t5];
              return n5 === r3 ? void 0 : n5;
            }
            return tt.call(e5, t5) ? e5[t5] : void 0;
          }, kt.prototype.has = function(t5) {
            var e5 = this.__data__;
            return yt ? void 0 !== e5[t5] : tt.call(e5, t5);
          }, kt.prototype.set = function(t5, e5) {
            return this.__data__[t5] = yt && void 0 === e5 ? r3 : e5, this;
          }, _t.prototype.clear = function() {
            this.__data__ = [];
          }, _t.prototype.delete = function(t5) {
            var e5 = this.__data__, n5 = Ct(e5, t5);
            return !(n5 < 0) && (n5 == e5.length - 1 ? e5.pop() : ct2.call(e5, n5, 1), true);
          }, _t.prototype.get = function(t5) {
            var e5 = this.__data__, n5 = Ct(e5, t5);
            return n5 < 0 ? void 0 : e5[n5][1];
          }, _t.prototype.has = function(t5) {
            return Ct(this.__data__, t5) > -1;
          }, _t.prototype.set = function(t5, e5) {
            var n5 = this.__data__, r4 = Ct(n5, t5);
            return r4 < 0 ? n5.push([t5, e5]) : n5[r4][1] = e5, this;
          }, Lt.prototype.clear = function() {
            this.__data__ = { hash: new kt(), map: new (pt || _t)(), string: new kt() };
          }, Lt.prototype.delete = function(t5) {
            return Bt(this, t5).delete(t5);
          }, Lt.prototype.get = function(t5) {
            return Bt(this, t5).get(t5);
          }, Lt.prototype.has = function(t5) {
            return Bt(this, t5).has(t5);
          }, Lt.prototype.set = function(t5, e5) {
            return Bt(this, t5).set(t5, e5), this;
          }, Ot.prototype.clear = function() {
            this.__data__ = new _t();
          }, Ot.prototype.delete = function(t5) {
            return this.__data__.delete(t5);
          }, Ot.prototype.get = function(t5) {
            return this.__data__.get(t5);
          }, Ot.prototype.has = function(t5) {
            return this.__data__.has(t5);
          }, Ot.prototype.set = function(t5, e5) {
            var n5 = this.__data__;
            if (n5 instanceof _t) {
              var r4 = n5.__data__;
              if (!pt || r4.length < 199)
                return r4.push([t5, e5]), this;
              n5 = this.__data__ = new Lt(r4);
            }
            return n5.set(t5, e5), this;
          };
          var Dt = ut ? V3(ut, Object) : function() {
            return [];
          }, Pt = /* @__PURE__ */ __name(function(t5) {
            return et.call(t5);
          }, "Pt");
          function zt(t5, e5) {
            return !!(e5 = null == e5 ? s3 : e5) && ("number" == typeof t5 || C3.test(t5)) && t5 > -1 && t5 % 1 == 0 && t5 < e5;
          }
          __name(zt, "zt");
          function Ht(t5) {
            var e5 = t5 && t5.constructor;
            return t5 === ("function" == typeof e5 && e5.prototype || X3);
          }
          __name(Ht, "Ht");
          function Ft(t5) {
            if (null != t5) {
              try {
                return J3.call(t5);
              } catch (t6) {
              }
              try {
                return t5 + "";
              } catch (t6) {
              }
            }
            return "";
          }
          __name(Ft, "Ft");
          function $t(t5, e5) {
            return t5 === e5 || t5 != t5 && e5 != e5;
          }
          __name($t, "$t");
          (ft && Pt(new ft(new ArrayBuffer(1))) != x3 || pt && Pt(new pt()) != u3 || gt && Pt(gt.resolve()) != f3 || mt && Pt(new mt()) != g3 || bt2 && Pt(new bt2()) != y3) && (Pt = /* @__PURE__ */ __name(function(t5) {
            var e5 = et.call(t5), n5 = e5 == d3 ? t5.constructor : void 0, r4 = n5 ? Ft(n5) : void 0;
            if (r4)
              switch (r4) {
                case vt:
                  return x3;
                case xt:
                  return u3;
                case Nt:
                  return f3;
                case wt:
                  return g3;
                case Et:
                  return y3;
              }
            return e5;
          }, "Pt"));
          var Vt = Array.isArray;
          function Kt(t5) {
            return null != t5 && function(t6) {
              return "number" == typeof t6 && t6 > -1 && t6 % 1 == 0 && t6 <= s3;
            }(t5.length) && !Zt(t5);
          }
          __name(Kt, "Kt");
          var Wt = ht || function() {
            return false;
          };
          function Zt(t5) {
            var e5 = Gt(t5) ? et.call(t5) : "";
            return e5 == a3 || e5 == c3;
          }
          __name(Zt, "Zt");
          function Gt(t5) {
            var e5 = typeof t5;
            return !!t5 && ("object" == e5 || "function" == e5);
          }
          __name(Gt, "Gt");
          function Xt(t5) {
            return Kt(t5) ? Tt(t5) : function(t6) {
              if (!Ht(t6))
                return dt(t6);
              var e5 = [];
              for (var n5 in Object(t6))
                tt.call(t6, n5) && "constructor" != n5 && e5.push(n5);
              return e5;
            }(t5);
          }
          __name(Xt, "Xt");
          t4.exports = function(t5) {
            return jt(t5, true, true);
          };
        }, 142: (t4, e4, n4) => {
          t4 = n4.nmd(t4);
          var r3 = "__lodash_hash_undefined__", s3 = 1, i3 = 2, o3 = 9007199254740991, l3 = "[object Arguments]", a3 = "[object Array]", c3 = "[object AsyncFunction]", u3 = "[object Boolean]", h3 = "[object Date]", d3 = "[object Error]", f3 = "[object Function]", p3 = "[object GeneratorFunction]", g3 = "[object Map]", m3 = "[object Number]", b3 = "[object Null]", y3 = "[object Object]", v3 = "[object Promise]", x3 = "[object Proxy]", N3 = "[object RegExp]", w3 = "[object Set]", E3 = "[object String]", A3 = "[object Symbol]", q3 = "[object Undefined]", k3 = "[object WeakMap]", _2 = "[object ArrayBuffer]", L5 = "[object DataView]", O3 = /^\[object .+?Constructor\]$/, T3 = /^(?:0|[1-9]\d*)$/, S3 = {};
          S3["[object Float32Array]"] = S3["[object Float64Array]"] = S3["[object Int8Array]"] = S3["[object Int16Array]"] = S3["[object Int32Array]"] = S3["[object Uint8Array]"] = S3["[object Uint8ClampedArray]"] = S3["[object Uint16Array]"] = S3["[object Uint32Array]"] = true, S3[l3] = S3[a3] = S3[_2] = S3[u3] = S3[L5] = S3[h3] = S3[d3] = S3[f3] = S3[g3] = S3[m3] = S3[y3] = S3[N3] = S3[w3] = S3[E3] = S3[k3] = false;
          var C3 = "object" == typeof n4.g && n4.g && n4.g.Object === Object && n4.g, j3 = "object" == typeof self && self && self.Object === Object && self, R3 = C3 || j3 || Function("return this")(), I3 = e4 && !e4.nodeType && e4, M3 = I3 && t4 && !t4.nodeType && t4, B3 = M3 && M3.exports === I3, U3 = B3 && C3.process, D3 = function() {
            try {
              return U3 && U3.binding && U3.binding("util");
            } catch (t5) {
            }
          }(), P3 = D3 && D3.isTypedArray;
          function z3(t5, e5) {
            for (var n5 = -1, r4 = null == t5 ? 0 : t5.length; ++n5 < r4; )
              if (e5(t5[n5], n5, t5))
                return true;
            return false;
          }
          __name(z3, "z");
          function H3(t5) {
            var e5 = -1, n5 = Array(t5.size);
            return t5.forEach(function(t6, r4) {
              n5[++e5] = [r4, t6];
            }), n5;
          }
          __name(H3, "H");
          function F3(t5) {
            var e5 = -1, n5 = Array(t5.size);
            return t5.forEach(function(t6) {
              n5[++e5] = t6;
            }), n5;
          }
          __name(F3, "F");
          var $2, V3, K3, W3 = Array.prototype, Z2 = Function.prototype, G3 = Object.prototype, X3 = R3["__core-js_shared__"], Q3 = Z2.toString, Y3 = G3.hasOwnProperty, J3 = ($2 = /[^.]+$/.exec(X3 && X3.keys && X3.keys.IE_PROTO || "")) ? "Symbol(src)_1." + $2 : "", tt = G3.toString, et = RegExp("^" + Q3.call(Y3).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"), nt = B3 ? R3.Buffer : void 0, rt = R3.Symbol, st = R3.Uint8Array, it = G3.propertyIsEnumerable, ot = W3.splice, lt = rt ? rt.toStringTag : void 0, at2 = Object.getOwnPropertySymbols, ct2 = nt ? nt.isBuffer : void 0, ut = (V3 = Object.keys, K3 = Object, function(t5) {
            return V3(K3(t5));
          }), ht = Dt(R3, "DataView"), dt = Dt(R3, "Map"), ft = Dt(R3, "Promise"), pt = Dt(R3, "Set"), gt = Dt(R3, "WeakMap"), mt = Dt(Object, "create"), bt2 = Ft(ht), yt = Ft(dt), vt = Ft(ft), xt = Ft(pt), Nt = Ft(gt), wt = rt ? rt.prototype : void 0, Et = wt ? wt.valueOf : void 0;
          function At(t5) {
            var e5 = -1, n5 = null == t5 ? 0 : t5.length;
            for (this.clear(); ++e5 < n5; ) {
              var r4 = t5[e5];
              this.set(r4[0], r4[1]);
            }
          }
          __name(At, "At");
          function qt(t5) {
            var e5 = -1, n5 = null == t5 ? 0 : t5.length;
            for (this.clear(); ++e5 < n5; ) {
              var r4 = t5[e5];
              this.set(r4[0], r4[1]);
            }
          }
          __name(qt, "qt");
          function kt(t5) {
            var e5 = -1, n5 = null == t5 ? 0 : t5.length;
            for (this.clear(); ++e5 < n5; ) {
              var r4 = t5[e5];
              this.set(r4[0], r4[1]);
            }
          }
          __name(kt, "kt");
          function _t(t5) {
            var e5 = -1, n5 = null == t5 ? 0 : t5.length;
            for (this.__data__ = new kt(); ++e5 < n5; )
              this.add(t5[e5]);
          }
          __name(_t, "_t");
          function Lt(t5) {
            var e5 = this.__data__ = new qt(t5);
            this.size = e5.size;
          }
          __name(Lt, "Lt");
          function Ot(t5, e5) {
            var n5 = Kt(t5), r4 = !n5 && Vt(t5), s4 = !n5 && !r4 && Wt(t5), i4 = !n5 && !r4 && !s4 && Yt(t5), o4 = n5 || r4 || s4 || i4, l4 = o4 ? function(t6, e6) {
              for (var n6 = -1, r5 = Array(t6); ++n6 < t6; )
                r5[n6] = e6(n6);
              return r5;
            }(t5.length, String) : [], a4 = l4.length;
            for (var c4 in t5)
              !e5 && !Y3.call(t5, c4) || o4 && ("length" == c4 || s4 && ("offset" == c4 || "parent" == c4) || i4 && ("buffer" == c4 || "byteLength" == c4 || "byteOffset" == c4) || Ht(c4, a4)) || l4.push(c4);
            return l4;
          }
          __name(Ot, "Ot");
          function Tt(t5, e5) {
            for (var n5 = t5.length; n5--; )
              if ($t(t5[n5][0], e5))
                return n5;
            return -1;
          }
          __name(Tt, "Tt");
          function St(t5) {
            return null == t5 ? void 0 === t5 ? q3 : b3 : lt && lt in Object(t5) ? function(t6) {
              var e5 = Y3.call(t6, lt), n5 = t6[lt];
              try {
                t6[lt] = void 0;
                var r4 = true;
              } catch (t7) {
              }
              var s4 = tt.call(t6);
              r4 && (e5 ? t6[lt] = n5 : delete t6[lt]);
              return s4;
            }(t5) : function(t6) {
              return tt.call(t6);
            }(t5);
          }
          __name(St, "St");
          function Ct(t5) {
            return Qt(t5) && St(t5) == l3;
          }
          __name(Ct, "Ct");
          function jt(t5, e5, n5, r4, o4) {
            return t5 === e5 || (null == t5 || null == e5 || !Qt(t5) && !Qt(e5) ? t5 != t5 && e5 != e5 : function(t6, e6, n6, r5, o5, c4) {
              var f4 = Kt(t6), p4 = Kt(e6), b4 = f4 ? a3 : zt(t6), v5 = p4 ? a3 : zt(e6), x4 = (b4 = b4 == l3 ? y3 : b4) == y3, q4 = (v5 = v5 == l3 ? y3 : v5) == y3, k4 = b4 == v5;
              if (k4 && Wt(t6)) {
                if (!Wt(e6))
                  return false;
                f4 = true, x4 = false;
              }
              if (k4 && !x4)
                return c4 || (c4 = new Lt()), f4 || Yt(t6) ? Mt(t6, e6, n6, r5, o5, c4) : function(t7, e7, n7, r6, o6, l4, a4) {
                  switch (n7) {
                    case L5:
                      if (t7.byteLength != e7.byteLength || t7.byteOffset != e7.byteOffset)
                        return false;
                      t7 = t7.buffer, e7 = e7.buffer;
                    case _2:
                      return !(t7.byteLength != e7.byteLength || !l4(new st(t7), new st(e7)));
                    case u3:
                    case h3:
                    case m3:
                      return $t(+t7, +e7);
                    case d3:
                      return t7.name == e7.name && t7.message == e7.message;
                    case N3:
                    case E3:
                      return t7 == e7 + "";
                    case g3:
                      var c5 = H3;
                    case w3:
                      var f5 = r6 & s3;
                      if (c5 || (c5 = F3), t7.size != e7.size && !f5)
                        return false;
                      var p5 = a4.get(t7);
                      if (p5)
                        return p5 == e7;
                      r6 |= i3, a4.set(t7, e7);
                      var b5 = Mt(c5(t7), c5(e7), r6, o6, l4, a4);
                      return a4.delete(t7), b5;
                    case A3:
                      if (Et)
                        return Et.call(t7) == Et.call(e7);
                  }
                  return false;
                }(t6, e6, b4, n6, r5, o5, c4);
              if (!(n6 & s3)) {
                var O4 = x4 && Y3.call(t6, "__wrapped__"), T4 = q4 && Y3.call(e6, "__wrapped__");
                if (O4 || T4) {
                  var S4 = O4 ? t6.value() : t6, C4 = T4 ? e6.value() : e6;
                  return c4 || (c4 = new Lt()), o5(S4, C4, n6, r5, c4);
                }
              }
              if (!k4)
                return false;
              return c4 || (c4 = new Lt()), function(t7, e7, n7, r6, i4, o6) {
                var l4 = n7 & s3, a4 = Bt(t7), c5 = a4.length, u4 = Bt(e7), h4 = u4.length;
                if (c5 != h4 && !l4)
                  return false;
                var d4 = c5;
                for (; d4--; ) {
                  var f5 = a4[d4];
                  if (!(l4 ? f5 in e7 : Y3.call(e7, f5)))
                    return false;
                }
                var p5 = o6.get(t7);
                if (p5 && o6.get(e7))
                  return p5 == e7;
                var g4 = true;
                o6.set(t7, e7), o6.set(e7, t7);
                var m4 = l4;
                for (; ++d4 < c5; ) {
                  var b5 = t7[f5 = a4[d4]], y4 = e7[f5];
                  if (r6)
                    var v6 = l4 ? r6(y4, b5, f5, e7, t7, o6) : r6(b5, y4, f5, t7, e7, o6);
                  if (!(void 0 === v6 ? b5 === y4 || i4(b5, y4, n7, r6, o6) : v6)) {
                    g4 = false;
                    break;
                  }
                  m4 || (m4 = "constructor" == f5);
                }
                if (g4 && !m4) {
                  var x5 = t7.constructor, N4 = e7.constructor;
                  x5 == N4 || !("constructor" in t7) || !("constructor" in e7) || "function" == typeof x5 && x5 instanceof x5 && "function" == typeof N4 && N4 instanceof N4 || (g4 = false);
                }
                return o6.delete(t7), o6.delete(e7), g4;
              }(t6, e6, n6, r5, o5, c4);
            }(t5, e5, n5, r4, jt, o4));
          }
          __name(jt, "jt");
          function Rt(t5) {
            return !(!Xt(t5) || function(t6) {
              return !!J3 && J3 in t6;
            }(t5)) && (Zt(t5) ? et : O3).test(Ft(t5));
          }
          __name(Rt, "Rt");
          function It(t5) {
            if (n5 = (e5 = t5) && e5.constructor, r4 = "function" == typeof n5 && n5.prototype || G3, e5 !== r4)
              return ut(t5);
            var e5, n5, r4, s4 = [];
            for (var i4 in Object(t5))
              Y3.call(t5, i4) && "constructor" != i4 && s4.push(i4);
            return s4;
          }
          __name(It, "It");
          function Mt(t5, e5, n5, r4, o4, l4) {
            var a4 = n5 & s3, c4 = t5.length, u4 = e5.length;
            if (c4 != u4 && !(a4 && u4 > c4))
              return false;
            var h4 = l4.get(t5);
            if (h4 && l4.get(e5))
              return h4 == e5;
            var d4 = -1, f4 = true, p4 = n5 & i3 ? new _t() : void 0;
            for (l4.set(t5, e5), l4.set(e5, t5); ++d4 < c4; ) {
              var g4 = t5[d4], m4 = e5[d4];
              if (r4)
                var b4 = a4 ? r4(m4, g4, d4, e5, t5, l4) : r4(g4, m4, d4, t5, e5, l4);
              if (void 0 !== b4) {
                if (b4)
                  continue;
                f4 = false;
                break;
              }
              if (p4) {
                if (!z3(e5, function(t6, e6) {
                  if (s4 = e6, !p4.has(s4) && (g4 === t6 || o4(g4, t6, n5, r4, l4)))
                    return p4.push(e6);
                  var s4;
                })) {
                  f4 = false;
                  break;
                }
              } else if (g4 !== m4 && !o4(g4, m4, n5, r4, l4)) {
                f4 = false;
                break;
              }
            }
            return l4.delete(t5), l4.delete(e5), f4;
          }
          __name(Mt, "Mt");
          function Bt(t5) {
            return function(t6, e5, n5) {
              var r4 = e5(t6);
              return Kt(t6) ? r4 : function(t7, e6) {
                for (var n6 = -1, r5 = e6.length, s4 = t7.length; ++n6 < r5; )
                  t7[s4 + n6] = e6[n6];
                return t7;
              }(r4, n5(t6));
            }(t5, Jt, Pt);
          }
          __name(Bt, "Bt");
          function Ut(t5, e5) {
            var n5, r4, s4 = t5.__data__;
            return ("string" == (r4 = typeof (n5 = e5)) || "number" == r4 || "symbol" == r4 || "boolean" == r4 ? "__proto__" !== n5 : null === n5) ? s4["string" == typeof e5 ? "string" : "hash"] : s4.map;
          }
          __name(Ut, "Ut");
          function Dt(t5, e5) {
            var n5 = function(t6, e6) {
              return null == t6 ? void 0 : t6[e6];
            }(t5, e5);
            return Rt(n5) ? n5 : void 0;
          }
          __name(Dt, "Dt");
          At.prototype.clear = function() {
            this.__data__ = mt ? mt(null) : {}, this.size = 0;
          }, At.prototype.delete = function(t5) {
            var e5 = this.has(t5) && delete this.__data__[t5];
            return this.size -= e5 ? 1 : 0, e5;
          }, At.prototype.get = function(t5) {
            var e5 = this.__data__;
            if (mt) {
              var n5 = e5[t5];
              return n5 === r3 ? void 0 : n5;
            }
            return Y3.call(e5, t5) ? e5[t5] : void 0;
          }, At.prototype.has = function(t5) {
            var e5 = this.__data__;
            return mt ? void 0 !== e5[t5] : Y3.call(e5, t5);
          }, At.prototype.set = function(t5, e5) {
            var n5 = this.__data__;
            return this.size += this.has(t5) ? 0 : 1, n5[t5] = mt && void 0 === e5 ? r3 : e5, this;
          }, qt.prototype.clear = function() {
            this.__data__ = [], this.size = 0;
          }, qt.prototype.delete = function(t5) {
            var e5 = this.__data__, n5 = Tt(e5, t5);
            return !(n5 < 0) && (n5 == e5.length - 1 ? e5.pop() : ot.call(e5, n5, 1), --this.size, true);
          }, qt.prototype.get = function(t5) {
            var e5 = this.__data__, n5 = Tt(e5, t5);
            return n5 < 0 ? void 0 : e5[n5][1];
          }, qt.prototype.has = function(t5) {
            return Tt(this.__data__, t5) > -1;
          }, qt.prototype.set = function(t5, e5) {
            var n5 = this.__data__, r4 = Tt(n5, t5);
            return r4 < 0 ? (++this.size, n5.push([t5, e5])) : n5[r4][1] = e5, this;
          }, kt.prototype.clear = function() {
            this.size = 0, this.__data__ = { hash: new At(), map: new (dt || qt)(), string: new At() };
          }, kt.prototype.delete = function(t5) {
            var e5 = Ut(this, t5).delete(t5);
            return this.size -= e5 ? 1 : 0, e5;
          }, kt.prototype.get = function(t5) {
            return Ut(this, t5).get(t5);
          }, kt.prototype.has = function(t5) {
            return Ut(this, t5).has(t5);
          }, kt.prototype.set = function(t5, e5) {
            var n5 = Ut(this, t5), r4 = n5.size;
            return n5.set(t5, e5), this.size += n5.size == r4 ? 0 : 1, this;
          }, _t.prototype.add = _t.prototype.push = function(t5) {
            return this.__data__.set(t5, r3), this;
          }, _t.prototype.has = function(t5) {
            return this.__data__.has(t5);
          }, Lt.prototype.clear = function() {
            this.__data__ = new qt(), this.size = 0;
          }, Lt.prototype.delete = function(t5) {
            var e5 = this.__data__, n5 = e5.delete(t5);
            return this.size = e5.size, n5;
          }, Lt.prototype.get = function(t5) {
            return this.__data__.get(t5);
          }, Lt.prototype.has = function(t5) {
            return this.__data__.has(t5);
          }, Lt.prototype.set = function(t5, e5) {
            var n5 = this.__data__;
            if (n5 instanceof qt) {
              var r4 = n5.__data__;
              if (!dt || r4.length < 199)
                return r4.push([t5, e5]), this.size = ++n5.size, this;
              n5 = this.__data__ = new kt(r4);
            }
            return n5.set(t5, e5), this.size = n5.size, this;
          };
          var Pt = at2 ? function(t5) {
            return null == t5 ? [] : (t5 = Object(t5), function(t6, e5) {
              for (var n5 = -1, r4 = null == t6 ? 0 : t6.length, s4 = 0, i4 = []; ++n5 < r4; ) {
                var o4 = t6[n5];
                e5(o4, n5, t6) && (i4[s4++] = o4);
              }
              return i4;
            }(at2(t5), function(e5) {
              return it.call(t5, e5);
            }));
          } : function() {
            return [];
          }, zt = St;
          function Ht(t5, e5) {
            return !!(e5 = null == e5 ? o3 : e5) && ("number" == typeof t5 || T3.test(t5)) && t5 > -1 && t5 % 1 == 0 && t5 < e5;
          }
          __name(Ht, "Ht");
          function Ft(t5) {
            if (null != t5) {
              try {
                return Q3.call(t5);
              } catch (t6) {
              }
              try {
                return t5 + "";
              } catch (t6) {
              }
            }
            return "";
          }
          __name(Ft, "Ft");
          function $t(t5, e5) {
            return t5 === e5 || t5 != t5 && e5 != e5;
          }
          __name($t, "$t");
          (ht && zt(new ht(new ArrayBuffer(1))) != L5 || dt && zt(new dt()) != g3 || ft && zt(ft.resolve()) != v3 || pt && zt(new pt()) != w3 || gt && zt(new gt()) != k3) && (zt = /* @__PURE__ */ __name(function(t5) {
            var e5 = St(t5), n5 = e5 == y3 ? t5.constructor : void 0, r4 = n5 ? Ft(n5) : "";
            if (r4)
              switch (r4) {
                case bt2:
                  return L5;
                case yt:
                  return g3;
                case vt:
                  return v3;
                case xt:
                  return w3;
                case Nt:
                  return k3;
              }
            return e5;
          }, "zt"));
          var Vt = Ct(/* @__PURE__ */ function() {
            return arguments;
          }()) ? Ct : function(t5) {
            return Qt(t5) && Y3.call(t5, "callee") && !it.call(t5, "callee");
          }, Kt = Array.isArray;
          var Wt = ct2 || function() {
            return false;
          };
          function Zt(t5) {
            if (!Xt(t5))
              return false;
            var e5 = St(t5);
            return e5 == f3 || e5 == p3 || e5 == c3 || e5 == x3;
          }
          __name(Zt, "Zt");
          function Gt(t5) {
            return "number" == typeof t5 && t5 > -1 && t5 % 1 == 0 && t5 <= o3;
          }
          __name(Gt, "Gt");
          function Xt(t5) {
            var e5 = typeof t5;
            return null != t5 && ("object" == e5 || "function" == e5);
          }
          __name(Xt, "Xt");
          function Qt(t5) {
            return null != t5 && "object" == typeof t5;
          }
          __name(Qt, "Qt");
          var Yt = P3 ? /* @__PURE__ */ function(t5) {
            return function(e5) {
              return t5(e5);
            };
          }(P3) : function(t5) {
            return Qt(t5) && Gt(t5.length) && !!S3[St(t5)];
          };
          function Jt(t5) {
            return null != (e5 = t5) && Gt(e5.length) && !Zt(e5) ? Ot(t5) : It(t5);
            var e5;
          }
          __name(Jt, "Jt");
          t4.exports = function(t5, e5) {
            return jt(t5, e5);
          };
        }, 106: (t4, e4, n4) => {
          "use strict";
          Object.defineProperty(e4, "__esModule", { value: true });
          const r3 = n4(193), s3 = n4(142);
          var i3;
          !function(t5) {
            t5.compose = function(t6 = {}, e5 = {}, n5 = false) {
              "object" != typeof t6 && (t6 = {}), "object" != typeof e5 && (e5 = {});
              let s4 = r3(e5);
              n5 || (s4 = Object.keys(s4).reduce((t7, e6) => (null != s4[e6] && (t7[e6] = s4[e6]), t7), {}));
              for (const n6 in t6)
                void 0 !== t6[n6] && void 0 === e5[n6] && (s4[n6] = t6[n6]);
              return Object.keys(s4).length > 0 ? s4 : void 0;
            }, t5.diff = function(t6 = {}, e5 = {}) {
              "object" != typeof t6 && (t6 = {}), "object" != typeof e5 && (e5 = {});
              const n5 = Object.keys(t6).concat(Object.keys(e5)).reduce((n6, r4) => (s3(t6[r4], e5[r4]) || (n6[r4] = void 0 === e5[r4] ? null : e5[r4]), n6), {});
              return Object.keys(n5).length > 0 ? n5 : void 0;
            }, t5.invert = function(t6 = {}, e5 = {}) {
              t6 = t6 || {};
              const n5 = Object.keys(e5).reduce((n6, r4) => (e5[r4] !== t6[r4] && void 0 !== t6[r4] && (n6[r4] = e5[r4]), n6), {});
              return Object.keys(t6).reduce((n6, r4) => (t6[r4] !== e5[r4] && void 0 === e5[r4] && (n6[r4] = null), n6), n5);
            }, t5.transform = function(t6, e5, n5 = false) {
              if ("object" != typeof t6)
                return e5;
              if ("object" != typeof e5)
                return;
              if (!n5)
                return e5;
              const r4 = Object.keys(e5).reduce((n6, r5) => (void 0 === t6[r5] && (n6[r5] = e5[r5]), n6), {});
              return Object.keys(r4).length > 0 ? r4 : void 0;
            };
          }(i3 || (i3 = {})), e4.default = i3;
        }, 660: (t4, e4, n4) => {
          "use strict";
          Object.defineProperty(e4, "__esModule", { value: true }), e4.AttributeMap = e4.OpIterator = e4.Op = void 0;
          const r3 = n4(606), s3 = n4(193), i3 = n4(142), o3 = n4(106);
          e4.AttributeMap = o3.default;
          const l3 = n4(759);
          e4.Op = l3.default;
          const a3 = n4(317);
          e4.OpIterator = a3.default;
          const c3 = String.fromCharCode(0), u3 = /* @__PURE__ */ __name((t5, e5) => {
            if ("object" != typeof t5 || null === t5)
              throw new Error("cannot retain a " + typeof t5);
            if ("object" != typeof e5 || null === e5)
              throw new Error("cannot retain a " + typeof e5);
            const n5 = Object.keys(t5)[0];
            if (!n5 || n5 !== Object.keys(e5)[0])
              throw new Error(`embed types not matched: ${n5} != ${Object.keys(e5)[0]}`);
            return [n5, t5[n5], e5[n5]];
          }, "u");
          class h3 {
            static {
              __name(this, "h");
            }
            constructor(t5) {
              Array.isArray(t5) ? this.ops = t5 : null != t5 && Array.isArray(t5.ops) ? this.ops = t5.ops : this.ops = [];
            }
            static registerEmbed(t5, e5) {
              this.handlers[t5] = e5;
            }
            static unregisterEmbed(t5) {
              delete this.handlers[t5];
            }
            static getHandler(t5) {
              const e5 = this.handlers[t5];
              if (!e5)
                throw new Error(`no handlers for embed type "${t5}"`);
              return e5;
            }
            insert(t5, e5) {
              const n5 = {};
              return "string" == typeof t5 && 0 === t5.length ? this : (n5.insert = t5, null != e5 && "object" == typeof e5 && Object.keys(e5).length > 0 && (n5.attributes = e5), this.push(n5));
            }
            delete(t5) {
              return t5 <= 0 ? this : this.push({ delete: t5 });
            }
            retain(t5, e5) {
              if ("number" == typeof t5 && t5 <= 0)
                return this;
              const n5 = { retain: t5 };
              return null != e5 && "object" == typeof e5 && Object.keys(e5).length > 0 && (n5.attributes = e5), this.push(n5);
            }
            push(t5) {
              let e5 = this.ops.length, n5 = this.ops[e5 - 1];
              if (t5 = s3(t5), "object" == typeof n5) {
                if ("number" == typeof t5.delete && "number" == typeof n5.delete)
                  return this.ops[e5 - 1] = { delete: n5.delete + t5.delete }, this;
                if ("number" == typeof n5.delete && null != t5.insert && (e5 -= 1, n5 = this.ops[e5 - 1], "object" != typeof n5))
                  return this.ops.unshift(t5), this;
                if (i3(t5.attributes, n5.attributes)) {
                  if ("string" == typeof t5.insert && "string" == typeof n5.insert)
                    return this.ops[e5 - 1] = { insert: n5.insert + t5.insert }, "object" == typeof t5.attributes && (this.ops[e5 - 1].attributes = t5.attributes), this;
                  if ("number" == typeof t5.retain && "number" == typeof n5.retain)
                    return this.ops[e5 - 1] = { retain: n5.retain + t5.retain }, "object" == typeof t5.attributes && (this.ops[e5 - 1].attributes = t5.attributes), this;
                }
              }
              return e5 === this.ops.length ? this.ops.push(t5) : this.ops.splice(e5, 0, t5), this;
            }
            chop() {
              const t5 = this.ops[this.ops.length - 1];
              return t5 && "number" == typeof t5.retain && !t5.attributes && this.ops.pop(), this;
            }
            filter(t5) {
              return this.ops.filter(t5);
            }
            forEach(t5) {
              this.ops.forEach(t5);
            }
            map(t5) {
              return this.ops.map(t5);
            }
            partition(t5) {
              const e5 = [], n5 = [];
              return this.forEach((r4) => {
                (t5(r4) ? e5 : n5).push(r4);
              }), [e5, n5];
            }
            reduce(t5, e5) {
              return this.ops.reduce(t5, e5);
            }
            changeLength() {
              return this.reduce((t5, e5) => e5.insert ? t5 + l3.default.length(e5) : e5.delete ? t5 - e5.delete : t5, 0);
            }
            length() {
              return this.reduce((t5, e5) => t5 + l3.default.length(e5), 0);
            }
            slice(t5 = 0, e5 = 1 / 0) {
              const n5 = [], r4 = new a3.default(this.ops);
              let s4 = 0;
              for (; s4 < e5 && r4.hasNext(); ) {
                let i4;
                s4 < t5 ? i4 = r4.next(t5 - s4) : (i4 = r4.next(e5 - s4), n5.push(i4)), s4 += l3.default.length(i4);
              }
              return new h3(n5);
            }
            compose(t5) {
              const e5 = new a3.default(this.ops), n5 = new a3.default(t5.ops), r4 = [], s4 = n5.peek();
              if (null != s4 && "number" == typeof s4.retain && null == s4.attributes) {
                let t6 = s4.retain;
                for (; "insert" === e5.peekType() && e5.peekLength() <= t6; )
                  t6 -= e5.peekLength(), r4.push(e5.next());
                s4.retain - t6 > 0 && n5.next(s4.retain - t6);
              }
              const l4 = new h3(r4);
              for (; e5.hasNext() || n5.hasNext(); )
                if ("insert" === n5.peekType())
                  l4.push(n5.next());
                else if ("delete" === e5.peekType())
                  l4.push(e5.next());
                else {
                  const t6 = Math.min(e5.peekLength(), n5.peekLength()), r5 = e5.next(t6), s5 = n5.next(t6);
                  if (s5.retain) {
                    const a4 = {};
                    if ("number" == typeof r5.retain)
                      a4.retain = "number" == typeof s5.retain ? t6 : s5.retain;
                    else if ("number" == typeof s5.retain)
                      null == r5.retain ? a4.insert = r5.insert : a4.retain = r5.retain;
                    else {
                      const t7 = null == r5.retain ? "insert" : "retain", [e6, n6, i4] = u3(r5[t7], s5.retain), o4 = h3.getHandler(e6);
                      a4[t7] = { [e6]: o4.compose(n6, i4, "retain" === t7) };
                    }
                    const c4 = o3.default.compose(r5.attributes, s5.attributes, "number" == typeof r5.retain);
                    if (c4 && (a4.attributes = c4), l4.push(a4), !n5.hasNext() && i3(l4.ops[l4.ops.length - 1], a4)) {
                      const t7 = new h3(e5.rest());
                      return l4.concat(t7).chop();
                    }
                  } else
                    "number" == typeof s5.delete && ("number" == typeof r5.retain || "object" == typeof r5.retain && null !== r5.retain) && l4.push(s5);
                }
              return l4.chop();
            }
            concat(t5) {
              const e5 = new h3(this.ops.slice());
              return t5.ops.length > 0 && (e5.push(t5.ops[0]), e5.ops = e5.ops.concat(t5.ops.slice(1))), e5;
            }
            diff(t5, e5) {
              if (this.ops === t5.ops)
                return new h3();
              const n5 = [this, t5].map((e6) => e6.map((n6) => {
                if (null != n6.insert)
                  return "string" == typeof n6.insert ? n6.insert : c3;
                throw new Error("diff() called " + (e6 === t5 ? "on" : "with") + " non-document");
              }).join("")), s4 = new h3(), l4 = r3(n5[0], n5[1], e5, true), u4 = new a3.default(this.ops), d3 = new a3.default(t5.ops);
              return l4.forEach((t6) => {
                let e6 = t6[1].length;
                for (; e6 > 0; ) {
                  let n6 = 0;
                  switch (t6[0]) {
                    case r3.INSERT:
                      n6 = Math.min(d3.peekLength(), e6), s4.push(d3.next(n6));
                      break;
                    case r3.DELETE:
                      n6 = Math.min(e6, u4.peekLength()), u4.next(n6), s4.delete(n6);
                      break;
                    case r3.EQUAL:
                      n6 = Math.min(u4.peekLength(), d3.peekLength(), e6);
                      const t7 = u4.next(n6), l5 = d3.next(n6);
                      i3(t7.insert, l5.insert) ? s4.retain(n6, o3.default.diff(t7.attributes, l5.attributes)) : s4.push(l5).delete(n6);
                  }
                  e6 -= n6;
                }
              }), s4.chop();
            }
            eachLine(t5, e5 = "\n") {
              const n5 = new a3.default(this.ops);
              let r4 = new h3(), s4 = 0;
              for (; n5.hasNext(); ) {
                if ("insert" !== n5.peekType())
                  return;
                const i4 = n5.peek(), o4 = l3.default.length(i4) - n5.peekLength(), a4 = "string" == typeof i4.insert ? i4.insert.indexOf(e5, o4) - o4 : -1;
                if (a4 < 0)
                  r4.push(n5.next());
                else if (a4 > 0)
                  r4.push(n5.next(a4));
                else {
                  if (false === t5(r4, n5.next(1).attributes || {}, s4))
                    return;
                  s4 += 1, r4 = new h3();
                }
              }
              r4.length() > 0 && t5(r4, {}, s4);
            }
            invert(t5) {
              const e5 = new h3();
              return this.reduce((n5, r4) => {
                if (r4.insert)
                  e5.delete(l3.default.length(r4));
                else {
                  if ("number" == typeof r4.retain && null == r4.attributes)
                    return e5.retain(r4.retain), n5 + r4.retain;
                  if (r4.delete || "number" == typeof r4.retain) {
                    const s4 = r4.delete || r4.retain;
                    return t5.slice(n5, n5 + s4).forEach((t6) => {
                      r4.delete ? e5.push(t6) : r4.retain && r4.attributes && e5.retain(l3.default.length(t6), o3.default.invert(r4.attributes, t6.attributes));
                    }), n5 + s4;
                  }
                  if ("object" == typeof r4.retain && null !== r4.retain) {
                    const s4 = t5.slice(n5, n5 + 1), i4 = new a3.default(s4.ops).next(), [l4, c4, d3] = u3(r4.retain, i4.insert), f3 = h3.getHandler(l4);
                    return e5.retain({ [l4]: f3.invert(c4, d3) }, o3.default.invert(r4.attributes, i4.attributes)), n5 + 1;
                  }
                }
                return n5;
              }, 0), e5.chop();
            }
            transform(t5, e5 = false) {
              if (e5 = !!e5, "number" == typeof t5)
                return this.transformPosition(t5, e5);
              const n5 = t5, r4 = new a3.default(this.ops), s4 = new a3.default(n5.ops), i4 = new h3();
              for (; r4.hasNext() || s4.hasNext(); )
                if ("insert" !== r4.peekType() || !e5 && "insert" === s4.peekType())
                  if ("insert" === s4.peekType())
                    i4.push(s4.next());
                  else {
                    const t6 = Math.min(r4.peekLength(), s4.peekLength()), n6 = r4.next(t6), l4 = s4.next(t6);
                    if (n6.delete)
                      continue;
                    if (l4.delete)
                      i4.push(l4);
                    else {
                      const r5 = n6.retain, s5 = l4.retain;
                      let a4 = "object" == typeof s5 && null !== s5 ? s5 : t6;
                      if ("object" == typeof r5 && null !== r5 && "object" == typeof s5 && null !== s5) {
                        const t7 = Object.keys(r5)[0];
                        if (t7 === Object.keys(s5)[0]) {
                          const n7 = h3.getHandler(t7);
                          n7 && (a4 = { [t7]: n7.transform(r5[t7], s5[t7], e5) });
                        }
                      }
                      i4.retain(a4, o3.default.transform(n6.attributes, l4.attributes, e5));
                    }
                  }
                else
                  i4.retain(l3.default.length(r4.next()));
              return i4.chop();
            }
            transformPosition(t5, e5 = false) {
              e5 = !!e5;
              const n5 = new a3.default(this.ops);
              let r4 = 0;
              for (; n5.hasNext() && r4 <= t5; ) {
                const s4 = n5.peekLength(), i4 = n5.peekType();
                n5.next(), "delete" !== i4 ? ("insert" === i4 && (r4 < t5 || !e5) && (t5 += s4), r4 += s4) : t5 -= Math.min(s4, t5 - r4);
              }
              return t5;
            }
          }
          h3.Op = l3.default, h3.OpIterator = a3.default, h3.AttributeMap = o3.default, h3.handlers = {}, e4.default = h3, t4.exports = h3, t4.exports.default = h3;
        }, 759: (t4, e4) => {
          "use strict";
          var n4;
          Object.defineProperty(e4, "__esModule", { value: true }), function(t5) {
            t5.length = function(t6) {
              return "number" == typeof t6.delete ? t6.delete : "number" == typeof t6.retain ? t6.retain : "object" == typeof t6.retain && null !== t6.retain ? 1 : "string" == typeof t6.insert ? t6.insert.length : 1;
            };
          }(n4 || (n4 = {})), e4.default = n4;
        }, 317: (t4, e4, n4) => {
          "use strict";
          Object.defineProperty(e4, "__esModule", { value: true });
          const r3 = n4(759);
          e4.default = class {
            constructor(t5) {
              this.ops = t5, this.index = 0, this.offset = 0;
            }
            hasNext() {
              return this.peekLength() < 1 / 0;
            }
            next(t5) {
              t5 || (t5 = 1 / 0);
              const e5 = this.ops[this.index];
              if (e5) {
                const n5 = this.offset, s3 = r3.default.length(e5);
                if (t5 >= s3 - n5 ? (t5 = s3 - n5, this.index += 1, this.offset = 0) : this.offset += t5, "number" == typeof e5.delete)
                  return { delete: t5 };
                {
                  const r4 = {};
                  return e5.attributes && (r4.attributes = e5.attributes), "number" == typeof e5.retain ? r4.retain = t5 : "object" == typeof e5.retain && null !== e5.retain ? r4.retain = e5.retain : "string" == typeof e5.insert ? r4.insert = e5.insert.substr(n5, t5) : r4.insert = e5.insert, r4;
                }
              }
              return { retain: 1 / 0 };
            }
            peek() {
              return this.ops[this.index];
            }
            peekLength() {
              return this.ops[this.index] ? r3.default.length(this.ops[this.index]) - this.offset : 1 / 0;
            }
            peekType() {
              const t5 = this.ops[this.index];
              return t5 ? "number" == typeof t5.delete ? "delete" : "number" == typeof t5.retain || "object" == typeof t5.retain && null !== t5.retain ? "retain" : "insert" : "retain";
            }
            rest() {
              if (this.hasNext()) {
                if (0 === this.offset)
                  return this.ops.slice(this.index);
                {
                  const t5 = this.offset, e5 = this.index, n5 = this.next(), r4 = this.ops.slice(this.index);
                  return this.offset = t5, this.index = e5, [n5].concat(r4);
                }
              }
              return [];
            }
          };
        }, 968: (t4, e4, n4) => {
          var r3 = n4(64);
          "string" == typeof r3 && (r3 = [[t4.id, r3, ""]]);
          var s3 = { hmr: true, transform: void 0 };
          n4(27)(r3, s3);
          r3.locals && (t4.exports = r3.locals);
        }, 27: (t4, e4, n4) => {
          var r3, s3, i3 = {}, o3 = (r3 = /* @__PURE__ */ __name(function() {
            return window && document && document.all && !window.atob;
          }, "r"), function() {
            return void 0 === s3 && (s3 = r3.apply(this, arguments)), s3;
          }), l3 = /* @__PURE__ */ function(t5) {
            var e5 = {};
            return function(n5) {
              if (void 0 === e5[n5]) {
                var r4 = t5.call(this, n5);
                if (r4 instanceof window.HTMLIFrameElement)
                  try {
                    r4 = r4.contentDocument.head;
                  } catch (t6) {
                    r4 = null;
                  }
                e5[n5] = r4;
              }
              return e5[n5];
            };
          }(function(t5) {
            return document.querySelector(t5);
          }), a3 = null, c3 = 0, u3 = [], h3 = n4(874);
          function d3(t5, e5) {
            for (var n5 = 0; n5 < t5.length; n5++) {
              var r4 = t5[n5], s4 = i3[r4.id];
              if (s4) {
                s4.refs++;
                for (var o4 = 0; o4 < s4.parts.length; o4++)
                  s4.parts[o4](r4.parts[o4]);
                for (; o4 < r4.parts.length; o4++)
                  s4.parts.push(y3(r4.parts[o4], e5));
              } else {
                var l4 = [];
                for (o4 = 0; o4 < r4.parts.length; o4++)
                  l4.push(y3(r4.parts[o4], e5));
                i3[r4.id] = { id: r4.id, refs: 1, parts: l4 };
              }
            }
          }
          __name(d3, "d");
          function f3(t5, e5) {
            for (var n5 = [], r4 = {}, s4 = 0; s4 < t5.length; s4++) {
              var i4 = t5[s4], o4 = e5.base ? i4[0] + e5.base : i4[0], l4 = { css: i4[1], media: i4[2], sourceMap: i4[3] };
              r4[o4] ? r4[o4].parts.push(l4) : n5.push(r4[o4] = { id: o4, parts: [l4] });
            }
            return n5;
          }
          __name(f3, "f");
          function p3(t5, e5) {
            var n5 = l3(t5.insertInto);
            if (!n5)
              throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");
            var r4 = u3[u3.length - 1];
            if ("top" === t5.insertAt)
              r4 ? r4.nextSibling ? n5.insertBefore(e5, r4.nextSibling) : n5.appendChild(e5) : n5.insertBefore(e5, n5.firstChild), u3.push(e5);
            else if ("bottom" === t5.insertAt)
              n5.appendChild(e5);
            else {
              if ("object" != typeof t5.insertAt || !t5.insertAt.before)
                throw new Error("[Style Loader]\n\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\n Must be 'top', 'bottom', or Object.\n (https://github.com/webpack-contrib/style-loader#insertat)\n");
              var s4 = l3(t5.insertInto + " " + t5.insertAt.before);
              n5.insertBefore(e5, s4);
            }
          }
          __name(p3, "p");
          function g3(t5) {
            if (null === t5.parentNode)
              return false;
            t5.parentNode.removeChild(t5);
            var e5 = u3.indexOf(t5);
            e5 >= 0 && u3.splice(e5, 1);
          }
          __name(g3, "g");
          function m3(t5) {
            var e5 = document.createElement("style");
            return t5.attrs.type = "text/css", b3(e5, t5.attrs), p3(t5, e5), e5;
          }
          __name(m3, "m");
          function b3(t5, e5) {
            Object.keys(e5).forEach(function(n5) {
              t5.setAttribute(n5, e5[n5]);
            });
          }
          __name(b3, "b");
          function y3(t5, e5) {
            var n5, r4, s4, i4;
            if (e5.transform && t5.css) {
              if (!(i4 = e5.transform(t5.css)))
                return function() {
                };
              t5.css = i4;
            }
            if (e5.singleton) {
              var o4 = c3++;
              n5 = a3 || (a3 = m3(e5)), r4 = N3.bind(null, n5, o4, false), s4 = N3.bind(null, n5, o4, true);
            } else
              t5.sourceMap && "function" == typeof URL && "function" == typeof URL.createObjectURL && "function" == typeof URL.revokeObjectURL && "function" == typeof Blob && "function" == typeof btoa ? (n5 = function(t6) {
                var e6 = document.createElement("link");
                return t6.attrs.type = "text/css", t6.attrs.rel = "stylesheet", b3(e6, t6.attrs), p3(t6, e6), e6;
              }(e5), r4 = E3.bind(null, n5, e5), s4 = /* @__PURE__ */ __name(function() {
                g3(n5), n5.href && URL.revokeObjectURL(n5.href);
              }, "s")) : (n5 = m3(e5), r4 = w3.bind(null, n5), s4 = /* @__PURE__ */ __name(function() {
                g3(n5);
              }, "s"));
            return r4(t5), function(e6) {
              if (e6) {
                if (e6.css === t5.css && e6.media === t5.media && e6.sourceMap === t5.sourceMap)
                  return;
                r4(t5 = e6);
              } else
                s4();
            };
          }
          __name(y3, "y");
          t4.exports = function(t5, e5) {
            if ("undefined" != typeof DEBUG && DEBUG && "object" != typeof document)
              throw new Error("The style-loader cannot be used in a non-browser environment");
            (e5 = e5 || {}).attrs = "object" == typeof e5.attrs ? e5.attrs : {}, e5.singleton || "boolean" == typeof e5.singleton || (e5.singleton = o3()), e5.insertInto || (e5.insertInto = "head"), e5.insertAt || (e5.insertAt = "bottom");
            var n5 = f3(t5, e5);
            return d3(n5, e5), function(t6) {
              for (var r4 = [], s4 = 0; s4 < n5.length; s4++) {
                var o4 = n5[s4];
                (l4 = i3[o4.id]).refs--, r4.push(l4);
              }
              t6 && d3(f3(t6, e5), e5);
              for (s4 = 0; s4 < r4.length; s4++) {
                var l4;
                if (0 === (l4 = r4[s4]).refs) {
                  for (var a4 = 0; a4 < l4.parts.length; a4++)
                    l4.parts[a4]();
                  delete i3[l4.id];
                }
              }
            };
          };
          var v3, x3 = (v3 = [], function(t5, e5) {
            return v3[t5] = e5, v3.filter(Boolean).join("\n");
          });
          function N3(t5, e5, n5, r4) {
            var s4 = n5 ? "" : r4.css;
            if (t5.styleSheet)
              t5.styleSheet.cssText = x3(e5, s4);
            else {
              var i4 = document.createTextNode(s4), o4 = t5.childNodes;
              o4[e5] && t5.removeChild(o4[e5]), o4.length ? t5.insertBefore(i4, o4[e5]) : t5.appendChild(i4);
            }
          }
          __name(N3, "N");
          function w3(t5, e5) {
            var n5 = e5.css, r4 = e5.media;
            if (r4 && t5.setAttribute("media", r4), t5.styleSheet)
              t5.styleSheet.cssText = n5;
            else {
              for (; t5.firstChild; )
                t5.removeChild(t5.firstChild);
              t5.appendChild(document.createTextNode(n5));
            }
          }
          __name(w3, "w");
          function E3(t5, e5, n5) {
            var r4 = n5.css, s4 = n5.sourceMap, i4 = void 0 === e5.convertToAbsoluteUrls && s4;
            (e5.convertToAbsoluteUrls || i4) && (r4 = h3(r4)), s4 && (r4 += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(s4)))) + " */");
            var o4 = new Blob([r4], { type: "text/css" }), l4 = t5.href;
            t5.href = URL.createObjectURL(o4), l4 && URL.revokeObjectURL(l4);
          }
          __name(E3, "E");
        }, 874: (t4) => {
          t4.exports = function(t5) {
            var e4 = "undefined" != typeof window && window.location;
            if (!e4)
              throw new Error("fixUrls requires window.location");
            if (!t5 || "string" != typeof t5)
              return t5;
            var n4 = e4.protocol + "//" + e4.host, r3 = n4 + e4.pathname.replace(/\/[^\/]*$/, "/");
            return t5.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi, function(t6, e5) {
              var s3, i3 = e5.trim().replace(/^"(.*)"$/, function(t7, e6) {
                return e6;
              }).replace(/^'(.*)'$/, function(t7, e6) {
                return e6;
              });
              return /^(#|data:|http:\/\/|https:\/\/|file:\/\/\/)/i.test(i3) ? t6 : (s3 = 0 === i3.indexOf("//") ? i3 : 0 === i3.indexOf("/") ? n4 + i3 : r3 + i3.replace(/^\.\//, ""), "url(" + JSON.stringify(s3) + ")");
            });
          };
        }, 676: (t4, e4) => {
          "use strict";
          Object.defineProperty(e4, "__esModule", { value: true }), e4.FormatHTMLStringIndentation = function(t5, e5) {
            for (var n4 = " ".repeat(2), r3 = 0, s3 = "\n", i3 = null, o3 = null, l3 = null, a3 = "", c3 = 0; c3 <= t5.length; c3++) {
              i3 = o3, o3 = t5.substr(c3, 1), l3 = t5.substr(c3 + 1, 1);
              var u3 = "<br>" === t5.substr(c3, 4), h3 = "<" === o3 && "/" !== l3 && !u3, d3 = "<" === o3 && "/" === l3 && !u3, f3 = ">" === i3 && "<" !== o3 && r3 > 0, p3 = !u3 && !h3 && !d3 && f3 && "" === t5.substr(c3, t5.substr(c3).indexOf("<")).trim();
              u3 && (a3 += s3, r3--, c3 += 4), h3 ? (a3 += s3 + n4.repeat(r3), r3++) : d3 ? (--r3 < 0 && (r3 = 0), a3 += s3 + n4.repeat(r3)) : (" " === o3 && " " === l3 || o3 === s3 && "" === t5.substr(c3, t5.substr(c3).indexOf("<")).trim()) && (o3 = ""), f3 && !p3 && (a3 += s3 + n4.repeat(r3)), a3 += o3;
            }
            return e5.log("formatHTML", { before: t5, after: a3 }), a3;
          };
        }, 795: (t4, e4) => {
          "use strict";
          function n4(t5) {
            return t5.replace(/\s+/g, " ").trim();
          }
          __name(n4, "n");
          function r3(t5) {
            return t5.replace(/<br([\s]*[\/]?>)/g, "<p> </p>");
          }
          __name(r3, "r");
          function s3(t5) {
            return t5.replace(/<p><\/p>/g, "<p> </p>");
          }
          __name(s3, "s");
          function i3(t5) {
            return t5.replace(/(<(?!\/)[\w=\."'\s]*>) /g, "$1");
          }
          __name(i3, "i");
          function o3(t5) {
            return t5.replace(/ (<\/[\w]+>)/g, "$1");
          }
          __name(o3, "o");
          function l3(t5, e5) {
            return t5.reduce(function(t6, e6) {
              return e6(t6);
            }, e5);
          }
          __name(l3, "l");
          Object.defineProperty(e4, "__esModule", { value: true }), e4.OutputHTMLParser = function(t5) {
            return l3([n4, i3, o3, r3, s3], t5);
          }, e4.ConvertMultipleSpacesToSingle = n4, e4.PreserveNewlinesBr = r3, e4.PreserveNewlinesPTags = s3, e4.FixTagSpaceOpenTag = i3, e4.FixTagSpaceCloseTag = o3, e4.Compose = l3;
        }, 614: (t4, e4) => {
          "use strict";
          Object.defineProperty(e4, "__esModule", { value: true }), e4.QuillHtmlLogger = void 0;
          var n4 = function() {
            function t5() {
              this.debug = false;
            }
            __name(t5, "t");
            return t5.prototype.setDebug = function(t6) {
              this.debug = t6;
            }, t5.prototype.prefixString = function() {
              return "</> quill-html-edit-button: ";
            }, Object.defineProperty(t5.prototype, "log", { get: function() {
              return this.debug ? console.log.bind(console, this.prefixString()) : function() {
                for (var t6 = [], e5 = 0; e5 < arguments.length; e5++)
                  t6[e5] = arguments[e5];
              };
            }, enumerable: false, configurable: true }), t5;
          }();
          e4.QuillHtmlLogger = n4;
        }, 190: function(t4, e4, n4) {
          "use strict";
          var r3 = this && this.__assign || function() {
            return r3 = Object.assign || function(t5) {
              for (var e5, n5 = 1, r4 = arguments.length; n5 < r4; n5++)
                for (var s4 in e5 = arguments[n5])
                  Object.prototype.hasOwnProperty.call(e5, s4) && (t5[s4] = e5[s4]);
              return t5;
            }, r3.apply(this, arguments);
          }, s3 = this && this.__importDefault || function(t5) {
            return t5 && t5.__esModule ? t5 : { default: t5 };
          };
          Object.defineProperty(e4, "__esModule", { value: true }), e4.htmlEditButton = void 0;
          var i3 = n4(614);
          n4(968);
          var o3 = s3(n4(429)), l3 = n4(795), a3 = n4(676);
          function c3(t5) {
            return document.createElement(t5);
          }
          __name(c3, "c");
          function u3(t5, e5, n5) {
            return t5.setAttribute(e5, n5);
          }
          __name(u3, "u");
          var h3 = new i3.QuillHtmlLogger(), d3 = /* @__PURE__ */ __name(function(t5, e5) {
            var n5 = e5 || {}, s4 = !(!n5 || !n5.debug);
            h3.setDebug(s4), h3.log("logging enabled");
            var i4 = t5.getModule("toolbar");
            if (!i4)
              throw new Error('quill.htmlEditButton requires the "toolbar" module to be included too');
            var d4 = i4.container, f3 = c3("span");
            u3(f3, "class", "ql-formats");
            var p3 = c3("button");
            p3.innerHTML = n5.buttonHTML || "&lt;&gt;", p3.title = n5.buttonTitle || "Show HTML source", p3.type = "button";
            var g3 = /* @__PURE__ */ __name(function(e6) {
              t5.clipboard.dangerouslyPasteHTML(e6);
            }, "g");
            p3.onclick = function(e6) {
              e6.preventDefault(), function(t6, e7, n6) {
                var s5 = t6.container.querySelector(".ql-editor").innerHTML, i5 = c3("div"), d5 = c3("div"), f4 = e7.msg || `Edit HTML here, when you click "OK" the quill editor's contents will be replaced`, p4 = e7.cancelText || "Cancel", g4 = e7.okText || "Ok", m3 = false !== e7.closeOnClickOverlay;
                u3(d5, "class", "ql-html-overlayContainer"), u3(i5, "class", "ql-html-popupContainer");
                var b3 = c3("span");
                u3(b3, "class", "ql-html-popupTitle"), b3.innerText = f4;
                var y3 = c3("div");
                y3.appendChild(b3), u3(y3, "class", "ql-html-textContainer");
                var v3 = c3("pre");
                u3(v3, "data-language", "xml"), v3.innerText = (0, a3.FormatHTMLStringIndentation)(s5, h3);
                var x3 = c3("div");
                u3(x3, "class", "ql-html-textArea");
                var N3 = c3("button");
                N3.innerHTML = p4, u3(N3, "class", "ql-html-buttonCancel");
                var w3 = c3("button");
                w3.innerHTML = g4, u3(w3, "class", "ql-html-buttonOk");
                var E3 = c3("div");
                u3(E3, "class", "ql-html-buttonGroup");
                var A3 = document.querySelector(e7.prependSelector);
                E3.appendChild(N3), E3.appendChild(w3), x3.appendChild(v3), y3.appendChild(x3), y3.appendChild(E3), i5.appendChild(y3), d5.appendChild(i5), A3 ? A3.prepend(d5) : document.body.appendChild(d5);
                var q3 = e7 && e7.editorModules, k3 = q3 && Object.keys(q3).length ? q3 : {}, _2 = new o3.default(x3, { modules: r3({ syntax: e7.syntax }, k3) });
                N3.onclick = function() {
                  A3 ? A3.removeChild(d5) : document.body.removeChild(d5);
                }, m3 && (d5.onclick = N3.onclick), i5.onclick = function(t7) {
                  t7.preventDefault(), t7.stopPropagation();
                }, w3.onclick = function() {
                  var t7 = _2.container.querySelector(".ql-editor").innerText, e8 = (0, l3.OutputHTMLParser)(t7);
                  h3.log("OutputHTMLParser", { htmlInputFromPopup: t7, htmlOutputFormatted: e8 }), n6(e8), A3 ? A3.removeChild(d5) : document.body.removeChild(d5);
                };
              }(t5, n5, g3);
            }, f3.appendChild(p3), null == d4 || d4.appendChild(f3);
          }, "d");
          e4.htmlEditButton = d3, window.htmlEditButton = d3, e4.default = d3;
        }, 429: (t4, e4, n4) => {
          "use strict";
          n4.r(e4), n4.d(e4, { Module: () => xs, Parchment: () => r3, Range: () => cs2, default: () => tl });
          var r3 = {};
          n4.r(r3), n4.d(r3, { Attributor: () => ze, AttributorStore: () => Ge, BlockBlot: () => an2, ClassAttributor: () => Ke, ContainerBlot: () => un, EmbedBlot: () => hn, InlineBlot: () => on2, LeafBlot: () => Je, ParentBlot: () => rn, Registry: () => $e, Scope: () => Pe, ScrollBlot: () => pn, StyleAttributor: () => Ze, TextBlot: () => mn });
          const s3 = /* @__PURE__ */ __name(function() {
            this.__data__ = [], this.size = 0;
          }, "s");
          const i3 = /* @__PURE__ */ __name(function(t5, e5) {
            return t5 === e5 || t5 != t5 && e5 != e5;
          }, "i");
          const o3 = /* @__PURE__ */ __name(function(t5, e5) {
            for (var n5 = t5.length; n5--; )
              if (i3(t5[n5][0], e5))
                return n5;
            return -1;
          }, "o");
          var l3 = Array.prototype.splice;
          const a3 = /* @__PURE__ */ __name(function(t5) {
            var e5 = this.__data__, n5 = o3(e5, t5);
            return !(n5 < 0) && (n5 == e5.length - 1 ? e5.pop() : l3.call(e5, n5, 1), --this.size, true);
          }, "a");
          const c3 = /* @__PURE__ */ __name(function(t5) {
            var e5 = this.__data__, n5 = o3(e5, t5);
            return n5 < 0 ? void 0 : e5[n5][1];
          }, "c");
          const u3 = /* @__PURE__ */ __name(function(t5) {
            return o3(this.__data__, t5) > -1;
          }, "u");
          const h3 = /* @__PURE__ */ __name(function(t5, e5) {
            var n5 = this.__data__, r4 = o3(n5, t5);
            return r4 < 0 ? (++this.size, n5.push([t5, e5])) : n5[r4][1] = e5, this;
          }, "h");
          function d3(t5) {
            var e5 = -1, n5 = null == t5 ? 0 : t5.length;
            for (this.clear(); ++e5 < n5; ) {
              var r4 = t5[e5];
              this.set(r4[0], r4[1]);
            }
          }
          __name(d3, "d");
          d3.prototype.clear = s3, d3.prototype.delete = a3, d3.prototype.get = c3, d3.prototype.has = u3, d3.prototype.set = h3;
          const f3 = d3;
          const p3 = /* @__PURE__ */ __name(function() {
            this.__data__ = new f3(), this.size = 0;
          }, "p");
          const g3 = /* @__PURE__ */ __name(function(t5) {
            var e5 = this.__data__, n5 = e5.delete(t5);
            return this.size = e5.size, n5;
          }, "g");
          const m3 = /* @__PURE__ */ __name(function(t5) {
            return this.__data__.get(t5);
          }, "m");
          const b3 = /* @__PURE__ */ __name(function(t5) {
            return this.__data__.has(t5);
          }, "b");
          const y3 = "object" == typeof global && global && global.Object === Object && global;
          var v3 = "object" == typeof self && self && self.Object === Object && self;
          const x3 = y3 || v3 || Function("return this")();
          const N3 = x3.Symbol;
          var w3 = Object.prototype, E3 = w3.hasOwnProperty, A3 = w3.toString, q3 = N3 ? N3.toStringTag : void 0;
          const k3 = /* @__PURE__ */ __name(function(t5) {
            var e5 = E3.call(t5, q3), n5 = t5[q3];
            try {
              t5[q3] = void 0;
              var r4 = true;
            } catch (t6) {
            }
            var s4 = A3.call(t5);
            return r4 && (e5 ? t5[q3] = n5 : delete t5[q3]), s4;
          }, "k");
          var _2 = Object.prototype.toString;
          const L5 = /* @__PURE__ */ __name(function(t5) {
            return _2.call(t5);
          }, "L");
          var O3 = N3 ? N3.toStringTag : void 0;
          const T3 = /* @__PURE__ */ __name(function(t5) {
            return null == t5 ? void 0 === t5 ? "[object Undefined]" : "[object Null]" : O3 && O3 in Object(t5) ? k3(t5) : L5(t5);
          }, "T");
          const S3 = /* @__PURE__ */ __name(function(t5) {
            var e5 = typeof t5;
            return null != t5 && ("object" == e5 || "function" == e5);
          }, "S");
          const C3 = /* @__PURE__ */ __name(function(t5) {
            if (!S3(t5))
              return false;
            var e5 = T3(t5);
            return "[object Function]" == e5 || "[object GeneratorFunction]" == e5 || "[object AsyncFunction]" == e5 || "[object Proxy]" == e5;
          }, "C");
          const j3 = x3["__core-js_shared__"];
          var R3, I3 = (R3 = /[^.]+$/.exec(j3 && j3.keys && j3.keys.IE_PROTO || "")) ? "Symbol(src)_1." + R3 : "";
          const M3 = /* @__PURE__ */ __name(function(t5) {
            return !!I3 && I3 in t5;
          }, "M");
          var B3 = Function.prototype.toString;
          const U3 = /* @__PURE__ */ __name(function(t5) {
            if (null != t5) {
              try {
                return B3.call(t5);
              } catch (t6) {
              }
              try {
                return t5 + "";
              } catch (t6) {
              }
            }
            return "";
          }, "U");
          var D3 = /^\[object .+?Constructor\]$/, P3 = Function.prototype, z3 = Object.prototype, H3 = P3.toString, F3 = z3.hasOwnProperty, $2 = RegExp("^" + H3.call(F3).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
          const V3 = /* @__PURE__ */ __name(function(t5) {
            return !(!S3(t5) || M3(t5)) && (C3(t5) ? $2 : D3).test(U3(t5));
          }, "V");
          const K3 = /* @__PURE__ */ __name(function(t5, e5) {
            return null == t5 ? void 0 : t5[e5];
          }, "K");
          const W3 = /* @__PURE__ */ __name(function(t5, e5) {
            var n5 = K3(t5, e5);
            return V3(n5) ? n5 : void 0;
          }, "W");
          const Z2 = W3(x3, "Map");
          const G3 = W3(Object, "create");
          const X3 = /* @__PURE__ */ __name(function() {
            this.__data__ = G3 ? G3(null) : {}, this.size = 0;
          }, "X");
          const Q3 = /* @__PURE__ */ __name(function(t5) {
            var e5 = this.has(t5) && delete this.__data__[t5];
            return this.size -= e5 ? 1 : 0, e5;
          }, "Q");
          var Y3 = Object.prototype.hasOwnProperty;
          const J3 = /* @__PURE__ */ __name(function(t5) {
            var e5 = this.__data__;
            if (G3) {
              var n5 = e5[t5];
              return "__lodash_hash_undefined__" === n5 ? void 0 : n5;
            }
            return Y3.call(e5, t5) ? e5[t5] : void 0;
          }, "J");
          var tt = Object.prototype.hasOwnProperty;
          const et = /* @__PURE__ */ __name(function(t5) {
            var e5 = this.__data__;
            return G3 ? void 0 !== e5[t5] : tt.call(e5, t5);
          }, "et");
          const nt = /* @__PURE__ */ __name(function(t5, e5) {
            var n5 = this.__data__;
            return this.size += this.has(t5) ? 0 : 1, n5[t5] = G3 && void 0 === e5 ? "__lodash_hash_undefined__" : e5, this;
          }, "nt");
          function rt(t5) {
            var e5 = -1, n5 = null == t5 ? 0 : t5.length;
            for (this.clear(); ++e5 < n5; ) {
              var r4 = t5[e5];
              this.set(r4[0], r4[1]);
            }
          }
          __name(rt, "rt");
          rt.prototype.clear = X3, rt.prototype.delete = Q3, rt.prototype.get = J3, rt.prototype.has = et, rt.prototype.set = nt;
          const st = rt;
          const it = /* @__PURE__ */ __name(function() {
            this.size = 0, this.__data__ = { hash: new st(), map: new (Z2 || f3)(), string: new st() };
          }, "it");
          const ot = /* @__PURE__ */ __name(function(t5) {
            var e5 = typeof t5;
            return "string" == e5 || "number" == e5 || "symbol" == e5 || "boolean" == e5 ? "__proto__" !== t5 : null === t5;
          }, "ot");
          const lt = /* @__PURE__ */ __name(function(t5, e5) {
            var n5 = t5.__data__;
            return ot(e5) ? n5["string" == typeof e5 ? "string" : "hash"] : n5.map;
          }, "lt");
          const at2 = /* @__PURE__ */ __name(function(t5) {
            var e5 = lt(this, t5).delete(t5);
            return this.size -= e5 ? 1 : 0, e5;
          }, "at");
          const ct2 = /* @__PURE__ */ __name(function(t5) {
            return lt(this, t5).get(t5);
          }, "ct");
          const ut = /* @__PURE__ */ __name(function(t5) {
            return lt(this, t5).has(t5);
          }, "ut");
          const ht = /* @__PURE__ */ __name(function(t5, e5) {
            var n5 = lt(this, t5), r4 = n5.size;
            return n5.set(t5, e5), this.size += n5.size == r4 ? 0 : 1, this;
          }, "ht");
          function dt(t5) {
            var e5 = -1, n5 = null == t5 ? 0 : t5.length;
            for (this.clear(); ++e5 < n5; ) {
              var r4 = t5[e5];
              this.set(r4[0], r4[1]);
            }
          }
          __name(dt, "dt");
          dt.prototype.clear = it, dt.prototype.delete = at2, dt.prototype.get = ct2, dt.prototype.has = ut, dt.prototype.set = ht;
          const ft = dt;
          const pt = /* @__PURE__ */ __name(function(t5, e5) {
            var n5 = this.__data__;
            if (n5 instanceof f3) {
              var r4 = n5.__data__;
              if (!Z2 || r4.length < 199)
                return r4.push([t5, e5]), this.size = ++n5.size, this;
              n5 = this.__data__ = new ft(r4);
            }
            return n5.set(t5, e5), this.size = n5.size, this;
          }, "pt");
          function gt(t5) {
            var e5 = this.__data__ = new f3(t5);
            this.size = e5.size;
          }
          __name(gt, "gt");
          gt.prototype.clear = p3, gt.prototype.delete = g3, gt.prototype.get = m3, gt.prototype.has = b3, gt.prototype.set = pt;
          const mt = gt;
          const bt2 = function() {
            try {
              var t5 = W3(Object, "defineProperty");
              return t5({}, "", {}), t5;
            } catch (t6) {
            }
          }();
          const yt = /* @__PURE__ */ __name(function(t5, e5, n5) {
            "__proto__" == e5 && bt2 ? bt2(t5, e5, { configurable: true, enumerable: true, value: n5, writable: true }) : t5[e5] = n5;
          }, "yt");
          const vt = /* @__PURE__ */ __name(function(t5, e5, n5) {
            (void 0 !== n5 && !i3(t5[e5], n5) || void 0 === n5 && !(e5 in t5)) && yt(t5, e5, n5);
          }, "vt");
          const xt = /* @__PURE__ */ function(t5) {
            return function(e5, n5, r4) {
              for (var s4 = -1, i4 = Object(e5), o4 = r4(e5), l4 = o4.length; l4--; ) {
                var a4 = o4[t5 ? l4 : ++s4];
                if (false === n5(i4[a4], a4, i4))
                  break;
              }
              return e5;
            };
          }();
          var Nt = "object" == typeof exports2 && exports2 && !exports2.nodeType && exports2, wt = Nt && "object" == typeof module2 && module2 && !module2.nodeType && module2, Et = wt && wt.exports === Nt ? x3.Buffer : void 0, At = Et ? Et.allocUnsafe : void 0;
          const qt = /* @__PURE__ */ __name(function(t5, e5) {
            if (e5)
              return t5.slice();
            var n5 = t5.length, r4 = At ? At(n5) : new t5.constructor(n5);
            return t5.copy(r4), r4;
          }, "qt");
          const kt = x3.Uint8Array;
          const _t = /* @__PURE__ */ __name(function(t5) {
            var e5 = new t5.constructor(t5.byteLength);
            return new kt(e5).set(new kt(t5)), e5;
          }, "_t");
          const Lt = /* @__PURE__ */ __name(function(t5, e5) {
            var n5 = e5 ? _t(t5.buffer) : t5.buffer;
            return new t5.constructor(n5, t5.byteOffset, t5.length);
          }, "Lt");
          const Ot = /* @__PURE__ */ __name(function(t5, e5) {
            var n5 = -1, r4 = t5.length;
            for (e5 || (e5 = Array(r4)); ++n5 < r4; )
              e5[n5] = t5[n5];
            return e5;
          }, "Ot");
          var Tt = Object.create;
          const St = /* @__PURE__ */ function() {
            function t5() {
            }
            __name(t5, "t");
            return function(e5) {
              if (!S3(e5))
                return {};
              if (Tt)
                return Tt(e5);
              t5.prototype = e5;
              var n5 = new t5();
              return t5.prototype = void 0, n5;
            };
          }();
          const Ct = /* @__PURE__ */ __name(function(t5, e5) {
            return function(n5) {
              return t5(e5(n5));
            };
          }, "Ct");
          const jt = Ct(Object.getPrototypeOf, Object);
          var Rt = Object.prototype;
          const It = /* @__PURE__ */ __name(function(t5) {
            var e5 = t5 && t5.constructor;
            return t5 === ("function" == typeof e5 && e5.prototype || Rt);
          }, "It");
          const Mt = /* @__PURE__ */ __name(function(t5) {
            return "function" != typeof t5.constructor || It(t5) ? {} : St(jt(t5));
          }, "Mt");
          const Bt = /* @__PURE__ */ __name(function(t5) {
            return null != t5 && "object" == typeof t5;
          }, "Bt");
          const Ut = /* @__PURE__ */ __name(function(t5) {
            return Bt(t5) && "[object Arguments]" == T3(t5);
          }, "Ut");
          var Dt = Object.prototype, Pt = Dt.hasOwnProperty, zt = Dt.propertyIsEnumerable;
          const Ht = Ut(/* @__PURE__ */ function() {
            return arguments;
          }()) ? Ut : function(t5) {
            return Bt(t5) && Pt.call(t5, "callee") && !zt.call(t5, "callee");
          };
          const Ft = Array.isArray;
          const $t = /* @__PURE__ */ __name(function(t5) {
            return "number" == typeof t5 && t5 > -1 && t5 % 1 == 0 && t5 <= 9007199254740991;
          }, "$t");
          const Vt = /* @__PURE__ */ __name(function(t5) {
            return null != t5 && $t(t5.length) && !C3(t5);
          }, "Vt");
          const Kt = /* @__PURE__ */ __name(function(t5) {
            return Bt(t5) && Vt(t5);
          }, "Kt");
          const Wt = /* @__PURE__ */ __name(function() {
            return false;
          }, "Wt");
          var Zt = "object" == typeof exports2 && exports2 && !exports2.nodeType && exports2, Gt = Zt && "object" == typeof module2 && module2 && !module2.nodeType && module2, Xt = Gt && Gt.exports === Zt ? x3.Buffer : void 0;
          const Qt = (Xt ? Xt.isBuffer : void 0) || Wt;
          var Yt = Function.prototype, Jt = Object.prototype, te = Yt.toString, ee = Jt.hasOwnProperty, ne = te.call(Object);
          const re = /* @__PURE__ */ __name(function(t5) {
            if (!Bt(t5) || "[object Object]" != T3(t5))
              return false;
            var e5 = jt(t5);
            if (null === e5)
              return true;
            var n5 = ee.call(e5, "constructor") && e5.constructor;
            return "function" == typeof n5 && n5 instanceof n5 && te.call(n5) == ne;
          }, "re");
          var se = {};
          se["[object Float32Array]"] = se["[object Float64Array]"] = se["[object Int8Array]"] = se["[object Int16Array]"] = se["[object Int32Array]"] = se["[object Uint8Array]"] = se["[object Uint8ClampedArray]"] = se["[object Uint16Array]"] = se["[object Uint32Array]"] = true, se["[object Arguments]"] = se["[object Array]"] = se["[object ArrayBuffer]"] = se["[object Boolean]"] = se["[object DataView]"] = se["[object Date]"] = se["[object Error]"] = se["[object Function]"] = se["[object Map]"] = se["[object Number]"] = se["[object Object]"] = se["[object RegExp]"] = se["[object Set]"] = se["[object String]"] = se["[object WeakMap]"] = false;
          const ie = /* @__PURE__ */ __name(function(t5) {
            return Bt(t5) && $t(t5.length) && !!se[T3(t5)];
          }, "ie");
          const oe = /* @__PURE__ */ __name(function(t5) {
            return function(e5) {
              return t5(e5);
            };
          }, "oe");
          var le = "object" == typeof exports2 && exports2 && !exports2.nodeType && exports2, ae2 = le && "object" == typeof module2 && module2 && !module2.nodeType && module2, ce2 = ae2 && ae2.exports === le && y3.process;
          const ue = function() {
            try {
              var t5 = ae2 && ae2.require && ae2.require("util").types;
              return t5 || ce2 && ce2.binding && ce2.binding("util");
            } catch (t6) {
            }
          }();
          var he = ue && ue.isTypedArray;
          const de = he ? oe(he) : ie;
          const fe = /* @__PURE__ */ __name(function(t5, e5) {
            if (("constructor" !== e5 || "function" != typeof t5[e5]) && "__proto__" != e5)
              return t5[e5];
          }, "fe");
          var pe = Object.prototype.hasOwnProperty;
          const ge = /* @__PURE__ */ __name(function(t5, e5, n5) {
            var r4 = t5[e5];
            pe.call(t5, e5) && i3(r4, n5) && (void 0 !== n5 || e5 in t5) || yt(t5, e5, n5);
          }, "ge");
          const me = /* @__PURE__ */ __name(function(t5, e5, n5, r4) {
            var s4 = !n5;
            n5 || (n5 = {});
            for (var i4 = -1, o4 = e5.length; ++i4 < o4; ) {
              var l4 = e5[i4], a4 = r4 ? r4(n5[l4], t5[l4], l4, n5, t5) : void 0;
              void 0 === a4 && (a4 = t5[l4]), s4 ? yt(n5, l4, a4) : ge(n5, l4, a4);
            }
            return n5;
          }, "me");
          const be2 = /* @__PURE__ */ __name(function(t5, e5) {
            for (var n5 = -1, r4 = Array(t5); ++n5 < t5; )
              r4[n5] = e5(n5);
            return r4;
          }, "be");
          var ye = /^(?:0|[1-9]\d*)$/;
          const ve = /* @__PURE__ */ __name(function(t5, e5) {
            var n5 = typeof t5;
            return !!(e5 = null == e5 ? 9007199254740991 : e5) && ("number" == n5 || "symbol" != n5 && ye.test(t5)) && t5 > -1 && t5 % 1 == 0 && t5 < e5;
          }, "ve");
          var xe = Object.prototype.hasOwnProperty;
          const Ne = /* @__PURE__ */ __name(function(t5, e5) {
            var n5 = Ft(t5), r4 = !n5 && Ht(t5), s4 = !n5 && !r4 && Qt(t5), i4 = !n5 && !r4 && !s4 && de(t5), o4 = n5 || r4 || s4 || i4, l4 = o4 ? be2(t5.length, String) : [], a4 = l4.length;
            for (var c4 in t5)
              !e5 && !xe.call(t5, c4) || o4 && ("length" == c4 || s4 && ("offset" == c4 || "parent" == c4) || i4 && ("buffer" == c4 || "byteLength" == c4 || "byteOffset" == c4) || ve(c4, a4)) || l4.push(c4);
            return l4;
          }, "Ne");
          const we = /* @__PURE__ */ __name(function(t5) {
            var e5 = [];
            if (null != t5)
              for (var n5 in Object(t5))
                e5.push(n5);
            return e5;
          }, "we");
          var Ee = Object.prototype.hasOwnProperty;
          const Ae = /* @__PURE__ */ __name(function(t5) {
            if (!S3(t5))
              return we(t5);
            var e5 = It(t5), n5 = [];
            for (var r4 in t5)
              ("constructor" != r4 || !e5 && Ee.call(t5, r4)) && n5.push(r4);
            return n5;
          }, "Ae");
          const qe = /* @__PURE__ */ __name(function(t5) {
            return Vt(t5) ? Ne(t5, true) : Ae(t5);
          }, "qe");
          const ke = /* @__PURE__ */ __name(function(t5) {
            return me(t5, qe(t5));
          }, "ke");
          const _e2 = /* @__PURE__ */ __name(function(t5, e5, n5, r4, s4, i4, o4) {
            var l4 = fe(t5, n5), a4 = fe(e5, n5), c4 = o4.get(a4);
            if (c4)
              vt(t5, n5, c4);
            else {
              var u4 = i4 ? i4(l4, a4, n5 + "", t5, e5, o4) : void 0, h4 = void 0 === u4;
              if (h4) {
                var d4 = Ft(a4), f4 = !d4 && Qt(a4), p4 = !d4 && !f4 && de(a4);
                u4 = a4, d4 || f4 || p4 ? Ft(l4) ? u4 = l4 : Kt(l4) ? u4 = Ot(l4) : f4 ? (h4 = false, u4 = qt(a4, true)) : p4 ? (h4 = false, u4 = Lt(a4, true)) : u4 = [] : re(a4) || Ht(a4) ? (u4 = l4, Ht(l4) ? u4 = ke(l4) : S3(l4) && !C3(l4) || (u4 = Mt(a4))) : h4 = false;
              }
              h4 && (o4.set(a4, u4), s4(u4, a4, r4, i4, o4), o4.delete(a4)), vt(t5, n5, u4);
            }
          }, "_e");
          const Le = /* @__PURE__ */ __name(function t5(e5, n5, r4, s4, i4) {
            e5 !== n5 && xt(n5, function(o4, l4) {
              if (i4 || (i4 = new mt()), S3(o4))
                _e2(e5, n5, l4, r4, t5, s4, i4);
              else {
                var a4 = s4 ? s4(fe(e5, l4), o4, l4 + "", e5, n5, i4) : void 0;
                void 0 === a4 && (a4 = o4), vt(e5, l4, a4);
              }
            }, qe);
          }, "t");
          const Oe = /* @__PURE__ */ __name(function(t5) {
            return t5;
          }, "Oe");
          const Te = /* @__PURE__ */ __name(function(t5, e5, n5) {
            switch (n5.length) {
              case 0:
                return t5.call(e5);
              case 1:
                return t5.call(e5, n5[0]);
              case 2:
                return t5.call(e5, n5[0], n5[1]);
              case 3:
                return t5.call(e5, n5[0], n5[1], n5[2]);
            }
            return t5.apply(e5, n5);
          }, "Te");
          var Se = Math.max;
          const Ce = /* @__PURE__ */ __name(function(t5, e5, n5) {
            return e5 = Se(void 0 === e5 ? t5.length - 1 : e5, 0), function() {
              for (var r4 = arguments, s4 = -1, i4 = Se(r4.length - e5, 0), o4 = Array(i4); ++s4 < i4; )
                o4[s4] = r4[e5 + s4];
              s4 = -1;
              for (var l4 = Array(e5 + 1); ++s4 < e5; )
                l4[s4] = r4[s4];
              return l4[e5] = n5(o4), Te(t5, this, l4);
            };
          }, "Ce");
          const je = /* @__PURE__ */ __name(function(t5) {
            return function() {
              return t5;
            };
          }, "je");
          const Re = bt2 ? function(t5, e5) {
            return bt2(t5, "toString", { configurable: true, enumerable: false, value: je(e5), writable: true });
          } : Oe;
          var Ie = Date.now;
          const Me = /* @__PURE__ */ function(t5) {
            var e5 = 0, n5 = 0;
            return function() {
              var r4 = Ie(), s4 = 16 - (r4 - n5);
              if (n5 = r4, s4 > 0) {
                if (++e5 >= 800)
                  return arguments[0];
              } else
                e5 = 0;
              return t5.apply(void 0, arguments);
            };
          }(Re);
          const Be = /* @__PURE__ */ __name(function(t5, e5) {
            return Me(Ce(t5, e5, Oe), t5 + "");
          }, "Be");
          const Ue = /* @__PURE__ */ __name(function(t5, e5, n5) {
            if (!S3(n5))
              return false;
            var r4 = typeof e5;
            return !!("number" == r4 ? Vt(n5) && ve(e5, n5.length) : "string" == r4 && e5 in n5) && i3(n5[e5], t5);
          }, "Ue");
          const De = function(t5) {
            return Be(function(e5, n5) {
              var r4 = -1, s4 = n5.length, i4 = s4 > 1 ? n5[s4 - 1] : void 0, o4 = s4 > 2 ? n5[2] : void 0;
              for (i4 = t5.length > 3 && "function" == typeof i4 ? (s4--, i4) : void 0, o4 && Ue(n5[0], n5[1], o4) && (i4 = s4 < 3 ? void 0 : i4, s4 = 1), e5 = Object(e5); ++r4 < s4; ) {
                var l4 = n5[r4];
                l4 && t5(e5, l4, r4, i4);
              }
              return e5;
            });
          }(function(t5, e5, n5) {
            Le(t5, e5, n5);
          });
          var Pe = ((t5) => (t5[t5.TYPE = 3] = "TYPE", t5[t5.LEVEL = 12] = "LEVEL", t5[t5.ATTRIBUTE = 13] = "ATTRIBUTE", t5[t5.BLOT = 14] = "BLOT", t5[t5.INLINE = 7] = "INLINE", t5[t5.BLOCK = 11] = "BLOCK", t5[t5.BLOCK_BLOT = 10] = "BLOCK_BLOT", t5[t5.INLINE_BLOT = 6] = "INLINE_BLOT", t5[t5.BLOCK_ATTRIBUTE = 9] = "BLOCK_ATTRIBUTE", t5[t5.INLINE_ATTRIBUTE = 5] = "INLINE_ATTRIBUTE", t5[t5.ANY = 15] = "ANY", t5))(Pe || {});
          class ze {
            static {
              __name(this, "ze");
            }
            constructor(t5, e5, n5 = {}) {
              this.attrName = t5, this.keyName = e5;
              const r4 = Pe.TYPE & Pe.ATTRIBUTE;
              this.scope = null != n5.scope ? n5.scope & Pe.LEVEL | r4 : Pe.ATTRIBUTE, null != n5.whitelist && (this.whitelist = n5.whitelist);
            }
            static keys(t5) {
              return Array.from(t5.attributes).map((t6) => t6.name);
            }
            add(t5, e5) {
              return !!this.canAdd(t5, e5) && (t5.setAttribute(this.keyName, e5), true);
            }
            canAdd(t5, e5) {
              return null == this.whitelist || ("string" == typeof e5 ? this.whitelist.indexOf(e5.replace(/["']/g, "")) > -1 : this.whitelist.indexOf(e5) > -1);
            }
            remove(t5) {
              t5.removeAttribute(this.keyName);
            }
            value(t5) {
              const e5 = t5.getAttribute(this.keyName);
              return this.canAdd(t5, e5) && e5 ? e5 : "";
            }
          }
          class He extends Error {
            static {
              __name(this, "He");
            }
            constructor(t5) {
              super(t5 = "[Parchment] " + t5), this.message = t5, this.name = this.constructor.name;
            }
          }
          const Fe = class t5 {
            static {
              __name(this, "t");
            }
            constructor() {
              this.attributes = {}, this.classes = {}, this.tags = {}, this.types = {};
            }
            static find(t6, e5 = false) {
              if (null == t6)
                return null;
              if (this.blots.has(t6))
                return this.blots.get(t6) || null;
              if (e5) {
                let n5 = null;
                try {
                  n5 = t6.parentNode;
                } catch {
                  return null;
                }
                return this.find(n5, e5);
              }
              return null;
            }
            create(e5, n5, r4) {
              const s4 = this.query(n5);
              if (null == s4)
                throw new He(`Unable to create ${n5} blot`);
              const i4 = s4, o4 = n5 instanceof Node || n5.nodeType === Node.TEXT_NODE ? n5 : i4.create(r4), l4 = new i4(e5, o4, r4);
              return t5.blots.set(l4.domNode, l4), l4;
            }
            find(e5, n5 = false) {
              return t5.find(e5, n5);
            }
            query(t6, e5 = Pe.ANY) {
              let n5;
              return "string" == typeof t6 ? n5 = this.types[t6] || this.attributes[t6] : t6 instanceof Text || t6.nodeType === Node.TEXT_NODE ? n5 = this.types.text : "number" == typeof t6 ? t6 & Pe.LEVEL & Pe.BLOCK ? n5 = this.types.block : t6 & Pe.LEVEL & Pe.INLINE && (n5 = this.types.inline) : t6 instanceof Element && ((t6.getAttribute("class") || "").split(/\s+/).some((t7) => (n5 = this.classes[t7], !!n5)), n5 = n5 || this.tags[t6.tagName]), null == n5 ? null : "scope" in n5 && e5 & Pe.LEVEL & n5.scope && e5 & Pe.TYPE & n5.scope ? n5 : null;
            }
            register(...t6) {
              return t6.map((t7) => {
                const e5 = "blotName" in t7, n5 = "attrName" in t7;
                if (!e5 && !n5)
                  throw new He("Invalid definition");
                if (e5 && "abstract" === t7.blotName)
                  throw new He("Cannot register abstract class");
                const r4 = e5 ? t7.blotName : n5 ? t7.attrName : void 0;
                return this.types[r4] = t7, n5 ? "string" == typeof t7.keyName && (this.attributes[t7.keyName] = t7) : e5 && (t7.className && (this.classes[t7.className] = t7), t7.tagName && (Array.isArray(t7.tagName) ? t7.tagName = t7.tagName.map((t8) => t8.toUpperCase()) : t7.tagName = t7.tagName.toUpperCase(), (Array.isArray(t7.tagName) ? t7.tagName : [t7.tagName]).forEach((e6) => {
                  (null == this.tags[e6] || null == t7.className) && (this.tags[e6] = t7);
                }))), t7;
              });
            }
          };
          Fe.blots = /* @__PURE__ */ new WeakMap();
          let $e = Fe;
          function Ve(t5, e5) {
            return (t5.getAttribute("class") || "").split(/\s+/).filter((t6) => 0 === t6.indexOf(`${e5}-`));
          }
          __name(Ve, "Ve");
          const Ke = class extends ze {
            static {
              __name(this, "Ke");
            }
            static keys(t5) {
              return (t5.getAttribute("class") || "").split(/\s+/).map((t6) => t6.split("-").slice(0, -1).join("-"));
            }
            add(t5, e5) {
              return !!this.canAdd(t5, e5) && (this.remove(t5), t5.classList.add(`${this.keyName}-${e5}`), true);
            }
            remove(t5) {
              Ve(t5, this.keyName).forEach((e5) => {
                t5.classList.remove(e5);
              }), 0 === t5.classList.length && t5.removeAttribute("class");
            }
            value(t5) {
              const e5 = (Ve(t5, this.keyName)[0] || "").slice(this.keyName.length + 1);
              return this.canAdd(t5, e5) ? e5 : "";
            }
          };
          function We(t5) {
            const e5 = t5.split("-"), n5 = e5.slice(1).map((t6) => t6[0].toUpperCase() + t6.slice(1)).join("");
            return e5[0] + n5;
          }
          __name(We, "We");
          const Ze = class extends ze {
            static {
              __name(this, "Ze");
            }
            static keys(t5) {
              return (t5.getAttribute("style") || "").split(";").map((t6) => t6.split(":")[0].trim());
            }
            add(t5, e5) {
              return !!this.canAdd(t5, e5) && (t5.style[We(this.keyName)] = e5, true);
            }
            remove(t5) {
              t5.style[We(this.keyName)] = "", t5.getAttribute("style") || t5.removeAttribute("style");
            }
            value(t5) {
              const e5 = t5.style[We(this.keyName)];
              return this.canAdd(t5, e5) ? e5 : "";
            }
          };
          const Ge = class {
            static {
              __name(this, "Ge");
            }
            constructor(t5) {
              this.attributes = {}, this.domNode = t5, this.build();
            }
            attribute(t5, e5) {
              e5 ? t5.add(this.domNode, e5) && (null != t5.value(this.domNode) ? this.attributes[t5.attrName] = t5 : delete this.attributes[t5.attrName]) : (t5.remove(this.domNode), delete this.attributes[t5.attrName]);
            }
            build() {
              this.attributes = {};
              const t5 = $e.find(this.domNode);
              if (null == t5)
                return;
              const e5 = ze.keys(this.domNode), n5 = Ke.keys(this.domNode), r4 = Ze.keys(this.domNode);
              e5.concat(n5).concat(r4).forEach((e6) => {
                const n6 = t5.scroll.query(e6, Pe.ATTRIBUTE);
                n6 instanceof ze && (this.attributes[n6.attrName] = n6);
              });
            }
            copy(t5) {
              Object.keys(this.attributes).forEach((e5) => {
                const n5 = this.attributes[e5].value(this.domNode);
                t5.format(e5, n5);
              });
            }
            move(t5) {
              this.copy(t5), Object.keys(this.attributes).forEach((t6) => {
                this.attributes[t6].remove(this.domNode);
              }), this.attributes = {};
            }
            values() {
              return Object.keys(this.attributes).reduce((t5, e5) => (t5[e5] = this.attributes[e5].value(this.domNode), t5), {});
            }
          }, Xe = class {
            static {
              __name(this, "Xe");
            }
            constructor(t5, e5) {
              this.scroll = t5, this.domNode = e5, $e.blots.set(e5, this), this.prev = null, this.next = null;
            }
            static create(t5) {
              if (null == this.tagName)
                throw new He("Blot definition missing tagName");
              let e5, n5;
              return Array.isArray(this.tagName) ? ("string" == typeof t5 ? (n5 = t5.toUpperCase(), parseInt(n5, 10).toString() === n5 && (n5 = parseInt(n5, 10))) : "number" == typeof t5 && (n5 = t5), e5 = "number" == typeof n5 ? document.createElement(this.tagName[n5 - 1]) : n5 && this.tagName.indexOf(n5) > -1 ? document.createElement(n5) : document.createElement(this.tagName[0])) : e5 = document.createElement(this.tagName), this.className && e5.classList.add(this.className), e5;
            }
            get statics() {
              return this.constructor;
            }
            attach() {
            }
            clone() {
              const t5 = this.domNode.cloneNode(false);
              return this.scroll.create(t5);
            }
            detach() {
              null != this.parent && this.parent.removeChild(this), $e.blots.delete(this.domNode);
            }
            deleteAt(t5, e5) {
              this.isolate(t5, e5).remove();
            }
            formatAt(t5, e5, n5, r4) {
              const s4 = this.isolate(t5, e5);
              if (null != this.scroll.query(n5, Pe.BLOT) && r4)
                s4.wrap(n5, r4);
              else if (null != this.scroll.query(n5, Pe.ATTRIBUTE)) {
                const t6 = this.scroll.create(this.statics.scope);
                s4.wrap(t6), t6.format(n5, r4);
              }
            }
            insertAt(t5, e5, n5) {
              const r4 = null == n5 ? this.scroll.create("text", e5) : this.scroll.create(e5, n5), s4 = this.split(t5);
              this.parent.insertBefore(r4, s4 || void 0);
            }
            isolate(t5, e5) {
              const n5 = this.split(t5);
              if (null == n5)
                throw new Error("Attempt to isolate at end");
              return n5.split(e5), n5;
            }
            length() {
              return 1;
            }
            offset(t5 = this.parent) {
              return null == this.parent || this === t5 ? 0 : this.parent.children.offset(this) + this.parent.offset(t5);
            }
            optimize(t5) {
              this.statics.requiredContainer && !(this.parent instanceof this.statics.requiredContainer) && this.wrap(this.statics.requiredContainer.blotName);
            }
            remove() {
              null != this.domNode.parentNode && this.domNode.parentNode.removeChild(this.domNode), this.detach();
            }
            replaceWith(t5, e5) {
              const n5 = "string" == typeof t5 ? this.scroll.create(t5, e5) : t5;
              return null != this.parent && (this.parent.insertBefore(n5, this.next || void 0), this.remove()), n5;
            }
            split(t5, e5) {
              return 0 === t5 ? this : this.next;
            }
            update(t5, e5) {
            }
            wrap(t5, e5) {
              const n5 = "string" == typeof t5 ? this.scroll.create(t5, e5) : t5;
              if (null != this.parent && this.parent.insertBefore(n5, this.next || void 0), "function" != typeof n5.appendChild)
                throw new He(`Cannot wrap ${t5}`);
              return n5.appendChild(this), n5;
            }
          };
          Xe.blotName = "abstract";
          let Qe = Xe;
          const Ye = class extends Qe {
            static {
              __name(this, "Ye");
            }
            static value(t5) {
              return true;
            }
            index(t5, e5) {
              return this.domNode === t5 || this.domNode.compareDocumentPosition(t5) & Node.DOCUMENT_POSITION_CONTAINED_BY ? Math.min(e5, 1) : -1;
            }
            position(t5, e5) {
              let n5 = Array.from(this.parent.domNode.childNodes).indexOf(this.domNode);
              return t5 > 0 && (n5 += 1), [this.parent.domNode, n5];
            }
            value() {
              return { [this.statics.blotName]: this.statics.value(this.domNode) || true };
            }
          };
          Ye.scope = Pe.INLINE_BLOT;
          const Je = Ye;
          class tn {
            static {
              __name(this, "tn");
            }
            constructor() {
              this.head = null, this.tail = null, this.length = 0;
            }
            append(...t5) {
              if (this.insertBefore(t5[0], null), t5.length > 1) {
                const e5 = t5.slice(1);
                this.append(...e5);
              }
            }
            at(t5) {
              const e5 = this.iterator();
              let n5 = e5();
              for (; n5 && t5 > 0; )
                t5 -= 1, n5 = e5();
              return n5;
            }
            contains(t5) {
              const e5 = this.iterator();
              let n5 = e5();
              for (; n5; ) {
                if (n5 === t5)
                  return true;
                n5 = e5();
              }
              return false;
            }
            indexOf(t5) {
              const e5 = this.iterator();
              let n5 = e5(), r4 = 0;
              for (; n5; ) {
                if (n5 === t5)
                  return r4;
                r4 += 1, n5 = e5();
              }
              return -1;
            }
            insertBefore(t5, e5) {
              null != t5 && (this.remove(t5), t5.next = e5, null != e5 ? (t5.prev = e5.prev, null != e5.prev && (e5.prev.next = t5), e5.prev = t5, e5 === this.head && (this.head = t5)) : null != this.tail ? (this.tail.next = t5, t5.prev = this.tail, this.tail = t5) : (t5.prev = null, this.head = this.tail = t5), this.length += 1);
            }
            offset(t5) {
              let e5 = 0, n5 = this.head;
              for (; null != n5; ) {
                if (n5 === t5)
                  return e5;
                e5 += n5.length(), n5 = n5.next;
              }
              return -1;
            }
            remove(t5) {
              this.contains(t5) && (null != t5.prev && (t5.prev.next = t5.next), null != t5.next && (t5.next.prev = t5.prev), t5 === this.head && (this.head = t5.next), t5 === this.tail && (this.tail = t5.prev), this.length -= 1);
            }
            iterator(t5 = this.head) {
              return () => {
                const e5 = t5;
                return null != t5 && (t5 = t5.next), e5;
              };
            }
            find(t5, e5 = false) {
              const n5 = this.iterator();
              let r4 = n5();
              for (; r4; ) {
                const s4 = r4.length();
                if (t5 < s4 || e5 && t5 === s4 && (null == r4.next || 0 !== r4.next.length()))
                  return [r4, t5];
                t5 -= s4, r4 = n5();
              }
              return [null, 0];
            }
            forEach(t5) {
              const e5 = this.iterator();
              let n5 = e5();
              for (; n5; )
                t5(n5), n5 = e5();
            }
            forEachAt(t5, e5, n5) {
              if (e5 <= 0)
                return;
              const [r4, s4] = this.find(t5);
              let i4 = t5 - s4;
              const o4 = this.iterator(r4);
              let l4 = o4();
              for (; l4 && i4 < t5 + e5; ) {
                const r5 = l4.length();
                t5 > i4 ? n5(l4, t5 - i4, Math.min(e5, i4 + r5 - t5)) : n5(l4, 0, Math.min(r5, t5 + e5 - i4)), i4 += r5, l4 = o4();
              }
            }
            map(t5) {
              return this.reduce((e5, n5) => (e5.push(t5(n5)), e5), []);
            }
            reduce(t5, e5) {
              const n5 = this.iterator();
              let r4 = n5();
              for (; r4; )
                e5 = t5(e5, r4), r4 = n5();
              return e5;
            }
          }
          function en(t5, e5) {
            const n5 = e5.find(t5);
            if (n5)
              return n5;
            try {
              return e5.create(t5);
            } catch {
              const n6 = e5.create(Pe.INLINE);
              return Array.from(t5.childNodes).forEach((t6) => {
                n6.domNode.appendChild(t6);
              }), t5.parentNode && t5.parentNode.replaceChild(n6.domNode, t5), n6.attach(), n6;
            }
          }
          __name(en, "en");
          const nn = class t5 extends Qe {
            static {
              __name(this, "t");
            }
            constructor(t6, e5) {
              super(t6, e5), this.uiNode = null, this.build();
            }
            appendChild(t6) {
              this.insertBefore(t6);
            }
            attach() {
              super.attach(), this.children.forEach((t6) => {
                t6.attach();
              });
            }
            attachUI(e5) {
              null != this.uiNode && this.uiNode.remove(), this.uiNode = e5, t5.uiClass && this.uiNode.classList.add(t5.uiClass), this.uiNode.setAttribute("contenteditable", "false"), this.domNode.insertBefore(this.uiNode, this.domNode.firstChild);
            }
            build() {
              this.children = new tn(), Array.from(this.domNode.childNodes).filter((t6) => t6 !== this.uiNode).reverse().forEach((t6) => {
                try {
                  const e5 = en(t6, this.scroll);
                  this.insertBefore(e5, this.children.head || void 0);
                } catch (t7) {
                  if (t7 instanceof He)
                    return;
                  throw t7;
                }
              });
            }
            deleteAt(t6, e5) {
              if (0 === t6 && e5 === this.length())
                return this.remove();
              this.children.forEachAt(t6, e5, (t7, e6, n5) => {
                t7.deleteAt(e6, n5);
              });
            }
            descendant(e5, n5 = 0) {
              const [r4, s4] = this.children.find(n5);
              return null == e5.blotName && e5(r4) || null != e5.blotName && r4 instanceof e5 ? [r4, s4] : r4 instanceof t5 ? r4.descendant(e5, s4) : [null, -1];
            }
            descendants(e5, n5 = 0, r4 = Number.MAX_VALUE) {
              let s4 = [], i4 = r4;
              return this.children.forEachAt(n5, r4, (n6, r5, o4) => {
                (null == e5.blotName && e5(n6) || null != e5.blotName && n6 instanceof e5) && s4.push(n6), n6 instanceof t5 && (s4 = s4.concat(n6.descendants(e5, r5, i4))), i4 -= o4;
              }), s4;
            }
            detach() {
              this.children.forEach((t6) => {
                t6.detach();
              }), super.detach();
            }
            enforceAllowedChildren() {
              let e5 = false;
              this.children.forEach((n5) => {
                e5 || this.statics.allowedChildren.some((t6) => n5 instanceof t6) || (n5.statics.scope === Pe.BLOCK_BLOT ? (null != n5.next && this.splitAfter(n5), null != n5.prev && this.splitAfter(n5.prev), n5.parent.unwrap(), e5 = true) : n5 instanceof t5 ? n5.unwrap() : n5.remove());
              });
            }
            formatAt(t6, e5, n5, r4) {
              this.children.forEachAt(t6, e5, (t7, e6, s4) => {
                t7.formatAt(e6, s4, n5, r4);
              });
            }
            insertAt(t6, e5, n5) {
              const [r4, s4] = this.children.find(t6);
              if (r4)
                r4.insertAt(s4, e5, n5);
              else {
                const t7 = null == n5 ? this.scroll.create("text", e5) : this.scroll.create(e5, n5);
                this.appendChild(t7);
              }
            }
            insertBefore(t6, e5) {
              null != t6.parent && t6.parent.children.remove(t6);
              let n5 = null;
              this.children.insertBefore(t6, e5 || null), t6.parent = this, null != e5 && (n5 = e5.domNode), (this.domNode.parentNode !== t6.domNode || this.domNode.nextSibling !== n5) && this.domNode.insertBefore(t6.domNode, n5), t6.attach();
            }
            length() {
              return this.children.reduce((t6, e5) => t6 + e5.length(), 0);
            }
            moveChildren(t6, e5) {
              this.children.forEach((n5) => {
                t6.insertBefore(n5, e5);
              });
            }
            optimize(t6) {
              if (super.optimize(t6), this.enforceAllowedChildren(), null != this.uiNode && this.uiNode !== this.domNode.firstChild && this.domNode.insertBefore(this.uiNode, this.domNode.firstChild), 0 === this.children.length)
                if (null != this.statics.defaultChild) {
                  const t7 = this.scroll.create(this.statics.defaultChild.blotName);
                  this.appendChild(t7);
                } else
                  this.remove();
            }
            path(e5, n5 = false) {
              const [r4, s4] = this.children.find(e5, n5), i4 = [[this, e5]];
              return r4 instanceof t5 ? i4.concat(r4.path(s4, n5)) : (null != r4 && i4.push([r4, s4]), i4);
            }
            removeChild(t6) {
              this.children.remove(t6);
            }
            replaceWith(e5, n5) {
              const r4 = "string" == typeof e5 ? this.scroll.create(e5, n5) : e5;
              return r4 instanceof t5 && this.moveChildren(r4), super.replaceWith(r4);
            }
            split(t6, e5 = false) {
              if (!e5) {
                if (0 === t6)
                  return this;
                if (t6 === this.length())
                  return this.next;
              }
              const n5 = this.clone();
              return this.parent && this.parent.insertBefore(n5, this.next || void 0), this.children.forEachAt(t6, this.length(), (t7, r4, s4) => {
                const i4 = t7.split(r4, e5);
                null != i4 && n5.appendChild(i4);
              }), n5;
            }
            splitAfter(t6) {
              const e5 = this.clone();
              for (; null != t6.next; )
                e5.appendChild(t6.next);
              return this.parent && this.parent.insertBefore(e5, this.next || void 0), e5;
            }
            unwrap() {
              this.parent && this.moveChildren(this.parent, this.next || void 0), this.remove();
            }
            update(t6, e5) {
              const n5 = [], r4 = [];
              t6.forEach((t7) => {
                t7.target === this.domNode && "childList" === t7.type && (n5.push(...t7.addedNodes), r4.push(...t7.removedNodes));
              }), r4.forEach((t7) => {
                if (null != t7.parentNode && "IFRAME" !== t7.tagName && document.body.compareDocumentPosition(t7) & Node.DOCUMENT_POSITION_CONTAINED_BY)
                  return;
                const e6 = this.scroll.find(t7);
                null != e6 && (null == e6.domNode.parentNode || e6.domNode.parentNode === this.domNode) && e6.detach();
              }), n5.filter((t7) => t7.parentNode === this.domNode && t7 !== this.uiNode).sort((t7, e6) => t7 === e6 ? 0 : t7.compareDocumentPosition(e6) & Node.DOCUMENT_POSITION_FOLLOWING ? 1 : -1).forEach((t7) => {
                let e6 = null;
                null != t7.nextSibling && (e6 = this.scroll.find(t7.nextSibling));
                const n6 = en(t7, this.scroll);
                (n6.next !== e6 || null == n6.next) && (null != n6.parent && n6.parent.removeChild(this), this.insertBefore(n6, e6 || void 0));
              }), this.enforceAllowedChildren();
            }
          };
          nn.uiClass = "";
          const rn = nn;
          const sn = class t5 extends rn {
            static {
              __name(this, "t");
            }
            static create(t6) {
              return super.create(t6);
            }
            static formats(e5, n5) {
              const r4 = n5.query(t5.blotName);
              if (null == r4 || e5.tagName !== r4.tagName) {
                if ("string" == typeof this.tagName)
                  return true;
                if (Array.isArray(this.tagName))
                  return e5.tagName.toLowerCase();
              }
            }
            constructor(t6, e5) {
              super(t6, e5), this.attributes = new Ge(this.domNode);
            }
            format(e5, n5) {
              if (e5 !== this.statics.blotName || n5) {
                const t6 = this.scroll.query(e5, Pe.INLINE);
                if (null == t6)
                  return;
                t6 instanceof ze ? this.attributes.attribute(t6, n5) : n5 && (e5 !== this.statics.blotName || this.formats()[e5] !== n5) && this.replaceWith(e5, n5);
              } else
                this.children.forEach((e6) => {
                  e6 instanceof t5 || (e6 = e6.wrap(t5.blotName, true)), this.attributes.copy(e6);
                }), this.unwrap();
            }
            formats() {
              const t6 = this.attributes.values(), e5 = this.statics.formats(this.domNode, this.scroll);
              return null != e5 && (t6[this.statics.blotName] = e5), t6;
            }
            formatAt(t6, e5, n5, r4) {
              null != this.formats()[n5] || this.scroll.query(n5, Pe.ATTRIBUTE) ? this.isolate(t6, e5).format(n5, r4) : super.formatAt(t6, e5, n5, r4);
            }
            optimize(e5) {
              super.optimize(e5);
              const n5 = this.formats();
              if (0 === Object.keys(n5).length)
                return this.unwrap();
              const r4 = this.next;
              r4 instanceof t5 && r4.prev === this && function(t6, e6) {
                if (Object.keys(t6).length !== Object.keys(e6).length)
                  return false;
                for (const n6 in t6)
                  if (t6[n6] !== e6[n6])
                    return false;
                return true;
              }(n5, r4.formats()) && (r4.moveChildren(this), r4.remove());
            }
            replaceWith(t6, e5) {
              const n5 = super.replaceWith(t6, e5);
              return this.attributes.copy(n5), n5;
            }
            update(t6, e5) {
              super.update(t6, e5), t6.some((t7) => t7.target === this.domNode && "attributes" === t7.type) && this.attributes.build();
            }
            wrap(e5, n5) {
              const r4 = super.wrap(e5, n5);
              return r4 instanceof t5 && this.attributes.move(r4), r4;
            }
          };
          sn.allowedChildren = [sn, Je], sn.blotName = "inline", sn.scope = Pe.INLINE_BLOT, sn.tagName = "SPAN";
          const on2 = sn, ln = class t5 extends rn {
            static {
              __name(this, "t");
            }
            static create(t6) {
              return super.create(t6);
            }
            static formats(e5, n5) {
              const r4 = n5.query(t5.blotName);
              if (null == r4 || e5.tagName !== r4.tagName) {
                if ("string" == typeof this.tagName)
                  return true;
                if (Array.isArray(this.tagName))
                  return e5.tagName.toLowerCase();
              }
            }
            constructor(t6, e5) {
              super(t6, e5), this.attributes = new Ge(this.domNode);
            }
            format(e5, n5) {
              const r4 = this.scroll.query(e5, Pe.BLOCK);
              null != r4 && (r4 instanceof ze ? this.attributes.attribute(r4, n5) : e5 !== this.statics.blotName || n5 ? n5 && (e5 !== this.statics.blotName || this.formats()[e5] !== n5) && this.replaceWith(e5, n5) : this.replaceWith(t5.blotName));
            }
            formats() {
              const t6 = this.attributes.values(), e5 = this.statics.formats(this.domNode, this.scroll);
              return null != e5 && (t6[this.statics.blotName] = e5), t6;
            }
            formatAt(t6, e5, n5, r4) {
              null != this.scroll.query(n5, Pe.BLOCK) ? this.format(n5, r4) : super.formatAt(t6, e5, n5, r4);
            }
            insertAt(t6, e5, n5) {
              if (null == n5 || null != this.scroll.query(e5, Pe.INLINE))
                super.insertAt(t6, e5, n5);
              else {
                const r4 = this.split(t6);
                if (null == r4)
                  throw new Error("Attempt to insertAt after block boundaries");
                {
                  const t7 = this.scroll.create(e5, n5);
                  r4.parent.insertBefore(t7, r4);
                }
              }
            }
            replaceWith(t6, e5) {
              const n5 = super.replaceWith(t6, e5);
              return this.attributes.copy(n5), n5;
            }
            update(t6, e5) {
              super.update(t6, e5), t6.some((t7) => t7.target === this.domNode && "attributes" === t7.type) && this.attributes.build();
            }
          };
          ln.blotName = "block", ln.scope = Pe.BLOCK_BLOT, ln.tagName = "P", ln.allowedChildren = [on2, ln, Je];
          const an2 = ln, cn2 = class extends rn {
            static {
              __name(this, "cn");
            }
            checkMerge() {
              return null !== this.next && this.next.statics.blotName === this.statics.blotName;
            }
            deleteAt(t5, e5) {
              super.deleteAt(t5, e5), this.enforceAllowedChildren();
            }
            formatAt(t5, e5, n5, r4) {
              super.formatAt(t5, e5, n5, r4), this.enforceAllowedChildren();
            }
            insertAt(t5, e5, n5) {
              super.insertAt(t5, e5, n5), this.enforceAllowedChildren();
            }
            optimize(t5) {
              super.optimize(t5), this.children.length > 0 && null != this.next && this.checkMerge() && (this.next.moveChildren(this), this.next.remove());
            }
          };
          cn2.blotName = "container", cn2.scope = Pe.BLOCK_BLOT;
          const un = cn2;
          const hn = class extends Je {
            static {
              __name(this, "hn");
            }
            static formats(t5, e5) {
            }
            format(t5, e5) {
              super.formatAt(0, this.length(), t5, e5);
            }
            formatAt(t5, e5, n5, r4) {
              0 === t5 && e5 === this.length() ? this.format(n5, r4) : super.formatAt(t5, e5, n5, r4);
            }
            formats() {
              return this.statics.formats(this.domNode, this.scroll);
            }
          }, dn = { attributes: true, characterData: true, characterDataOldValue: true, childList: true, subtree: true }, fn = class extends rn {
            static {
              __name(this, "fn");
            }
            constructor(t5, e5) {
              super(null, e5), this.registry = t5, this.scroll = this, this.build(), this.observer = new MutationObserver((t6) => {
                this.update(t6);
              }), this.observer.observe(this.domNode, dn), this.attach();
            }
            create(t5, e5) {
              return this.registry.create(this, t5, e5);
            }
            find(t5, e5 = false) {
              const n5 = this.registry.find(t5, e5);
              return n5 ? n5.scroll === this ? n5 : e5 ? this.find(n5.scroll.domNode.parentNode, true) : null : null;
            }
            query(t5, e5 = Pe.ANY) {
              return this.registry.query(t5, e5);
            }
            register(...t5) {
              return this.registry.register(...t5);
            }
            build() {
              null != this.scroll && super.build();
            }
            detach() {
              super.detach(), this.observer.disconnect();
            }
            deleteAt(t5, e5) {
              this.update(), 0 === t5 && e5 === this.length() ? this.children.forEach((t6) => {
                t6.remove();
              }) : super.deleteAt(t5, e5);
            }
            formatAt(t5, e5, n5, r4) {
              this.update(), super.formatAt(t5, e5, n5, r4);
            }
            insertAt(t5, e5, n5) {
              this.update(), super.insertAt(t5, e5, n5);
            }
            optimize(t5 = [], e5 = {}) {
              super.optimize(e5);
              const n5 = e5.mutationsMap || /* @__PURE__ */ new WeakMap();
              let r4 = Array.from(this.observer.takeRecords());
              for (; r4.length > 0; )
                t5.push(r4.pop());
              const s4 = /* @__PURE__ */ __name((t6, e6 = true) => {
                null == t6 || t6 === this || null != t6.domNode.parentNode && (n5.has(t6.domNode) || n5.set(t6.domNode, []), e6 && s4(t6.parent));
              }, "s"), i4 = /* @__PURE__ */ __name((t6) => {
                n5.has(t6.domNode) && (t6 instanceof rn && t6.children.forEach(i4), n5.delete(t6.domNode), t6.optimize(e5));
              }, "i");
              let o4 = t5;
              for (let e6 = 0; o4.length > 0; e6 += 1) {
                if (e6 >= 100)
                  throw new Error("[Parchment] Maximum optimize iterations reached");
                for (o4.forEach((t6) => {
                  const e7 = this.find(t6.target, true);
                  null != e7 && (e7.domNode === t6.target && ("childList" === t6.type ? (s4(this.find(t6.previousSibling, false)), Array.from(t6.addedNodes).forEach((t7) => {
                    const e8 = this.find(t7, false);
                    s4(e8, false), e8 instanceof rn && e8.children.forEach((t8) => {
                      s4(t8, false);
                    });
                  })) : "attributes" === t6.type && s4(e7.prev)), s4(e7));
                }), this.children.forEach(i4), o4 = Array.from(this.observer.takeRecords()), r4 = o4.slice(); r4.length > 0; )
                  t5.push(r4.pop());
              }
            }
            update(t5, e5 = {}) {
              t5 = t5 || this.observer.takeRecords();
              const n5 = /* @__PURE__ */ new WeakMap();
              t5.map((t6) => {
                const e6 = this.find(t6.target, true);
                return null == e6 ? null : n5.has(e6.domNode) ? (n5.get(e6.domNode).push(t6), null) : (n5.set(e6.domNode, [t6]), e6);
              }).forEach((t6) => {
                null != t6 && t6 !== this && n5.has(t6.domNode) && t6.update(n5.get(t6.domNode) || [], e5);
              }), e5.mutationsMap = n5, n5.has(this.domNode) && super.update(n5.get(this.domNode), e5), this.optimize(t5, e5);
            }
          };
          fn.blotName = "scroll", fn.defaultChild = an2, fn.allowedChildren = [an2, un], fn.scope = Pe.BLOCK_BLOT, fn.tagName = "DIV";
          const pn = fn, gn = class t5 extends Je {
            static {
              __name(this, "t");
            }
            static create(t6) {
              return document.createTextNode(t6);
            }
            static value(t6) {
              return t6.data;
            }
            constructor(t6, e5) {
              super(t6, e5), this.text = this.statics.value(this.domNode);
            }
            deleteAt(t6, e5) {
              this.domNode.data = this.text = this.text.slice(0, t6) + this.text.slice(t6 + e5);
            }
            index(t6, e5) {
              return this.domNode === t6 ? e5 : -1;
            }
            insertAt(t6, e5, n5) {
              null == n5 ? (this.text = this.text.slice(0, t6) + e5 + this.text.slice(t6), this.domNode.data = this.text) : super.insertAt(t6, e5, n5);
            }
            length() {
              return this.text.length;
            }
            optimize(e5) {
              super.optimize(e5), this.text = this.statics.value(this.domNode), 0 === this.text.length ? this.remove() : this.next instanceof t5 && this.next.prev === this && (this.insertAt(this.length(), this.next.value()), this.next.remove());
            }
            position(t6, e5 = false) {
              return [this.domNode, t6];
            }
            split(t6, e5 = false) {
              if (!e5) {
                if (0 === t6)
                  return this;
                if (t6 === this.length())
                  return this.next;
              }
              const n5 = this.scroll.create(this.domNode.splitText(t6));
              return this.parent.insertBefore(n5, this.next || void 0), this.text = this.statics.value(this.domNode), n5;
            }
            update(t6, e5) {
              t6.some((t7) => "characterData" === t7.type && t7.target === this.domNode) && (this.text = this.statics.value(this.domNode));
            }
            value() {
              return this.text;
            }
          };
          gn.blotName = "text", gn.scope = Pe.INLINE_BLOT;
          const mn = gn;
          var bn2 = n4(660);
          const yn = /* @__PURE__ */ __name(function(t5, e5) {
            for (var n5 = -1, r4 = null == t5 ? 0 : t5.length; ++n5 < r4 && false !== e5(t5[n5], n5, t5); )
              ;
            return t5;
          }, "yn");
          const vn = Ct(Object.keys, Object);
          var xn = Object.prototype.hasOwnProperty;
          const Nn = /* @__PURE__ */ __name(function(t5) {
            if (!It(t5))
              return vn(t5);
            var e5 = [];
            for (var n5 in Object(t5))
              xn.call(t5, n5) && "constructor" != n5 && e5.push(n5);
            return e5;
          }, "Nn");
          const wn = /* @__PURE__ */ __name(function(t5) {
            return Vt(t5) ? Ne(t5) : Nn(t5);
          }, "wn");
          const En = /* @__PURE__ */ __name(function(t5, e5) {
            return t5 && me(e5, wn(e5), t5);
          }, "En");
          const An = /* @__PURE__ */ __name(function(t5, e5) {
            return t5 && me(e5, qe(e5), t5);
          }, "An");
          const qn = /* @__PURE__ */ __name(function(t5, e5) {
            for (var n5 = -1, r4 = null == t5 ? 0 : t5.length, s4 = 0, i4 = []; ++n5 < r4; ) {
              var o4 = t5[n5];
              e5(o4, n5, t5) && (i4[s4++] = o4);
            }
            return i4;
          }, "qn");
          const kn = /* @__PURE__ */ __name(function() {
            return [];
          }, "kn");
          var _n = Object.prototype.propertyIsEnumerable, Ln = Object.getOwnPropertySymbols;
          const On = Ln ? function(t5) {
            return null == t5 ? [] : (t5 = Object(t5), qn(Ln(t5), function(e5) {
              return _n.call(t5, e5);
            }));
          } : kn;
          const Tn = /* @__PURE__ */ __name(function(t5, e5) {
            return me(t5, On(t5), e5);
          }, "Tn");
          const Sn = /* @__PURE__ */ __name(function(t5, e5) {
            for (var n5 = -1, r4 = e5.length, s4 = t5.length; ++n5 < r4; )
              t5[s4 + n5] = e5[n5];
            return t5;
          }, "Sn");
          const Cn = Object.getOwnPropertySymbols ? function(t5) {
            for (var e5 = []; t5; )
              Sn(e5, On(t5)), t5 = jt(t5);
            return e5;
          } : kn;
          const jn = /* @__PURE__ */ __name(function(t5, e5) {
            return me(t5, Cn(t5), e5);
          }, "jn");
          const Rn = /* @__PURE__ */ __name(function(t5, e5, n5) {
            var r4 = e5(t5);
            return Ft(t5) ? r4 : Sn(r4, n5(t5));
          }, "Rn");
          const In = /* @__PURE__ */ __name(function(t5) {
            return Rn(t5, wn, On);
          }, "In");
          const Mn = /* @__PURE__ */ __name(function(t5) {
            return Rn(t5, qe, Cn);
          }, "Mn");
          const Bn = W3(x3, "DataView");
          const Un = W3(x3, "Promise");
          const Dn = W3(x3, "Set");
          const Pn = W3(x3, "WeakMap");
          var zn = "[object Map]", Hn = "[object Promise]", Fn = "[object Set]", $n = "[object WeakMap]", Vn = "[object DataView]", Kn = U3(Bn), Wn = U3(Z2), Zn = U3(Un), Gn = U3(Dn), Xn = U3(Pn), Qn = T3;
          (Bn && Qn(new Bn(new ArrayBuffer(1))) != Vn || Z2 && Qn(new Z2()) != zn || Un && Qn(Un.resolve()) != Hn || Dn && Qn(new Dn()) != Fn || Pn && Qn(new Pn()) != $n) && (Qn = /* @__PURE__ */ __name(function(t5) {
            var e5 = T3(t5), n5 = "[object Object]" == e5 ? t5.constructor : void 0, r4 = n5 ? U3(n5) : "";
            if (r4)
              switch (r4) {
                case Kn:
                  return Vn;
                case Wn:
                  return zn;
                case Zn:
                  return Hn;
                case Gn:
                  return Fn;
                case Xn:
                  return $n;
              }
            return e5;
          }, "Qn"));
          const Yn = Qn;
          var Jn = Object.prototype.hasOwnProperty;
          const tr = /* @__PURE__ */ __name(function(t5) {
            var e5 = t5.length, n5 = new t5.constructor(e5);
            return e5 && "string" == typeof t5[0] && Jn.call(t5, "index") && (n5.index = t5.index, n5.input = t5.input), n5;
          }, "tr");
          const er = /* @__PURE__ */ __name(function(t5, e5) {
            var n5 = e5 ? _t(t5.buffer) : t5.buffer;
            return new t5.constructor(n5, t5.byteOffset, t5.byteLength);
          }, "er");
          var nr = /\w*$/;
          const rr = /* @__PURE__ */ __name(function(t5) {
            var e5 = new t5.constructor(t5.source, nr.exec(t5));
            return e5.lastIndex = t5.lastIndex, e5;
          }, "rr");
          var sr = N3 ? N3.prototype : void 0, ir = sr ? sr.valueOf : void 0;
          const or = /* @__PURE__ */ __name(function(t5) {
            return ir ? Object(ir.call(t5)) : {};
          }, "or");
          const lr = /* @__PURE__ */ __name(function(t5, e5, n5) {
            var r4 = t5.constructor;
            switch (e5) {
              case "[object ArrayBuffer]":
                return _t(t5);
              case "[object Boolean]":
              case "[object Date]":
                return new r4(+t5);
              case "[object DataView]":
                return er(t5, n5);
              case "[object Float32Array]":
              case "[object Float64Array]":
              case "[object Int8Array]":
              case "[object Int16Array]":
              case "[object Int32Array]":
              case "[object Uint8Array]":
              case "[object Uint8ClampedArray]":
              case "[object Uint16Array]":
              case "[object Uint32Array]":
                return Lt(t5, n5);
              case "[object Map]":
              case "[object Set]":
                return new r4();
              case "[object Number]":
              case "[object String]":
                return new r4(t5);
              case "[object RegExp]":
                return rr(t5);
              case "[object Symbol]":
                return or(t5);
            }
          }, "lr");
          const ar2 = /* @__PURE__ */ __name(function(t5) {
            return Bt(t5) && "[object Map]" == Yn(t5);
          }, "ar");
          var cr2 = ue && ue.isMap;
          const ur = cr2 ? oe(cr2) : ar2;
          const hr = /* @__PURE__ */ __name(function(t5) {
            return Bt(t5) && "[object Set]" == Yn(t5);
          }, "hr");
          var dr = ue && ue.isSet;
          const fr = dr ? oe(dr) : hr;
          var pr = "[object Arguments]", gr = "[object Function]", mr = "[object Object]", br2 = {};
          br2[pr] = br2["[object Array]"] = br2["[object ArrayBuffer]"] = br2["[object DataView]"] = br2["[object Boolean]"] = br2["[object Date]"] = br2["[object Float32Array]"] = br2["[object Float64Array]"] = br2["[object Int8Array]"] = br2["[object Int16Array]"] = br2["[object Int32Array]"] = br2["[object Map]"] = br2["[object Number]"] = br2[mr] = br2["[object RegExp]"] = br2["[object Set]"] = br2["[object String]"] = br2["[object Symbol]"] = br2["[object Uint8Array]"] = br2["[object Uint8ClampedArray]"] = br2["[object Uint16Array]"] = br2["[object Uint32Array]"] = true, br2["[object Error]"] = br2[gr] = br2["[object WeakMap]"] = false;
          const yr = /* @__PURE__ */ __name(function t5(e5, n5, r4, s4, i4, o4) {
            var l4, a4 = 1 & n5, c4 = 2 & n5, u4 = 4 & n5;
            if (r4 && (l4 = i4 ? r4(e5, s4, i4, o4) : r4(e5)), void 0 !== l4)
              return l4;
            if (!S3(e5))
              return e5;
            var h4 = Ft(e5);
            if (h4) {
              if (l4 = tr(e5), !a4)
                return Ot(e5, l4);
            } else {
              var d4 = Yn(e5), f4 = d4 == gr || "[object GeneratorFunction]" == d4;
              if (Qt(e5))
                return qt(e5, a4);
              if (d4 == mr || d4 == pr || f4 && !i4) {
                if (l4 = c4 || f4 ? {} : Mt(e5), !a4)
                  return c4 ? jn(e5, An(l4, e5)) : Tn(e5, En(l4, e5));
              } else {
                if (!br2[d4])
                  return i4 ? e5 : {};
                l4 = lr(e5, d4, a4);
              }
            }
            o4 || (o4 = new mt());
            var p4 = o4.get(e5);
            if (p4)
              return p4;
            o4.set(e5, l4), fr(e5) ? e5.forEach(function(s5) {
              l4.add(t5(s5, n5, r4, s5, e5, o4));
            }) : ur(e5) && e5.forEach(function(s5, i5) {
              l4.set(i5, t5(s5, n5, r4, i5, e5, o4));
            });
            var g4 = h4 ? void 0 : (u4 ? c4 ? Mn : In : c4 ? qe : wn)(e5);
            return yn(g4 || e5, function(s5, i5) {
              g4 && (s5 = e5[i5 = s5]), ge(l4, i5, t5(s5, n5, r4, i5, e5, o4));
            }), l4;
          }, "t");
          const vr = /* @__PURE__ */ __name(function(t5) {
            return yr(t5, 5);
          }, "vr");
          const xr = /* @__PURE__ */ __name(function(t5) {
            return this.__data__.set(t5, "__lodash_hash_undefined__"), this;
          }, "xr");
          const Nr = /* @__PURE__ */ __name(function(t5) {
            return this.__data__.has(t5);
          }, "Nr");
          function wr(t5) {
            var e5 = -1, n5 = null == t5 ? 0 : t5.length;
            for (this.__data__ = new ft(); ++e5 < n5; )
              this.add(t5[e5]);
          }
          __name(wr, "wr");
          wr.prototype.add = wr.prototype.push = xr, wr.prototype.has = Nr;
          const Er = wr;
          const Ar = /* @__PURE__ */ __name(function(t5, e5) {
            for (var n5 = -1, r4 = null == t5 ? 0 : t5.length; ++n5 < r4; )
              if (e5(t5[n5], n5, t5))
                return true;
            return false;
          }, "Ar");
          const qr = /* @__PURE__ */ __name(function(t5, e5) {
            return t5.has(e5);
          }, "qr");
          const kr = /* @__PURE__ */ __name(function(t5, e5, n5, r4, s4, i4) {
            var o4 = 1 & n5, l4 = t5.length, a4 = e5.length;
            if (l4 != a4 && !(o4 && a4 > l4))
              return false;
            var c4 = i4.get(t5), u4 = i4.get(e5);
            if (c4 && u4)
              return c4 == e5 && u4 == t5;
            var h4 = -1, d4 = true, f4 = 2 & n5 ? new Er() : void 0;
            for (i4.set(t5, e5), i4.set(e5, t5); ++h4 < l4; ) {
              var p4 = t5[h4], g4 = e5[h4];
              if (r4)
                var m4 = o4 ? r4(g4, p4, h4, e5, t5, i4) : r4(p4, g4, h4, t5, e5, i4);
              if (void 0 !== m4) {
                if (m4)
                  continue;
                d4 = false;
                break;
              }
              if (f4) {
                if (!Ar(e5, function(t6, e6) {
                  if (!qr(f4, e6) && (p4 === t6 || s4(p4, t6, n5, r4, i4)))
                    return f4.push(e6);
                })) {
                  d4 = false;
                  break;
                }
              } else if (p4 !== g4 && !s4(p4, g4, n5, r4, i4)) {
                d4 = false;
                break;
              }
            }
            return i4.delete(t5), i4.delete(e5), d4;
          }, "kr");
          const _r = /* @__PURE__ */ __name(function(t5) {
            var e5 = -1, n5 = Array(t5.size);
            return t5.forEach(function(t6, r4) {
              n5[++e5] = [r4, t6];
            }), n5;
          }, "_r");
          const Lr = /* @__PURE__ */ __name(function(t5) {
            var e5 = -1, n5 = Array(t5.size);
            return t5.forEach(function(t6) {
              n5[++e5] = t6;
            }), n5;
          }, "Lr");
          var Or = N3 ? N3.prototype : void 0, Tr = Or ? Or.valueOf : void 0;
          const Sr = /* @__PURE__ */ __name(function(t5, e5, n5, r4, s4, o4, l4) {
            switch (n5) {
              case "[object DataView]":
                if (t5.byteLength != e5.byteLength || t5.byteOffset != e5.byteOffset)
                  return false;
                t5 = t5.buffer, e5 = e5.buffer;
              case "[object ArrayBuffer]":
                return !(t5.byteLength != e5.byteLength || !o4(new kt(t5), new kt(e5)));
              case "[object Boolean]":
              case "[object Date]":
              case "[object Number]":
                return i3(+t5, +e5);
              case "[object Error]":
                return t5.name == e5.name && t5.message == e5.message;
              case "[object RegExp]":
              case "[object String]":
                return t5 == e5 + "";
              case "[object Map]":
                var a4 = _r;
              case "[object Set]":
                var c4 = 1 & r4;
                if (a4 || (a4 = Lr), t5.size != e5.size && !c4)
                  return false;
                var u4 = l4.get(t5);
                if (u4)
                  return u4 == e5;
                r4 |= 2, l4.set(t5, e5);
                var h4 = kr(a4(t5), a4(e5), r4, s4, o4, l4);
                return l4.delete(t5), h4;
              case "[object Symbol]":
                if (Tr)
                  return Tr.call(t5) == Tr.call(e5);
            }
            return false;
          }, "Sr");
          var Cr = Object.prototype.hasOwnProperty;
          const jr = /* @__PURE__ */ __name(function(t5, e5, n5, r4, s4, i4) {
            var o4 = 1 & n5, l4 = In(t5), a4 = l4.length;
            if (a4 != In(e5).length && !o4)
              return false;
            for (var c4 = a4; c4--; ) {
              var u4 = l4[c4];
              if (!(o4 ? u4 in e5 : Cr.call(e5, u4)))
                return false;
            }
            var h4 = i4.get(t5), d4 = i4.get(e5);
            if (h4 && d4)
              return h4 == e5 && d4 == t5;
            var f4 = true;
            i4.set(t5, e5), i4.set(e5, t5);
            for (var p4 = o4; ++c4 < a4; ) {
              var g4 = t5[u4 = l4[c4]], m4 = e5[u4];
              if (r4)
                var b4 = o4 ? r4(m4, g4, u4, e5, t5, i4) : r4(g4, m4, u4, t5, e5, i4);
              if (!(void 0 === b4 ? g4 === m4 || s4(g4, m4, n5, r4, i4) : b4)) {
                f4 = false;
                break;
              }
              p4 || (p4 = "constructor" == u4);
            }
            if (f4 && !p4) {
              var y4 = t5.constructor, v5 = e5.constructor;
              y4 == v5 || !("constructor" in t5) || !("constructor" in e5) || "function" == typeof y4 && y4 instanceof y4 && "function" == typeof v5 && v5 instanceof v5 || (f4 = false);
            }
            return i4.delete(t5), i4.delete(e5), f4;
          }, "jr");
          var Rr = "[object Arguments]", Ir = "[object Array]", Mr = "[object Object]", Br = Object.prototype.hasOwnProperty;
          const Ur = /* @__PURE__ */ __name(function(t5, e5, n5, r4, s4, i4) {
            var o4 = Ft(t5), l4 = Ft(e5), a4 = o4 ? Ir : Yn(t5), c4 = l4 ? Ir : Yn(e5), u4 = (a4 = a4 == Rr ? Mr : a4) == Mr, h4 = (c4 = c4 == Rr ? Mr : c4) == Mr, d4 = a4 == c4;
            if (d4 && Qt(t5)) {
              if (!Qt(e5))
                return false;
              o4 = true, u4 = false;
            }
            if (d4 && !u4)
              return i4 || (i4 = new mt()), o4 || de(t5) ? kr(t5, e5, n5, r4, s4, i4) : Sr(t5, e5, a4, n5, r4, s4, i4);
            if (!(1 & n5)) {
              var f4 = u4 && Br.call(t5, "__wrapped__"), p4 = h4 && Br.call(e5, "__wrapped__");
              if (f4 || p4) {
                var g4 = f4 ? t5.value() : t5, m4 = p4 ? e5.value() : e5;
                return i4 || (i4 = new mt()), s4(g4, m4, n5, r4, i4);
              }
            }
            return !!d4 && (i4 || (i4 = new mt()), jr(t5, e5, n5, r4, s4, i4));
          }, "Ur");
          const Dr = /* @__PURE__ */ __name(function t5(e5, n5, r4, s4, i4) {
            return e5 === n5 || (null == e5 || null == n5 || !Bt(e5) && !Bt(n5) ? e5 != e5 && n5 != n5 : Ur(e5, n5, r4, s4, t5, i4));
          }, "t");
          const Pr = /* @__PURE__ */ __name(function(t5, e5) {
            return Dr(t5, e5);
          }, "Pr");
          class zr extends hn {
            static {
              __name(this, "zr");
            }
            static value() {
            }
            optimize() {
              (this.prev || this.next) && this.remove();
            }
            length() {
              return 0;
            }
            value() {
              return "";
            }
          }
          zr.blotName = "break", zr.tagName = "BR";
          const Hr = zr;
          class Fr extends mn {
            static {
              __name(this, "Fr");
            }
          }
          function $r(t5) {
            return t5.replace(/[&<>"']/g, (t6) => ({ "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" })[t6]);
          }
          __name($r, "$r");
          class Vr extends on2 {
            static {
              __name(this, "Vr");
            }
            static allowedChildren = [Vr, Hr, hn, Fr];
            static order = ["cursor", "inline", "link", "underline", "strike", "italic", "bold", "script", "code"];
            static compare(t5, e5) {
              const n5 = Vr.order.indexOf(t5), r4 = Vr.order.indexOf(e5);
              return n5 >= 0 || r4 >= 0 ? n5 - r4 : t5 === e5 ? 0 : t5 < e5 ? -1 : 1;
            }
            formatAt(t5, e5, n5, r4) {
              if (Vr.compare(this.statics.blotName, n5) < 0 && this.scroll.query(n5, Pe.BLOT)) {
                const s4 = this.isolate(t5, e5);
                r4 && s4.wrap(n5, r4);
              } else
                super.formatAt(t5, e5, n5, r4);
            }
            optimize(t5) {
              if (super.optimize(t5), this.parent instanceof Vr && Vr.compare(this.statics.blotName, this.parent.statics.blotName) > 0) {
                const t6 = this.parent.isolate(this.offset(), this.length());
                this.moveChildren(t6), t6.wrap(this);
              }
            }
          }
          const Kr = Vr;
          class Wr extends an2 {
            static {
              __name(this, "Wr");
            }
            cache = {};
            delta() {
              return null == this.cache.delta && (this.cache.delta = Gr(this)), this.cache.delta;
            }
            deleteAt(t5, e5) {
              super.deleteAt(t5, e5), this.cache = {};
            }
            formatAt(t5, e5, n5, r4) {
              e5 <= 0 || (this.scroll.query(n5, Pe.BLOCK) ? t5 + e5 === this.length() && this.format(n5, r4) : super.formatAt(t5, Math.min(e5, this.length() - t5 - 1), n5, r4), this.cache = {});
            }
            insertAt(t5, e5, n5) {
              if (null != n5)
                return super.insertAt(t5, e5, n5), void (this.cache = {});
              if (0 === e5.length)
                return;
              const r4 = e5.split("\n"), s4 = r4.shift();
              s4.length > 0 && (t5 < this.length() - 1 || null == this.children.tail ? super.insertAt(Math.min(t5, this.length() - 1), s4) : this.children.tail.insertAt(this.children.tail.length(), s4), this.cache = {});
              let i4 = this;
              r4.reduce((t6, e6) => (i4 = i4.split(t6, true), i4.insertAt(0, e6), e6.length), t5 + s4.length);
            }
            insertBefore(t5, e5) {
              const { head: n5 } = this.children;
              super.insertBefore(t5, e5), n5 instanceof Hr && n5.remove(), this.cache = {};
            }
            length() {
              return null == this.cache.length && (this.cache.length = super.length() + 1), this.cache.length;
            }
            moveChildren(t5, e5) {
              super.moveChildren(t5, e5), this.cache = {};
            }
            optimize(t5) {
              super.optimize(t5), this.cache = {};
            }
            path(t5) {
              return super.path(t5, true);
            }
            removeChild(t5) {
              super.removeChild(t5), this.cache = {};
            }
            split(t5) {
              let e5 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
              if (e5 && (0 === t5 || t5 >= this.length() - 1)) {
                const e6 = this.clone();
                return 0 === t5 ? (this.parent.insertBefore(e6, this), this) : (this.parent.insertBefore(e6, this.next), e6);
              }
              const n5 = super.split(t5, e5);
              return this.cache = {}, n5;
            }
          }
          Wr.blotName = "block", Wr.tagName = "P", Wr.defaultChild = Hr, Wr.allowedChildren = [Hr, Kr, hn, Fr];
          class Zr extends hn {
            static {
              __name(this, "Zr");
            }
            attach() {
              super.attach(), this.attributes = new Ge(this.domNode);
            }
            delta() {
              return new bn2().insert(this.value(), { ...this.formats(), ...this.attributes.values() });
            }
            format(t5, e5) {
              const n5 = this.scroll.query(t5, Pe.BLOCK_ATTRIBUTE);
              null != n5 && this.attributes.attribute(n5, e5);
            }
            formatAt(t5, e5, n5, r4) {
              this.format(n5, r4);
            }
            insertAt(t5, e5, n5) {
              if (null != n5)
                return void super.insertAt(t5, e5, n5);
              const r4 = e5.split("\n"), s4 = r4.pop(), i4 = r4.map((t6) => {
                const e6 = this.scroll.create(Wr.blotName);
                return e6.insertAt(0, t6), e6;
              }), o4 = this.split(t5);
              i4.forEach((t6) => {
                this.parent.insertBefore(t6, o4);
              }), s4 && this.parent.insertBefore(this.scroll.create("text", s4), o4);
            }
          }
          function Gr(t5) {
            let e5 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
            return t5.descendants(Je).reduce((t6, n5) => 0 === n5.length() ? t6 : t6.insert(n5.value(), Xr(n5, {}, e5)), new bn2()).insert("\n", Xr(t5));
          }
          __name(Gr, "Gr");
          function Xr(t5) {
            let e5 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, n5 = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
            return null == t5 ? e5 : ("formats" in t5 && "function" == typeof t5.formats && (e5 = { ...e5, ...t5.formats() }, n5 && delete e5["code-token"]), null == t5.parent || "scroll" === t5.parent.statics.blotName || t5.parent.statics.scope !== t5.statics.scope ? e5 : Xr(t5.parent, e5, n5));
          }
          __name(Xr, "Xr");
          Zr.scope = Pe.BLOCK_BLOT;
          class Qr extends hn {
            static {
              __name(this, "Qr");
            }
            static blotName = "cursor";
            static className = "ql-cursor";
            static tagName = "span";
            static CONTENTS = "\uFEFF";
            static value() {
            }
            constructor(t5, e5, n5) {
              super(t5, e5), this.selection = n5, this.textNode = document.createTextNode(Qr.CONTENTS), this.domNode.appendChild(this.textNode), this.savedLength = 0;
            }
            detach() {
              null != this.parent && this.parent.removeChild(this);
            }
            format(t5, e5) {
              if (0 !== this.savedLength)
                return void super.format(t5, e5);
              let n5 = this, r4 = 0;
              for (; null != n5 && n5.statics.scope !== Pe.BLOCK_BLOT; )
                r4 += n5.offset(n5.parent), n5 = n5.parent;
              null != n5 && (this.savedLength = Qr.CONTENTS.length, n5.optimize(), n5.formatAt(r4, Qr.CONTENTS.length, t5, e5), this.savedLength = 0);
            }
            index(t5, e5) {
              return t5 === this.textNode ? 0 : super.index(t5, e5);
            }
            length() {
              return this.savedLength;
            }
            position() {
              return [this.textNode, this.textNode.data.length];
            }
            remove() {
              super.remove(), this.parent = null;
            }
            restore() {
              if (this.selection.composing || null == this.parent)
                return null;
              const t5 = this.selection.getNativeRange();
              for (; null != this.domNode.lastChild && this.domNode.lastChild !== this.textNode; )
                this.domNode.parentNode.insertBefore(this.domNode.lastChild, this.domNode);
              const e5 = this.prev instanceof Fr ? this.prev : null, n5 = e5 ? e5.length() : 0, r4 = this.next instanceof Fr ? this.next : null, s4 = r4 ? r4.text : "", { textNode: i4 } = this, o4 = i4.data.split(Qr.CONTENTS).join("");
              let l4;
              if (i4.data = Qr.CONTENTS, e5)
                l4 = e5, (o4 || r4) && (e5.insertAt(e5.length(), o4 + s4), r4 && r4.remove());
              else if (r4)
                l4 = r4, r4.insertAt(0, o4);
              else {
                const t6 = document.createTextNode(o4);
                l4 = this.scroll.create(t6), this.parent.insertBefore(l4, this);
              }
              if (this.remove(), t5) {
                const s5 = /* @__PURE__ */ __name((t6, s6) => e5 && t6 === e5.domNode ? s6 : t6 === i4 ? n5 + s6 - 1 : r4 && t6 === r4.domNode ? n5 + o4.length + s6 : null, "s"), a4 = s5(t5.start.node, t5.start.offset), c4 = s5(t5.end.node, t5.end.offset);
                if (null !== a4 && null !== c4)
                  return { startNode: l4.domNode, startOffset: a4, endNode: l4.domNode, endOffset: c4 };
              }
              return null;
            }
            update(t5, e5) {
              if (t5.some((t6) => "characterData" === t6.type && t6.target === this.textNode)) {
                const t6 = this.restore();
                t6 && (e5.range = t6);
              }
            }
            optimize(t5) {
              super.optimize(t5);
              let { parent: e5 } = this;
              for (; e5; ) {
                if ("A" === e5.domNode.tagName) {
                  this.savedLength = Qr.CONTENTS.length, e5.isolate(this.offset(e5), this.length()).unwrap(), this.savedLength = 0;
                  break;
                }
                e5 = e5.parent;
              }
            }
            value() {
              return "";
            }
          }
          const Yr = Qr;
          var Jr = n4(228);
          const ts = /* @__PURE__ */ new WeakMap(), es = ["error", "warn", "log", "info"];
          let ns = "warn";
          function rs(t5) {
            if (ns && es.indexOf(t5) <= es.indexOf(ns)) {
              for (var e5 = arguments.length, n5 = new Array(e5 > 1 ? e5 - 1 : 0), r4 = 1; r4 < e5; r4++)
                n5[r4 - 1] = arguments[r4];
              console[t5](...n5);
            }
          }
          __name(rs, "rs");
          function ss(t5) {
            return es.reduce((e5, n5) => (e5[n5] = rs.bind(console, n5, t5), e5), {});
          }
          __name(ss, "ss");
          ss.level = (t5) => {
            ns = t5;
          }, rs.level = ss.level;
          const is2 = ss, os = is2("quill:events");
          ["selectionchange", "mousedown", "mouseup", "click"].forEach((t5) => {
            document.addEventListener(t5, function() {
              for (var t6 = arguments.length, e5 = new Array(t6), n5 = 0; n5 < t6; n5++)
                e5[n5] = arguments[n5];
              Array.from(document.querySelectorAll(".ql-container")).forEach((t7) => {
                const n6 = ts.get(t7);
                n6 && n6.emitter && n6.emitter.handleDOM(...e5);
              });
            });
          });
          const ls = class extends Jr {
            static {
              __name(this, "ls");
            }
            static events = { EDITOR_CHANGE: "editor-change", SCROLL_BEFORE_UPDATE: "scroll-before-update", SCROLL_BLOT_MOUNT: "scroll-blot-mount", SCROLL_BLOT_UNMOUNT: "scroll-blot-unmount", SCROLL_OPTIMIZE: "scroll-optimize", SCROLL_UPDATE: "scroll-update", SCROLL_EMBED_UPDATE: "scroll-embed-update", SELECTION_CHANGE: "selection-change", TEXT_CHANGE: "text-change", COMPOSITION_BEFORE_START: "composition-before-start", COMPOSITION_START: "composition-start", COMPOSITION_BEFORE_END: "composition-before-end", COMPOSITION_END: "composition-end" };
            static sources = { API: "api", SILENT: "silent", USER: "user" };
            constructor() {
              super(), this.domListeners = {}, this.on("error", os.error);
            }
            emit() {
              for (var t5 = arguments.length, e5 = new Array(t5), n5 = 0; n5 < t5; n5++)
                e5[n5] = arguments[n5];
              return os.log.call(os, ...e5), super.emit(...e5);
            }
            handleDOM(t5) {
              for (var e5 = arguments.length, n5 = new Array(e5 > 1 ? e5 - 1 : 0), r4 = 1; r4 < e5; r4++)
                n5[r4 - 1] = arguments[r4];
              (this.domListeners[t5.type] || []).forEach((e6) => {
                let { node: r5, handler: s4 } = e6;
                (t5.target === r5 || r5.contains(t5.target)) && s4(t5, ...n5);
              });
            }
            listenDOM(t5, e5, n5) {
              this.domListeners[t5] || (this.domListeners[t5] = []), this.domListeners[t5].push({ node: e5, handler: n5 });
            }
          }, as2 = is2("quill:selection");
          class cs2 {
            static {
              __name(this, "cs");
            }
            constructor(t5) {
              let e5 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
              this.index = t5, this.length = e5;
            }
          }
          function us(t5, e5) {
            try {
              e5.parentNode;
            } catch (t6) {
              return false;
            }
            return t5.contains(e5);
          }
          __name(us, "us");
          const hs = class {
            static {
              __name(this, "hs");
            }
            constructor(t5, e5) {
              this.emitter = e5, this.scroll = t5, this.composing = false, this.mouseDown = false, this.root = this.scroll.domNode, this.cursor = this.scroll.create("cursor", this), this.savedRange = new cs2(0, 0), this.lastRange = this.savedRange, this.lastNative = null, this.handleComposition(), this.handleDragging(), this.emitter.listenDOM("selectionchange", document, () => {
                this.mouseDown || this.composing || setTimeout(this.update.bind(this, ls.sources.USER), 1);
              }), this.emitter.on(ls.events.SCROLL_BEFORE_UPDATE, () => {
                if (!this.hasFocus())
                  return;
                const t6 = this.getNativeRange();
                null != t6 && t6.start.node !== this.cursor.textNode && this.emitter.once(ls.events.SCROLL_UPDATE, (e6, n5) => {
                  try {
                    this.root.contains(t6.start.node) && this.root.contains(t6.end.node) && this.setNativeRange(t6.start.node, t6.start.offset, t6.end.node, t6.end.offset);
                    const r4 = n5.some((t7) => "characterData" === t7.type || "childList" === t7.type || "attributes" === t7.type && t7.target === this.root);
                    this.update(r4 ? ls.sources.SILENT : e6);
                  } catch (t7) {
                  }
                });
              }), this.emitter.on(ls.events.SCROLL_OPTIMIZE, (t6, e6) => {
                if (e6.range) {
                  const { startNode: t7, startOffset: n5, endNode: r4, endOffset: s4 } = e6.range;
                  this.setNativeRange(t7, n5, r4, s4), this.update(ls.sources.SILENT);
                }
              }), this.update(ls.sources.SILENT);
            }
            handleComposition() {
              this.emitter.on(ls.events.COMPOSITION_BEFORE_START, () => {
                this.composing = true;
              }), this.emitter.on(ls.events.COMPOSITION_END, () => {
                if (this.composing = false, this.cursor.parent) {
                  const t5 = this.cursor.restore();
                  if (!t5)
                    return;
                  setTimeout(() => {
                    this.setNativeRange(t5.startNode, t5.startOffset, t5.endNode, t5.endOffset);
                  }, 1);
                }
              });
            }
            handleDragging() {
              this.emitter.listenDOM("mousedown", document.body, () => {
                this.mouseDown = true;
              }), this.emitter.listenDOM("mouseup", document.body, () => {
                this.mouseDown = false, this.update(ls.sources.USER);
              });
            }
            focus() {
              this.hasFocus() || (this.root.focus({ preventScroll: true }), this.setRange(this.savedRange));
            }
            format(t5, e5) {
              this.scroll.update();
              const n5 = this.getNativeRange();
              if (null != n5 && n5.native.collapsed && !this.scroll.query(t5, Pe.BLOCK)) {
                if (n5.start.node !== this.cursor.textNode) {
                  const t6 = this.scroll.find(n5.start.node, false);
                  if (null == t6)
                    return;
                  if (t6 instanceof Je) {
                    const e6 = t6.split(n5.start.offset);
                    t6.parent.insertBefore(this.cursor, e6);
                  } else
                    t6.insertBefore(this.cursor, n5.start.node);
                  this.cursor.attach();
                }
                this.cursor.format(t5, e5), this.scroll.optimize(), this.setNativeRange(this.cursor.textNode, this.cursor.textNode.data.length), this.update();
              }
            }
            getBounds(t5) {
              let e5 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
              const n5 = this.scroll.length();
              let r4;
              t5 = Math.min(t5, n5 - 1), e5 = Math.min(t5 + e5, n5 - 1) - t5;
              let [s4, i4] = this.scroll.leaf(t5);
              if (null == s4)
                return null;
              if (e5 > 0 && i4 === s4.length()) {
                const [e6] = this.scroll.leaf(t5 + 1);
                if (e6) {
                  const [n6] = this.scroll.line(t5), [r5] = this.scroll.line(t5 + 1);
                  n6 === r5 && (s4 = e6, i4 = 0);
                }
              }
              [r4, i4] = s4.position(i4, true);
              const o4 = document.createRange();
              if (e5 > 0)
                return o4.setStart(r4, i4), [s4, i4] = this.scroll.leaf(t5 + e5), null == s4 ? null : ([r4, i4] = s4.position(i4, true), o4.setEnd(r4, i4), o4.getBoundingClientRect());
              let l4, a4 = "left";
              if (r4 instanceof Text) {
                if (!r4.data.length)
                  return null;
                i4 < r4.data.length ? (o4.setStart(r4, i4), o4.setEnd(r4, i4 + 1)) : (o4.setStart(r4, i4 - 1), o4.setEnd(r4, i4), a4 = "right"), l4 = o4.getBoundingClientRect();
              } else {
                if (!(s4.domNode instanceof Element))
                  return null;
                l4 = s4.domNode.getBoundingClientRect(), i4 > 0 && (a4 = "right");
              }
              return { bottom: l4.top + l4.height, height: l4.height, left: l4[a4], right: l4[a4], top: l4.top, width: 0 };
            }
            getNativeRange() {
              const t5 = document.getSelection();
              if (null == t5 || t5.rangeCount <= 0)
                return null;
              const e5 = t5.getRangeAt(0);
              if (null == e5)
                return null;
              const n5 = this.normalizeNative(e5);
              return as2.info("getNativeRange", n5), n5;
            }
            getRange() {
              const t5 = this.scroll.domNode;
              if ("isConnected" in t5 && !t5.isConnected)
                return [null, null];
              const e5 = this.getNativeRange();
              if (null == e5)
                return [null, null];
              return [this.normalizedToRange(e5), e5];
            }
            hasFocus() {
              return document.activeElement === this.root || null != document.activeElement && us(this.root, document.activeElement);
            }
            normalizedToRange(t5) {
              const e5 = [[t5.start.node, t5.start.offset]];
              t5.native.collapsed || e5.push([t5.end.node, t5.end.offset]);
              const n5 = e5.map((t6) => {
                const [e6, n6] = t6, r5 = this.scroll.find(e6, true), s5 = r5.offset(this.scroll);
                return 0 === n6 ? s5 : r5 instanceof Je ? s5 + r5.index(e6, n6) : s5 + r5.length();
              }), r4 = Math.min(Math.max(...n5), this.scroll.length() - 1), s4 = Math.min(r4, ...n5);
              return new cs2(s4, r4 - s4);
            }
            normalizeNative(t5) {
              if (!us(this.root, t5.startContainer) || !t5.collapsed && !us(this.root, t5.endContainer))
                return null;
              const e5 = { start: { node: t5.startContainer, offset: t5.startOffset }, end: { node: t5.endContainer, offset: t5.endOffset }, native: t5 };
              return [e5.start, e5.end].forEach((t6) => {
                let { node: e6, offset: n5 } = t6;
                for (; !(e6 instanceof Text) && e6.childNodes.length > 0; )
                  if (e6.childNodes.length > n5)
                    e6 = e6.childNodes[n5], n5 = 0;
                  else {
                    if (e6.childNodes.length !== n5)
                      break;
                    e6 = e6.lastChild, n5 = e6 instanceof Text ? e6.data.length : e6.childNodes.length > 0 ? e6.childNodes.length : e6.childNodes.length + 1;
                  }
                t6.node = e6, t6.offset = n5;
              }), e5;
            }
            rangeToNative(t5) {
              const e5 = this.scroll.length(), n5 = /* @__PURE__ */ __name((t6, n6) => {
                t6 = Math.min(e5 - 1, t6);
                const [r4, s4] = this.scroll.leaf(t6);
                return r4 ? r4.position(s4, n6) : [null, -1];
              }, "n");
              return [...n5(t5.index, false), ...n5(t5.index + t5.length, true)];
            }
            setNativeRange(t5, e5) {
              let n5 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : t5, r4 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : e5, s4 = arguments.length > 4 && void 0 !== arguments[4] && arguments[4];
              if (as2.info("setNativeRange", t5, e5, n5, r4), null != t5 && (null == this.root.parentNode || null == t5.parentNode || null == n5.parentNode))
                return;
              const i4 = document.getSelection();
              if (null != i4)
                if (null != t5) {
                  this.hasFocus() || this.root.focus({ preventScroll: true });
                  const { native: o4 } = this.getNativeRange() || {};
                  if (null == o4 || s4 || t5 !== o4.startContainer || e5 !== o4.startOffset || n5 !== o4.endContainer || r4 !== o4.endOffset) {
                    t5 instanceof Element && "BR" === t5.tagName && (e5 = Array.from(t5.parentNode.childNodes).indexOf(t5), t5 = t5.parentNode), n5 instanceof Element && "BR" === n5.tagName && (r4 = Array.from(n5.parentNode.childNodes).indexOf(n5), n5 = n5.parentNode);
                    const s5 = document.createRange();
                    s5.setStart(t5, e5), s5.setEnd(n5, r4), i4.removeAllRanges(), i4.addRange(s5);
                  }
                } else
                  i4.removeAllRanges(), this.root.blur();
            }
            setRange(t5) {
              let e5 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], n5 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : ls.sources.API;
              if ("string" == typeof e5 && (n5 = e5, e5 = false), as2.info("setRange", t5), null != t5) {
                const n6 = this.rangeToNative(t5);
                this.setNativeRange(...n6, e5);
              } else
                this.setNativeRange(null);
              this.update(n5);
            }
            update() {
              let t5 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ls.sources.USER;
              const e5 = this.lastRange, [n5, r4] = this.getRange();
              if (this.lastRange = n5, this.lastNative = r4, null != this.lastRange && (this.savedRange = this.lastRange), !Pr(e5, this.lastRange)) {
                if (!this.composing && null != r4 && r4.native.collapsed && r4.start.node !== this.cursor.textNode) {
                  const t6 = this.cursor.restore();
                  t6 && this.setNativeRange(t6.startNode, t6.startOffset, t6.endNode, t6.endOffset);
                }
                const n6 = [ls.events.SELECTION_CHANGE, vr(this.lastRange), vr(e5), t5];
                this.emitter.emit(ls.events.EDITOR_CHANGE, ...n6), t5 !== ls.sources.SILENT && this.emitter.emit(...n6);
              }
            }
          }, ds = /^[ -~]*$/;
          function fs(t5, e5, n5) {
            if (0 === t5.length) {
              const [t6] = ms(n5.pop());
              return e5 <= 0 ? `</li></${t6}>` : `</li></${t6}>${fs([], e5 - 1, n5)}`;
            }
            const [{ child: r4, offset: s4, length: i4, indent: o4, type: l4 }, ...a4] = t5, [c4, u4] = ms(l4);
            if (o4 > e5)
              return n5.push(l4), o4 === e5 + 1 ? `<${c4}><li${u4}>${ps(r4, s4, i4)}${fs(a4, o4, n5)}` : `<${c4}><li>${fs(t5, e5 + 1, n5)}`;
            const h4 = n5[n5.length - 1];
            if (o4 === e5 && l4 === h4)
              return `</li><li${u4}>${ps(r4, s4, i4)}${fs(a4, o4, n5)}`;
            const [d4] = ms(n5.pop());
            return `</li></${d4}>${fs(t5, e5 - 1, n5)}`;
          }
          __name(fs, "fs");
          function ps(t5, e5, n5) {
            let r4 = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
            if ("html" in t5 && "function" == typeof t5.html)
              return t5.html(e5, n5);
            if (t5 instanceof Fr)
              return $r(t5.value().slice(e5, e5 + n5));
            if (t5 instanceof rn) {
              if ("list-container" === t5.statics.blotName) {
                const r5 = [];
                return t5.children.forEachAt(e5, n5, (t6, e6, n6) => {
                  const s5 = "formats" in t6 && "function" == typeof t6.formats ? t6.formats() : {};
                  r5.push({ child: t6, offset: e6, length: n6, indent: s5.indent || 0, type: s5.list });
                }), fs(r5, -1, []);
              }
              const s4 = [];
              if (t5.children.forEachAt(e5, n5, (t6, e6, n6) => {
                s4.push(ps(t6, e6, n6));
              }), r4 || "list" === t5.statics.blotName)
                return s4.join("");
              const { outerHTML: i4, innerHTML: o4 } = t5.domNode, [l4, a4] = i4.split(`>${o4}<`);
              return "<table" === l4 ? `<table style="border: 1px solid #000;">${s4.join("")}<${a4}` : `${l4}>${s4.join("")}<${a4}`;
            }
            return t5.domNode instanceof Element ? t5.domNode.outerHTML : "";
          }
          __name(ps, "ps");
          function gs(t5, e5) {
            return Object.keys(e5).reduce((n5, r4) => {
              if (null == t5[r4])
                return n5;
              const s4 = e5[r4];
              return s4 === t5[r4] ? n5[r4] = s4 : Array.isArray(s4) ? s4.indexOf(t5[r4]) < 0 ? n5[r4] = s4.concat([t5[r4]]) : n5[r4] = s4 : n5[r4] = [s4, t5[r4]], n5;
            }, {});
          }
          __name(gs, "gs");
          function ms(t5) {
            const e5 = "ordered" === t5 ? "ol" : "ul";
            switch (t5) {
              case "checked":
                return [e5, ' data-list="checked"'];
              case "unchecked":
                return [e5, ' data-list="unchecked"'];
              default:
                return [e5, ""];
            }
          }
          __name(ms, "ms");
          function bs2(t5) {
            return t5.reduce((t6, e5) => {
              if ("string" == typeof e5.insert) {
                const n5 = e5.insert.replace(/\r\n/g, "\n").replace(/\r/g, "\n");
                return t6.insert(n5, e5.attributes);
              }
              return t6.push(e5);
            }, new bn2());
          }
          __name(bs2, "bs");
          function ys(t5, e5) {
            let { index: n5, length: r4 } = t5;
            return new cs2(n5 + e5, r4);
          }
          __name(ys, "ys");
          const vs = class {
            static {
              __name(this, "vs");
            }
            constructor(t5) {
              this.scroll = t5, this.delta = this.getDelta();
            }
            applyDelta(t5) {
              this.scroll.update();
              let e5 = this.scroll.length();
              this.scroll.batchStart();
              const n5 = bs2(t5), r4 = new bn2();
              return function(t6) {
                const e6 = [];
                return t6.forEach((t7) => {
                  if ("string" == typeof t7.insert) {
                    t7.insert.split("\n").forEach((n6, r5) => {
                      r5 && e6.push({ insert: "\n", attributes: t7.attributes }), n6 && e6.push({ insert: n6, attributes: t7.attributes });
                    });
                  } else
                    e6.push(t7);
                }), e6;
              }(n5.ops.slice()).reduce((t6, n6) => {
                const s4 = bn2.Op.length(n6);
                let i4 = n6.attributes || {}, o4 = false, l4 = false;
                if (null != n6.insert) {
                  if (r4.retain(s4), "string" == typeof n6.insert) {
                    const r5 = n6.insert;
                    l4 = !r5.endsWith("\n") && (e5 <= t6 || !!this.scroll.descendant(Zr, t6)[0]), this.scroll.insertAt(t6, r5);
                    const [s5, o5] = this.scroll.line(t6);
                    let a5 = De({}, Xr(s5));
                    if (s5 instanceof Wr) {
                      const [t7] = s5.descendant(Je, o5);
                      t7 && (a5 = De(a5, Xr(t7)));
                    }
                    i4 = bn2.AttributeMap.diff(a5, i4) || {};
                  } else if ("object" == typeof n6.insert) {
                    const r5 = Object.keys(n6.insert)[0];
                    if (null == r5)
                      return t6;
                    const s5 = null != this.scroll.query(r5, Pe.INLINE);
                    if (s5)
                      (e5 <= t6 || this.scroll.descendant(Zr, t6)[0]) && (l4 = true);
                    else if (t6 > 0) {
                      const [e6, n7] = this.scroll.descendant(Je, t6 - 1);
                      if (e6 instanceof Fr) {
                        "\n" !== e6.value()[n7] && (o4 = true);
                      } else
                        e6 instanceof hn && e6.statics.scope === Pe.INLINE_BLOT && (o4 = true);
                    }
                    if (this.scroll.insertAt(t6, r5, n6.insert[r5]), s5) {
                      const [e6] = this.scroll.descendant(Je, t6);
                      if (e6) {
                        const t7 = De({}, Xr(e6));
                        i4 = bn2.AttributeMap.diff(t7, i4) || {};
                      }
                    }
                  }
                  e5 += s4;
                } else if (r4.push(n6), null !== n6.retain && "object" == typeof n6.retain) {
                  const e6 = Object.keys(n6.retain)[0];
                  if (null == e6)
                    return t6;
                  this.scroll.updateEmbedAt(t6, e6, n6.retain[e6]);
                }
                Object.keys(i4).forEach((e6) => {
                  this.scroll.formatAt(t6, s4, e6, i4[e6]);
                });
                const a4 = o4 ? 1 : 0, c4 = l4 ? 1 : 0;
                return e5 += a4 + c4, r4.retain(a4), r4.delete(c4), t6 + s4 + a4 + c4;
              }, 0), r4.reduce((t6, e6) => "number" == typeof e6.delete ? (this.scroll.deleteAt(t6, e6.delete), t6) : t6 + bn2.Op.length(e6), 0), this.scroll.batchEnd(), this.scroll.optimize(), this.update(n5);
            }
            deleteText(t5, e5) {
              return this.scroll.deleteAt(t5, e5), this.update(new bn2().retain(t5).delete(e5));
            }
            formatLine(t5, e5) {
              let n5 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
              this.scroll.update(), Object.keys(n5).forEach((r5) => {
                this.scroll.lines(t5, Math.max(e5, 1)).forEach((t6) => {
                  t6.format(r5, n5[r5]);
                });
              }), this.scroll.optimize();
              const r4 = new bn2().retain(t5).retain(e5, vr(n5));
              return this.update(r4);
            }
            formatText(t5, e5) {
              let n5 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
              Object.keys(n5).forEach((r5) => {
                this.scroll.formatAt(t5, e5, r5, n5[r5]);
              });
              const r4 = new bn2().retain(t5).retain(e5, vr(n5));
              return this.update(r4);
            }
            getContents(t5, e5) {
              return this.delta.slice(t5, t5 + e5);
            }
            getDelta() {
              return this.scroll.lines().reduce((t5, e5) => t5.concat(e5.delta()), new bn2());
            }
            getFormat(t5) {
              let e5 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, n5 = [], r4 = [];
              0 === e5 ? this.scroll.path(t5).forEach((t6) => {
                const [e6] = t6;
                e6 instanceof Wr ? n5.push(e6) : e6 instanceof Je && r4.push(e6);
              }) : (n5 = this.scroll.lines(t5, e5), r4 = this.scroll.descendants(Je, t5, e5));
              const [s4, i4] = [n5, r4].map((t6) => {
                const e6 = t6.shift();
                if (null == e6)
                  return {};
                let n6 = Xr(e6);
                for (; Object.keys(n6).length > 0; ) {
                  const e7 = t6.shift();
                  if (null == e7)
                    return n6;
                  n6 = gs(Xr(e7), n6);
                }
                return n6;
              });
              return { ...s4, ...i4 };
            }
            getHTML(t5, e5) {
              const [n5, r4] = this.scroll.line(t5);
              if (n5) {
                const s4 = n5.length();
                return !(n5.length() >= r4 + e5) || 0 === r4 && e5 === s4 ? ps(this.scroll, t5, e5, true) : ps(n5, r4, e5, true);
              }
              return "";
            }
            getText(t5, e5) {
              return this.getContents(t5, e5).filter((t6) => "string" == typeof t6.insert).map((t6) => t6.insert).join("");
            }
            insertContents(t5, e5) {
              const n5 = bs2(e5), r4 = new bn2().retain(t5).concat(n5);
              return this.scroll.insertContents(t5, n5), this.update(r4);
            }
            insertEmbed(t5, e5, n5) {
              return this.scroll.insertAt(t5, e5, n5), this.update(new bn2().retain(t5).insert({ [e5]: n5 }));
            }
            insertText(t5, e5) {
              let n5 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
              return e5 = e5.replace(/\r\n/g, "\n").replace(/\r/g, "\n"), this.scroll.insertAt(t5, e5), Object.keys(n5).forEach((r4) => {
                this.scroll.formatAt(t5, e5.length, r4, n5[r4]);
              }), this.update(new bn2().retain(t5).insert(e5, vr(n5)));
            }
            isBlank() {
              if (0 === this.scroll.children.length)
                return true;
              if (this.scroll.children.length > 1)
                return false;
              const t5 = this.scroll.children.head;
              if (t5?.statics.blotName !== Wr.blotName)
                return false;
              const e5 = t5;
              return !(e5.children.length > 1) && e5.children.head instanceof Hr;
            }
            removeFormat(t5, e5) {
              const n5 = this.getText(t5, e5), [r4, s4] = this.scroll.line(t5 + e5);
              let i4 = 0, o4 = new bn2();
              null != r4 && (i4 = r4.length() - s4, o4 = r4.delta().slice(s4, s4 + i4 - 1).insert("\n"));
              const l4 = this.getContents(t5, e5 + i4).diff(new bn2().insert(n5).concat(o4)), a4 = new bn2().retain(t5).concat(l4);
              return this.applyDelta(a4);
            }
            update(t5) {
              let e5 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [], n5 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : void 0;
              const r4 = this.delta;
              if (1 === e5.length && "characterData" === e5[0].type && e5[0].target.data.match(ds) && this.scroll.find(e5[0].target)) {
                const s4 = this.scroll.find(e5[0].target), i4 = Xr(s4), o4 = s4.offset(this.scroll), l4 = e5[0].oldValue.replace(Yr.CONTENTS, ""), a4 = new bn2().insert(l4), c4 = new bn2().insert(s4.value()), u4 = n5 && { oldRange: ys(n5.oldRange, -o4), newRange: ys(n5.newRange, -o4) };
                t5 = new bn2().retain(o4).concat(a4.diff(c4, u4)).reduce((t6, e6) => e6.insert ? t6.insert(e6.insert, i4) : t6.push(e6), new bn2()), this.delta = r4.compose(t5);
              } else
                this.delta = this.getDelta(), t5 && Pr(r4.compose(t5), this.delta) || (t5 = r4.diff(this.delta, n5));
              return t5;
            }
          };
          const xs = class {
            static {
              __name(this, "xs");
            }
            static DEFAULTS = {};
            constructor(t5) {
              let e5 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
              this.quill = t5, this.options = e5;
            }
          }, Ns = "\uFEFF";
          const ws = class extends hn {
            static {
              __name(this, "ws");
            }
            constructor(t5, e5) {
              super(t5, e5), this.contentNode = document.createElement("span"), this.contentNode.setAttribute("contenteditable", "false"), Array.from(this.domNode.childNodes).forEach((t6) => {
                this.contentNode.appendChild(t6);
              }), this.leftGuard = document.createTextNode(Ns), this.rightGuard = document.createTextNode(Ns), this.domNode.appendChild(this.leftGuard), this.domNode.appendChild(this.contentNode), this.domNode.appendChild(this.rightGuard);
            }
            index(t5, e5) {
              return t5 === this.leftGuard ? 0 : t5 === this.rightGuard ? 1 : super.index(t5, e5);
            }
            restore(t5) {
              let e5, n5 = null;
              const r4 = t5.data.split(Ns).join("");
              if (t5 === this.leftGuard)
                if (this.prev instanceof Fr) {
                  const t6 = this.prev.length();
                  this.prev.insertAt(t6, r4), n5 = { startNode: this.prev.domNode, startOffset: t6 + r4.length };
                } else
                  e5 = document.createTextNode(r4), this.parent.insertBefore(this.scroll.create(e5), this), n5 = { startNode: e5, startOffset: r4.length };
              else
                t5 === this.rightGuard && (this.next instanceof Fr ? (this.next.insertAt(0, r4), n5 = { startNode: this.next.domNode, startOffset: r4.length }) : (e5 = document.createTextNode(r4), this.parent.insertBefore(this.scroll.create(e5), this.next), n5 = { startNode: e5, startOffset: r4.length }));
              return t5.data = Ns, n5;
            }
            update(t5, e5) {
              t5.forEach((t6) => {
                if ("characterData" === t6.type && (t6.target === this.leftGuard || t6.target === this.rightGuard)) {
                  const n5 = this.restore(t6.target);
                  n5 && (e5.range = n5);
                }
              });
            }
          };
          const Es = class {
            static {
              __name(this, "Es");
            }
            isComposing = false;
            constructor(t5, e5) {
              this.scroll = t5, this.emitter = e5, this.setupListeners();
            }
            setupListeners() {
              this.scroll.domNode.addEventListener("compositionstart", (t5) => {
                this.isComposing || this.handleCompositionStart(t5);
              }), this.scroll.domNode.addEventListener("compositionend", (t5) => {
                this.isComposing && queueMicrotask(() => {
                  this.handleCompositionEnd(t5);
                });
              });
            }
            handleCompositionStart(t5) {
              const e5 = t5.target instanceof Node ? this.scroll.find(t5.target, true) : null;
              !e5 || e5 instanceof ws || (this.emitter.emit(ls.events.COMPOSITION_BEFORE_START, t5), this.scroll.batchStart(), this.emitter.emit(ls.events.COMPOSITION_START, t5), this.isComposing = true);
            }
            handleCompositionEnd(t5) {
              this.emitter.emit(ls.events.COMPOSITION_BEFORE_END, t5), this.scroll.batchEnd(), this.emitter.emit(ls.events.COMPOSITION_END, t5), this.isComposing = false;
            }
          };
          class As {
            static {
              __name(this, "As");
            }
            static DEFAULTS = { modules: {} };
            static themes = { default: As };
            modules = {};
            constructor(t5, e5) {
              this.quill = t5, this.options = e5;
            }
            init() {
              Object.keys(this.options.modules).forEach((t5) => {
                null == this.modules[t5] && this.addModule(t5);
              });
            }
            addModule(t5) {
              const e5 = this.quill.constructor.import(`modules/${t5}`);
              return this.modules[t5] = new e5(this.quill, this.options.modules[t5] || {}), this.modules[t5];
            }
          }
          const qs = As, ks = /* @__PURE__ */ __name((t5) => {
            const e5 = t5.getBoundingClientRect(), n5 = "offsetWidth" in t5 && Math.abs(e5.width) / t5.offsetWidth || 1, r4 = "offsetHeight" in t5 && Math.abs(e5.height) / t5.offsetHeight || 1;
            return { top: e5.top, right: e5.left + t5.clientWidth * n5, bottom: e5.top + t5.clientHeight * r4, left: e5.left };
          }, "ks"), _s2 = /* @__PURE__ */ __name((t5) => {
            const e5 = parseInt(t5, 10);
            return Number.isNaN(e5) ? 0 : e5;
          }, "_s"), Ls = /* @__PURE__ */ __name((t5, e5, n5, r4, s4, i4) => t5 < n5 && e5 > r4 ? 0 : t5 < n5 ? -(n5 - t5 + s4) : e5 > r4 ? e5 - t5 > r4 - n5 ? t5 + s4 - n5 : e5 - r4 + i4 : 0, "Ls"), Os = /* @__PURE__ */ __name((t5, e5) => {
            const n5 = t5.ownerDocument;
            let r4 = e5, s4 = t5;
            for (; s4; ) {
              const t6 = s4 === n5.body, e6 = t6 ? { top: 0, right: window.visualViewport?.width ?? n5.documentElement.clientWidth, bottom: window.visualViewport?.height ?? n5.documentElement.clientHeight, left: 0 } : ks(s4), o4 = getComputedStyle(s4), l4 = Ls(r4.left, r4.right, e6.left, e6.right, _s2(o4.scrollPaddingLeft), _s2(o4.scrollPaddingRight)), a4 = Ls(r4.top, r4.bottom, e6.top, e6.bottom, _s2(o4.scrollPaddingTop), _s2(o4.scrollPaddingBottom));
              if (l4 || a4)
                if (t6)
                  n5.defaultView?.scrollBy(l4, a4);
                else {
                  const { scrollLeft: t7, scrollTop: e7 } = s4;
                  a4 && (s4.scrollTop += a4), l4 && (s4.scrollLeft += l4);
                  const n6 = s4.scrollLeft - t7, i5 = s4.scrollTop - e7;
                  r4 = { left: r4.left - n6, top: r4.top - i5, right: r4.right - n6, bottom: r4.bottom - i5 };
                }
              s4 = t6 || "fixed" === o4.position ? null : (i4 = s4).parentElement || i4.getRootNode().host || null;
            }
            var i4;
          }, "Os"), Ts = ["block", "break", "cursor", "inline", "scroll", "text"], Ss = /* @__PURE__ */ __name((t5, e5, n5) => {
            const r4 = new $e();
            return Ts.forEach((t6) => {
              const n6 = e5.query(t6);
              n6 && r4.register(n6);
            }), t5.forEach((t6) => {
              let s4 = e5.query(t6);
              s4 || n5.error(`Cannot register "${t6}" specified in "formats" config. Are you sure it was registered?`);
              let i4 = 0;
              for (; s4; )
                if (r4.register(s4), s4 = "blotName" in s4 ? s4.requiredContainer ?? null : null, i4 += 1, i4 > 100) {
                  n5.error(`Cycle detected in registering blot requiredContainer: "${t6}"`);
                  break;
                }
            }), r4;
          }, "Ss"), Cs = is2("quill"), js = new $e();
          rn.uiClass = "ql-ui";
          class Rs {
            static {
              __name(this, "Rs");
            }
            static DEFAULTS = { bounds: null, modules: { clipboard: true, keyboard: true, history: true, uploader: true }, placeholder: "", readOnly: false, registry: js, theme: "default" };
            static events = ls.events;
            static sources = ls.sources;
            static version = "2.0.2";
            static imports = { delta: bn2, parchment: r3, "core/module": xs, "core/theme": qs };
            static debug(t5) {
              true === t5 && (t5 = "log"), is2.level(t5);
            }
            static find(t5) {
              let e5 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
              return ts.get(t5) || js.find(t5, e5);
            }
            static import(t5) {
              return null == this.imports[t5] && Cs.error(`Cannot import ${t5}. Are you sure it was registered?`), this.imports[t5];
            }
            static register() {
              if ("string" != typeof (arguments.length <= 0 ? void 0 : arguments[0])) {
                const t5 = arguments.length <= 0 ? void 0 : arguments[0], e5 = !!(arguments.length <= 1 ? void 0 : arguments[1]), n5 = "attrName" in t5 ? t5.attrName : t5.blotName;
                "string" == typeof n5 ? this.register(`formats/${n5}`, t5, e5) : Object.keys(t5).forEach((n6) => {
                  this.register(n6, t5[n6], e5);
                });
              } else {
                const t5 = arguments.length <= 0 ? void 0 : arguments[0], e5 = arguments.length <= 1 ? void 0 : arguments[1], n5 = !!(arguments.length <= 2 ? void 0 : arguments[2]);
                null == this.imports[t5] || n5 || Cs.warn(`Overwriting ${t5} with`, e5), this.imports[t5] = e5, (t5.startsWith("blots/") || t5.startsWith("formats/")) && e5 && "boolean" != typeof e5 && "abstract" !== e5.blotName && js.register(e5), "function" == typeof e5.register && e5.register(js);
              }
            }
            constructor(t5) {
              let e5 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
              if (this.options = function(t6, e6) {
                const n6 = Is(t6);
                if (!n6)
                  throw new Error("Invalid Quill container");
                const r5 = !e6.theme || e6.theme === Rs.DEFAULTS.theme, s5 = r5 ? qs : Rs.import(`themes/${e6.theme}`);
                if (!s5)
                  throw new Error(`Invalid theme ${e6.theme}. Did you register it?`);
                const { modules: i4, ...o4 } = Rs.DEFAULTS, { modules: l4, ...a4 } = s5.DEFAULTS;
                let c4 = Ms(e6.modules);
                null != c4 && c4.toolbar && c4.toolbar.constructor !== Object && (c4 = { ...c4, toolbar: { container: c4.toolbar } });
                const u4 = De({}, Ms(i4), Ms(l4), c4), h4 = { ...o4, ...Bs(a4), ...Bs(e6) };
                let d4 = e6.registry;
                d4 ? e6.formats && Cs.warn('Ignoring "formats" option because "registry" is specified') : d4 = e6.formats ? Ss(e6.formats, h4.registry, Cs) : h4.registry;
                return { ...h4, registry: d4, container: n6, theme: s5, modules: Object.entries(u4).reduce((t7, e7) => {
                  let [n7, r6] = e7;
                  if (!r6)
                    return t7;
                  const s6 = Rs.import(`modules/${n7}`);
                  return null == s6 ? (Cs.error(`Cannot load ${n7} module. Are you sure you registered it?`), t7) : { ...t7, [n7]: De({}, s6.DEFAULTS || {}, r6) };
                }, {}), bounds: Is(h4.bounds) };
              }(t5, e5), this.container = this.options.container, null == this.container)
                return void Cs.error("Invalid Quill container", t5);
              this.options.debug && Rs.debug(this.options.debug);
              const n5 = this.container.innerHTML.trim();
              this.container.classList.add("ql-container"), this.container.innerHTML = "", ts.set(this.container, this), this.root = this.addContainer("ql-editor"), this.root.classList.add("ql-blank"), this.emitter = new ls();
              const r4 = pn.blotName, s4 = this.options.registry.query(r4);
              if (!s4 || !("blotName" in s4))
                throw new Error(`Cannot initialize Quill without "${r4}" blot`);
              if (this.scroll = new s4(this.options.registry, this.root, { emitter: this.emitter }), this.editor = new vs(this.scroll), this.selection = new hs(this.scroll, this.emitter), this.composition = new Es(this.scroll, this.emitter), this.theme = new this.options.theme(this, this.options), this.keyboard = this.theme.addModule("keyboard"), this.clipboard = this.theme.addModule("clipboard"), this.history = this.theme.addModule("history"), this.uploader = this.theme.addModule("uploader"), this.theme.addModule("input"), this.theme.addModule("uiNode"), this.theme.init(), this.emitter.on(ls.events.EDITOR_CHANGE, (t6) => {
                t6 === ls.events.TEXT_CHANGE && this.root.classList.toggle("ql-blank", this.editor.isBlank());
              }), this.emitter.on(ls.events.SCROLL_UPDATE, (t6, e6) => {
                const n6 = this.selection.lastRange, [r5] = this.selection.getRange(), s5 = n6 && r5 ? { oldRange: n6, newRange: r5 } : void 0;
                Us.call(this, () => this.editor.update(null, e6, s5), t6);
              }), this.emitter.on(ls.events.SCROLL_EMBED_UPDATE, (t6, e6) => {
                const n6 = this.selection.lastRange, [r5] = this.selection.getRange(), s5 = n6 && r5 ? { oldRange: n6, newRange: r5 } : void 0;
                Us.call(this, () => {
                  const n7 = new bn2().retain(t6.offset(this)).retain({ [t6.statics.blotName]: e6 });
                  return this.editor.update(n7, [], s5);
                }, Rs.sources.USER);
              }), n5) {
                const t6 = this.clipboard.convert({ html: `${n5}<p><br></p>`, text: "\n" });
                this.setContents(t6);
              }
              this.history.clear(), this.options.placeholder && this.root.setAttribute("data-placeholder", this.options.placeholder), this.options.readOnly && this.disable(), this.allowReadOnlyEdits = false;
            }
            addContainer(t5) {
              let e5 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
              if ("string" == typeof t5) {
                const e6 = t5;
                (t5 = document.createElement("div")).classList.add(e6);
              }
              return this.container.insertBefore(t5, e5), t5;
            }
            blur() {
              this.selection.setRange(null);
            }
            deleteText(t5, e5, n5) {
              return [t5, e5, , n5] = Ds(t5, e5, n5), Us.call(this, () => this.editor.deleteText(t5, e5), n5, t5, -1 * e5);
            }
            disable() {
              this.enable(false);
            }
            editReadOnly(t5) {
              this.allowReadOnlyEdits = true;
              const e5 = t5();
              return this.allowReadOnlyEdits = false, e5;
            }
            enable() {
              let t5 = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
              this.scroll.enable(t5), this.container.classList.toggle("ql-disabled", !t5);
            }
            focus() {
              let t5 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
              this.selection.focus(), t5.preventScroll || this.scrollSelectionIntoView();
            }
            format(t5, e5) {
              let n5 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : ls.sources.API;
              return Us.call(this, () => {
                const n6 = this.getSelection(true);
                let r4 = new bn2();
                if (null == n6)
                  return r4;
                if (this.scroll.query(t5, Pe.BLOCK))
                  r4 = this.editor.formatLine(n6.index, n6.length, { [t5]: e5 });
                else {
                  if (0 === n6.length)
                    return this.selection.format(t5, e5), r4;
                  r4 = this.editor.formatText(n6.index, n6.length, { [t5]: e5 });
                }
                return this.setSelection(n6, ls.sources.SILENT), r4;
              }, n5);
            }
            formatLine(t5, e5, n5, r4, s4) {
              let i4;
              return [t5, e5, i4, s4] = Ds(t5, e5, n5, r4, s4), Us.call(this, () => this.editor.formatLine(t5, e5, i4), s4, t5, 0);
            }
            formatText(t5, e5, n5, r4, s4) {
              let i4;
              return [t5, e5, i4, s4] = Ds(t5, e5, n5, r4, s4), Us.call(this, () => this.editor.formatText(t5, e5, i4), s4, t5, 0);
            }
            getBounds(t5) {
              let e5 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, n5 = null;
              if (n5 = "number" == typeof t5 ? this.selection.getBounds(t5, e5) : this.selection.getBounds(t5.index, t5.length), !n5)
                return null;
              const r4 = this.container.getBoundingClientRect();
              return { bottom: n5.bottom - r4.top, height: n5.height, left: n5.left - r4.left, right: n5.right - r4.left, top: n5.top - r4.top, width: n5.width };
            }
            getContents() {
              let t5 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, e5 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.getLength() - t5;
              return [t5, e5] = Ds(t5, e5), this.editor.getContents(t5, e5);
            }
            getFormat() {
              let t5 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.getSelection(true), e5 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
              return "number" == typeof t5 ? this.editor.getFormat(t5, e5) : this.editor.getFormat(t5.index, t5.length);
            }
            getIndex(t5) {
              return t5.offset(this.scroll);
            }
            getLength() {
              return this.scroll.length();
            }
            getLeaf(t5) {
              return this.scroll.leaf(t5);
            }
            getLine(t5) {
              return this.scroll.line(t5);
            }
            getLines() {
              let t5 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, e5 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Number.MAX_VALUE;
              return "number" != typeof t5 ? this.scroll.lines(t5.index, t5.length) : this.scroll.lines(t5, e5);
            }
            getModule(t5) {
              return this.theme.modules[t5];
            }
            getSelection() {
              return arguments.length > 0 && void 0 !== arguments[0] && arguments[0] && this.focus(), this.update(), this.selection.getRange()[0];
            }
            getSemanticHTML() {
              let t5 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, e5 = arguments.length > 1 ? arguments[1] : void 0;
              return "number" == typeof t5 && (e5 = e5 ?? this.getLength() - t5), [t5, e5] = Ds(t5, e5), this.editor.getHTML(t5, e5);
            }
            getText() {
              let t5 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, e5 = arguments.length > 1 ? arguments[1] : void 0;
              return "number" == typeof t5 && (e5 = e5 ?? this.getLength() - t5), [t5, e5] = Ds(t5, e5), this.editor.getText(t5, e5);
            }
            hasFocus() {
              return this.selection.hasFocus();
            }
            insertEmbed(t5, e5, n5) {
              let r4 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : Rs.sources.API;
              return Us.call(this, () => this.editor.insertEmbed(t5, e5, n5), r4, t5);
            }
            insertText(t5, e5, n5, r4, s4) {
              let i4;
              return [t5, , i4, s4] = Ds(t5, 0, n5, r4, s4), Us.call(this, () => this.editor.insertText(t5, e5, i4), s4, t5, e5.length);
            }
            isEnabled() {
              return this.scroll.isEnabled();
            }
            off() {
              return this.emitter.off(...arguments);
            }
            on() {
              return this.emitter.on(...arguments);
            }
            once() {
              return this.emitter.once(...arguments);
            }
            removeFormat(t5, e5, n5) {
              return [t5, e5, , n5] = Ds(t5, e5, n5), Us.call(this, () => this.editor.removeFormat(t5, e5), n5, t5);
            }
            scrollRectIntoView(t5) {
              Os(this.root, t5);
            }
            scrollIntoView() {
              console.warn("Quill#scrollIntoView() has been deprecated and will be removed in the near future. Please use Quill#scrollSelectionIntoView() instead."), this.scrollSelectionIntoView();
            }
            scrollSelectionIntoView() {
              const t5 = this.selection.lastRange, e5 = t5 && this.selection.getBounds(t5.index, t5.length);
              e5 && this.scrollRectIntoView(e5);
            }
            setContents(t5) {
              let e5 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : ls.sources.API;
              return Us.call(this, () => {
                t5 = new bn2(t5);
                const e6 = this.getLength(), n5 = this.editor.deleteText(0, e6), r4 = this.editor.insertContents(0, t5), s4 = this.editor.deleteText(this.getLength() - 1, 1);
                return n5.compose(r4).compose(s4);
              }, e5);
            }
            setSelection(t5, e5, n5) {
              null == t5 ? this.selection.setRange(null, e5 || Rs.sources.API) : ([t5, e5, , n5] = Ds(t5, e5, n5), this.selection.setRange(new cs2(Math.max(0, t5), e5), n5), n5 !== ls.sources.SILENT && this.scrollSelectionIntoView());
            }
            setText(t5) {
              let e5 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : ls.sources.API;
              const n5 = new bn2().insert(t5);
              return this.setContents(n5, e5);
            }
            update() {
              let t5 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ls.sources.USER;
              const e5 = this.scroll.update(t5);
              return this.selection.update(t5), e5;
            }
            updateContents(t5) {
              let e5 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : ls.sources.API;
              return Us.call(this, () => (t5 = new bn2(t5), this.editor.applyDelta(t5)), e5, true);
            }
          }
          function Is(t5) {
            return "string" == typeof t5 ? document.querySelector(t5) : t5;
          }
          __name(Is, "Is");
          function Ms(t5) {
            return Object.entries(t5 ?? {}).reduce((t6, e5) => {
              let [n5, r4] = e5;
              return { ...t6, [n5]: true === r4 ? {} : r4 };
            }, {});
          }
          __name(Ms, "Ms");
          function Bs(t5) {
            return Object.fromEntries(Object.entries(t5).filter((t6) => void 0 !== t6[1]));
          }
          __name(Bs, "Bs");
          function Us(t5, e5, n5, r4) {
            if (!this.isEnabled() && e5 === ls.sources.USER && !this.allowReadOnlyEdits)
              return new bn2();
            let s4 = null == n5 ? null : this.getSelection();
            const i4 = this.editor.delta, o4 = t5();
            if (null != s4 && (true === n5 && (n5 = s4.index), null == r4 ? s4 = Ps(s4, o4, e5) : 0 !== r4 && (s4 = Ps(s4, n5, r4, e5)), this.setSelection(s4, ls.sources.SILENT)), o4.length() > 0) {
              const t6 = [ls.events.TEXT_CHANGE, o4, i4, e5];
              this.emitter.emit(ls.events.EDITOR_CHANGE, ...t6), e5 !== ls.sources.SILENT && this.emitter.emit(...t6);
            }
            return o4;
          }
          __name(Us, "Us");
          function Ds(t5, e5, n5, r4, s4) {
            let i4 = {};
            return "number" == typeof t5.index && "number" == typeof t5.length ? "number" != typeof e5 ? (s4 = r4, r4 = n5, n5 = e5, e5 = t5.length, t5 = t5.index) : (e5 = t5.length, t5 = t5.index) : "number" != typeof e5 && (s4 = r4, r4 = n5, n5 = e5, e5 = 0), "object" == typeof n5 ? (i4 = n5, s4 = r4) : "string" == typeof n5 && (null != r4 ? i4[n5] = r4 : s4 = n5), [t5, e5, i4, s4 = s4 || ls.sources.API];
          }
          __name(Ds, "Ds");
          function Ps(t5, e5, n5, r4) {
            const s4 = "number" == typeof n5 ? n5 : 0;
            if (null == t5)
              return null;
            let i4, o4;
            return e5 && "function" == typeof e5.transformPosition ? [i4, o4] = [t5.index, t5.index + t5.length].map((t6) => e5.transformPosition(t6, r4 !== ls.sources.USER)) : [i4, o4] = [t5.index, t5.index + t5.length].map((t6) => t6 < e5 || t6 === e5 && r4 === ls.sources.USER ? t6 : s4 >= 0 ? t6 + s4 : Math.max(e5, t6 + s4)), new cs2(i4, o4 - i4);
          }
          __name(Ps, "Ps");
          const zs = class extends un {
            static {
              __name(this, "zs");
            }
          };
          function Hs(t5) {
            return t5 instanceof Wr || t5 instanceof Zr;
          }
          __name(Hs, "Hs");
          function Fs(t5) {
            return "function" == typeof t5.updateContent;
          }
          __name(Fs, "Fs");
          function $s(t5, e5, n5) {
            n5.reduce((e6, n6) => {
              const r4 = bn2.Op.length(n6);
              let s4 = n6.attributes || {};
              if (null != n6.insert) {
                if ("string" == typeof n6.insert) {
                  const r5 = n6.insert;
                  t5.insertAt(e6, r5);
                  const [i4] = t5.descendant(Je, e6), o4 = Xr(i4);
                  s4 = bn2.AttributeMap.diff(o4, s4) || {};
                } else if ("object" == typeof n6.insert) {
                  const r5 = Object.keys(n6.insert)[0];
                  if (null == r5)
                    return e6;
                  t5.insertAt(e6, r5, n6.insert[r5]);
                  if (null != t5.scroll.query(r5, Pe.INLINE)) {
                    const [n7] = t5.descendant(Je, e6), r6 = Xr(n7);
                    s4 = bn2.AttributeMap.diff(r6, s4) || {};
                  }
                }
              }
              return Object.keys(s4).forEach((n7) => {
                t5.formatAt(e6, r4, n7, s4[n7]);
              }), e6 + r4;
            }, e5);
          }
          __name($s, "$s");
          const Vs = class extends pn {
            static {
              __name(this, "Vs");
            }
            static blotName = "scroll";
            static className = "ql-editor";
            static tagName = "DIV";
            static defaultChild = Wr;
            static allowedChildren = [Wr, Zr, zs];
            constructor(t5, e5, n5) {
              let { emitter: r4 } = n5;
              super(t5, e5), this.emitter = r4, this.batch = false, this.optimize(), this.enable(), this.domNode.addEventListener("dragstart", (t6) => this.handleDragStart(t6));
            }
            batchStart() {
              Array.isArray(this.batch) || (this.batch = []);
            }
            batchEnd() {
              if (!this.batch)
                return;
              const t5 = this.batch;
              this.batch = false, this.update(t5);
            }
            emitMount(t5) {
              this.emitter.emit(ls.events.SCROLL_BLOT_MOUNT, t5);
            }
            emitUnmount(t5) {
              this.emitter.emit(ls.events.SCROLL_BLOT_UNMOUNT, t5);
            }
            emitEmbedUpdate(t5, e5) {
              this.emitter.emit(ls.events.SCROLL_EMBED_UPDATE, t5, e5);
            }
            deleteAt(t5, e5) {
              const [n5, r4] = this.line(t5), [s4] = this.line(t5 + e5);
              if (super.deleteAt(t5, e5), null != s4 && n5 !== s4 && r4 > 0) {
                if (n5 instanceof Zr || s4 instanceof Zr)
                  return void this.optimize();
                const t6 = s4.children.head instanceof Hr ? null : s4.children.head;
                n5.moveChildren(s4, t6), n5.remove();
              }
              this.optimize();
            }
            enable() {
              let t5 = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
              this.domNode.setAttribute("contenteditable", t5 ? "true" : "false");
            }
            formatAt(t5, e5, n5, r4) {
              super.formatAt(t5, e5, n5, r4), this.optimize();
            }
            insertAt(t5, e5, n5) {
              if (t5 >= this.length())
                if (null == n5 || null == this.scroll.query(e5, Pe.BLOCK)) {
                  const t6 = this.scroll.create(this.statics.defaultChild.blotName);
                  this.appendChild(t6), null == n5 && e5.endsWith("\n") ? t6.insertAt(0, e5.slice(0, -1), n5) : t6.insertAt(0, e5, n5);
                } else {
                  const t6 = this.scroll.create(e5, n5);
                  this.appendChild(t6);
                }
              else
                super.insertAt(t5, e5, n5);
              this.optimize();
            }
            insertBefore(t5, e5) {
              if (t5.statics.scope === Pe.INLINE_BLOT) {
                const n5 = this.scroll.create(this.statics.defaultChild.blotName);
                n5.appendChild(t5), super.insertBefore(n5, e5);
              } else
                super.insertBefore(t5, e5);
            }
            insertContents(t5, e5) {
              const n5 = this.deltaToRenderBlocks(e5.concat(new bn2().insert("\n"))), r4 = n5.pop();
              if (null == r4)
                return;
              this.batchStart();
              const s4 = n5.shift();
              if (s4) {
                const e6 = "block" === s4.type && (0 === s4.delta.length() || !this.descendant(Zr, t5)[0] && t5 < this.length()), n6 = "block" === s4.type ? s4.delta : new bn2().insert({ [s4.key]: s4.value });
                $s(this, t5, n6);
                const r5 = "block" === s4.type ? 1 : 0, i5 = t5 + n6.length() + r5;
                e6 && this.insertAt(i5 - 1, "\n");
                const o5 = Xr(this.line(t5)[0]), l4 = bn2.AttributeMap.diff(o5, s4.attributes) || {};
                Object.keys(l4).forEach((t6) => {
                  this.formatAt(i5 - 1, 1, t6, l4[t6]);
                }), t5 = i5;
              }
              let [i4, o4] = this.children.find(t5);
              if (n5.length && (i4 && (i4 = i4.split(o4), o4 = 0), n5.forEach((t6) => {
                if ("block" === t6.type) {
                  $s(this.createBlock(t6.attributes, i4 || void 0), 0, t6.delta);
                } else {
                  const e6 = this.create(t6.key, t6.value);
                  this.insertBefore(e6, i4 || void 0), Object.keys(t6.attributes).forEach((n6) => {
                    e6.format(n6, t6.attributes[n6]);
                  });
                }
              })), "block" === r4.type && r4.delta.length()) {
                $s(this, i4 ? i4.offset(i4.scroll) + o4 : this.length(), r4.delta);
              }
              this.batchEnd(), this.optimize();
            }
            isEnabled() {
              return "true" === this.domNode.getAttribute("contenteditable");
            }
            leaf(t5) {
              const e5 = this.path(t5).pop();
              if (!e5)
                return [null, -1];
              const [n5, r4] = e5;
              return n5 instanceof Je ? [n5, r4] : [null, -1];
            }
            line(t5) {
              return t5 === this.length() ? this.line(t5 - 1) : this.descendant(Hs, t5);
            }
            lines() {
              let t5 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, e5 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Number.MAX_VALUE;
              const n5 = /* @__PURE__ */ __name((t6, e6, r4) => {
                let s4 = [], i4 = r4;
                return t6.children.forEachAt(e6, r4, (t7, e7, r5) => {
                  Hs(t7) ? s4.push(t7) : t7 instanceof un && (s4 = s4.concat(n5(t7, e7, i4))), i4 -= r5;
                }), s4;
              }, "n");
              return n5(this, t5, e5);
            }
            optimize() {
              let t5 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [], e5 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
              this.batch || (super.optimize(t5, e5), t5.length > 0 && this.emitter.emit(ls.events.SCROLL_OPTIMIZE, t5, e5));
            }
            path(t5) {
              return super.path(t5).slice(1);
            }
            remove() {
            }
            update(t5) {
              if (this.batch)
                return void (Array.isArray(t5) && (this.batch = this.batch.concat(t5)));
              let e5 = ls.sources.USER;
              "string" == typeof t5 && (e5 = t5), Array.isArray(t5) || (t5 = this.observer.takeRecords()), (t5 = t5.filter((t6) => {
                let { target: e6 } = t6;
                const n5 = this.find(e6, true);
                return n5 && !Fs(n5);
              })).length > 0 && this.emitter.emit(ls.events.SCROLL_BEFORE_UPDATE, e5, t5), super.update(t5.concat([])), t5.length > 0 && this.emitter.emit(ls.events.SCROLL_UPDATE, e5, t5);
            }
            updateEmbedAt(t5, e5, n5) {
              const [r4] = this.descendant((t6) => t6 instanceof Zr, t5);
              r4 && r4.statics.blotName === e5 && Fs(r4) && r4.updateContent(n5);
            }
            handleDragStart(t5) {
              t5.preventDefault();
            }
            deltaToRenderBlocks(t5) {
              const e5 = [];
              let n5 = new bn2();
              return t5.forEach((t6) => {
                const r4 = t6?.insert;
                if (r4)
                  if ("string" == typeof r4) {
                    const s4 = r4.split("\n");
                    s4.slice(0, -1).forEach((r5) => {
                      n5.insert(r5, t6.attributes), e5.push({ type: "block", delta: n5, attributes: t6.attributes ?? {} }), n5 = new bn2();
                    });
                    const i4 = s4[s4.length - 1];
                    i4 && n5.insert(i4, t6.attributes);
                  } else {
                    const s4 = Object.keys(r4)[0];
                    if (!s4)
                      return;
                    this.query(s4, Pe.INLINE) ? n5.push(t6) : (n5.length() && e5.push({ type: "block", delta: n5, attributes: {} }), n5 = new bn2(), e5.push({ type: "blockEmbed", key: s4, value: r4[s4], attributes: t6.attributes ?? {} }));
                  }
              }), n5.length() && e5.push({ type: "block", delta: n5, attributes: {} }), e5;
            }
            createBlock(t5, e5) {
              let n5;
              const r4 = {};
              Object.entries(t5).forEach((t6) => {
                let [e6, s5] = t6;
                null != this.query(e6, Pe.BLOCK & Pe.BLOT) ? n5 = e6 : r4[e6] = s5;
              });
              const s4 = this.create(n5 || this.statics.defaultChild.blotName, n5 ? t5[n5] : void 0);
              this.insertBefore(s4, e5 || void 0);
              const i4 = s4.length();
              return Object.entries(r4).forEach((t6) => {
                let [e6, n6] = t6;
                s4.formatAt(0, i4, e6, n6);
              }), s4;
            }
          }, Ks = { scope: Pe.BLOCK, whitelist: ["right", "center", "justify"] }, Ws = new ze("align", "align", Ks), Zs = new Ke("align", "ql-align", Ks), Gs = new Ze("align", "text-align", Ks);
          class Xs extends Ze {
            static {
              __name(this, "Xs");
            }
            value(t5) {
              let e5 = super.value(t5);
              if (!e5.startsWith("rgb("))
                return e5;
              e5 = e5.replace(/^[^\d]+/, "").replace(/[^\d]+$/, "");
              return `#${e5.split(",").map((t6) => `00${parseInt(t6, 10).toString(16)}`.slice(-2)).join("")}`;
            }
          }
          const Qs = new Ke("color", "ql-color", { scope: Pe.INLINE }), Ys = new Xs("color", "color", { scope: Pe.INLINE }), Js = new Ke("background", "ql-bg", { scope: Pe.INLINE }), ti = new Xs("background", "background-color", { scope: Pe.INLINE });
          class ei extends zs {
            static {
              __name(this, "ei");
            }
            static create(t5) {
              const e5 = super.create(t5);
              return e5.setAttribute("spellcheck", "false"), e5;
            }
            code(t5, e5) {
              return this.children.map((t6) => t6.length() <= 1 ? "" : t6.domNode.innerText).join("\n").slice(t5, t5 + e5);
            }
            html(t5, e5) {
              return `<pre>
${$r(this.code(t5, e5))}
</pre>`;
            }
          }
          class ni extends Wr {
            static {
              __name(this, "ni");
            }
            static TAB = "  ";
            static register() {
              Rs.register(ei);
            }
          }
          class ri extends Kr {
            static {
              __name(this, "ri");
            }
          }
          ri.blotName = "code", ri.tagName = "CODE", ni.blotName = "code-block", ni.className = "ql-code-block", ni.tagName = "DIV", ei.blotName = "code-block-container", ei.className = "ql-code-block-container", ei.tagName = "DIV", ei.allowedChildren = [ni], ni.allowedChildren = [Fr, Hr, Yr], ni.requiredContainer = ei;
          const si = { scope: Pe.BLOCK, whitelist: ["rtl"] }, ii2 = new ze("direction", "dir", si), oi = new Ke("direction", "ql-direction", si), li = new Ze("direction", "direction", si), ai2 = { scope: Pe.INLINE, whitelist: ["serif", "monospace"] }, ci2 = new Ke("font", "ql-font", ai2);
          const ui = new class extends Ze {
            value(t5) {
              return super.value(t5).replace(/["']/g, "");
            }
          }("font", "font-family", ai2), hi = new Ke("size", "ql-size", { scope: Pe.INLINE, whitelist: ["small", "large", "huge"] }), di = new Ze("size", "font-size", { scope: Pe.INLINE, whitelist: ["10px", "18px", "32px"] }), fi = is2("quill:keyboard"), pi = /Mac/i.test(navigator.platform) ? "metaKey" : "ctrlKey";
          class gi extends xs {
            static {
              __name(this, "gi");
            }
            static match(t5, e5) {
              return !["altKey", "ctrlKey", "metaKey", "shiftKey"].some((n5) => !!e5[n5] !== t5[n5] && null !== e5[n5]) && (e5.key === t5.key || e5.key === t5.which);
            }
            constructor(t5, e5) {
              super(t5, e5), this.bindings = {}, Object.keys(this.options.bindings).forEach((t6) => {
                this.options.bindings[t6] && this.addBinding(this.options.bindings[t6]);
              }), this.addBinding({ key: "Enter", shiftKey: null }, this.handleEnter), this.addBinding({ key: "Enter", metaKey: null, ctrlKey: null, altKey: null }, () => {
              }), /Firefox/i.test(navigator.userAgent) ? (this.addBinding({ key: "Backspace" }, { collapsed: true }, this.handleBackspace), this.addBinding({ key: "Delete" }, { collapsed: true }, this.handleDelete)) : (this.addBinding({ key: "Backspace" }, { collapsed: true, prefix: /^.?$/ }, this.handleBackspace), this.addBinding({ key: "Delete" }, { collapsed: true, suffix: /^.?$/ }, this.handleDelete)), this.addBinding({ key: "Backspace" }, { collapsed: false }, this.handleDeleteRange), this.addBinding({ key: "Delete" }, { collapsed: false }, this.handleDeleteRange), this.addBinding({ key: "Backspace", altKey: null, ctrlKey: null, metaKey: null, shiftKey: null }, { collapsed: true, offset: 0 }, this.handleBackspace), this.listen();
            }
            addBinding(t5) {
              let e5 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, n5 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
              const r4 = function(t6) {
                if ("string" == typeof t6 || "number" == typeof t6)
                  t6 = { key: t6 };
                else {
                  if ("object" != typeof t6)
                    return null;
                  t6 = vr(t6);
                }
                t6.shortKey && (t6[pi] = t6.shortKey, delete t6.shortKey);
                return t6;
              }(t5);
              if (null == r4)
                return void fi.warn("Attempted to add invalid keyboard binding", r4);
              "function" == typeof e5 && (e5 = { handler: e5 }), "function" == typeof n5 && (n5 = { handler: n5 });
              (Array.isArray(r4.key) ? r4.key : [r4.key]).forEach((t6) => {
                const s4 = { ...r4, key: t6, ...e5, ...n5 };
                this.bindings[s4.key] = this.bindings[s4.key] || [], this.bindings[s4.key].push(s4);
              });
            }
            listen() {
              this.quill.root.addEventListener("keydown", (t5) => {
                if (t5.defaultPrevented || t5.isComposing)
                  return;
                if (229 === t5.keyCode && ("Enter" === t5.key || "Backspace" === t5.key))
                  return;
                const e5 = (this.bindings[t5.key] || []).concat(this.bindings[t5.which] || []).filter((e6) => gi.match(t5, e6));
                if (0 === e5.length)
                  return;
                const n5 = Rs.find(t5.target, true);
                if (n5 && n5.scroll !== this.quill.scroll)
                  return;
                const r4 = this.quill.getSelection();
                if (null == r4 || !this.quill.hasFocus())
                  return;
                const [s4, i4] = this.quill.getLine(r4.index), [o4, l4] = this.quill.getLeaf(r4.index), [a4, c4] = 0 === r4.length ? [o4, l4] : this.quill.getLeaf(r4.index + r4.length), u4 = o4 instanceof mn ? o4.value().slice(0, l4) : "", h4 = a4 instanceof mn ? a4.value().slice(c4) : "", d4 = { collapsed: 0 === r4.length, empty: 0 === r4.length && s4.length() <= 1, format: this.quill.getFormat(r4), line: s4, offset: i4, prefix: u4, suffix: h4, event: t5 };
                e5.some((t6) => {
                  if (null != t6.collapsed && t6.collapsed !== d4.collapsed)
                    return false;
                  if (null != t6.empty && t6.empty !== d4.empty)
                    return false;
                  if (null != t6.offset && t6.offset !== d4.offset)
                    return false;
                  if (Array.isArray(t6.format)) {
                    if (t6.format.every((t7) => null == d4.format[t7]))
                      return false;
                  } else if ("object" == typeof t6.format && !Object.keys(t6.format).every((e6) => true === t6.format[e6] ? null != d4.format[e6] : false === t6.format[e6] ? null == d4.format[e6] : Pr(t6.format[e6], d4.format[e6])))
                    return false;
                  return !(null != t6.prefix && !t6.prefix.test(d4.prefix)) && (!(null != t6.suffix && !t6.suffix.test(d4.suffix)) && true !== t6.handler.call(this, r4, d4, t6));
                }) && t5.preventDefault();
              });
            }
            handleBackspace(t5, e5) {
              const n5 = /[\uD800-\uDBFF][\uDC00-\uDFFF]$/.test(e5.prefix) ? 2 : 1;
              if (0 === t5.index || this.quill.getLength() <= 1)
                return;
              let r4 = {};
              const [s4] = this.quill.getLine(t5.index);
              let i4 = new bn2().retain(t5.index - n5).delete(n5);
              if (0 === e5.offset) {
                const [e6] = this.quill.getLine(t5.index - 1);
                if (e6) {
                  if (!("block" === e6.statics.blotName && e6.length() <= 1)) {
                    const e7 = s4.formats(), n6 = this.quill.getFormat(t5.index - 1, 1);
                    if (r4 = bn2.AttributeMap.diff(e7, n6) || {}, Object.keys(r4).length > 0) {
                      const e8 = new bn2().retain(t5.index + s4.length() - 2).retain(1, r4);
                      i4 = i4.compose(e8);
                    }
                  }
                }
              }
              this.quill.updateContents(i4, Rs.sources.USER), this.quill.focus();
            }
            handleDelete(t5, e5) {
              const n5 = /^[\uD800-\uDBFF][\uDC00-\uDFFF]/.test(e5.suffix) ? 2 : 1;
              if (t5.index >= this.quill.getLength() - n5)
                return;
              let r4 = {};
              const [s4] = this.quill.getLine(t5.index);
              let i4 = new bn2().retain(t5.index).delete(n5);
              if (e5.offset >= s4.length() - 1) {
                const [e6] = this.quill.getLine(t5.index + 1);
                if (e6) {
                  const n6 = s4.formats(), o4 = this.quill.getFormat(t5.index, 1);
                  r4 = bn2.AttributeMap.diff(n6, o4) || {}, Object.keys(r4).length > 0 && (i4 = i4.retain(e6.length() - 1).retain(1, r4));
                }
              }
              this.quill.updateContents(i4, Rs.sources.USER), this.quill.focus();
            }
            handleDeleteRange(t5) {
              Ni({ range: t5, quill: this.quill }), this.quill.focus();
            }
            handleEnter(t5, e5) {
              const n5 = Object.keys(e5.format).reduce((t6, n6) => (this.quill.scroll.query(n6, Pe.BLOCK) && !Array.isArray(e5.format[n6]) && (t6[n6] = e5.format[n6]), t6), {}), r4 = new bn2().retain(t5.index).delete(t5.length).insert("\n", n5);
              this.quill.updateContents(r4, Rs.sources.USER), this.quill.setSelection(t5.index + 1, Rs.sources.SILENT), this.quill.focus();
            }
          }
          const mi = { bindings: { bold: vi("bold"), italic: vi("italic"), underline: vi("underline"), indent: { key: "Tab", format: ["blockquote", "indent", "list"], handler(t5, e5) {
            return !(!e5.collapsed || 0 === e5.offset) || (this.quill.format("indent", "+1", Rs.sources.USER), false);
          } }, outdent: { key: "Tab", shiftKey: true, format: ["blockquote", "indent", "list"], handler(t5, e5) {
            return !(!e5.collapsed || 0 === e5.offset) || (this.quill.format("indent", "-1", Rs.sources.USER), false);
          } }, "outdent backspace": { key: "Backspace", collapsed: true, shiftKey: null, metaKey: null, ctrlKey: null, altKey: null, format: ["indent", "list"], offset: 0, handler(t5, e5) {
            null != e5.format.indent ? this.quill.format("indent", "-1", Rs.sources.USER) : null != e5.format.list && this.quill.format("list", false, Rs.sources.USER);
          } }, "indent code-block": bi2(true), "outdent code-block": bi2(false), "remove tab": { key: "Tab", shiftKey: true, collapsed: true, prefix: /\t$/, handler(t5) {
            this.quill.deleteText(t5.index - 1, 1, Rs.sources.USER);
          } }, tab: { key: "Tab", handler(t5, e5) {
            if (e5.format.table)
              return true;
            this.quill.history.cutoff();
            const n5 = new bn2().retain(t5.index).delete(t5.length).insert("	");
            return this.quill.updateContents(n5, Rs.sources.USER), this.quill.history.cutoff(), this.quill.setSelection(t5.index + 1, Rs.sources.SILENT), false;
          } }, "blockquote empty enter": { key: "Enter", collapsed: true, format: ["blockquote"], empty: true, handler() {
            this.quill.format("blockquote", false, Rs.sources.USER);
          } }, "list empty enter": { key: "Enter", collapsed: true, format: ["list"], empty: true, handler(t5, e5) {
            const n5 = { list: false };
            e5.format.indent && (n5.indent = false), this.quill.formatLine(t5.index, t5.length, n5, Rs.sources.USER);
          } }, "checklist enter": { key: "Enter", collapsed: true, format: { list: "checked" }, handler(t5) {
            const [e5, n5] = this.quill.getLine(t5.index), r4 = { ...e5.formats(), list: "checked" }, s4 = new bn2().retain(t5.index).insert("\n", r4).retain(e5.length() - n5 - 1).retain(1, { list: "unchecked" });
            this.quill.updateContents(s4, Rs.sources.USER), this.quill.setSelection(t5.index + 1, Rs.sources.SILENT), this.quill.scrollSelectionIntoView();
          } }, "header enter": { key: "Enter", collapsed: true, format: ["header"], suffix: /^$/, handler(t5, e5) {
            const [n5, r4] = this.quill.getLine(t5.index), s4 = new bn2().retain(t5.index).insert("\n", e5.format).retain(n5.length() - r4 - 1).retain(1, { header: null });
            this.quill.updateContents(s4, Rs.sources.USER), this.quill.setSelection(t5.index + 1, Rs.sources.SILENT), this.quill.scrollSelectionIntoView();
          } }, "table backspace": { key: "Backspace", format: ["table"], collapsed: true, offset: 0, handler() {
          } }, "table delete": { key: "Delete", format: ["table"], collapsed: true, suffix: /^$/, handler() {
          } }, "table enter": { key: "Enter", shiftKey: null, format: ["table"], handler(t5) {
            const e5 = this.quill.getModule("table");
            if (e5) {
              const [n5, r4, s4, i4] = e5.getTable(t5), o4 = function(t6, e6, n6, r5) {
                if (null == e6.prev && null == e6.next)
                  return null == n6.prev && null == n6.next ? 0 === r5 ? -1 : 1 : null == n6.prev ? -1 : 1;
                if (null == e6.prev)
                  return -1;
                if (null == e6.next)
                  return 1;
                return null;
              }(0, r4, s4, i4);
              if (null == o4)
                return;
              let l4 = n5.offset();
              if (o4 < 0) {
                const e6 = new bn2().retain(l4).insert("\n");
                this.quill.updateContents(e6, Rs.sources.USER), this.quill.setSelection(t5.index + 1, t5.length, Rs.sources.SILENT);
              } else if (o4 > 0) {
                l4 += n5.length();
                const t6 = new bn2().retain(l4).insert("\n");
                this.quill.updateContents(t6, Rs.sources.USER), this.quill.setSelection(l4, Rs.sources.USER);
              }
            }
          } }, "table tab": { key: "Tab", shiftKey: null, format: ["table"], handler(t5, e5) {
            const { event: n5, line: r4 } = e5, s4 = r4.offset(this.quill.scroll);
            n5.shiftKey ? this.quill.setSelection(s4 - 1, Rs.sources.USER) : this.quill.setSelection(s4 + r4.length(), Rs.sources.USER);
          } }, "list autofill": { key: " ", shiftKey: null, collapsed: true, format: { "code-block": false, blockquote: false, table: false }, prefix: /^\s*?(\d+\.|-|\*|\[ ?\]|\[x\])$/, handler(t5, e5) {
            if (null == this.quill.scroll.query("list"))
              return true;
            const { length: n5 } = e5.prefix, [r4, s4] = this.quill.getLine(t5.index);
            if (s4 > n5)
              return true;
            let i4;
            switch (e5.prefix.trim()) {
              case "[]":
              case "[ ]":
                i4 = "unchecked";
                break;
              case "[x]":
                i4 = "checked";
                break;
              case "-":
              case "*":
                i4 = "bullet";
                break;
              default:
                i4 = "ordered";
            }
            this.quill.insertText(t5.index, " ", Rs.sources.USER), this.quill.history.cutoff();
            const o4 = new bn2().retain(t5.index - s4).delete(n5 + 1).retain(r4.length() - 2 - s4).retain(1, { list: i4 });
            return this.quill.updateContents(o4, Rs.sources.USER), this.quill.history.cutoff(), this.quill.setSelection(t5.index - n5, Rs.sources.SILENT), false;
          } }, "code exit": { key: "Enter", collapsed: true, format: ["code-block"], prefix: /^$/, suffix: /^\s*$/, handler(t5) {
            const [e5, n5] = this.quill.getLine(t5.index);
            let r4 = 2, s4 = e5;
            for (; null != s4 && s4.length() <= 1 && s4.formats()["code-block"]; )
              if (s4 = s4.prev, r4 -= 1, r4 <= 0) {
                const r5 = new bn2().retain(t5.index + e5.length() - n5 - 2).retain(1, { "code-block": null }).delete(1);
                return this.quill.updateContents(r5, Rs.sources.USER), this.quill.setSelection(t5.index - 1, Rs.sources.SILENT), false;
              }
            return true;
          } }, "embed left": yi("ArrowLeft", false), "embed left shift": yi("ArrowLeft", true), "embed right": yi("ArrowRight", false), "embed right shift": yi("ArrowRight", true), "table down": xi(false), "table up": xi(true) } };
          function bi2(t5) {
            return { key: "Tab", shiftKey: !t5, format: { "code-block": true }, handler(e5, n5) {
              let { event: r4 } = n5;
              const s4 = this.quill.scroll.query("code-block"), { TAB: i4 } = s4;
              if (0 === e5.length && !r4.shiftKey)
                return this.quill.insertText(e5.index, i4, Rs.sources.USER), void this.quill.setSelection(e5.index + i4.length, Rs.sources.SILENT);
              const o4 = 0 === e5.length ? this.quill.getLines(e5.index, 1) : this.quill.getLines(e5);
              let { index: l4, length: a4 } = e5;
              o4.forEach((e6, n6) => {
                t5 ? (e6.insertAt(0, i4), 0 === n6 ? l4 += i4.length : a4 += i4.length) : e6.domNode.textContent.startsWith(i4) && (e6.deleteAt(0, i4.length), 0 === n6 ? l4 -= i4.length : a4 -= i4.length);
              }), this.quill.update(Rs.sources.USER), this.quill.setSelection(l4, a4, Rs.sources.SILENT);
            } };
          }
          __name(bi2, "bi");
          function yi(t5, e5) {
            const n5 = "ArrowLeft" === t5 ? "prefix" : "suffix";
            return { key: t5, shiftKey: e5, altKey: null, [n5]: /^$/, handler(n6) {
              let { index: r4 } = n6;
              "ArrowRight" === t5 && (r4 += n6.length + 1);
              const [s4] = this.quill.getLeaf(r4);
              return !(s4 instanceof hn) || ("ArrowLeft" === t5 ? e5 ? this.quill.setSelection(n6.index - 1, n6.length + 1, Rs.sources.USER) : this.quill.setSelection(n6.index - 1, Rs.sources.USER) : e5 ? this.quill.setSelection(n6.index, n6.length + 1, Rs.sources.USER) : this.quill.setSelection(n6.index + n6.length + 1, Rs.sources.USER), false);
            } };
          }
          __name(yi, "yi");
          function vi(t5) {
            return { key: t5[0], shortKey: true, handler(e5, n5) {
              this.quill.format(t5, !n5.format[t5], Rs.sources.USER);
            } };
          }
          __name(vi, "vi");
          function xi(t5) {
            return { key: t5 ? "ArrowUp" : "ArrowDown", collapsed: true, format: ["table"], handler(e5, n5) {
              const r4 = t5 ? "prev" : "next", s4 = n5.line, i4 = s4.parent[r4];
              if (null != i4) {
                if ("table-row" === i4.statics.blotName) {
                  let t6 = i4.children.head, e6 = s4;
                  for (; null != e6.prev; )
                    e6 = e6.prev, t6 = t6.next;
                  const r5 = t6.offset(this.quill.scroll) + Math.min(n5.offset, t6.length() - 1);
                  this.quill.setSelection(r5, 0, Rs.sources.USER);
                }
              } else {
                const e6 = s4.table()[r4];
                null != e6 && (t5 ? this.quill.setSelection(e6.offset(this.quill.scroll) + e6.length() - 1, 0, Rs.sources.USER) : this.quill.setSelection(e6.offset(this.quill.scroll), 0, Rs.sources.USER));
              }
              return false;
            } };
          }
          __name(xi, "xi");
          function Ni(t5) {
            let { quill: e5, range: n5 } = t5;
            const r4 = e5.getLines(n5);
            let s4 = {};
            if (r4.length > 1) {
              const t6 = r4[0].formats(), e6 = r4[r4.length - 1].formats();
              s4 = bn2.AttributeMap.diff(e6, t6) || {};
            }
            e5.deleteText(n5, Rs.sources.USER), Object.keys(s4).length > 0 && e5.formatLine(n5.index, 1, s4, Rs.sources.USER), e5.setSelection(n5.index, Rs.sources.SILENT);
          }
          __name(Ni, "Ni");
          gi.DEFAULTS = mi;
          const wi = /font-weight:\s*normal/, Ei = ["P", "OL", "UL"], Ai = /* @__PURE__ */ __name((t5) => t5 && Ei.includes(t5.tagName), "Ai");
          const qi = /\bmso-list:[^;]*ignore/i, ki = /\bmso-list:[^;]*\bl(\d+)/i, _i = /\bmso-list:[^;]*\blevel(\d+)/i, Li = /* @__PURE__ */ __name((t5) => {
            const e5 = Array.from(t5.querySelectorAll("[style*=mso-list]")), n5 = [], r4 = [];
            e5.forEach((t6) => {
              (t6.getAttribute("style") || "").match(qi) ? n5.push(t6) : r4.push(t6);
            }), n5.forEach((t6) => t6.parentNode?.removeChild(t6));
            const s4 = t5.documentElement.innerHTML, i4 = r4.map((t6) => ((t7, e6) => {
              const n6 = t7.getAttribute("style"), r5 = n6?.match(ki);
              if (!r5)
                return null;
              const s5 = Number(r5[1]), i5 = n6?.match(_i), o4 = i5 ? Number(i5[1]) : 1, l4 = new RegExp(`@list l${s5}:level${o4}\\s*\\{[^\\}]*mso-level-number-format:\\s*([\\w-]+)`, "i"), a4 = e6.match(l4);
              return { id: s5, indent: o4, type: a4 && "bullet" === a4[1] ? "bullet" : "ordered", element: t7 };
            })(t6, s4)).filter((t6) => t6);
            for (; i4.length; ) {
              const t6 = [];
              let e6 = i4.shift();
              for (; e6; )
                t6.push(e6), e6 = i4.length && i4[0]?.element === e6.element.nextElementSibling && i4[0].id === e6.id ? i4.shift() : null;
              const n6 = document.createElement("ul");
              t6.forEach((t7) => {
                const e7 = document.createElement("li");
                e7.setAttribute("data-list", t7.type), t7.indent > 1 && e7.setAttribute("class", "ql-indent-" + (t7.indent - 1)), e7.innerHTML = t7.element.innerHTML, n6.appendChild(e7);
              });
              const r5 = t6[0]?.element, { parentNode: s5 } = r5 ?? {};
              r5 && s5?.replaceChild(n6, r5), t6.slice(1).forEach((t7) => {
                let { element: e7 } = t7;
                s5?.removeChild(e7);
              });
            }
          }, "Li");
          const Oi = [function(t5) {
            "urn:schemas-microsoft-com:office:word" === t5.documentElement.getAttribute("xmlns:w") && Li(t5);
          }, function(t5) {
            t5.querySelector('[id^="docs-internal-guid-"]') && (((t6) => {
              Array.from(t6.querySelectorAll('b[style*="font-weight"]')).filter((t7) => t7.getAttribute("style")?.match(wi)).forEach((e5) => {
                const n5 = t6.createDocumentFragment();
                n5.append(...e5.childNodes), e5.parentNode?.replaceChild(n5, e5);
              });
            })(t5), ((t6) => {
              Array.from(t6.querySelectorAll("br")).filter((t7) => Ai(t7.previousElementSibling) && Ai(t7.nextElementSibling)).forEach((t7) => {
                t7.parentNode?.removeChild(t7);
              });
            })(t5));
          }], Ti = /* @__PURE__ */ __name((t5) => {
            t5.documentElement && Oi.forEach((e5) => {
              e5(t5);
            });
          }, "Ti"), Si = is2("quill:clipboard"), Ci = [[Node.TEXT_NODE, function(t5, e5, n5) {
            let r4 = t5.data;
            if ("O:P" === t5.parentElement?.tagName)
              return e5.insert(r4.trim());
            if (!Di(t5)) {
              if (0 === r4.trim().length && r4.includes("\n") && !function(t6, e6) {
                return t6.previousElementSibling && t6.nextElementSibling && !Bi(t6.previousElementSibling, e6) && !Bi(t6.nextElementSibling, e6);
              }(t5, n5))
                return e5;
              const s4 = /* @__PURE__ */ __name((t6, e6) => {
                const n6 = e6.replace(/[^\u00a0]/g, "");
                return n6.length < 1 && t6 ? " " : n6;
              }, "s");
              r4 = r4.replace(/\r\n/g, " ").replace(/\n/g, " "), r4 = r4.replace(/\s\s+/g, s4.bind(s4, true)), (null == t5.previousSibling && null != t5.parentElement && Bi(t5.parentElement, n5) || t5.previousSibling instanceof Element && Bi(t5.previousSibling, n5)) && (r4 = r4.replace(/^\s+/, s4.bind(s4, false))), (null == t5.nextSibling && null != t5.parentElement && Bi(t5.parentElement, n5) || t5.nextSibling instanceof Element && Bi(t5.nextSibling, n5)) && (r4 = r4.replace(/\s+$/, s4.bind(s4, false)));
            }
            return e5.insert(r4);
          }], [Node.TEXT_NODE, Hi], ["br", function(t5, e5) {
            Mi(e5, "\n") || e5.insert("\n");
            return e5;
          }], [Node.ELEMENT_NODE, Hi], [Node.ELEMENT_NODE, function(t5, e5, n5) {
            const r4 = n5.query(t5);
            if (null == r4)
              return e5;
            if (r4.prototype instanceof hn) {
              const e6 = {}, s4 = r4.value(t5);
              if (null != s4)
                return e6[r4.blotName] = s4, new bn2().insert(e6, r4.formats(t5, n5));
            } else if (r4.prototype instanceof an2 && !Mi(e5, "\n") && e5.insert("\n"), "blotName" in r4 && "formats" in r4 && "function" == typeof r4.formats)
              return Ii(e5, r4.blotName, r4.formats(t5, n5), n5);
            return e5;
          }], [Node.ELEMENT_NODE, function(t5, e5, n5) {
            const r4 = ze.keys(t5), s4 = Ke.keys(t5), i4 = Ze.keys(t5), o4 = {};
            return r4.concat(s4).concat(i4).forEach((e6) => {
              let r5 = n5.query(e6, Pe.ATTRIBUTE);
              null != r5 && (o4[r5.attrName] = r5.value(t5), o4[r5.attrName]) || (r5 = ji[e6], null == r5 || r5.attrName !== e6 && r5.keyName !== e6 || (o4[r5.attrName] = r5.value(t5) || void 0), r5 = Ri[e6], null == r5 || r5.attrName !== e6 && r5.keyName !== e6 || (r5 = Ri[e6], o4[r5.attrName] = r5.value(t5) || void 0));
            }), Object.entries(o4).reduce((t6, e6) => {
              let [r5, s5] = e6;
              return Ii(t6, r5, s5, n5);
            }, e5);
          }], [Node.ELEMENT_NODE, function(t5, e5, n5) {
            const r4 = {}, s4 = t5.style || {};
            "italic" === s4.fontStyle && (r4.italic = true);
            "underline" === s4.textDecoration && (r4.underline = true);
            "line-through" === s4.textDecoration && (r4.strike = true);
            (s4.fontWeight?.startsWith("bold") || parseInt(s4.fontWeight, 10) >= 700) && (r4.bold = true);
            if (e5 = Object.entries(r4).reduce((t6, e6) => {
              let [r5, s5] = e6;
              return Ii(t6, r5, s5, n5);
            }, e5), parseFloat(s4.textIndent || 0) > 0)
              return new bn2().insert("	").concat(e5);
            return e5;
          }], ["li", function(t5, e5, n5) {
            const r4 = n5.query(t5);
            if (null == r4 || "list" !== r4.blotName || !Mi(e5, "\n"))
              return e5;
            let s4 = -1, i4 = t5.parentNode;
            for (; null != i4; )
              ["OL", "UL"].includes(i4.tagName) && (s4 += 1), i4 = i4.parentNode;
            return s4 <= 0 ? e5 : e5.reduce((t6, e6) => e6.insert ? e6.attributes && "number" == typeof e6.attributes.indent ? t6.push(e6) : t6.insert(e6.insert, { indent: s4, ...e6.attributes || {} }) : t6, new bn2());
          }], ["ol, ul", function(t5, e5, n5) {
            const r4 = t5;
            let s4 = "OL" === r4.tagName ? "ordered" : "bullet";
            const i4 = r4.getAttribute("data-checked");
            i4 && (s4 = "true" === i4 ? "checked" : "unchecked");
            return Ii(e5, "list", s4, n5);
          }], ["pre", function(t5, e5, n5) {
            const r4 = n5.query("code-block"), s4 = !r4 || !("formats" in r4) || "function" != typeof r4.formats || r4.formats(t5, n5);
            return Ii(e5, "code-block", s4, n5);
          }], ["tr", function(t5, e5, n5) {
            const r4 = "TABLE" === t5.parentElement?.tagName ? t5.parentElement : t5.parentElement?.parentElement;
            if (null != r4) {
              return Ii(e5, "table", Array.from(r4.querySelectorAll("tr")).indexOf(t5) + 1, n5);
            }
            return e5;
          }], ["b", zi("bold")], ["i", zi("italic")], ["strike", zi("strike")], ["style", function() {
            return new bn2();
          }]], ji = [Ws, ii2].reduce((t5, e5) => (t5[e5.keyName] = e5, t5), {}), Ri = [Gs, ti, Ys, li, ui, di].reduce((t5, e5) => (t5[e5.keyName] = e5, t5), {});
          function Ii(t5, e5, n5, r4) {
            return r4.query(e5) ? t5.reduce((t6, r5) => {
              if (!r5.insert)
                return t6;
              if (r5.attributes && r5.attributes[e5])
                return t6.push(r5);
              const s4 = n5 ? { [e5]: n5 } : {};
              return t6.insert(r5.insert, { ...s4, ...r5.attributes });
            }, new bn2()) : t5;
          }
          __name(Ii, "Ii");
          function Mi(t5, e5) {
            let n5 = "";
            for (let r4 = t5.ops.length - 1; r4 >= 0 && n5.length < e5.length; --r4) {
              const e6 = t5.ops[r4];
              if ("string" != typeof e6.insert)
                break;
              n5 = e6.insert + n5;
            }
            return n5.slice(-1 * e5.length) === e5;
          }
          __name(Mi, "Mi");
          function Bi(t5, e5) {
            if (!(t5 instanceof Element))
              return false;
            const n5 = e5.query(t5);
            return !(n5 && n5.prototype instanceof hn) && ["address", "article", "blockquote", "canvas", "dd", "div", "dl", "dt", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "header", "iframe", "li", "main", "nav", "ol", "output", "p", "pre", "section", "table", "td", "tr", "ul", "video"].includes(t5.tagName.toLowerCase());
          }
          __name(Bi, "Bi");
          const Ui = /* @__PURE__ */ new WeakMap();
          function Di(t5) {
            return null != t5 && (Ui.has(t5) || ("PRE" === t5.tagName ? Ui.set(t5, true) : Ui.set(t5, Di(t5.parentNode))), Ui.get(t5));
          }
          __name(Di, "Di");
          function Pi(t5, e5, n5, r4, s4) {
            return e5.nodeType === e5.TEXT_NODE ? r4.reduce((n6, r5) => r5(e5, n6, t5), new bn2()) : e5.nodeType === e5.ELEMENT_NODE ? Array.from(e5.childNodes || []).reduce((i4, o4) => {
              let l4 = Pi(t5, o4, n5, r4, s4);
              return o4.nodeType === e5.ELEMENT_NODE && (l4 = n5.reduce((e6, n6) => n6(o4, e6, t5), l4), l4 = (s4.get(o4) || []).reduce((e6, n6) => n6(o4, e6, t5), l4)), i4.concat(l4);
            }, new bn2()) : new bn2();
          }
          __name(Pi, "Pi");
          function zi(t5) {
            return (e5, n5, r4) => Ii(n5, t5, true, r4);
          }
          __name(zi, "zi");
          function Hi(t5, e5, n5) {
            if (!Mi(e5, "\n")) {
              if (Bi(t5, n5) && (t5.childNodes.length > 0 || t5 instanceof HTMLParagraphElement))
                return e5.insert("\n");
              if (e5.length() > 0 && t5.nextSibling) {
                let r4 = t5.nextSibling;
                for (; null != r4; ) {
                  if (Bi(r4, n5))
                    return e5.insert("\n");
                  const t6 = n5.query(r4);
                  if (t6 && t6.prototype instanceof Zr)
                    return e5.insert("\n");
                  r4 = r4.firstChild;
                }
              }
            }
            return e5;
          }
          __name(Hi, "Hi");
          function Fi(t5, e5) {
            let n5 = e5;
            for (let e6 = t5.length - 1; e6 >= 0; e6 -= 1) {
              const r4 = t5[e6];
              t5[e6] = { delta: n5.transform(r4.delta, true), range: r4.range && $i(r4.range, n5) }, n5 = r4.delta.transform(n5), 0 === t5[e6].delta.length() && t5.splice(e6, 1);
            }
          }
          __name(Fi, "Fi");
          function $i(t5, e5) {
            if (!t5)
              return t5;
            const n5 = e5.transformPosition(t5.index);
            return { index: n5, length: e5.transformPosition(t5.index + t5.length) - n5 };
          }
          __name($i, "$i");
          class Vi extends xs {
            static {
              __name(this, "Vi");
            }
            constructor(t5, e5) {
              super(t5, e5), t5.root.addEventListener("drop", (e6) => {
                e6.preventDefault();
                let n5 = null;
                if (document.caretRangeFromPoint)
                  n5 = document.caretRangeFromPoint(e6.clientX, e6.clientY);
                else if (document.caretPositionFromPoint) {
                  const t6 = document.caretPositionFromPoint(e6.clientX, e6.clientY);
                  n5 = document.createRange(), n5.setStart(t6.offsetNode, t6.offset), n5.setEnd(t6.offsetNode, t6.offset);
                }
                const r4 = n5 && t5.selection.normalizeNative(n5);
                if (r4) {
                  const n6 = t5.selection.normalizedToRange(r4);
                  e6.dataTransfer?.files && this.upload(n6, e6.dataTransfer.files);
                }
              });
            }
            upload(t5, e5) {
              const n5 = [];
              Array.from(e5).forEach((t6) => {
                t6 && this.options.mimetypes?.includes(t6.type) && n5.push(t6);
              }), n5.length > 0 && this.options.handler.call(this, t5, n5);
            }
          }
          Vi.DEFAULTS = { mimetypes: ["image/png", "image/jpeg"], handler(t5, e5) {
            if (!this.quill.scroll.query("image"))
              return;
            const n5 = e5.map((t6) => new Promise((e6) => {
              const n6 = new FileReader();
              n6.onload = () => {
                e6(n6.result);
              }, n6.readAsDataURL(t6);
            }));
            Promise.all(n5).then((e6) => {
              const n6 = e6.reduce((t6, e7) => t6.insert({ image: e7 }), new bn2().retain(t5.index).delete(t5.length));
              this.quill.updateContents(n6, ls.sources.USER), this.quill.setSelection(t5.index + e6.length, ls.sources.SILENT);
            });
          } };
          const Ki = Vi, Wi = ["insertText", "insertReplacementText"];
          const Zi = class extends xs {
            static {
              __name(this, "Zi");
            }
            constructor(t5, e5) {
              super(t5, e5), t5.root.addEventListener("beforeinput", (t6) => {
                this.handleBeforeInput(t6);
              }), /Android/i.test(navigator.userAgent) || t5.on(Rs.events.COMPOSITION_BEFORE_START, () => {
                this.handleCompositionStart();
              });
            }
            deleteRange(t5) {
              Ni({ range: t5, quill: this.quill });
            }
            replaceText(t5) {
              let e5 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "";
              if (0 === t5.length)
                return false;
              if (e5) {
                const n5 = this.quill.getFormat(t5.index, 1);
                this.deleteRange(t5), this.quill.updateContents(new bn2().retain(t5.index).insert(e5, n5), Rs.sources.USER);
              } else
                this.deleteRange(t5);
              return this.quill.setSelection(t5.index + e5.length, 0, Rs.sources.SILENT), true;
            }
            handleBeforeInput(t5) {
              if (this.quill.composition.isComposing || t5.defaultPrevented || !Wi.includes(t5.inputType))
                return;
              const e5 = t5.getTargetRanges ? t5.getTargetRanges()[0] : null;
              if (!e5 || true === e5.collapsed)
                return;
              const n5 = function(t6) {
                if ("string" == typeof t6.data)
                  return t6.data;
                if (t6.dataTransfer?.types.includes("text/plain"))
                  return t6.dataTransfer.getData("text/plain");
                return null;
              }(t5);
              if (null == n5)
                return;
              const r4 = this.quill.selection.normalizeNative(e5), s4 = r4 ? this.quill.selection.normalizedToRange(r4) : null;
              s4 && this.replaceText(s4, n5) && t5.preventDefault();
            }
            handleCompositionStart() {
              const t5 = this.quill.getSelection();
              t5 && this.replaceText(t5);
            }
          }, Gi = /Mac/i.test(navigator.platform);
          const Xi = class extends xs {
            static {
              __name(this, "Xi");
            }
            isListening = false;
            selectionChangeDeadline = 0;
            constructor(t5, e5) {
              super(t5, e5), this.handleArrowKeys(), this.handleNavigationShortcuts();
            }
            handleArrowKeys() {
              this.quill.keyboard.addBinding({ key: ["ArrowLeft", "ArrowRight"], offset: 0, shiftKey: null, handler(t5, e5) {
                let { line: n5, event: r4 } = e5;
                if (!(n5 instanceof rn && n5.uiNode))
                  return true;
                const s4 = "rtl" === getComputedStyle(n5.domNode).direction;
                return !!(s4 && "ArrowRight" !== r4.key || !s4 && "ArrowLeft" !== r4.key) || (this.quill.setSelection(t5.index - 1, t5.length + (r4.shiftKey ? 1 : 0), Rs.sources.USER), false);
              } });
            }
            handleNavigationShortcuts() {
              this.quill.root.addEventListener("keydown", (t5) => {
                !t5.defaultPrevented && ((t6) => "ArrowLeft" === t6.key || "ArrowRight" === t6.key || "ArrowUp" === t6.key || "ArrowDown" === t6.key || "Home" === t6.key || !(!Gi || "a" !== t6.key || true !== t6.ctrlKey))(t5) && this.ensureListeningToSelectionChange();
              });
            }
            ensureListeningToSelectionChange() {
              if (this.selectionChangeDeadline = Date.now() + 100, this.isListening)
                return;
              this.isListening = true;
              document.addEventListener("selectionchange", () => {
                this.isListening = false, Date.now() <= this.selectionChangeDeadline && this.handleSelectionChange();
              }, { once: true });
            }
            handleSelectionChange() {
              const t5 = document.getSelection();
              if (!t5)
                return;
              const e5 = t5.getRangeAt(0);
              if (true !== e5.collapsed || 0 !== e5.startOffset)
                return;
              const n5 = this.quill.scroll.find(e5.startContainer);
              if (!(n5 instanceof rn && n5.uiNode))
                return;
              const r4 = document.createRange();
              r4.setStartAfter(n5.uiNode), r4.setEndAfter(n5.uiNode), t5.removeAllRanges(), t5.addRange(r4);
            }
          };
          Rs.register({ "blots/block": Wr, "blots/block/embed": Zr, "blots/break": Hr, "blots/container": zs, "blots/cursor": Yr, "blots/embed": ws, "blots/inline": Kr, "blots/scroll": Vs, "blots/text": Fr, "modules/clipboard": class extends xs {
            static DEFAULTS = { matchers: [] };
            constructor(t5, e5) {
              super(t5, e5), this.quill.root.addEventListener("copy", (t6) => this.onCaptureCopy(t6, false)), this.quill.root.addEventListener("cut", (t6) => this.onCaptureCopy(t6, true)), this.quill.root.addEventListener("paste", this.onCapturePaste.bind(this)), this.matchers = [], Ci.concat(this.options.matchers ?? []).forEach((t6) => {
                let [e6, n5] = t6;
                this.addMatcher(e6, n5);
              });
            }
            addMatcher(t5, e5) {
              this.matchers.push([t5, e5]);
            }
            convert(t5) {
              let { html: e5, text: n5 } = t5, r4 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
              if (r4[ni.blotName])
                return new bn2().insert(n5 || "", { [ni.blotName]: r4[ni.blotName] });
              if (!e5)
                return new bn2().insert(n5 || "", r4);
              const s4 = this.convertHTML(e5);
              return Mi(s4, "\n") && (null == s4.ops[s4.ops.length - 1].attributes || r4.table) ? s4.compose(new bn2().retain(s4.length() - 1).delete(1)) : s4;
            }
            normalizeHTML(t5) {
              Ti(t5);
            }
            convertHTML(t5) {
              const e5 = new DOMParser().parseFromString(t5, "text/html");
              this.normalizeHTML(e5);
              const n5 = e5.body, r4 = /* @__PURE__ */ new WeakMap(), [s4, i4] = this.prepareMatching(n5, r4);
              return Pi(this.quill.scroll, n5, s4, i4, r4);
            }
            dangerouslyPasteHTML(t5, e5) {
              let n5 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : Rs.sources.API;
              if ("string" == typeof t5) {
                const n6 = this.convert({ html: t5, text: "" });
                this.quill.setContents(n6, e5), this.quill.setSelection(0, Rs.sources.SILENT);
              } else {
                const r4 = this.convert({ html: e5, text: "" });
                this.quill.updateContents(new bn2().retain(t5).concat(r4), n5), this.quill.setSelection(t5 + r4.length(), Rs.sources.SILENT);
              }
            }
            onCaptureCopy(t5) {
              let e5 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
              if (t5.defaultPrevented)
                return;
              t5.preventDefault();
              const [n5] = this.quill.selection.getRange();
              if (null == n5)
                return;
              const { html: r4, text: s4 } = this.onCopy(n5, e5);
              t5.clipboardData?.setData("text/plain", s4), t5.clipboardData?.setData("text/html", r4), e5 && Ni({ range: n5, quill: this.quill });
            }
            normalizeURIList(t5) {
              return t5.split(/\r?\n/).filter((t6) => "#" !== t6[0]).join("\n");
            }
            onCapturePaste(t5) {
              if (t5.defaultPrevented || !this.quill.isEnabled())
                return;
              t5.preventDefault();
              const e5 = this.quill.getSelection(true);
              if (null == e5)
                return;
              const n5 = t5.clipboardData?.getData("text/html");
              let r4 = t5.clipboardData?.getData("text/plain");
              if (!n5 && !r4) {
                const e6 = t5.clipboardData?.getData("text/uri-list");
                e6 && (r4 = this.normalizeURIList(e6));
              }
              const s4 = Array.from(t5.clipboardData?.files || []);
              if (!n5 && s4.length > 0)
                this.quill.uploader.upload(e5, s4);
              else {
                if (n5 && s4.length > 0) {
                  const t6 = new DOMParser().parseFromString(n5, "text/html");
                  if (1 === t6.body.childElementCount && "IMG" === t6.body.firstElementChild?.tagName)
                    return void this.quill.uploader.upload(e5, s4);
                }
                this.onPaste(e5, { html: n5, text: r4 });
              }
            }
            onCopy(t5) {
              const e5 = this.quill.getText(t5);
              return { html: this.quill.getSemanticHTML(t5), text: e5 };
            }
            onPaste(t5, e5) {
              let { text: n5, html: r4 } = e5;
              const s4 = this.quill.getFormat(t5.index), i4 = this.convert({ text: n5, html: r4 }, s4);
              Si.log("onPaste", i4, { text: n5, html: r4 });
              const o4 = new bn2().retain(t5.index).delete(t5.length).concat(i4);
              this.quill.updateContents(o4, Rs.sources.USER), this.quill.setSelection(o4.length() - t5.length, Rs.sources.SILENT), this.quill.scrollSelectionIntoView();
            }
            prepareMatching(t5, e5) {
              const n5 = [], r4 = [];
              return this.matchers.forEach((s4) => {
                const [i4, o4] = s4;
                switch (i4) {
                  case Node.TEXT_NODE:
                    r4.push(o4);
                    break;
                  case Node.ELEMENT_NODE:
                    n5.push(o4);
                    break;
                  default:
                    Array.from(t5.querySelectorAll(i4)).forEach((t6) => {
                      if (e5.has(t6)) {
                        const n6 = e5.get(t6);
                        n6?.push(o4);
                      } else
                        e5.set(t6, [o4]);
                    });
                }
              }), [n5, r4];
            }
          }, "modules/history": class extends xs {
            static DEFAULTS = { delay: 1e3, maxStack: 100, userOnly: false };
            lastRecorded = 0;
            ignoreChange = false;
            stack = { undo: [], redo: [] };
            currentRange = null;
            constructor(t5, e5) {
              super(t5, e5), this.quill.on(Rs.events.EDITOR_CHANGE, (t6, e6, n5, r4) => {
                t6 === Rs.events.SELECTION_CHANGE ? e6 && r4 !== Rs.sources.SILENT && (this.currentRange = e6) : t6 === Rs.events.TEXT_CHANGE && (this.ignoreChange || (this.options.userOnly && r4 !== Rs.sources.USER ? this.transform(e6) : this.record(e6, n5)), this.currentRange = $i(this.currentRange, e6));
              }), this.quill.keyboard.addBinding({ key: "z", shortKey: true }, this.undo.bind(this)), this.quill.keyboard.addBinding({ key: ["z", "Z"], shortKey: true, shiftKey: true }, this.redo.bind(this)), /Win/i.test(navigator.platform) && this.quill.keyboard.addBinding({ key: "y", shortKey: true }, this.redo.bind(this)), this.quill.root.addEventListener("beforeinput", (t6) => {
                "historyUndo" === t6.inputType ? (this.undo(), t6.preventDefault()) : "historyRedo" === t6.inputType && (this.redo(), t6.preventDefault());
              });
            }
            change(t5, e5) {
              if (0 === this.stack[t5].length)
                return;
              const n5 = this.stack[t5].pop();
              if (!n5)
                return;
              const r4 = this.quill.getContents(), s4 = n5.delta.invert(r4);
              this.stack[e5].push({ delta: s4, range: $i(n5.range, s4) }), this.lastRecorded = 0, this.ignoreChange = true, this.quill.updateContents(n5.delta, Rs.sources.USER), this.ignoreChange = false, this.restoreSelection(n5);
            }
            clear() {
              this.stack = { undo: [], redo: [] };
            }
            cutoff() {
              this.lastRecorded = 0;
            }
            record(t5, e5) {
              if (0 === t5.ops.length)
                return;
              this.stack.redo = [];
              let n5 = t5.invert(e5), r4 = this.currentRange;
              const s4 = Date.now();
              if (this.lastRecorded + this.options.delay > s4 && this.stack.undo.length > 0) {
                const t6 = this.stack.undo.pop();
                t6 && (n5 = n5.compose(t6.delta), r4 = t6.range);
              } else
                this.lastRecorded = s4;
              0 !== n5.length() && (this.stack.undo.push({ delta: n5, range: r4 }), this.stack.undo.length > this.options.maxStack && this.stack.undo.shift());
            }
            redo() {
              this.change("redo", "undo");
            }
            transform(t5) {
              Fi(this.stack.undo, t5), Fi(this.stack.redo, t5);
            }
            undo() {
              this.change("undo", "redo");
            }
            restoreSelection(t5) {
              if (t5.range)
                this.quill.setSelection(t5.range, Rs.sources.USER);
              else {
                const e5 = function(t6, e6) {
                  const n5 = e6.reduce((t7, e7) => t7 + (e7.delete || 0), 0);
                  let r4 = e6.length() - n5;
                  (function(t7, e7) {
                    const n6 = e7.ops[e7.ops.length - 1];
                    if (null == n6)
                      return false;
                    if (null != n6.insert)
                      return "string" == typeof n6.insert && n6.insert.endsWith("\n");
                    if (null != n6.attributes)
                      return Object.keys(n6.attributes).some((e8) => null != t7.query(e8, Pe.BLOCK));
                    return false;
                  })(t6, e6) && (r4 -= 1);
                  return r4;
                }(this.quill.scroll, t5.delta);
                this.quill.setSelection(e5, Rs.sources.USER);
              }
            }
          }, "modules/keyboard": gi, "modules/uploader": Ki, "modules/input": Zi, "modules/uiNode": Xi });
          const Qi = Rs;
          const Yi = new class extends Ke {
            add(t5, e5) {
              let n5 = 0;
              if ("+1" === e5 || "-1" === e5) {
                const r4 = this.value(t5) || 0;
                n5 = "+1" === e5 ? r4 + 1 : r4 - 1;
              } else
                "number" == typeof e5 && (n5 = e5);
              return 0 === n5 ? (this.remove(t5), true) : super.add(t5, n5.toString());
            }
            canAdd(t5, e5) {
              return super.canAdd(t5, e5) || super.canAdd(t5, parseInt(e5, 10));
            }
            value(t5) {
              return parseInt(super.value(t5), 10) || void 0;
            }
          }("indent", "ql-indent", { scope: Pe.BLOCK, whitelist: [1, 2, 3, 4, 5, 6, 7, 8] }), Ji = Yi;
          const to = class extends Wr {
            static {
              __name(this, "to");
            }
            static blotName = "blockquote";
            static tagName = "blockquote";
          };
          const eo = class extends Wr {
            static {
              __name(this, "eo");
            }
            static blotName = "header";
            static tagName = ["H1", "H2", "H3", "H4", "H5", "H6"];
            static formats(t5) {
              return this.tagName.indexOf(t5.tagName) + 1;
            }
          };
          class no extends zs {
            static {
              __name(this, "no");
            }
          }
          no.blotName = "list-container", no.tagName = "OL";
          class ro extends Wr {
            static {
              __name(this, "ro");
            }
            static create(t5) {
              const e5 = super.create();
              return e5.setAttribute("data-list", t5), e5;
            }
            static formats(t5) {
              return t5.getAttribute("data-list") || void 0;
            }
            static register() {
              Rs.register(no);
            }
            constructor(t5, e5) {
              super(t5, e5);
              const n5 = e5.ownerDocument.createElement("span"), r4 = /* @__PURE__ */ __name((n6) => {
                if (!t5.isEnabled())
                  return;
                const r5 = this.statics.formats(e5, t5);
                "checked" === r5 ? (this.format("list", "unchecked"), n6.preventDefault()) : "unchecked" === r5 && (this.format("list", "checked"), n6.preventDefault());
              }, "r");
              n5.addEventListener("mousedown", r4), n5.addEventListener("touchstart", r4), this.attachUI(n5);
            }
            format(t5, e5) {
              t5 === this.statics.blotName && e5 ? this.domNode.setAttribute("data-list", e5) : super.format(t5, e5);
            }
          }
          ro.blotName = "list", ro.tagName = "LI", no.allowedChildren = [ro], ro.requiredContainer = no;
          const so = class extends Kr {
            static {
              __name(this, "so");
            }
            static blotName = "bold";
            static tagName = ["STRONG", "B"];
            static create() {
              return super.create();
            }
            static formats() {
              return true;
            }
            optimize(t5) {
              super.optimize(t5), this.domNode.tagName !== this.statics.tagName[0] && this.replaceWith(this.statics.blotName);
            }
          };
          const io = class extends so {
            static {
              __name(this, "io");
            }
            static blotName = "italic";
            static tagName = ["EM", "I"];
          };
          class oo extends Kr {
            static {
              __name(this, "oo");
            }
            static blotName = "link";
            static tagName = "A";
            static SANITIZED_URL = "about:blank";
            static PROTOCOL_WHITELIST = ["http", "https", "mailto", "tel", "sms"];
            static create(t5) {
              const e5 = super.create(t5);
              return e5.setAttribute("href", this.sanitize(t5)), e5.setAttribute("rel", "noopener noreferrer"), e5.setAttribute("target", "_blank"), e5;
            }
            static formats(t5) {
              return t5.getAttribute("href");
            }
            static sanitize(t5) {
              return lo(t5, this.PROTOCOL_WHITELIST) ? t5 : this.SANITIZED_URL;
            }
            format(t5, e5) {
              t5 === this.statics.blotName && e5 ? this.domNode.setAttribute("href", this.constructor.sanitize(e5)) : super.format(t5, e5);
            }
          }
          function lo(t5, e5) {
            const n5 = document.createElement("a");
            n5.href = t5;
            const r4 = n5.href.slice(0, n5.href.indexOf(":"));
            return e5.indexOf(r4) > -1;
          }
          __name(lo, "lo");
          const ao2 = class extends Kr {
            static {
              __name(this, "ao");
            }
            static blotName = "script";
            static tagName = ["SUB", "SUP"];
            static create(t5) {
              return "super" === t5 ? document.createElement("sup") : "sub" === t5 ? document.createElement("sub") : super.create(t5);
            }
            static formats(t5) {
              return "SUB" === t5.tagName ? "sub" : "SUP" === t5.tagName ? "super" : void 0;
            }
          };
          const co2 = class extends so {
            static {
              __name(this, "co");
            }
            static blotName = "strike";
            static tagName = ["S", "STRIKE"];
          };
          const uo = class extends Kr {
            static {
              __name(this, "uo");
            }
            static blotName = "underline";
            static tagName = "U";
          };
          const ho = class extends ws {
            static {
              __name(this, "ho");
            }
            static blotName = "formula";
            static className = "ql-formula";
            static tagName = "SPAN";
            static create(t5) {
              if (null == window.katex)
                throw new Error("Formula module requires KaTeX.");
              const e5 = super.create(t5);
              return "string" == typeof t5 && (window.katex.render(t5, e5, { throwOnError: false, errorColor: "#f00" }), e5.setAttribute("data-value", t5)), e5;
            }
            static value(t5) {
              return t5.getAttribute("data-value");
            }
            html() {
              const { formula: t5 } = this.value();
              return `<span>${t5}</span>`;
            }
          }, fo = ["alt", "height", "width"];
          const po = class extends hn {
            static {
              __name(this, "po");
            }
            static blotName = "image";
            static tagName = "IMG";
            static create(t5) {
              const e5 = super.create(t5);
              return "string" == typeof t5 && e5.setAttribute("src", this.sanitize(t5)), e5;
            }
            static formats(t5) {
              return fo.reduce((e5, n5) => (t5.hasAttribute(n5) && (e5[n5] = t5.getAttribute(n5)), e5), {});
            }
            static match(t5) {
              return /\.(jpe?g|gif|png)$/.test(t5) || /^data:image\/.+;base64/.test(t5);
            }
            static sanitize(t5) {
              return lo(t5, ["http", "https", "data"]) ? t5 : "//:0";
            }
            static value(t5) {
              return t5.getAttribute("src");
            }
            format(t5, e5) {
              fo.indexOf(t5) > -1 ? e5 ? this.domNode.setAttribute(t5, e5) : this.domNode.removeAttribute(t5) : super.format(t5, e5);
            }
          }, go = ["height", "width"];
          const mo = class extends Zr {
            static {
              __name(this, "mo");
            }
            static blotName = "video";
            static className = "ql-video";
            static tagName = "IFRAME";
            static create(t5) {
              const e5 = super.create(t5);
              return e5.setAttribute("frameborder", "0"), e5.setAttribute("allowfullscreen", "true"), e5.setAttribute("src", this.sanitize(t5)), e5;
            }
            static formats(t5) {
              return go.reduce((e5, n5) => (t5.hasAttribute(n5) && (e5[n5] = t5.getAttribute(n5)), e5), {});
            }
            static sanitize(t5) {
              return oo.sanitize(t5);
            }
            static value(t5) {
              return t5.getAttribute("src");
            }
            format(t5, e5) {
              go.indexOf(t5) > -1 ? e5 ? this.domNode.setAttribute(t5, e5) : this.domNode.removeAttribute(t5) : super.format(t5, e5);
            }
            html() {
              const { video: t5 } = this.value();
              return `<a href="${t5}">${t5}</a>`;
            }
          }, bo2 = new Ke("code-token", "hljs", { scope: Pe.INLINE });
          class yo extends Kr {
            static {
              __name(this, "yo");
            }
            static formats(t5, e5) {
              for (; null != t5 && t5 !== e5.domNode; ) {
                if (t5.classList && t5.classList.contains(ni.className))
                  return super.formats(t5, e5);
                t5 = t5.parentNode;
              }
            }
            constructor(t5, e5, n5) {
              super(t5, e5, n5), bo2.add(this.domNode, n5);
            }
            format(t5, e5) {
              t5 !== yo.blotName ? super.format(t5, e5) : e5 ? bo2.add(this.domNode, e5) : (bo2.remove(this.domNode), this.domNode.classList.remove(this.statics.className));
            }
            optimize() {
              super.optimize(...arguments), bo2.value(this.domNode) || this.unwrap();
            }
          }
          yo.blotName = "code-token", yo.className = "ql-token";
          class vo extends ni {
            static {
              __name(this, "vo");
            }
            static create(t5) {
              const e5 = super.create(t5);
              return "string" == typeof t5 && e5.setAttribute("data-language", t5), e5;
            }
            static formats(t5) {
              return t5.getAttribute("data-language") || "plain";
            }
            static register() {
            }
            format(t5, e5) {
              t5 === this.statics.blotName && e5 ? this.domNode.setAttribute("data-language", e5) : super.format(t5, e5);
            }
            replaceWith(t5, e5) {
              return this.formatAt(0, this.length(), yo.blotName, false), super.replaceWith(t5, e5);
            }
          }
          class xo extends ei {
            static {
              __name(this, "xo");
            }
            attach() {
              super.attach(), this.forceNext = false, this.scroll.emitMount(this);
            }
            format(t5, e5) {
              t5 === vo.blotName && (this.forceNext = true, this.children.forEach((n5) => {
                n5.format(t5, e5);
              }));
            }
            formatAt(t5, e5, n5, r4) {
              n5 === vo.blotName && (this.forceNext = true), super.formatAt(t5, e5, n5, r4);
            }
            highlight(t5) {
              let e5 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
              if (null == this.children.head)
                return;
              const n5 = `${Array.from(this.domNode.childNodes).filter((t6) => t6 !== this.uiNode).map((t6) => t6.textContent).join("\n")}
`, r4 = vo.formats(this.children.head.domNode);
              if (e5 || this.forceNext || this.cachedText !== n5) {
                if (n5.trim().length > 0 || null == this.cachedText) {
                  const e6 = this.children.reduce((t6, e7) => t6.concat(Gr(e7, false)), new bn2()), s4 = t5(n5, r4);
                  e6.diff(s4).reduce((t6, e7) => {
                    let { retain: n6, attributes: r5 } = e7;
                    return n6 ? (r5 && Object.keys(r5).forEach((e8) => {
                      [vo.blotName, yo.blotName].includes(e8) && this.formatAt(t6, n6, e8, r5[e8]);
                    }), t6 + n6) : t6;
                  }, 0);
                }
                this.cachedText = n5, this.forceNext = false;
              }
            }
            html(t5, e5) {
              const [n5] = this.children.find(t5);
              return `<pre data-language="${n5 ? vo.formats(n5.domNode) : "plain"}">
${$r(this.code(t5, e5))}
</pre>`;
            }
            optimize(t5) {
              if (super.optimize(t5), null != this.parent && null != this.children.head && null != this.uiNode) {
                const t6 = vo.formats(this.children.head.domNode);
                t6 !== this.uiNode.value && (this.uiNode.value = t6);
              }
            }
          }
          xo.allowedChildren = [vo], vo.requiredContainer = xo, vo.allowedChildren = [yo, Yr, Fr, Hr];
          class No extends xs {
            static {
              __name(this, "No");
            }
            static register() {
              Rs.register(yo, true), Rs.register(vo, true), Rs.register(xo, true);
            }
            constructor(t5, e5) {
              if (super(t5, e5), null == this.options.hljs)
                throw new Error("Syntax module requires highlight.js. Please include the library on the page before Quill.");
              this.languages = this.options.languages.reduce((t6, e6) => {
                let { key: n5 } = e6;
                return t6[n5] = true, t6;
              }, {}), this.highlightBlot = this.highlightBlot.bind(this), this.initListener(), this.initTimer();
            }
            initListener() {
              this.quill.on(Rs.events.SCROLL_BLOT_MOUNT, (t5) => {
                if (!(t5 instanceof xo))
                  return;
                const e5 = this.quill.root.ownerDocument.createElement("select");
                this.options.languages.forEach((t6) => {
                  let { key: n5, label: r4 } = t6;
                  const s4 = e5.ownerDocument.createElement("option");
                  s4.textContent = r4, s4.setAttribute("value", n5), e5.appendChild(s4);
                }), e5.addEventListener("change", () => {
                  t5.format(vo.blotName, e5.value), this.quill.root.focus(), this.highlight(t5, true);
                }), null == t5.uiNode && (t5.attachUI(e5), t5.children.head && (e5.value = vo.formats(t5.children.head.domNode)));
              });
            }
            initTimer() {
              let t5 = null;
              this.quill.on(Rs.events.SCROLL_OPTIMIZE, () => {
                t5 && clearTimeout(t5), t5 = setTimeout(() => {
                  this.highlight(), t5 = null;
                }, this.options.interval);
              });
            }
            highlight() {
              let t5 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null, e5 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
              if (this.quill.selection.composing)
                return;
              this.quill.update(Rs.sources.USER);
              const n5 = this.quill.getSelection();
              (null == t5 ? this.quill.scroll.descendants(xo) : [t5]).forEach((t6) => {
                t6.highlight(this.highlightBlot, e5);
              }), this.quill.update(Rs.sources.SILENT), null != n5 && this.quill.setSelection(n5, Rs.sources.SILENT);
            }
            highlightBlot(t5) {
              let e5 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "plain";
              if (e5 = this.languages[e5] ? e5 : "plain", "plain" === e5)
                return $r(t5).split("\n").reduce((t6, n6, r4) => (0 !== r4 && t6.insert("\n", { [ni.blotName]: e5 }), t6.insert(n6)), new bn2());
              const n5 = this.quill.root.ownerDocument.createElement("div");
              return n5.classList.add(ni.className), n5.innerHTML = ((t6, e6, n6) => {
                if ("string" == typeof t6.versionString) {
                  const r4 = t6.versionString.split(".")[0];
                  if (parseInt(r4, 10) >= 11)
                    return t6.highlight(n6, { language: e6 }).value;
                }
                return t6.highlight(e6, n6).value;
              })(this.options.hljs, e5, t5), Pi(this.quill.scroll, n5, [(t6, e6) => {
                const n6 = bo2.value(t6);
                return n6 ? e6.compose(new bn2().retain(e6.length(), { [yo.blotName]: n6 })) : e6;
              }], [(t6, n6) => t6.data.split("\n").reduce((t7, n7, r4) => (0 !== r4 && t7.insert("\n", { [ni.blotName]: e5 }), t7.insert(n7)), n6)], /* @__PURE__ */ new WeakMap());
            }
          }
          No.DEFAULTS = { hljs: window.hljs, interval: 1e3, languages: [{ key: "plain", label: "Plain" }, { key: "bash", label: "Bash" }, { key: "cpp", label: "C++" }, { key: "cs", label: "C#" }, { key: "css", label: "CSS" }, { key: "diff", label: "Diff" }, { key: "xml", label: "HTML/XML" }, { key: "java", label: "Java" }, { key: "javascript", label: "JavaScript" }, { key: "markdown", label: "Markdown" }, { key: "php", label: "PHP" }, { key: "python", label: "Python" }, { key: "ruby", label: "Ruby" }, { key: "sql", label: "SQL" }] };
          class wo extends Wr {
            static {
              __name(this, "wo");
            }
            static blotName = "table";
            static tagName = "TD";
            static create(t5) {
              const e5 = super.create();
              return t5 ? e5.setAttribute("data-row", t5) : e5.setAttribute("data-row", ko()), e5;
            }
            static formats(t5) {
              if (t5.hasAttribute("data-row"))
                return t5.getAttribute("data-row");
            }
            cellOffset() {
              return this.parent ? this.parent.children.indexOf(this) : -1;
            }
            format(t5, e5) {
              t5 === wo.blotName && e5 ? this.domNode.setAttribute("data-row", e5) : super.format(t5, e5);
            }
            row() {
              return this.parent;
            }
            rowOffset() {
              return this.row() ? this.row().rowOffset() : -1;
            }
            table() {
              return this.row() && this.row().table();
            }
          }
          class Eo extends zs {
            static {
              __name(this, "Eo");
            }
            static blotName = "table-row";
            static tagName = "TR";
            checkMerge() {
              if (super.checkMerge() && null != this.next.children.head) {
                const t5 = this.children.head.formats(), e5 = this.children.tail.formats(), n5 = this.next.children.head.formats(), r4 = this.next.children.tail.formats();
                return t5.table === e5.table && t5.table === n5.table && t5.table === r4.table;
              }
              return false;
            }
            optimize(t5) {
              super.optimize(t5), this.children.forEach((t6) => {
                if (null == t6.next)
                  return;
                const e5 = t6.formats(), n5 = t6.next.formats();
                if (e5.table !== n5.table) {
                  const e6 = this.splitAfter(t6);
                  e6 && e6.optimize(), this.prev && this.prev.optimize();
                }
              });
            }
            rowOffset() {
              return this.parent ? this.parent.children.indexOf(this) : -1;
            }
            table() {
              return this.parent && this.parent.parent;
            }
          }
          class Ao extends zs {
            static {
              __name(this, "Ao");
            }
            static blotName = "table-body";
            static tagName = "TBODY";
          }
          class qo extends zs {
            static {
              __name(this, "qo");
            }
            static blotName = "table-container";
            static tagName = "TABLE";
            balanceCells() {
              const t5 = this.descendants(Eo), e5 = t5.reduce((t6, e6) => Math.max(e6.children.length, t6), 0);
              t5.forEach((t6) => {
                new Array(e5 - t6.children.length).fill(0).forEach(() => {
                  let e6;
                  null != t6.children.head && (e6 = wo.formats(t6.children.head.domNode));
                  const n5 = this.scroll.create(wo.blotName, e6);
                  t6.appendChild(n5), n5.optimize();
                });
              });
            }
            cells(t5) {
              return this.rows().map((e5) => e5.children.at(t5));
            }
            deleteColumn(t5) {
              const [e5] = this.descendant(Ao);
              null != e5 && null != e5.children.head && e5.children.forEach((e6) => {
                const n5 = e6.children.at(t5);
                null != n5 && n5.remove();
              });
            }
            insertColumn(t5) {
              const [e5] = this.descendant(Ao);
              null != e5 && null != e5.children.head && e5.children.forEach((e6) => {
                const n5 = e6.children.at(t5), r4 = wo.formats(e6.children.head.domNode), s4 = this.scroll.create(wo.blotName, r4);
                e6.insertBefore(s4, n5);
              });
            }
            insertRow(t5) {
              const [e5] = this.descendant(Ao);
              if (null == e5 || null == e5.children.head)
                return;
              const n5 = ko(), r4 = this.scroll.create(Eo.blotName);
              e5.children.head.children.forEach(() => {
                const t6 = this.scroll.create(wo.blotName, n5);
                r4.appendChild(t6);
              });
              const s4 = e5.children.at(t5);
              e5.insertBefore(r4, s4);
            }
            rows() {
              const t5 = this.children.head;
              return null == t5 ? [] : t5.children.map((t6) => t6);
            }
          }
          function ko() {
            return `row-${Math.random().toString(36).slice(2, 6)}`;
          }
          __name(ko, "ko");
          qo.allowedChildren = [Ao], Ao.requiredContainer = qo, Ao.allowedChildren = [Eo], Eo.requiredContainer = Ao, Eo.allowedChildren = [wo], wo.requiredContainer = Eo;
          const _o = class extends xs {
            static {
              __name(this, "_o");
            }
            static register() {
              Rs.register(wo), Rs.register(Eo), Rs.register(Ao), Rs.register(qo);
            }
            constructor() {
              super(...arguments), this.listenBalanceCells();
            }
            balanceTables() {
              this.quill.scroll.descendants(qo).forEach((t5) => {
                t5.balanceCells();
              });
            }
            deleteColumn() {
              const [t5, , e5] = this.getTable();
              null != e5 && (t5.deleteColumn(e5.cellOffset()), this.quill.update(Rs.sources.USER));
            }
            deleteRow() {
              const [, t5] = this.getTable();
              null != t5 && (t5.remove(), this.quill.update(Rs.sources.USER));
            }
            deleteTable() {
              const [t5] = this.getTable();
              if (null == t5)
                return;
              const e5 = t5.offset();
              t5.remove(), this.quill.update(Rs.sources.USER), this.quill.setSelection(e5, Rs.sources.SILENT);
            }
            getTable() {
              let t5 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.quill.getSelection();
              if (null == t5)
                return [null, null, null, -1];
              const [e5, n5] = this.quill.getLine(t5.index);
              if (null == e5 || e5.statics.blotName !== wo.blotName)
                return [null, null, null, -1];
              const r4 = e5.parent;
              return [r4.parent.parent, r4, e5, n5];
            }
            insertColumn(t5) {
              const e5 = this.quill.getSelection();
              if (!e5)
                return;
              const [n5, r4, s4] = this.getTable(e5);
              if (null == s4)
                return;
              const i4 = s4.cellOffset();
              n5.insertColumn(i4 + t5), this.quill.update(Rs.sources.USER);
              let o4 = r4.rowOffset();
              0 === t5 && (o4 += 1), this.quill.setSelection(e5.index + o4, e5.length, Rs.sources.SILENT);
            }
            insertColumnLeft() {
              this.insertColumn(0);
            }
            insertColumnRight() {
              this.insertColumn(1);
            }
            insertRow(t5) {
              const e5 = this.quill.getSelection();
              if (!e5)
                return;
              const [n5, r4, s4] = this.getTable(e5);
              if (null == s4)
                return;
              const i4 = r4.rowOffset();
              n5.insertRow(i4 + t5), this.quill.update(Rs.sources.USER), t5 > 0 ? this.quill.setSelection(e5, Rs.sources.SILENT) : this.quill.setSelection(e5.index + r4.children.length, e5.length, Rs.sources.SILENT);
            }
            insertRowAbove() {
              this.insertRow(0);
            }
            insertRowBelow() {
              this.insertRow(1);
            }
            insertTable(t5, e5) {
              const n5 = this.quill.getSelection();
              if (null == n5)
                return;
              const r4 = new Array(t5).fill(0).reduce((t6) => {
                const n6 = new Array(e5).fill("\n").join("");
                return t6.insert(n6, { table: ko() });
              }, new bn2().retain(n5.index));
              this.quill.updateContents(r4, Rs.sources.USER), this.quill.setSelection(n5.index, Rs.sources.SILENT), this.balanceTables();
            }
            listenBalanceCells() {
              this.quill.on(Rs.events.SCROLL_OPTIMIZE, (t5) => {
                t5.some((t6) => !!["TD", "TR", "TBODY", "TABLE"].includes(t6.target.tagName) && (this.quill.once(Rs.events.TEXT_CHANGE, (t7, e5, n5) => {
                  n5 === Rs.sources.USER && this.balanceTables();
                }), true));
              });
            }
          }, Lo = is2("quill:toolbar");
          class Oo extends xs {
            static {
              __name(this, "Oo");
            }
            constructor(t5, e5) {
              if (super(t5, e5), Array.isArray(this.options.container)) {
                const e6 = document.createElement("div");
                e6.setAttribute("role", "toolbar"), function(t6, e7) {
                  Array.isArray(e7[0]) || (e7 = [e7]);
                  e7.forEach((e8) => {
                    const n5 = document.createElement("span");
                    n5.classList.add("ql-formats"), e8.forEach((t7) => {
                      if ("string" == typeof t7)
                        To(n5, t7);
                      else {
                        const e9 = Object.keys(t7)[0], r4 = t7[e9];
                        Array.isArray(r4) ? function(t8, e10, n6) {
                          const r5 = document.createElement("select");
                          r5.classList.add(`ql-${e10}`), n6.forEach((t9) => {
                            const e11 = document.createElement("option");
                            false !== t9 ? e11.setAttribute("value", String(t9)) : e11.setAttribute("selected", "selected"), r5.appendChild(e11);
                          }), t8.appendChild(r5);
                        }(n5, e9, r4) : To(n5, e9, r4);
                      }
                    }), t6.appendChild(n5);
                  });
                }(e6, this.options.container), t5.container?.parentNode?.insertBefore(e6, t5.container), this.container = e6;
              } else
                "string" == typeof this.options.container ? this.container = document.querySelector(this.options.container) : this.container = this.options.container;
              this.container instanceof HTMLElement ? (this.container.classList.add("ql-toolbar"), this.controls = [], this.handlers = {}, this.options.handlers && Object.keys(this.options.handlers).forEach((t6) => {
                const e6 = this.options.handlers?.[t6];
                e6 && this.addHandler(t6, e6);
              }), Array.from(this.container.querySelectorAll("button, select")).forEach((t6) => {
                this.attach(t6);
              }), this.quill.on(Rs.events.EDITOR_CHANGE, () => {
                const [t6] = this.quill.selection.getRange();
                this.update(t6);
              })) : Lo.error("Container required for toolbar", this.options);
            }
            addHandler(t5, e5) {
              this.handlers[t5] = e5;
            }
            attach(t5) {
              let e5 = Array.from(t5.classList).find((t6) => 0 === t6.indexOf("ql-"));
              if (!e5)
                return;
              if (e5 = e5.slice(3), "BUTTON" === t5.tagName && t5.setAttribute("type", "button"), null == this.handlers[e5] && null == this.quill.scroll.query(e5))
                return void Lo.warn("ignoring attaching to nonexistent format", e5, t5);
              const n5 = "SELECT" === t5.tagName ? "change" : "click";
              t5.addEventListener(n5, (n6) => {
                let r4;
                if ("SELECT" === t5.tagName) {
                  if (t5.selectedIndex < 0)
                    return;
                  const e6 = t5.options[t5.selectedIndex];
                  r4 = !e6.hasAttribute("selected") && (e6.value || false);
                } else
                  r4 = !t5.classList.contains("ql-active") && (t5.value || !t5.hasAttribute("value")), n6.preventDefault();
                this.quill.focus();
                const [s4] = this.quill.selection.getRange();
                if (null != this.handlers[e5])
                  this.handlers[e5].call(this, r4);
                else if (this.quill.scroll.query(e5).prototype instanceof hn) {
                  if (r4 = prompt(`Enter ${e5}`), !r4)
                    return;
                  this.quill.updateContents(new bn2().retain(s4.index).delete(s4.length).insert({ [e5]: r4 }), Rs.sources.USER);
                } else
                  this.quill.format(e5, r4, Rs.sources.USER);
                this.update(s4);
              }), this.controls.push([e5, t5]);
            }
            update(t5) {
              const e5 = null == t5 ? {} : this.quill.getFormat(t5);
              this.controls.forEach((n5) => {
                const [r4, s4] = n5;
                if ("SELECT" === s4.tagName) {
                  let n6 = null;
                  if (null == t5)
                    n6 = null;
                  else if (null == e5[r4])
                    n6 = s4.querySelector("option[selected]");
                  else if (!Array.isArray(e5[r4])) {
                    let t6 = e5[r4];
                    "string" == typeof t6 && (t6 = t6.replace(/"/g, '\\"')), n6 = s4.querySelector(`option[value="${t6}"]`);
                  }
                  null == n6 ? (s4.value = "", s4.selectedIndex = -1) : n6.selected = true;
                } else if (null == t5)
                  s4.classList.remove("ql-active"), s4.setAttribute("aria-pressed", "false");
                else if (s4.hasAttribute("value")) {
                  const t6 = e5[r4], n6 = t6 === s4.getAttribute("value") || null != t6 && t6.toString() === s4.getAttribute("value") || null == t6 && !s4.getAttribute("value");
                  s4.classList.toggle("ql-active", n6), s4.setAttribute("aria-pressed", n6.toString());
                } else {
                  const t6 = null != e5[r4];
                  s4.classList.toggle("ql-active", t6), s4.setAttribute("aria-pressed", t6.toString());
                }
              });
            }
          }
          function To(t5, e5, n5) {
            const r4 = document.createElement("button");
            r4.setAttribute("type", "button"), r4.classList.add(`ql-${e5}`), r4.setAttribute("aria-pressed", "false"), null != n5 ? (r4.value = n5, r4.setAttribute("aria-label", `${e5}: ${n5}`)) : r4.setAttribute("aria-label", e5), t5.appendChild(r4);
          }
          __name(To, "To");
          Oo.DEFAULTS = {}, Oo.DEFAULTS = { container: null, handlers: { clean() {
            const t5 = this.quill.getSelection();
            if (null != t5)
              if (0 === t5.length) {
                const t6 = this.quill.getFormat();
                Object.keys(t6).forEach((t7) => {
                  null != this.quill.scroll.query(t7, Pe.INLINE) && this.quill.format(t7, false, Rs.sources.USER);
                });
              } else
                this.quill.removeFormat(t5.index, t5.length, Rs.sources.USER);
          }, direction(t5) {
            const { align: e5 } = this.quill.getFormat();
            "rtl" === t5 && null == e5 ? this.quill.format("align", "right", Rs.sources.USER) : t5 || "right" !== e5 || this.quill.format("align", false, Rs.sources.USER), this.quill.format("direction", t5, Rs.sources.USER);
          }, indent(t5) {
            const e5 = this.quill.getSelection(), n5 = this.quill.getFormat(e5), r4 = parseInt(n5.indent || 0, 10);
            if ("+1" === t5 || "-1" === t5) {
              let e6 = "+1" === t5 ? 1 : -1;
              "rtl" === n5.direction && (e6 *= -1), this.quill.format("indent", r4 + e6, Rs.sources.USER);
            }
          }, link(t5) {
            true === t5 && (t5 = prompt("Enter link URL:")), this.quill.format("link", t5, Rs.sources.USER);
          }, list(t5) {
            const e5 = this.quill.getSelection(), n5 = this.quill.getFormat(e5);
            "check" === t5 ? "checked" === n5.list || "unchecked" === n5.list ? this.quill.format("list", false, Rs.sources.USER) : this.quill.format("list", "unchecked", Rs.sources.USER) : this.quill.format("list", t5, Rs.sources.USER);
          } } };
          const So = '<svg viewbox="0 0 18 18"><polyline class="ql-even ql-stroke" points="5 7 3 9 5 11"/><polyline class="ql-even ql-stroke" points="13 7 15 9 13 11"/><line class="ql-stroke" x1="10" x2="8" y1="5" y2="13"/></svg>', Co = { align: { "": '<svg viewbox="0 0 18 18"><line class="ql-stroke" x1="3" x2="15" y1="9" y2="9"/><line class="ql-stroke" x1="3" x2="13" y1="14" y2="14"/><line class="ql-stroke" x1="3" x2="9" y1="4" y2="4"/></svg>', center: '<svg viewbox="0 0 18 18"><line class="ql-stroke" x1="15" x2="3" y1="9" y2="9"/><line class="ql-stroke" x1="14" x2="4" y1="14" y2="14"/><line class="ql-stroke" x1="12" x2="6" y1="4" y2="4"/></svg>', right: '<svg viewbox="0 0 18 18"><line class="ql-stroke" x1="15" x2="3" y1="9" y2="9"/><line class="ql-stroke" x1="15" x2="5" y1="14" y2="14"/><line class="ql-stroke" x1="15" x2="9" y1="4" y2="4"/></svg>', justify: '<svg viewbox="0 0 18 18"><line class="ql-stroke" x1="15" x2="3" y1="9" y2="9"/><line class="ql-stroke" x1="15" x2="3" y1="14" y2="14"/><line class="ql-stroke" x1="15" x2="3" y1="4" y2="4"/></svg>' }, background: '<svg viewbox="0 0 18 18"><g class="ql-fill ql-color-label"><polygon points="6 6.868 6 6 5 6 5 7 5.942 7 6 6.868"/><rect height="1" width="1" x="4" y="4"/><polygon points="6.817 5 6 5 6 6 6.38 6 6.817 5"/><rect height="1" width="1" x="2" y="6"/><rect height="1" width="1" x="3" y="5"/><rect height="1" width="1" x="4" y="7"/><polygon points="4 11.439 4 11 3 11 3 12 3.755 12 4 11.439"/><rect height="1" width="1" x="2" y="12"/><rect height="1" width="1" x="2" y="9"/><rect height="1" width="1" x="2" y="15"/><polygon points="4.63 10 4 10 4 11 4.192 11 4.63 10"/><rect height="1" width="1" x="3" y="8"/><path d="M10.832,4.2L11,4.582V4H10.708A1.948,1.948,0,0,1,10.832,4.2Z"/><path d="M7,4.582L7.168,4.2A1.929,1.929,0,0,1,7.292,4H7V4.582Z"/><path d="M8,13H7.683l-0.351.8a1.933,1.933,0,0,1-.124.2H8V13Z"/><rect height="1" width="1" x="12" y="2"/><rect height="1" width="1" x="11" y="3"/><path d="M9,3H8V3.282A1.985,1.985,0,0,1,9,3Z"/><rect height="1" width="1" x="2" y="3"/><rect height="1" width="1" x="6" y="2"/><rect height="1" width="1" x="3" y="2"/><rect height="1" width="1" x="5" y="3"/><rect height="1" width="1" x="9" y="2"/><rect height="1" width="1" x="15" y="14"/><polygon points="13.447 10.174 13.469 10.225 13.472 10.232 13.808 11 14 11 14 10 13.37 10 13.447 10.174"/><rect height="1" width="1" x="13" y="7"/><rect height="1" width="1" x="15" y="5"/><rect height="1" width="1" x="14" y="6"/><rect height="1" width="1" x="15" y="8"/><rect height="1" width="1" x="14" y="9"/><path d="M3.775,14H3v1H4V14.314A1.97,1.97,0,0,1,3.775,14Z"/><rect height="1" width="1" x="14" y="3"/><polygon points="12 6.868 12 6 11.62 6 12 6.868"/><rect height="1" width="1" x="15" y="2"/><rect height="1" width="1" x="12" y="5"/><rect height="1" width="1" x="13" y="4"/><polygon points="12.933 9 13 9 13 8 12.495 8 12.933 9"/><rect height="1" width="1" x="9" y="14"/><rect height="1" width="1" x="8" y="15"/><path d="M6,14.926V15H7V14.316A1.993,1.993,0,0,1,6,14.926Z"/><rect height="1" width="1" x="5" y="15"/><path d="M10.668,13.8L10.317,13H10v1h0.792A1.947,1.947,0,0,1,10.668,13.8Z"/><rect height="1" width="1" x="11" y="15"/><path d="M14.332,12.2a1.99,1.99,0,0,1,.166.8H15V12H14.245Z"/><rect height="1" width="1" x="14" y="15"/><rect height="1" width="1" x="15" y="11"/></g><polyline class="ql-stroke" points="5.5 13 9 5 12.5 13"/><line class="ql-stroke" x1="11.63" x2="6.38" y1="11" y2="11"/></svg>', blockquote: '<svg viewbox="0 0 18 18"><rect class="ql-fill ql-stroke" height="3" width="3" x="4" y="5"/><rect class="ql-fill ql-stroke" height="3" width="3" x="11" y="5"/><path class="ql-even ql-fill ql-stroke" d="M7,8c0,4.031-3,5-3,5"/><path class="ql-even ql-fill ql-stroke" d="M14,8c0,4.031-3,5-3,5"/></svg>', bold: '<svg viewbox="0 0 18 18"><path class="ql-stroke" d="M5,4H9.5A2.5,2.5,0,0,1,12,6.5v0A2.5,2.5,0,0,1,9.5,9H5A0,0,0,0,1,5,9V4A0,0,0,0,1,5,4Z"/><path class="ql-stroke" d="M5,9h5.5A2.5,2.5,0,0,1,13,11.5v0A2.5,2.5,0,0,1,10.5,14H5a0,0,0,0,1,0,0V9A0,0,0,0,1,5,9Z"/></svg>', clean: '<svg class="" viewbox="0 0 18 18"><line class="ql-stroke" x1="5" x2="13" y1="3" y2="3"/><line class="ql-stroke" x1="6" x2="9.35" y1="12" y2="3"/><line class="ql-stroke" x1="11" x2="15" y1="11" y2="15"/><line class="ql-stroke" x1="15" x2="11" y1="11" y2="15"/><rect class="ql-fill" height="1" rx="0.5" ry="0.5" width="7" x="2" y="14"/></svg>', code: So, "code-block": So, color: '<svg viewbox="0 0 18 18"><line class="ql-color-label ql-stroke ql-transparent" x1="3" x2="15" y1="15" y2="15"/><polyline class="ql-stroke" points="5.5 11 9 3 12.5 11"/><line class="ql-stroke" x1="11.63" x2="6.38" y1="9" y2="9"/></svg>', direction: { "": '<svg viewbox="0 0 18 18"><polygon class="ql-stroke ql-fill" points="3 11 5 9 3 7 3 11"/><line class="ql-stroke ql-fill" x1="15" x2="11" y1="4" y2="4"/><path class="ql-fill" d="M11,3a3,3,0,0,0,0,6h1V3H11Z"/><rect class="ql-fill" height="11" width="1" x="11" y="4"/><rect class="ql-fill" height="11" width="1" x="13" y="4"/></svg>', rtl: '<svg viewbox="0 0 18 18"><polygon class="ql-stroke ql-fill" points="15 12 13 10 15 8 15 12"/><line class="ql-stroke ql-fill" x1="9" x2="5" y1="4" y2="4"/><path class="ql-fill" d="M5,3A3,3,0,0,0,5,9H6V3H5Z"/><rect class="ql-fill" height="11" width="1" x="5" y="4"/><rect class="ql-fill" height="11" width="1" x="7" y="4"/></svg>' }, formula: '<svg viewbox="0 0 18 18"><path class="ql-fill" d="M11.759,2.482a2.561,2.561,0,0,0-3.53.607A7.656,7.656,0,0,0,6.8,6.2C6.109,9.188,5.275,14.677,4.15,14.927a1.545,1.545,0,0,0-1.3-.933A0.922,0.922,0,0,0,2,15.036S1.954,16,4.119,16s3.091-2.691,3.7-5.553c0.177-.826.36-1.726,0.554-2.6L8.775,6.2c0.381-1.421.807-2.521,1.306-2.676a1.014,1.014,0,0,0,1.02.56A0.966,0.966,0,0,0,11.759,2.482Z"/><rect class="ql-fill" height="1.6" rx="0.8" ry="0.8" width="5" x="5.15" y="6.2"/><path class="ql-fill" d="M13.663,12.027a1.662,1.662,0,0,1,.266-0.276q0.193,0.069.456,0.138a2.1,2.1,0,0,0,.535.069,1.075,1.075,0,0,0,.767-0.3,1.044,1.044,0,0,0,.314-0.8,0.84,0.84,0,0,0-.238-0.619,0.8,0.8,0,0,0-.594-0.239,1.154,1.154,0,0,0-.781.3,4.607,4.607,0,0,0-.781,1q-0.091.15-.218,0.346l-0.246.38c-0.068-.288-0.137-0.582-0.212-0.885-0.459-1.847-2.494-.984-2.941-0.8-0.482.2-.353,0.647-0.094,0.529a0.869,0.869,0,0,1,1.281.585c0.217,0.751.377,1.436,0.527,2.038a5.688,5.688,0,0,1-.362.467,2.69,2.69,0,0,1-.264.271q-0.221-.08-0.471-0.147a2.029,2.029,0,0,0-.522-0.066,1.079,1.079,0,0,0-.768.3A1.058,1.058,0,0,0,9,15.131a0.82,0.82,0,0,0,.832.852,1.134,1.134,0,0,0,.787-0.3,5.11,5.11,0,0,0,.776-0.993q0.141-.219.215-0.34c0.046-.076.122-0.194,0.223-0.346a2.786,2.786,0,0,0,.918,1.726,2.582,2.582,0,0,0,2.376-.185c0.317-.181.212-0.565,0-0.494A0.807,0.807,0,0,1,14.176,15a5.159,5.159,0,0,1-.913-2.446l0,0Q13.487,12.24,13.663,12.027Z"/></svg>', header: { 1: '<svg viewBox="0 0 18 18"><path class="ql-fill" d="M10,4V14a1,1,0,0,1-2,0V10H3v4a1,1,0,0,1-2,0V4A1,1,0,0,1,3,4V8H8V4a1,1,0,0,1,2,0Zm6.06787,9.209H14.98975V7.59863a.54085.54085,0,0,0-.605-.60547h-.62744a1.01119,1.01119,0,0,0-.748.29688L11.645,8.56641a.5435.5435,0,0,0-.022.8584l.28613.30762a.53861.53861,0,0,0,.84717.0332l.09912-.08789a1.2137,1.2137,0,0,0,.2417-.35254h.02246s-.01123.30859-.01123.60547V13.209H12.041a.54085.54085,0,0,0-.605.60547v.43945a.54085.54085,0,0,0,.605.60547h4.02686a.54085.54085,0,0,0,.605-.60547v-.43945A.54085.54085,0,0,0,16.06787,13.209Z"/></svg>', 2: '<svg viewBox="0 0 18 18"><path class="ql-fill" d="M16.73975,13.81445v.43945a.54085.54085,0,0,1-.605.60547H11.855a.58392.58392,0,0,1-.64893-.60547V14.0127c0-2.90527,3.39941-3.42187,3.39941-4.55469a.77675.77675,0,0,0-.84717-.78125,1.17684,1.17684,0,0,0-.83594.38477c-.2749.26367-.561.374-.85791.13184l-.4292-.34082c-.30811-.24219-.38525-.51758-.1543-.81445a2.97155,2.97155,0,0,1,2.45361-1.17676,2.45393,2.45393,0,0,1,2.68408,2.40918c0,2.45312-3.1792,2.92676-3.27832,3.93848h2.79443A.54085.54085,0,0,1,16.73975,13.81445ZM9,3A.99974.99974,0,0,0,8,4V8H3V4A1,1,0,0,0,1,4V14a1,1,0,0,0,2,0V10H8v4a1,1,0,0,0,2,0V4A.99974.99974,0,0,0,9,3Z"/></svg>', 3: '<svg viewBox="0 0 18 18"><path class="ql-fill" d="M16.65186,12.30664a2.6742,2.6742,0,0,1-2.915,2.68457,3.96592,3.96592,0,0,1-2.25537-.6709.56007.56007,0,0,1-.13232-.83594L11.64648,13c.209-.34082.48389-.36328.82471-.1543a2.32654,2.32654,0,0,0,1.12256.33008c.71484,0,1.12207-.35156,1.12207-.78125,0-.61523-.61621-.86816-1.46338-.86816H13.2085a.65159.65159,0,0,1-.68213-.41895l-.05518-.10937a.67114.67114,0,0,1,.14307-.78125l.71533-.86914a8.55289,8.55289,0,0,1,.68213-.7373V8.58887a3.93913,3.93913,0,0,1-.748.05469H11.9873a.54085.54085,0,0,1-.605-.60547V7.59863a.54085.54085,0,0,1,.605-.60547h3.75146a.53773.53773,0,0,1,.60547.59375v.17676a1.03723,1.03723,0,0,1-.27539.748L14.74854,10.0293A2.31132,2.31132,0,0,1,16.65186,12.30664ZM9,3A.99974.99974,0,0,0,8,4V8H3V4A1,1,0,0,0,1,4V14a1,1,0,0,0,2,0V10H8v4a1,1,0,0,0,2,0V4A.99974.99974,0,0,0,9,3Z"/></svg>', 4: '<svg viewBox="0 0 18 18"><path class="ql-fill" d="M10,4V14a1,1,0,0,1-2,0V10H3v4a1,1,0,0,1-2,0V4A1,1,0,0,1,3,4V8H8V4a1,1,0,0,1,2,0Zm7.05371,7.96582v.38477c0,.39648-.165.60547-.46191.60547h-.47314v1.29785a.54085.54085,0,0,1-.605.60547h-.69336a.54085.54085,0,0,1-.605-.60547V12.95605H11.333a.5412.5412,0,0,1-.60547-.60547v-.15332a1.199,1.199,0,0,1,.22021-.748l2.56348-4.05957a.7819.7819,0,0,1,.72607-.39648h1.27637a.54085.54085,0,0,1,.605.60547v3.7627h.33008A.54055.54055,0,0,1,17.05371,11.96582ZM14.28125,8.7207h-.022a4.18969,4.18969,0,0,1-.38525.81348l-1.188,1.80469v.02246h1.5293V9.60059A7.04058,7.04058,0,0,1,14.28125,8.7207Z"/></svg>', 5: '<svg viewBox="0 0 18 18"><path class="ql-fill" d="M16.74023,12.18555a2.75131,2.75131,0,0,1-2.91553,2.80566,3.908,3.908,0,0,1-2.25537-.68164.54809.54809,0,0,1-.13184-.8252L11.73438,13c.209-.34082.48389-.36328.8252-.1543a2.23757,2.23757,0,0,0,1.1001.33008,1.01827,1.01827,0,0,0,1.1001-.96777c0-.61621-.53906-.97949-1.25439-.97949a2.15554,2.15554,0,0,0-.64893.09961,1.15209,1.15209,0,0,1-.814.01074l-.12109-.04395a.64116.64116,0,0,1-.45117-.71484l.231-3.00391a.56666.56666,0,0,1,.62744-.583H15.541a.54085.54085,0,0,1,.605.60547v.43945a.54085.54085,0,0,1-.605.60547H13.41748l-.04395.72559a1.29306,1.29306,0,0,1-.04395.30859h.022a2.39776,2.39776,0,0,1,.57227-.07715A2.53266,2.53266,0,0,1,16.74023,12.18555ZM9,3A.99974.99974,0,0,0,8,4V8H3V4A1,1,0,0,0,1,4V14a1,1,0,0,0,2,0V10H8v4a1,1,0,0,0,2,0V4A.99974.99974,0,0,0,9,3Z"/></svg>', 6: '<svg viewBox="0 0 18 18"><path class="ql-fill" d="M14.51758,9.64453a1.85627,1.85627,0,0,0-1.24316.38477H13.252a1.73532,1.73532,0,0,1,1.72754-1.4082,2.66491,2.66491,0,0,1,.5498.06641c.35254.05469.57227.01074.70508-.40723l.16406-.5166a.53393.53393,0,0,0-.373-.75977,4.83723,4.83723,0,0,0-1.17773-.14258c-2.43164,0-3.7627,2.17773-3.7627,4.43359,0,2.47559,1.60645,3.69629,3.19043,3.69629A2.70585,2.70585,0,0,0,16.96,12.19727,2.43861,2.43861,0,0,0,14.51758,9.64453Zm-.23047,3.58691c-.67187,0-1.22168-.81445-1.22168-1.45215,0-.47363.30762-.583.72559-.583.96875,0,1.27734.59375,1.27734,1.12207A.82182.82182,0,0,1,14.28711,13.23145ZM10,4V14a1,1,0,0,1-2,0V10H3v4a1,1,0,0,1-2,0V4A1,1,0,0,1,3,4V8H8V4a1,1,0,0,1,2,0Z"/></svg>' }, italic: '<svg viewbox="0 0 18 18"><line class="ql-stroke" x1="7" x2="13" y1="4" y2="4"/><line class="ql-stroke" x1="5" x2="11" y1="14" y2="14"/><line class="ql-stroke" x1="8" x2="10" y1="14" y2="4"/></svg>', image: '<svg viewbox="0 0 18 18"><rect class="ql-stroke" height="10" width="12" x="3" y="4"/><circle class="ql-fill" cx="6" cy="7" r="1"/><polyline class="ql-even ql-fill" points="5 12 5 11 7 9 8 10 11 7 13 9 13 12 5 12"/></svg>', indent: { "+1": '<svg viewbox="0 0 18 18"><line class="ql-stroke" x1="3" x2="15" y1="14" y2="14"/><line class="ql-stroke" x1="3" x2="15" y1="4" y2="4"/><line class="ql-stroke" x1="9" x2="15" y1="9" y2="9"/><polyline class="ql-fill ql-stroke" points="3 7 3 11 5 9 3 7"/></svg>', "-1": '<svg viewbox="0 0 18 18"><line class="ql-stroke" x1="3" x2="15" y1="14" y2="14"/><line class="ql-stroke" x1="3" x2="15" y1="4" y2="4"/><line class="ql-stroke" x1="9" x2="15" y1="9" y2="9"/><polyline class="ql-stroke" points="5 7 5 11 3 9 5 7"/></svg>' }, link: '<svg viewbox="0 0 18 18"><line class="ql-stroke" x1="7" x2="11" y1="7" y2="11"/><path class="ql-even ql-stroke" d="M8.9,4.577a3.476,3.476,0,0,1,.36,4.679A3.476,3.476,0,0,1,4.577,8.9C3.185,7.5,2.035,6.4,4.217,4.217S7.5,3.185,8.9,4.577Z"/><path class="ql-even ql-stroke" d="M13.423,9.1a3.476,3.476,0,0,0-4.679-.36,3.476,3.476,0,0,0,.36,4.679c1.392,1.392,2.5,2.542,4.679.36S14.815,10.5,13.423,9.1Z"/></svg>', list: { bullet: '<svg viewbox="0 0 18 18"><line class="ql-stroke" x1="6" x2="15" y1="4" y2="4"/><line class="ql-stroke" x1="6" x2="15" y1="9" y2="9"/><line class="ql-stroke" x1="6" x2="15" y1="14" y2="14"/><line class="ql-stroke" x1="3" x2="3" y1="4" y2="4"/><line class="ql-stroke" x1="3" x2="3" y1="9" y2="9"/><line class="ql-stroke" x1="3" x2="3" y1="14" y2="14"/></svg>', check: '<svg class="" viewbox="0 0 18 18"><line class="ql-stroke" x1="9" x2="15" y1="4" y2="4"/><polyline class="ql-stroke" points="3 4 4 5 6 3"/><line class="ql-stroke" x1="9" x2="15" y1="14" y2="14"/><polyline class="ql-stroke" points="3 14 4 15 6 13"/><line class="ql-stroke" x1="9" x2="15" y1="9" y2="9"/><polyline class="ql-stroke" points="3 9 4 10 6 8"/></svg>', ordered: '<svg viewbox="0 0 18 18"><line class="ql-stroke" x1="7" x2="15" y1="4" y2="4"/><line class="ql-stroke" x1="7" x2="15" y1="9" y2="9"/><line class="ql-stroke" x1="7" x2="15" y1="14" y2="14"/><line class="ql-stroke ql-thin" x1="2.5" x2="4.5" y1="5.5" y2="5.5"/><path class="ql-fill" d="M3.5,6A0.5,0.5,0,0,1,3,5.5V3.085l-0.276.138A0.5,0.5,0,0,1,2.053,3c-0.124-.247-0.023-0.324.224-0.447l1-.5A0.5,0.5,0,0,1,4,2.5v3A0.5,0.5,0,0,1,3.5,6Z"/><path class="ql-stroke ql-thin" d="M4.5,10.5h-2c0-.234,1.85-1.076,1.85-2.234A0.959,0.959,0,0,0,2.5,8.156"/><path class="ql-stroke ql-thin" d="M2.5,14.846a0.959,0.959,0,0,0,1.85-.109A0.7,0.7,0,0,0,3.75,14a0.688,0.688,0,0,0,.6-0.736,0.959,0.959,0,0,0-1.85-.109"/></svg>' }, script: { sub: '<svg viewbox="0 0 18 18"><path class="ql-fill" d="M15.5,15H13.861a3.858,3.858,0,0,0,1.914-2.975,1.8,1.8,0,0,0-1.6-1.751A1.921,1.921,0,0,0,12.021,11.7a0.50013,0.50013,0,1,0,.957.291h0a0.914,0.914,0,0,1,1.053-.725,0.81,0.81,0,0,1,.744.762c0,1.076-1.16971,1.86982-1.93971,2.43082A1.45639,1.45639,0,0,0,12,15.5a0.5,0.5,0,0,0,.5.5h3A0.5,0.5,0,0,0,15.5,15Z"/><path class="ql-fill" d="M9.65,5.241a1,1,0,0,0-1.409.108L6,7.964,3.759,5.349A1,1,0,0,0,2.192,6.59178Q2.21541,6.6213,2.241,6.649L4.684,9.5,2.241,12.35A1,1,0,0,0,3.71,13.70722q0.02557-.02768.049-0.05722L6,11.036,8.241,13.65a1,1,0,1,0,1.567-1.24277Q9.78459,12.3777,9.759,12.35L7.316,9.5,9.759,6.651A1,1,0,0,0,9.65,5.241Z"/></svg>', super: '<svg viewbox="0 0 18 18"><path class="ql-fill" d="M15.5,7H13.861a4.015,4.015,0,0,0,1.914-2.975,1.8,1.8,0,0,0-1.6-1.751A1.922,1.922,0,0,0,12.021,3.7a0.5,0.5,0,1,0,.957.291,0.917,0.917,0,0,1,1.053-.725,0.81,0.81,0,0,1,.744.762c0,1.077-1.164,1.925-1.934,2.486A1.423,1.423,0,0,0,12,7.5a0.5,0.5,0,0,0,.5.5h3A0.5,0.5,0,0,0,15.5,7Z"/><path class="ql-fill" d="M9.651,5.241a1,1,0,0,0-1.41.108L6,7.964,3.759,5.349a1,1,0,1,0-1.519,1.3L4.683,9.5,2.241,12.35a1,1,0,1,0,1.519,1.3L6,11.036,8.241,13.65a1,1,0,0,0,1.519-1.3L7.317,9.5,9.759,6.651A1,1,0,0,0,9.651,5.241Z"/></svg>' }, strike: '<svg viewbox="0 0 18 18"><line class="ql-stroke ql-thin" x1="15.5" x2="2.5" y1="8.5" y2="9.5"/><path class="ql-fill" d="M9.007,8C6.542,7.791,6,7.519,6,6.5,6,5.792,7.283,5,9,5c1.571,0,2.765.679,2.969,1.309a1,1,0,0,0,1.9-.617C13.356,4.106,11.354,3,9,3,6.2,3,4,4.538,4,6.5a3.2,3.2,0,0,0,.5,1.843Z"/><path class="ql-fill" d="M8.984,10C11.457,10.208,12,10.479,12,11.5c0,0.708-1.283,1.5-3,1.5-1.571,0-2.765-.679-2.969-1.309a1,1,0,1,0-1.9.617C4.644,13.894,6.646,15,9,15c2.8,0,5-1.538,5-3.5a3.2,3.2,0,0,0-.5-1.843Z"/></svg>', table: '<svg viewbox="0 0 18 18"><rect class="ql-stroke" height="12" width="12" x="3" y="3"/><rect class="ql-fill" height="2" width="3" x="5" y="5"/><rect class="ql-fill" height="2" width="4" x="9" y="5"/><g class="ql-fill ql-transparent"><rect height="2" width="3" x="5" y="8"/><rect height="2" width="4" x="9" y="8"/><rect height="2" width="3" x="5" y="11"/><rect height="2" width="4" x="9" y="11"/></g></svg>', underline: '<svg viewbox="0 0 18 18"><path class="ql-stroke" d="M5,3V9a4.012,4.012,0,0,0,4,4H9a4.012,4.012,0,0,0,4-4V3"/><rect class="ql-fill" height="1" rx="0.5" ry="0.5" width="12" x="3" y="15"/></svg>', video: '<svg viewbox="0 0 18 18"><rect class="ql-stroke" height="12" width="12" x="3" y="3"/><rect class="ql-fill" height="12" width="1" x="5" y="3"/><rect class="ql-fill" height="12" width="1" x="12" y="3"/><rect class="ql-fill" height="2" width="8" x="5" y="8"/><rect class="ql-fill" height="1" width="3" x="3" y="5"/><rect class="ql-fill" height="1" width="3" x="3" y="7"/><rect class="ql-fill" height="1" width="3" x="3" y="10"/><rect class="ql-fill" height="1" width="3" x="3" y="12"/><rect class="ql-fill" height="1" width="3" x="12" y="5"/><rect class="ql-fill" height="1" width="3" x="12" y="7"/><rect class="ql-fill" height="1" width="3" x="12" y="10"/><rect class="ql-fill" height="1" width="3" x="12" y="12"/></svg>' };
          let jo = 0;
          function Ro(t5, e5) {
            t5.setAttribute(e5, `${!("true" === t5.getAttribute(e5))}`);
          }
          __name(Ro, "Ro");
          const Io = class {
            static {
              __name(this, "Io");
            }
            constructor(t5) {
              this.select = t5, this.container = document.createElement("span"), this.buildPicker(), this.select.style.display = "none", this.select.parentNode.insertBefore(this.container, this.select), this.label.addEventListener("mousedown", () => {
                this.togglePicker();
              }), this.label.addEventListener("keydown", (t6) => {
                switch (t6.key) {
                  case "Enter":
                    this.togglePicker();
                    break;
                  case "Escape":
                    this.escape(), t6.preventDefault();
                }
              }), this.select.addEventListener("change", this.update.bind(this));
            }
            togglePicker() {
              this.container.classList.toggle("ql-expanded"), Ro(this.label, "aria-expanded"), Ro(this.options, "aria-hidden");
            }
            buildItem(t5) {
              const e5 = document.createElement("span");
              e5.tabIndex = "0", e5.setAttribute("role", "button"), e5.classList.add("ql-picker-item");
              const n5 = t5.getAttribute("value");
              return n5 && e5.setAttribute("data-value", n5), t5.textContent && e5.setAttribute("data-label", t5.textContent), e5.addEventListener("click", () => {
                this.selectItem(e5, true);
              }), e5.addEventListener("keydown", (t6) => {
                switch (t6.key) {
                  case "Enter":
                    this.selectItem(e5, true), t6.preventDefault();
                    break;
                  case "Escape":
                    this.escape(), t6.preventDefault();
                }
              }), e5;
            }
            buildLabel() {
              const t5 = document.createElement("span");
              return t5.classList.add("ql-picker-label"), t5.innerHTML = '<svg viewbox="0 0 18 18"><polygon class="ql-stroke" points="7 11 9 13 11 11 7 11"/><polygon class="ql-stroke" points="7 7 9 5 11 7 7 7"/></svg>', t5.tabIndex = "0", t5.setAttribute("role", "button"), t5.setAttribute("aria-expanded", "false"), this.container.appendChild(t5), t5;
            }
            buildOptions() {
              const t5 = document.createElement("span");
              t5.classList.add("ql-picker-options"), t5.setAttribute("aria-hidden", "true"), t5.tabIndex = "-1", t5.id = `ql-picker-options-${jo}`, jo += 1, this.label.setAttribute("aria-controls", t5.id), this.options = t5, Array.from(this.select.options).forEach((e5) => {
                const n5 = this.buildItem(e5);
                t5.appendChild(n5), true === e5.selected && this.selectItem(n5);
              }), this.container.appendChild(t5);
            }
            buildPicker() {
              Array.from(this.select.attributes).forEach((t5) => {
                this.container.setAttribute(t5.name, t5.value);
              }), this.container.classList.add("ql-picker"), this.label = this.buildLabel(), this.buildOptions();
            }
            escape() {
              this.close(), setTimeout(() => this.label.focus(), 1);
            }
            close() {
              this.container.classList.remove("ql-expanded"), this.label.setAttribute("aria-expanded", "false"), this.options.setAttribute("aria-hidden", "true");
            }
            selectItem(t5) {
              let e5 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
              const n5 = this.container.querySelector(".ql-selected");
              t5 !== n5 && (null != n5 && n5.classList.remove("ql-selected"), null != t5 && (t5.classList.add("ql-selected"), this.select.selectedIndex = Array.from(t5.parentNode.children).indexOf(t5), t5.hasAttribute("data-value") ? this.label.setAttribute("data-value", t5.getAttribute("data-value")) : this.label.removeAttribute("data-value"), t5.hasAttribute("data-label") ? this.label.setAttribute("data-label", t5.getAttribute("data-label")) : this.label.removeAttribute("data-label"), e5 && (this.select.dispatchEvent(new Event("change")), this.close())));
            }
            update() {
              let t5;
              if (this.select.selectedIndex > -1) {
                const e6 = this.container.querySelector(".ql-picker-options").children[this.select.selectedIndex];
                t5 = this.select.options[this.select.selectedIndex], this.selectItem(e6);
              } else
                this.selectItem(null);
              const e5 = null != t5 && t5 !== this.select.querySelector("option[selected]");
              this.label.classList.toggle("ql-active", e5);
            }
          };
          const Mo = class extends Io {
            static {
              __name(this, "Mo");
            }
            constructor(t5, e5) {
              super(t5), this.label.innerHTML = e5, this.container.classList.add("ql-color-picker"), Array.from(this.container.querySelectorAll(".ql-picker-item")).slice(0, 7).forEach((t6) => {
                t6.classList.add("ql-primary");
              });
            }
            buildItem(t5) {
              const e5 = super.buildItem(t5);
              return e5.style.backgroundColor = t5.getAttribute("value") || "", e5;
            }
            selectItem(t5, e5) {
              super.selectItem(t5, e5);
              const n5 = this.label.querySelector(".ql-color-label"), r4 = t5 && t5.getAttribute("data-value") || "";
              n5 && ("line" === n5.tagName ? n5.style.stroke = r4 : n5.style.fill = r4);
            }
          };
          const Bo = class extends Io {
            static {
              __name(this, "Bo");
            }
            constructor(t5, e5) {
              super(t5), this.container.classList.add("ql-icon-picker"), Array.from(this.container.querySelectorAll(".ql-picker-item")).forEach((t6) => {
                t6.innerHTML = e5[t6.getAttribute("data-value") || ""];
              }), this.defaultItem = this.container.querySelector(".ql-selected"), this.selectItem(this.defaultItem);
            }
            selectItem(t5, e5) {
              super.selectItem(t5, e5);
              const n5 = t5 || this.defaultItem;
              if (null != n5) {
                if (this.label.innerHTML === n5.innerHTML)
                  return;
                this.label.innerHTML = n5.innerHTML;
              }
            }
          };
          const Uo = class {
            static {
              __name(this, "Uo");
            }
            constructor(t5, e5) {
              this.quill = t5, this.boundsContainer = e5 || document.body, this.root = t5.addContainer("ql-tooltip"), this.root.innerHTML = this.constructor.TEMPLATE, ((t6) => {
                const { overflowY: e6 } = getComputedStyle(t6, null);
                return "visible" !== e6 && "clip" !== e6;
              })(this.quill.root) && this.quill.root.addEventListener("scroll", () => {
                this.root.style.marginTop = -1 * this.quill.root.scrollTop + "px";
              }), this.hide();
            }
            hide() {
              this.root.classList.add("ql-hidden");
            }
            position(t5) {
              const e5 = t5.left + t5.width / 2 - this.root.offsetWidth / 2, n5 = t5.bottom + this.quill.root.scrollTop;
              this.root.style.left = `${e5}px`, this.root.style.top = `${n5}px`, this.root.classList.remove("ql-flip");
              const r4 = this.boundsContainer.getBoundingClientRect(), s4 = this.root.getBoundingClientRect();
              let i4 = 0;
              if (s4.right > r4.right && (i4 = r4.right - s4.right, this.root.style.left = `${e5 + i4}px`), s4.left < r4.left && (i4 = r4.left - s4.left, this.root.style.left = `${e5 + i4}px`), s4.bottom > r4.bottom) {
                const e6 = s4.bottom - s4.top, r5 = t5.bottom - t5.top + e6;
                this.root.style.top = n5 - r5 + "px", this.root.classList.add("ql-flip");
              }
              return i4;
            }
            show() {
              this.root.classList.remove("ql-editing"), this.root.classList.remove("ql-hidden");
            }
          }, Do = [false, "center", "right", "justify"], Po = ["#000000", "#e60000", "#ff9900", "#ffff00", "#008a00", "#0066cc", "#9933ff", "#ffffff", "#facccc", "#ffebcc", "#ffffcc", "#cce8cc", "#cce0f5", "#ebd6ff", "#bbbbbb", "#f06666", "#ffc266", "#ffff66", "#66b966", "#66a3e0", "#c285ff", "#888888", "#a10000", "#b26b00", "#b2b200", "#006100", "#0047b2", "#6b24b2", "#444444", "#5c0000", "#663d00", "#666600", "#003700", "#002966", "#3d1466"], zo = [false, "serif", "monospace"], Ho = ["1", "2", "3", false], Fo = ["small", false, "large", "huge"];
          class $o extends qs {
            static {
              __name(this, "$o");
            }
            constructor(t5, e5) {
              super(t5, e5);
              const n5 = /* @__PURE__ */ __name((e6) => {
                document.body.contains(t5.root) ? (null == this.tooltip || this.tooltip.root.contains(e6.target) || document.activeElement === this.tooltip.textbox || this.quill.hasFocus() || this.tooltip.hide(), null != this.pickers && this.pickers.forEach((t6) => {
                  t6.container.contains(e6.target) || t6.close();
                })) : document.body.removeEventListener("click", n5);
              }, "n");
              t5.emitter.listenDOM("click", document.body, n5);
            }
            addModule(t5) {
              const e5 = super.addModule(t5);
              return "toolbar" === t5 && this.extendToolbar(e5), e5;
            }
            buildButtons(t5, e5) {
              Array.from(t5).forEach((t6) => {
                (t6.getAttribute("class") || "").split(/\s+/).forEach((n5) => {
                  if (n5.startsWith("ql-") && (n5 = n5.slice(3), null != e5[n5]))
                    if ("direction" === n5)
                      t6.innerHTML = e5[n5][""] + e5[n5].rtl;
                    else if ("string" == typeof e5[n5])
                      t6.innerHTML = e5[n5];
                    else {
                      const r4 = t6.value || "";
                      null != r4 && e5[n5][r4] && (t6.innerHTML = e5[n5][r4]);
                    }
                });
              });
            }
            buildPickers(t5, e5) {
              this.pickers = Array.from(t5).map((t6) => {
                if (t6.classList.contains("ql-align") && (null == t6.querySelector("option") && Ko(t6, Do), "object" == typeof e5.align))
                  return new Bo(t6, e5.align);
                if (t6.classList.contains("ql-background") || t6.classList.contains("ql-color")) {
                  const n5 = t6.classList.contains("ql-background") ? "background" : "color";
                  return null == t6.querySelector("option") && Ko(t6, Po, "background" === n5 ? "#ffffff" : "#000000"), new Mo(t6, e5[n5]);
                }
                return null == t6.querySelector("option") && (t6.classList.contains("ql-font") ? Ko(t6, zo) : t6.classList.contains("ql-header") ? Ko(t6, Ho) : t6.classList.contains("ql-size") && Ko(t6, Fo)), new Io(t6);
              });
              this.quill.on(ls.events.EDITOR_CHANGE, () => {
                this.pickers.forEach((t6) => {
                  t6.update();
                });
              });
            }
          }
          $o.DEFAULTS = De({}, qs.DEFAULTS, { modules: { toolbar: { handlers: { formula() {
            this.quill.theme.tooltip.edit("formula");
          }, image() {
            let t5 = this.container.querySelector("input.ql-image[type=file]");
            null == t5 && (t5 = document.createElement("input"), t5.setAttribute("type", "file"), t5.setAttribute("accept", this.quill.uploader.options.mimetypes.join(", ")), t5.classList.add("ql-image"), t5.addEventListener("change", () => {
              const e5 = this.quill.getSelection(true);
              this.quill.uploader.upload(e5, t5.files), t5.value = "";
            }), this.container.appendChild(t5)), t5.click();
          }, video() {
            this.quill.theme.tooltip.edit("video");
          } } } } });
          class Vo extends Uo {
            static {
              __name(this, "Vo");
            }
            constructor(t5, e5) {
              super(t5, e5), this.textbox = this.root.querySelector('input[type="text"]'), this.listen();
            }
            listen() {
              this.textbox.addEventListener("keydown", (t5) => {
                "Enter" === t5.key ? (this.save(), t5.preventDefault()) : "Escape" === t5.key && (this.cancel(), t5.preventDefault());
              });
            }
            cancel() {
              this.hide(), this.restoreFocus();
            }
            edit() {
              let t5 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "link", e5 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
              if (this.root.classList.remove("ql-hidden"), this.root.classList.add("ql-editing"), null == this.textbox)
                return;
              null != e5 ? this.textbox.value = e5 : t5 !== this.root.getAttribute("data-mode") && (this.textbox.value = "");
              const n5 = this.quill.getBounds(this.quill.selection.savedRange);
              null != n5 && this.position(n5), this.textbox.select(), this.textbox.setAttribute("placeholder", this.textbox.getAttribute(`data-${t5}`) || ""), this.root.setAttribute("data-mode", t5);
            }
            restoreFocus() {
              this.quill.focus({ preventScroll: true });
            }
            save() {
              let { value: t5 } = this.textbox;
              switch (this.root.getAttribute("data-mode")) {
                case "link": {
                  const { scrollTop: e5 } = this.quill.root;
                  this.linkRange ? (this.quill.formatText(this.linkRange, "link", t5, ls.sources.USER), delete this.linkRange) : (this.restoreFocus(), this.quill.format("link", t5, ls.sources.USER)), this.quill.root.scrollTop = e5;
                  break;
                }
                case "video":
                  t5 = function(t6) {
                    let e5 = t6.match(/^(?:(https?):\/\/)?(?:(?:www|m)\.)?youtube\.com\/watch.*v=([a-zA-Z0-9_-]+)/) || t6.match(/^(?:(https?):\/\/)?(?:(?:www|m)\.)?youtu\.be\/([a-zA-Z0-9_-]+)/);
                    if (e5)
                      return `${e5[1] || "https"}://www.youtube.com/embed/${e5[2]}?showinfo=0`;
                    if (e5 = t6.match(/^(?:(https?):\/\/)?(?:www\.)?vimeo\.com\/(\d+)/))
                      return `${e5[1] || "https"}://player.vimeo.com/video/${e5[2]}/`;
                    return t6;
                  }(t5);
                case "formula": {
                  if (!t5)
                    break;
                  const e5 = this.quill.getSelection(true);
                  if (null != e5) {
                    const n5 = e5.index + e5.length;
                    this.quill.insertEmbed(n5, this.root.getAttribute("data-mode"), t5, ls.sources.USER), "formula" === this.root.getAttribute("data-mode") && this.quill.insertText(n5 + 1, " ", ls.sources.USER), this.quill.setSelection(n5 + 2, ls.sources.USER);
                  }
                  break;
                }
              }
              this.textbox.value = "", this.hide();
            }
          }
          function Ko(t5, e5) {
            let n5 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
            e5.forEach((e6) => {
              const r4 = document.createElement("option");
              e6 === n5 ? r4.setAttribute("selected", "selected") : r4.setAttribute("value", String(e6)), t5.appendChild(r4);
            });
          }
          __name(Ko, "Ko");
          const Wo = [["bold", "italic", "link"], [{ header: 1 }, { header: 2 }, "blockquote"]];
          class Zo extends Vo {
            static {
              __name(this, "Zo");
            }
            static TEMPLATE = ['<span class="ql-tooltip-arrow"></span>', '<div class="ql-tooltip-editor">', '<input type="text" data-formula="e=mc^2" data-link="https://quilljs.com" data-video="Embed URL">', '<a class="ql-close"></a>', "</div>"].join("");
            constructor(t5, e5) {
              super(t5, e5), this.quill.on(ls.events.EDITOR_CHANGE, (t6, e6, n5, r4) => {
                if (t6 === ls.events.SELECTION_CHANGE)
                  if (null != e6 && e6.length > 0 && r4 === ls.sources.USER) {
                    this.show(), this.root.style.left = "0px", this.root.style.width = "", this.root.style.width = `${this.root.offsetWidth}px`;
                    const t7 = this.quill.getLines(e6.index, e6.length);
                    if (1 === t7.length) {
                      const t8 = this.quill.getBounds(e6);
                      null != t8 && this.position(t8);
                    } else {
                      const n6 = t7[t7.length - 1], r5 = this.quill.getIndex(n6), s4 = Math.min(n6.length() - 1, e6.index + e6.length - r5), i4 = this.quill.getBounds(new cs2(r5, s4));
                      null != i4 && this.position(i4);
                    }
                  } else
                    document.activeElement !== this.textbox && this.quill.hasFocus() && this.hide();
              });
            }
            listen() {
              super.listen(), this.root.querySelector(".ql-close").addEventListener("click", () => {
                this.root.classList.remove("ql-editing");
              }), this.quill.on(ls.events.SCROLL_OPTIMIZE, () => {
                setTimeout(() => {
                  if (this.root.classList.contains("ql-hidden"))
                    return;
                  const t5 = this.quill.getSelection();
                  if (null != t5) {
                    const e5 = this.quill.getBounds(t5);
                    null != e5 && this.position(e5);
                  }
                }, 1);
              });
            }
            cancel() {
              this.show();
            }
            position(t5) {
              const e5 = super.position(t5), n5 = this.root.querySelector(".ql-tooltip-arrow");
              return n5.style.marginLeft = "", 0 !== e5 && (n5.style.marginLeft = -1 * e5 - n5.offsetWidth / 2 + "px"), e5;
            }
          }
          class Go extends $o {
            static {
              __name(this, "Go");
            }
            constructor(t5, e5) {
              null != e5.modules.toolbar && null == e5.modules.toolbar.container && (e5.modules.toolbar.container = Wo), super(t5, e5), this.quill.container.classList.add("ql-bubble");
            }
            extendToolbar(t5) {
              this.tooltip = new Zo(this.quill, this.options.bounds), null != t5.container && (this.tooltip.root.appendChild(t5.container), this.buildButtons(t5.container.querySelectorAll("button"), Co), this.buildPickers(t5.container.querySelectorAll("select"), Co));
            }
          }
          Go.DEFAULTS = De({}, $o.DEFAULTS, { modules: { toolbar: { handlers: { link(t5) {
            t5 ? this.quill.theme.tooltip.edit() : this.quill.format("link", false, Rs.sources.USER);
          } } } } });
          const Xo = [[{ header: ["1", "2", "3", false] }], ["bold", "italic", "underline", "link"], [{ list: "ordered" }, { list: "bullet" }], ["clean"]];
          class Qo extends Vo {
            static {
              __name(this, "Qo");
            }
            static TEMPLATE = ['<a class="ql-preview" rel="noopener noreferrer" target="_blank" href="about:blank"></a>', '<input type="text" data-formula="e=mc^2" data-link="https://quilljs.com" data-video="Embed URL">', '<a class="ql-action"></a>', '<a class="ql-remove"></a>'].join("");
            preview = this.root.querySelector("a.ql-preview");
            listen() {
              super.listen(), this.root.querySelector("a.ql-action").addEventListener("click", (t5) => {
                this.root.classList.contains("ql-editing") ? this.save() : this.edit("link", this.preview.textContent), t5.preventDefault();
              }), this.root.querySelector("a.ql-remove").addEventListener("click", (t5) => {
                if (null != this.linkRange) {
                  const t6 = this.linkRange;
                  this.restoreFocus(), this.quill.formatText(t6, "link", false, ls.sources.USER), delete this.linkRange;
                }
                t5.preventDefault(), this.hide();
              }), this.quill.on(ls.events.SELECTION_CHANGE, (t5, e5, n5) => {
                if (null != t5) {
                  if (0 === t5.length && n5 === ls.sources.USER) {
                    const [e6, n6] = this.quill.scroll.descendant(oo, t5.index);
                    if (null != e6) {
                      this.linkRange = new cs2(t5.index - n6, e6.length());
                      const r4 = oo.formats(e6.domNode);
                      this.preview.textContent = r4, this.preview.setAttribute("href", r4), this.show();
                      const s4 = this.quill.getBounds(this.linkRange);
                      return void (null != s4 && this.position(s4));
                    }
                  } else
                    delete this.linkRange;
                  this.hide();
                }
              });
            }
            show() {
              super.show(), this.root.removeAttribute("data-mode");
            }
          }
          class Yo extends $o {
            static {
              __name(this, "Yo");
            }
            constructor(t5, e5) {
              null != e5.modules.toolbar && null == e5.modules.toolbar.container && (e5.modules.toolbar.container = Xo), super(t5, e5), this.quill.container.classList.add("ql-snow");
            }
            extendToolbar(t5) {
              null != t5.container && (t5.container.classList.add("ql-snow"), this.buildButtons(t5.container.querySelectorAll("button"), Co), this.buildPickers(t5.container.querySelectorAll("select"), Co), this.tooltip = new Qo(this.quill, this.options.bounds), t5.container.querySelector(".ql-link") && this.quill.keyboard.addBinding({ key: "k", shortKey: true }, (e5, n5) => {
                t5.handlers.link.call(t5, !n5.format.link);
              }));
            }
          }
          Yo.DEFAULTS = De({}, $o.DEFAULTS, { modules: { toolbar: { handlers: { link(t5) {
            if (t5) {
              const t6 = this.quill.getSelection();
              if (null == t6 || 0 === t6.length)
                return;
              let e5 = this.quill.getText(t6);
              /^\S+@\S+\.\S+$/.test(e5) && 0 !== e5.indexOf("mailto:") && (e5 = `mailto:${e5}`);
              const { tooltip: n5 } = this.quill.theme;
              n5.edit("link", e5);
            } else
              this.quill.format("link", false, Rs.sources.USER);
          } } } } });
          const Jo = Yo;
          Qi.register({ "attributors/attribute/direction": ii2, "attributors/class/align": Zs, "attributors/class/background": Js, "attributors/class/color": Qs, "attributors/class/direction": oi, "attributors/class/font": ci2, "attributors/class/size": hi, "attributors/style/align": Gs, "attributors/style/background": ti, "attributors/style/color": Ys, "attributors/style/direction": li, "attributors/style/font": ui, "attributors/style/size": di }, true), Qi.register({ "formats/align": Zs, "formats/direction": oi, "formats/indent": Ji, "formats/background": ti, "formats/color": Ys, "formats/font": ci2, "formats/size": hi, "formats/blockquote": to, "formats/code-block": ni, "formats/header": eo, "formats/list": ro, "formats/bold": so, "formats/code": ri, "formats/italic": io, "formats/link": oo, "formats/script": ao2, "formats/strike": co2, "formats/underline": uo, "formats/formula": ho, "formats/image": po, "formats/video": mo, "modules/syntax": No, "modules/table": _o, "modules/toolbar": Oo, "themes/bubble": Go, "themes/snow": Jo, "ui/icons": Co, "ui/picker": Io, "ui/icon-picker": Bo, "ui/color-picker": Mo, "ui/tooltip": Uo }, true);
          const tl = Qi;
        } }, e3 = {};
        function n3(r3) {
          var s3 = e3[r3];
          if (void 0 !== s3)
            return s3.exports;
          var i3 = e3[r3] = { id: r3, loaded: false, exports: {} };
          return t3[r3].call(i3.exports, i3, i3.exports, n3), i3.loaded = true, i3.exports;
        }
        __name(n3, "n");
        return n3.d = (t4, e4) => {
          for (var r3 in e4)
            n3.o(e4, r3) && !n3.o(t4, r3) && Object.defineProperty(t4, r3, { enumerable: true, get: e4[r3] });
        }, n3.g = function() {
          if ("object" == typeof globalThis)
            return globalThis;
          try {
            return this || new Function("return this")();
          } catch (t4) {
            if ("object" == typeof window)
              return window;
          }
        }(), n3.o = (t4, e4) => Object.prototype.hasOwnProperty.call(t4, e4), n3.r = (t4) => {
          "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t4, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t4, "__esModule", { value: true });
        }, n3.nmd = (t4) => (t4.paths = [], t4.children || (t4.children = []), t4), n3(190);
      })());
    }
  });

  // node_modules/fast-xml-parser/src/util.js
  var require_util = __commonJS({
    "node_modules/fast-xml-parser/src/util.js"(exports2) {
      "use strict";
      var nameStartChar = ":A-Za-z_\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
      var nameChar = nameStartChar + "\\-.\\d\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
      var nameRegexp = "[" + nameStartChar + "][" + nameChar + "]*";
      var regexName = new RegExp("^" + nameRegexp + "$");
      var getAllMatches = /* @__PURE__ */ __name(function(string, regex) {
        const matches2 = [];
        let match2 = regex.exec(string);
        while (match2) {
          const allmatches = [];
          allmatches.startIndex = regex.lastIndex - match2[0].length;
          const len = match2.length;
          for (let index2 = 0; index2 < len; index2++) {
            allmatches.push(match2[index2]);
          }
          matches2.push(allmatches);
          match2 = regex.exec(string);
        }
        return matches2;
      }, "getAllMatches");
      var isName = /* @__PURE__ */ __name(function(string) {
        const match2 = regexName.exec(string);
        return !(match2 === null || typeof match2 === "undefined");
      }, "isName");
      exports2.isExist = function(v3) {
        return typeof v3 !== "undefined";
      };
      exports2.isEmptyObject = function(obj) {
        return Object.keys(obj).length === 0;
      };
      exports2.merge = function(target, a3, arrayMode) {
        if (a3) {
          const keys2 = Object.keys(a3);
          const len = keys2.length;
          for (let i3 = 0; i3 < len; i3++) {
            if (arrayMode === "strict") {
              target[keys2[i3]] = [a3[keys2[i3]]];
            } else {
              target[keys2[i3]] = a3[keys2[i3]];
            }
          }
        }
      };
      exports2.getValue = function(v3) {
        if (exports2.isExist(v3)) {
          return v3;
        } else {
          return "";
        }
      };
      exports2.isName = isName;
      exports2.getAllMatches = getAllMatches;
      exports2.nameRegexp = nameRegexp;
    }
  });

  // node_modules/fast-xml-parser/src/validator.js
  var require_validator = __commonJS({
    "node_modules/fast-xml-parser/src/validator.js"(exports2) {
      "use strict";
      var util = require_util();
      var defaultOptions3 = {
        allowBooleanAttributes: false,
        //A tag can have attributes without any value
        unpairedTags: []
      };
      exports2.validate = function(xmlData, options) {
        options = Object.assign({}, defaultOptions3, options);
        const tags = [];
        let tagFound = false;
        let reachedRoot = false;
        if (xmlData[0] === "\uFEFF") {
          xmlData = xmlData.substr(1);
        }
        for (let i3 = 0; i3 < xmlData.length; i3++) {
          if (xmlData[i3] === "<" && xmlData[i3 + 1] === "?") {
            i3 += 2;
            i3 = readPI(xmlData, i3);
            if (i3.err)
              return i3;
          } else if (xmlData[i3] === "<") {
            let tagStartPos = i3;
            i3++;
            if (xmlData[i3] === "!") {
              i3 = readCommentAndCDATA(xmlData, i3);
              continue;
            } else {
              let closingTag = false;
              if (xmlData[i3] === "/") {
                closingTag = true;
                i3++;
              }
              let tagName = "";
              for (; i3 < xmlData.length && xmlData[i3] !== ">" && xmlData[i3] !== " " && xmlData[i3] !== "	" && xmlData[i3] !== "\n" && xmlData[i3] !== "\r"; i3++) {
                tagName += xmlData[i3];
              }
              tagName = tagName.trim();
              if (tagName[tagName.length - 1] === "/") {
                tagName = tagName.substring(0, tagName.length - 1);
                i3--;
              }
              if (!validateTagName(tagName)) {
                let msg;
                if (tagName.trim().length === 0) {
                  msg = "Invalid space after '<'.";
                } else {
                  msg = "Tag '" + tagName + "' is an invalid name.";
                }
                return getErrorObject("InvalidTag", msg, getLineNumberForPosition(xmlData, i3));
              }
              const result = readAttributeStr(xmlData, i3);
              if (result === false) {
                return getErrorObject("InvalidAttr", "Attributes for '" + tagName + "' have open quote.", getLineNumberForPosition(xmlData, i3));
              }
              let attrStr = result.value;
              i3 = result.index;
              if (attrStr[attrStr.length - 1] === "/") {
                const attrStrStart = i3 - attrStr.length;
                attrStr = attrStr.substring(0, attrStr.length - 1);
                const isValid = validateAttributeString(attrStr, options);
                if (isValid === true) {
                  tagFound = true;
                } else {
                  return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, attrStrStart + isValid.err.line));
                }
              } else if (closingTag) {
                if (!result.tagClosed) {
                  return getErrorObject("InvalidTag", "Closing tag '" + tagName + "' doesn't have proper closing.", getLineNumberForPosition(xmlData, i3));
                } else if (attrStr.trim().length > 0) {
                  return getErrorObject("InvalidTag", "Closing tag '" + tagName + "' can't have attributes or invalid starting.", getLineNumberForPosition(xmlData, tagStartPos));
                } else if (tags.length === 0) {
                  return getErrorObject("InvalidTag", "Closing tag '" + tagName + "' has not been opened.", getLineNumberForPosition(xmlData, tagStartPos));
                } else {
                  const otg = tags.pop();
                  if (tagName !== otg.tagName) {
                    let openPos = getLineNumberForPosition(xmlData, otg.tagStartPos);
                    return getErrorObject(
                      "InvalidTag",
                      "Expected closing tag '" + otg.tagName + "' (opened in line " + openPos.line + ", col " + openPos.col + ") instead of closing tag '" + tagName + "'.",
                      getLineNumberForPosition(xmlData, tagStartPos)
                    );
                  }
                  if (tags.length == 0) {
                    reachedRoot = true;
                  }
                }
              } else {
                const isValid = validateAttributeString(attrStr, options);
                if (isValid !== true) {
                  return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, i3 - attrStr.length + isValid.err.line));
                }
                if (reachedRoot === true) {
                  return getErrorObject("InvalidXml", "Multiple possible root nodes found.", getLineNumberForPosition(xmlData, i3));
                } else if (options.unpairedTags.indexOf(tagName) !== -1) {
                } else {
                  tags.push({ tagName, tagStartPos });
                }
                tagFound = true;
              }
              for (i3++; i3 < xmlData.length; i3++) {
                if (xmlData[i3] === "<") {
                  if (xmlData[i3 + 1] === "!") {
                    i3++;
                    i3 = readCommentAndCDATA(xmlData, i3);
                    continue;
                  } else if (xmlData[i3 + 1] === "?") {
                    i3 = readPI(xmlData, ++i3);
                    if (i3.err)
                      return i3;
                  } else {
                    break;
                  }
                } else if (xmlData[i3] === "&") {
                  const afterAmp = validateAmpersand(xmlData, i3);
                  if (afterAmp == -1)
                    return getErrorObject("InvalidChar", "char '&' is not expected.", getLineNumberForPosition(xmlData, i3));
                  i3 = afterAmp;
                } else {
                  if (reachedRoot === true && !isWhiteSpace(xmlData[i3])) {
                    return getErrorObject("InvalidXml", "Extra text at the end", getLineNumberForPosition(xmlData, i3));
                  }
                }
              }
              if (xmlData[i3] === "<") {
                i3--;
              }
            }
          } else {
            if (isWhiteSpace(xmlData[i3])) {
              continue;
            }
            return getErrorObject("InvalidChar", "char '" + xmlData[i3] + "' is not expected.", getLineNumberForPosition(xmlData, i3));
          }
        }
        if (!tagFound) {
          return getErrorObject("InvalidXml", "Start tag expected.", 1);
        } else if (tags.length == 1) {
          return getErrorObject("InvalidTag", "Unclosed tag '" + tags[0].tagName + "'.", getLineNumberForPosition(xmlData, tags[0].tagStartPos));
        } else if (tags.length > 0) {
          return getErrorObject("InvalidXml", "Invalid '" + JSON.stringify(tags.map((t3) => t3.tagName), null, 4).replace(/\r?\n/g, "") + "' found.", { line: 1, col: 1 });
        }
        return true;
      };
      function isWhiteSpace(char) {
        return char === " " || char === "	" || char === "\n" || char === "\r";
      }
      __name(isWhiteSpace, "isWhiteSpace");
      function readPI(xmlData, i3) {
        const start2 = i3;
        for (; i3 < xmlData.length; i3++) {
          if (xmlData[i3] == "?" || xmlData[i3] == " ") {
            const tagname = xmlData.substr(start2, i3 - start2);
            if (i3 > 5 && tagname === "xml") {
              return getErrorObject("InvalidXml", "XML declaration allowed only at the start of the document.", getLineNumberForPosition(xmlData, i3));
            } else if (xmlData[i3] == "?" && xmlData[i3 + 1] == ">") {
              i3++;
              break;
            } else {
              continue;
            }
          }
        }
        return i3;
      }
      __name(readPI, "readPI");
      function readCommentAndCDATA(xmlData, i3) {
        if (xmlData.length > i3 + 5 && xmlData[i3 + 1] === "-" && xmlData[i3 + 2] === "-") {
          for (i3 += 3; i3 < xmlData.length; i3++) {
            if (xmlData[i3] === "-" && xmlData[i3 + 1] === "-" && xmlData[i3 + 2] === ">") {
              i3 += 2;
              break;
            }
          }
        } else if (xmlData.length > i3 + 8 && xmlData[i3 + 1] === "D" && xmlData[i3 + 2] === "O" && xmlData[i3 + 3] === "C" && xmlData[i3 + 4] === "T" && xmlData[i3 + 5] === "Y" && xmlData[i3 + 6] === "P" && xmlData[i3 + 7] === "E") {
          let angleBracketsCount = 1;
          for (i3 += 8; i3 < xmlData.length; i3++) {
            if (xmlData[i3] === "<") {
              angleBracketsCount++;
            } else if (xmlData[i3] === ">") {
              angleBracketsCount--;
              if (angleBracketsCount === 0) {
                break;
              }
            }
          }
        } else if (xmlData.length > i3 + 9 && xmlData[i3 + 1] === "[" && xmlData[i3 + 2] === "C" && xmlData[i3 + 3] === "D" && xmlData[i3 + 4] === "A" && xmlData[i3 + 5] === "T" && xmlData[i3 + 6] === "A" && xmlData[i3 + 7] === "[") {
          for (i3 += 8; i3 < xmlData.length; i3++) {
            if (xmlData[i3] === "]" && xmlData[i3 + 1] === "]" && xmlData[i3 + 2] === ">") {
              i3 += 2;
              break;
            }
          }
        }
        return i3;
      }
      __name(readCommentAndCDATA, "readCommentAndCDATA");
      var doubleQuote = '"';
      var singleQuote = "'";
      function readAttributeStr(xmlData, i3) {
        let attrStr = "";
        let startChar = "";
        let tagClosed = false;
        for (; i3 < xmlData.length; i3++) {
          if (xmlData[i3] === doubleQuote || xmlData[i3] === singleQuote) {
            if (startChar === "") {
              startChar = xmlData[i3];
            } else if (startChar !== xmlData[i3]) {
            } else {
              startChar = "";
            }
          } else if (xmlData[i3] === ">") {
            if (startChar === "") {
              tagClosed = true;
              break;
            }
          }
          attrStr += xmlData[i3];
        }
        if (startChar !== "") {
          return false;
        }
        return {
          value: attrStr,
          index: i3,
          tagClosed
        };
      }
      __name(readAttributeStr, "readAttributeStr");
      var validAttrStrRegxp = new RegExp(`(\\s*)([^\\s=]+)(\\s*=)?(\\s*(['"])(([\\s\\S])*?)\\5)?`, "g");
      function validateAttributeString(attrStr, options) {
        const matches2 = util.getAllMatches(attrStr, validAttrStrRegxp);
        const attrNames = {};
        for (let i3 = 0; i3 < matches2.length; i3++) {
          if (matches2[i3][1].length === 0) {
            return getErrorObject("InvalidAttr", "Attribute '" + matches2[i3][2] + "' has no space in starting.", getPositionFromMatch(matches2[i3]));
          } else if (matches2[i3][3] !== void 0 && matches2[i3][4] === void 0) {
            return getErrorObject("InvalidAttr", "Attribute '" + matches2[i3][2] + "' is without value.", getPositionFromMatch(matches2[i3]));
          } else if (matches2[i3][3] === void 0 && !options.allowBooleanAttributes) {
            return getErrorObject("InvalidAttr", "boolean attribute '" + matches2[i3][2] + "' is not allowed.", getPositionFromMatch(matches2[i3]));
          }
          const attrName = matches2[i3][2];
          if (!validateAttrName(attrName)) {
            return getErrorObject("InvalidAttr", "Attribute '" + attrName + "' is an invalid name.", getPositionFromMatch(matches2[i3]));
          }
          if (!attrNames.hasOwnProperty(attrName)) {
            attrNames[attrName] = 1;
          } else {
            return getErrorObject("InvalidAttr", "Attribute '" + attrName + "' is repeated.", getPositionFromMatch(matches2[i3]));
          }
        }
        return true;
      }
      __name(validateAttributeString, "validateAttributeString");
      function validateNumberAmpersand(xmlData, i3) {
        let re = /\d/;
        if (xmlData[i3] === "x") {
          i3++;
          re = /[\da-fA-F]/;
        }
        for (; i3 < xmlData.length; i3++) {
          if (xmlData[i3] === ";")
            return i3;
          if (!xmlData[i3].match(re))
            break;
        }
        return -1;
      }
      __name(validateNumberAmpersand, "validateNumberAmpersand");
      function validateAmpersand(xmlData, i3) {
        i3++;
        if (xmlData[i3] === ";")
          return -1;
        if (xmlData[i3] === "#") {
          i3++;
          return validateNumberAmpersand(xmlData, i3);
        }
        let count = 0;
        for (; i3 < xmlData.length; i3++, count++) {
          if (xmlData[i3].match(/\w/) && count < 20)
            continue;
          if (xmlData[i3] === ";")
            break;
          return -1;
        }
        return i3;
      }
      __name(validateAmpersand, "validateAmpersand");
      function getErrorObject(code, message, lineNumber) {
        return {
          err: {
            code,
            msg: message,
            line: lineNumber.line || lineNumber,
            col: lineNumber.col
          }
        };
      }
      __name(getErrorObject, "getErrorObject");
      function validateAttrName(attrName) {
        return util.isName(attrName);
      }
      __name(validateAttrName, "validateAttrName");
      function validateTagName(tagname) {
        return util.isName(tagname);
      }
      __name(validateTagName, "validateTagName");
      function getLineNumberForPosition(xmlData, index2) {
        const lines = xmlData.substring(0, index2).split(/\r?\n/);
        return {
          line: lines.length,
          // column number is last line's length + 1, because column numbering starts at 1:
          col: lines[lines.length - 1].length + 1
        };
      }
      __name(getLineNumberForPosition, "getLineNumberForPosition");
      function getPositionFromMatch(match2) {
        return match2.startIndex + match2[1].length;
      }
      __name(getPositionFromMatch, "getPositionFromMatch");
    }
  });

  // node_modules/fast-xml-parser/src/xmlparser/OptionsBuilder.js
  var require_OptionsBuilder = __commonJS({
    "node_modules/fast-xml-parser/src/xmlparser/OptionsBuilder.js"(exports2) {
      var defaultOptions3 = {
        preserveOrder: false,
        attributeNamePrefix: "@_",
        attributesGroupName: false,
        textNodeName: "#text",
        ignoreAttributes: true,
        removeNSPrefix: false,
        // remove NS from tag name or attribute name if true
        allowBooleanAttributes: false,
        //a tag can have attributes without any value
        //ignoreRootElement : false,
        parseTagValue: true,
        parseAttributeValue: false,
        trimValues: true,
        //Trim string values of tag and attributes
        cdataPropName: false,
        numberParseOptions: {
          hex: true,
          leadingZeros: true,
          eNotation: true
        },
        tagValueProcessor: function(tagName, val2) {
          return val2;
        },
        attributeValueProcessor: function(attrName, val2) {
          return val2;
        },
        stopNodes: [],
        //nested tags will not be parsed even for errors
        alwaysCreateTextNode: false,
        isArray: () => false,
        commentPropName: false,
        unpairedTags: [],
        processEntities: true,
        htmlEntities: false,
        ignoreDeclaration: false,
        ignorePiTags: false,
        transformTagName: false,
        transformAttributeName: false,
        updateTag: function(tagName, jPath, attrs) {
          return tagName;
        }
        // skipEmptyListItem: false
      };
      var buildOptions = /* @__PURE__ */ __name(function(options) {
        return Object.assign({}, defaultOptions3, options);
      }, "buildOptions");
      exports2.buildOptions = buildOptions;
      exports2.defaultOptions = defaultOptions3;
    }
  });

  // node_modules/fast-xml-parser/src/xmlparser/xmlNode.js
  var require_xmlNode = __commonJS({
    "node_modules/fast-xml-parser/src/xmlparser/xmlNode.js"(exports2, module2) {
      "use strict";
      var XmlNode2 = class {
        static {
          __name(this, "XmlNode");
        }
        constructor(tagname) {
          this.tagname = tagname;
          this.child = [];
          this[":@"] = {};
        }
        add(key, val2) {
          if (key === "__proto__")
            key = "#__proto__";
          this.child.push({ [key]: val2 });
        }
        addChild(node) {
          if (node.tagname === "__proto__")
            node.tagname = "#__proto__";
          if (node[":@"] && Object.keys(node[":@"]).length > 0) {
            this.child.push({ [node.tagname]: node.child, [":@"]: node[":@"] });
          } else {
            this.child.push({ [node.tagname]: node.child });
          }
        }
      };
      module2.exports = XmlNode2;
    }
  });

  // node_modules/fast-xml-parser/src/xmlparser/DocTypeReader.js
  var require_DocTypeReader = __commonJS({
    "node_modules/fast-xml-parser/src/xmlparser/DocTypeReader.js"(exports2, module2) {
      var util = require_util();
      function readDocType(xmlData, i3) {
        const entities = {};
        if (xmlData[i3 + 3] === "O" && xmlData[i3 + 4] === "C" && xmlData[i3 + 5] === "T" && xmlData[i3 + 6] === "Y" && xmlData[i3 + 7] === "P" && xmlData[i3 + 8] === "E") {
          i3 = i3 + 9;
          let angleBracketsCount = 1;
          let hasBody = false, comment = false;
          let exp = "";
          for (; i3 < xmlData.length; i3++) {
            if (xmlData[i3] === "<" && !comment) {
              if (hasBody && isEntity(xmlData, i3)) {
                i3 += 7;
                [entityName, val, i3] = readEntityExp(xmlData, i3 + 1);
                if (val.indexOf("&") === -1)
                  entities[validateEntityName(entityName)] = {
                    regx: RegExp(`&${entityName};`, "g"),
                    val
                  };
              } else if (hasBody && isElement(xmlData, i3))
                i3 += 8;
              else if (hasBody && isAttlist(xmlData, i3))
                i3 += 8;
              else if (hasBody && isNotation(xmlData, i3))
                i3 += 9;
              else if (isComment)
                comment = true;
              else
                throw new Error("Invalid DOCTYPE");
              angleBracketsCount++;
              exp = "";
            } else if (xmlData[i3] === ">") {
              if (comment) {
                if (xmlData[i3 - 1] === "-" && xmlData[i3 - 2] === "-") {
                  comment = false;
                  angleBracketsCount--;
                }
              } else {
                angleBracketsCount--;
              }
              if (angleBracketsCount === 0) {
                break;
              }
            } else if (xmlData[i3] === "[") {
              hasBody = true;
            } else {
              exp += xmlData[i3];
            }
          }
          if (angleBracketsCount !== 0) {
            throw new Error(`Unclosed DOCTYPE`);
          }
        } else {
          throw new Error(`Invalid Tag instead of DOCTYPE`);
        }
        return { entities, i: i3 };
      }
      __name(readDocType, "readDocType");
      function readEntityExp(xmlData, i3) {
        let entityName2 = "";
        for (; i3 < xmlData.length && (xmlData[i3] !== "'" && xmlData[i3] !== '"'); i3++) {
          entityName2 += xmlData[i3];
        }
        entityName2 = entityName2.trim();
        if (entityName2.indexOf(" ") !== -1)
          throw new Error("External entites are not supported");
        const startChar = xmlData[i3++];
        let val2 = "";
        for (; i3 < xmlData.length && xmlData[i3] !== startChar; i3++) {
          val2 += xmlData[i3];
        }
        return [entityName2, val2, i3];
      }
      __name(readEntityExp, "readEntityExp");
      function isComment(xmlData, i3) {
        if (xmlData[i3 + 1] === "!" && xmlData[i3 + 2] === "-" && xmlData[i3 + 3] === "-")
          return true;
        return false;
      }
      __name(isComment, "isComment");
      function isEntity(xmlData, i3) {
        if (xmlData[i3 + 1] === "!" && xmlData[i3 + 2] === "E" && xmlData[i3 + 3] === "N" && xmlData[i3 + 4] === "T" && xmlData[i3 + 5] === "I" && xmlData[i3 + 6] === "T" && xmlData[i3 + 7] === "Y")
          return true;
        return false;
      }
      __name(isEntity, "isEntity");
      function isElement(xmlData, i3) {
        if (xmlData[i3 + 1] === "!" && xmlData[i3 + 2] === "E" && xmlData[i3 + 3] === "L" && xmlData[i3 + 4] === "E" && xmlData[i3 + 5] === "M" && xmlData[i3 + 6] === "E" && xmlData[i3 + 7] === "N" && xmlData[i3 + 8] === "T")
          return true;
        return false;
      }
      __name(isElement, "isElement");
      function isAttlist(xmlData, i3) {
        if (xmlData[i3 + 1] === "!" && xmlData[i3 + 2] === "A" && xmlData[i3 + 3] === "T" && xmlData[i3 + 4] === "T" && xmlData[i3 + 5] === "L" && xmlData[i3 + 6] === "I" && xmlData[i3 + 7] === "S" && xmlData[i3 + 8] === "T")
          return true;
        return false;
      }
      __name(isAttlist, "isAttlist");
      function isNotation(xmlData, i3) {
        if (xmlData[i3 + 1] === "!" && xmlData[i3 + 2] === "N" && xmlData[i3 + 3] === "O" && xmlData[i3 + 4] === "T" && xmlData[i3 + 5] === "A" && xmlData[i3 + 6] === "T" && xmlData[i3 + 7] === "I" && xmlData[i3 + 8] === "O" && xmlData[i3 + 9] === "N")
          return true;
        return false;
      }
      __name(isNotation, "isNotation");
      function validateEntityName(name) {
        if (util.isName(name))
          return name;
        else
          throw new Error(`Invalid entity name ${name}`);
      }
      __name(validateEntityName, "validateEntityName");
      module2.exports = readDocType;
    }
  });

  // node_modules/strnum/strnum.js
  var require_strnum = __commonJS({
    "node_modules/strnum/strnum.js"(exports2, module2) {
      var hexRegex = /^[-+]?0x[a-fA-F0-9]+$/;
      var numRegex = /^([\-\+])?(0*)([0-9]*(\.[0-9]*)?)$/;
      var consider = {
        hex: true,
        // oct: false,
        leadingZeros: true,
        decimalPoint: ".",
        eNotation: true
        //skipLike: /regex/
      };
      function toNumber(str, options = {}) {
        options = Object.assign({}, consider, options);
        if (!str || typeof str !== "string")
          return str;
        let trimmedStr = str.trim();
        if (options.skipLike !== void 0 && options.skipLike.test(trimmedStr))
          return str;
        else if (str === "0")
          return 0;
        else if (options.hex && hexRegex.test(trimmedStr)) {
          return parse_int(trimmedStr, 16);
        } else if (trimmedStr.search(/[eE]/) !== -1) {
          const notation = trimmedStr.match(/^([-\+])?(0*)([0-9]*(\.[0-9]*)?[eE][-\+]?[0-9]+)$/);
          if (notation) {
            if (options.leadingZeros) {
              trimmedStr = (notation[1] || "") + notation[3];
            } else {
              if (notation[2] === "0" && notation[3][0] === ".") {
              } else {
                return str;
              }
            }
            return options.eNotation ? Number(trimmedStr) : str;
          } else {
            return str;
          }
        } else {
          const match2 = numRegex.exec(trimmedStr);
          if (match2) {
            const sign = match2[1];
            const leadingZeros = match2[2];
            let numTrimmedByZeros = trimZeros(match2[3]);
            if (!options.leadingZeros && leadingZeros.length > 0 && sign && trimmedStr[2] !== ".")
              return str;
            else if (!options.leadingZeros && leadingZeros.length > 0 && !sign && trimmedStr[1] !== ".")
              return str;
            else if (options.leadingZeros && leadingZeros === str)
              return 0;
            else {
              const num = Number(trimmedStr);
              const numStr = "" + num;
              if (numStr.search(/[eE]/) !== -1) {
                if (options.eNotation)
                  return num;
                else
                  return str;
              } else if (trimmedStr.indexOf(".") !== -1) {
                if (numStr === "0" && numTrimmedByZeros === "")
                  return num;
                else if (numStr === numTrimmedByZeros)
                  return num;
                else if (sign && numStr === "-" + numTrimmedByZeros)
                  return num;
                else
                  return str;
              }
              if (leadingZeros) {
                return numTrimmedByZeros === numStr || sign + numTrimmedByZeros === numStr ? num : str;
              } else {
                return trimmedStr === numStr || trimmedStr === sign + numStr ? num : str;
              }
            }
          } else {
            return str;
          }
        }
      }
      __name(toNumber, "toNumber");
      function trimZeros(numStr) {
        if (numStr && numStr.indexOf(".") !== -1) {
          numStr = numStr.replace(/0+$/, "");
          if (numStr === ".")
            numStr = "0";
          else if (numStr[0] === ".")
            numStr = "0" + numStr;
          else if (numStr[numStr.length - 1] === ".")
            numStr = numStr.substr(0, numStr.length - 1);
          return numStr;
        }
        return numStr;
      }
      __name(trimZeros, "trimZeros");
      function parse_int(numStr, base) {
        if (parseInt)
          return parseInt(numStr, base);
        else if (Number.parseInt)
          return Number.parseInt(numStr, base);
        else if (window && window.parseInt)
          return window.parseInt(numStr, base);
        else
          throw new Error("parseInt, Number.parseInt, window.parseInt are not supported");
      }
      __name(parse_int, "parse_int");
      module2.exports = toNumber;
    }
  });

  // node_modules/fast-xml-parser/src/xmlparser/OrderedObjParser.js
  var require_OrderedObjParser = __commonJS({
    "node_modules/fast-xml-parser/src/xmlparser/OrderedObjParser.js"(exports2, module2) {
      "use strict";
      var util = require_util();
      var xmlNode = require_xmlNode();
      var readDocType = require_DocTypeReader();
      var toNumber = require_strnum();
      var OrderedObjParser = class {
        static {
          __name(this, "OrderedObjParser");
        }
        constructor(options) {
          this.options = options;
          this.currentNode = null;
          this.tagsNodeStack = [];
          this.docTypeEntities = {};
          this.lastEntities = {
            "apos": { regex: /&(apos|#39|#x27);/g, val: "'" },
            "gt": { regex: /&(gt|#62|#x3E);/g, val: ">" },
            "lt": { regex: /&(lt|#60|#x3C);/g, val: "<" },
            "quot": { regex: /&(quot|#34|#x22);/g, val: '"' }
          };
          this.ampEntity = { regex: /&(amp|#38|#x26);/g, val: "&" };
          this.htmlEntities = {
            "space": { regex: /&(nbsp|#160);/g, val: " " },
            // "lt" : { regex: /&(lt|#60);/g, val: "<" },
            // "gt" : { regex: /&(gt|#62);/g, val: ">" },
            // "amp" : { regex: /&(amp|#38);/g, val: "&" },
            // "quot" : { regex: /&(quot|#34);/g, val: "\"" },
            // "apos" : { regex: /&(apos|#39);/g, val: "'" },
            "cent": { regex: /&(cent|#162);/g, val: "\xA2" },
            "pound": { regex: /&(pound|#163);/g, val: "\xA3" },
            "yen": { regex: /&(yen|#165);/g, val: "\xA5" },
            "euro": { regex: /&(euro|#8364);/g, val: "\u20AC" },
            "copyright": { regex: /&(copy|#169);/g, val: "\xA9" },
            "reg": { regex: /&(reg|#174);/g, val: "\xAE" },
            "inr": { regex: /&(inr|#8377);/g, val: "\u20B9" },
            "num_dec": { regex: /&#([0-9]{1,7});/g, val: (_2, str) => String.fromCharCode(Number.parseInt(str, 10)) },
            "num_hex": { regex: /&#x([0-9a-fA-F]{1,6});/g, val: (_2, str) => String.fromCharCode(Number.parseInt(str, 16)) }
          };
          this.addExternalEntities = addExternalEntities;
          this.parseXml = parseXml;
          this.parseTextData = parseTextData;
          this.resolveNameSpace = resolveNameSpace;
          this.buildAttributesMap = buildAttributesMap;
          this.isItStopNode = isItStopNode;
          this.replaceEntitiesValue = replaceEntitiesValue;
          this.readStopNodeData = readStopNodeData;
          this.saveTextToParentTag = saveTextToParentTag;
          this.addChild = addChild;
        }
      };
      function addExternalEntities(externalEntities) {
        const entKeys = Object.keys(externalEntities);
        for (let i3 = 0; i3 < entKeys.length; i3++) {
          const ent = entKeys[i3];
          this.lastEntities[ent] = {
            regex: new RegExp("&" + ent + ";", "g"),
            val: externalEntities[ent]
          };
        }
      }
      __name(addExternalEntities, "addExternalEntities");
      function parseTextData(val2, tagName, jPath, dontTrim, hasAttributes, isLeafNode, escapeEntities) {
        if (val2 !== void 0) {
          if (this.options.trimValues && !dontTrim) {
            val2 = val2.trim();
          }
          if (val2.length > 0) {
            if (!escapeEntities)
              val2 = this.replaceEntitiesValue(val2);
            const newval = this.options.tagValueProcessor(tagName, val2, jPath, hasAttributes, isLeafNode);
            if (newval === null || newval === void 0) {
              return val2;
            } else if (typeof newval !== typeof val2 || newval !== val2) {
              return newval;
            } else if (this.options.trimValues) {
              return parseValue(val2, this.options.parseTagValue, this.options.numberParseOptions);
            } else {
              const trimmedVal = val2.trim();
              if (trimmedVal === val2) {
                return parseValue(val2, this.options.parseTagValue, this.options.numberParseOptions);
              } else {
                return val2;
              }
            }
          }
        }
      }
      __name(parseTextData, "parseTextData");
      function resolveNameSpace(tagname) {
        if (this.options.removeNSPrefix) {
          const tags = tagname.split(":");
          const prefix = tagname.charAt(0) === "/" ? "/" : "";
          if (tags[0] === "xmlns") {
            return "";
          }
          if (tags.length === 2) {
            tagname = prefix + tags[1];
          }
        }
        return tagname;
      }
      __name(resolveNameSpace, "resolveNameSpace");
      var attrsRegx = new RegExp(`([^\\s=]+)\\s*(=\\s*(['"])([\\s\\S]*?)\\3)?`, "gm");
      function buildAttributesMap(attrStr, jPath, tagName) {
        if (!this.options.ignoreAttributes && typeof attrStr === "string") {
          const matches2 = util.getAllMatches(attrStr, attrsRegx);
          const len = matches2.length;
          const attrs = {};
          for (let i3 = 0; i3 < len; i3++) {
            const attrName = this.resolveNameSpace(matches2[i3][1]);
            let oldVal = matches2[i3][4];
            let aName = this.options.attributeNamePrefix + attrName;
            if (attrName.length) {
              if (this.options.transformAttributeName) {
                aName = this.options.transformAttributeName(aName);
              }
              if (aName === "__proto__")
                aName = "#__proto__";
              if (oldVal !== void 0) {
                if (this.options.trimValues) {
                  oldVal = oldVal.trim();
                }
                oldVal = this.replaceEntitiesValue(oldVal);
                const newVal = this.options.attributeValueProcessor(attrName, oldVal, jPath);
                if (newVal === null || newVal === void 0) {
                  attrs[aName] = oldVal;
                } else if (typeof newVal !== typeof oldVal || newVal !== oldVal) {
                  attrs[aName] = newVal;
                } else {
                  attrs[aName] = parseValue(
                    oldVal,
                    this.options.parseAttributeValue,
                    this.options.numberParseOptions
                  );
                }
              } else if (this.options.allowBooleanAttributes) {
                attrs[aName] = true;
              }
            }
          }
          if (!Object.keys(attrs).length) {
            return;
          }
          if (this.options.attributesGroupName) {
            const attrCollection = {};
            attrCollection[this.options.attributesGroupName] = attrs;
            return attrCollection;
          }
          return attrs;
        }
      }
      __name(buildAttributesMap, "buildAttributesMap");
      var parseXml = /* @__PURE__ */ __name(function(xmlData) {
        xmlData = xmlData.replace(/\r\n?/g, "\n");
        const xmlObj = new xmlNode("!xml");
        let currentNode = xmlObj;
        let textData = "";
        let jPath = "";
        for (let i3 = 0; i3 < xmlData.length; i3++) {
          const ch2 = xmlData[i3];
          if (ch2 === "<") {
            if (xmlData[i3 + 1] === "/") {
              const closeIndex = findClosingIndex(xmlData, ">", i3, "Closing Tag is not closed.");
              let tagName = xmlData.substring(i3 + 2, closeIndex).trim();
              if (this.options.removeNSPrefix) {
                const colonIndex = tagName.indexOf(":");
                if (colonIndex !== -1) {
                  tagName = tagName.substr(colonIndex + 1);
                }
              }
              if (this.options.transformTagName) {
                tagName = this.options.transformTagName(tagName);
              }
              if (currentNode) {
                textData = this.saveTextToParentTag(textData, currentNode, jPath);
              }
              const lastTagName = jPath.substring(jPath.lastIndexOf(".") + 1);
              if (tagName && this.options.unpairedTags.indexOf(tagName) !== -1) {
                throw new Error(`Unpaired tag can not be used as closing tag: </${tagName}>`);
              }
              let propIndex = 0;
              if (lastTagName && this.options.unpairedTags.indexOf(lastTagName) !== -1) {
                propIndex = jPath.lastIndexOf(".", jPath.lastIndexOf(".") - 1);
                this.tagsNodeStack.pop();
              } else {
                propIndex = jPath.lastIndexOf(".");
              }
              jPath = jPath.substring(0, propIndex);
              currentNode = this.tagsNodeStack.pop();
              textData = "";
              i3 = closeIndex;
            } else if (xmlData[i3 + 1] === "?") {
              let tagData = readTagExp(xmlData, i3, false, "?>");
              if (!tagData)
                throw new Error("Pi Tag is not closed.");
              textData = this.saveTextToParentTag(textData, currentNode, jPath);
              if (this.options.ignoreDeclaration && tagData.tagName === "?xml" || this.options.ignorePiTags) {
              } else {
                const childNode = new xmlNode(tagData.tagName);
                childNode.add(this.options.textNodeName, "");
                if (tagData.tagName !== tagData.tagExp && tagData.attrExpPresent) {
                  childNode[":@"] = this.buildAttributesMap(tagData.tagExp, jPath, tagData.tagName);
                }
                this.addChild(currentNode, childNode, jPath);
              }
              i3 = tagData.closeIndex + 1;
            } else if (xmlData.substr(i3 + 1, 3) === "!--") {
              const endIndex = findClosingIndex(xmlData, "-->", i3 + 4, "Comment is not closed.");
              if (this.options.commentPropName) {
                const comment = xmlData.substring(i3 + 4, endIndex - 2);
                textData = this.saveTextToParentTag(textData, currentNode, jPath);
                currentNode.add(this.options.commentPropName, [{ [this.options.textNodeName]: comment }]);
              }
              i3 = endIndex;
            } else if (xmlData.substr(i3 + 1, 2) === "!D") {
              const result = readDocType(xmlData, i3);
              this.docTypeEntities = result.entities;
              i3 = result.i;
            } else if (xmlData.substr(i3 + 1, 2) === "![") {
              const closeIndex = findClosingIndex(xmlData, "]]>", i3, "CDATA is not closed.") - 2;
              const tagExp = xmlData.substring(i3 + 9, closeIndex);
              textData = this.saveTextToParentTag(textData, currentNode, jPath);
              let val2 = this.parseTextData(tagExp, currentNode.tagname, jPath, true, false, true, true);
              if (val2 == void 0)
                val2 = "";
              if (this.options.cdataPropName) {
                currentNode.add(this.options.cdataPropName, [{ [this.options.textNodeName]: tagExp }]);
              } else {
                currentNode.add(this.options.textNodeName, val2);
              }
              i3 = closeIndex + 2;
            } else {
              let result = readTagExp(xmlData, i3, this.options.removeNSPrefix);
              let tagName = result.tagName;
              const rawTagName = result.rawTagName;
              let tagExp = result.tagExp;
              let attrExpPresent = result.attrExpPresent;
              let closeIndex = result.closeIndex;
              if (this.options.transformTagName) {
                tagName = this.options.transformTagName(tagName);
              }
              if (currentNode && textData) {
                if (currentNode.tagname !== "!xml") {
                  textData = this.saveTextToParentTag(textData, currentNode, jPath, false);
                }
              }
              const lastTag = currentNode;
              if (lastTag && this.options.unpairedTags.indexOf(lastTag.tagname) !== -1) {
                currentNode = this.tagsNodeStack.pop();
                jPath = jPath.substring(0, jPath.lastIndexOf("."));
              }
              if (tagName !== xmlObj.tagname) {
                jPath += jPath ? "." + tagName : tagName;
              }
              if (this.isItStopNode(this.options.stopNodes, jPath, tagName)) {
                let tagContent = "";
                if (tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1) {
                  if (tagName[tagName.length - 1] === "/") {
                    tagName = tagName.substr(0, tagName.length - 1);
                    jPath = jPath.substr(0, jPath.length - 1);
                    tagExp = tagName;
                  } else {
                    tagExp = tagExp.substr(0, tagExp.length - 1);
                  }
                  i3 = result.closeIndex;
                } else if (this.options.unpairedTags.indexOf(tagName) !== -1) {
                  i3 = result.closeIndex;
                } else {
                  const result2 = this.readStopNodeData(xmlData, rawTagName, closeIndex + 1);
                  if (!result2)
                    throw new Error(`Unexpected end of ${rawTagName}`);
                  i3 = result2.i;
                  tagContent = result2.tagContent;
                }
                const childNode = new xmlNode(tagName);
                if (tagName !== tagExp && attrExpPresent) {
                  childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
                }
                if (tagContent) {
                  tagContent = this.parseTextData(tagContent, tagName, jPath, true, attrExpPresent, true, true);
                }
                jPath = jPath.substr(0, jPath.lastIndexOf("."));
                childNode.add(this.options.textNodeName, tagContent);
                this.addChild(currentNode, childNode, jPath);
              } else {
                if (tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1) {
                  if (tagName[tagName.length - 1] === "/") {
                    tagName = tagName.substr(0, tagName.length - 1);
                    jPath = jPath.substr(0, jPath.length - 1);
                    tagExp = tagName;
                  } else {
                    tagExp = tagExp.substr(0, tagExp.length - 1);
                  }
                  if (this.options.transformTagName) {
                    tagName = this.options.transformTagName(tagName);
                  }
                  const childNode = new xmlNode(tagName);
                  if (tagName !== tagExp && attrExpPresent) {
                    childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
                  }
                  this.addChild(currentNode, childNode, jPath);
                  jPath = jPath.substr(0, jPath.lastIndexOf("."));
                } else {
                  const childNode = new xmlNode(tagName);
                  this.tagsNodeStack.push(currentNode);
                  if (tagName !== tagExp && attrExpPresent) {
                    childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
                  }
                  this.addChild(currentNode, childNode, jPath);
                  currentNode = childNode;
                }
                textData = "";
                i3 = closeIndex;
              }
            }
          } else {
            textData += xmlData[i3];
          }
        }
        return xmlObj.child;
      }, "parseXml");
      function addChild(currentNode, childNode, jPath) {
        const result = this.options.updateTag(childNode.tagname, jPath, childNode[":@"]);
        if (result === false) {
        } else if (typeof result === "string") {
          childNode.tagname = result;
          currentNode.addChild(childNode);
        } else {
          currentNode.addChild(childNode);
        }
      }
      __name(addChild, "addChild");
      var replaceEntitiesValue = /* @__PURE__ */ __name(function(val2) {
        if (this.options.processEntities) {
          for (let entityName2 in this.docTypeEntities) {
            const entity = this.docTypeEntities[entityName2];
            val2 = val2.replace(entity.regx, entity.val);
          }
          for (let entityName2 in this.lastEntities) {
            const entity = this.lastEntities[entityName2];
            val2 = val2.replace(entity.regex, entity.val);
          }
          if (this.options.htmlEntities) {
            for (let entityName2 in this.htmlEntities) {
              const entity = this.htmlEntities[entityName2];
              val2 = val2.replace(entity.regex, entity.val);
            }
          }
          val2 = val2.replace(this.ampEntity.regex, this.ampEntity.val);
        }
        return val2;
      }, "replaceEntitiesValue");
      function saveTextToParentTag(textData, currentNode, jPath, isLeafNode) {
        if (textData) {
          if (isLeafNode === void 0)
            isLeafNode = Object.keys(currentNode.child).length === 0;
          textData = this.parseTextData(
            textData,
            currentNode.tagname,
            jPath,
            false,
            currentNode[":@"] ? Object.keys(currentNode[":@"]).length !== 0 : false,
            isLeafNode
          );
          if (textData !== void 0 && textData !== "")
            currentNode.add(this.options.textNodeName, textData);
          textData = "";
        }
        return textData;
      }
      __name(saveTextToParentTag, "saveTextToParentTag");
      function isItStopNode(stopNodes, jPath, currentTagName) {
        const allNodesExp = "*." + currentTagName;
        for (const stopNodePath in stopNodes) {
          const stopNodeExp = stopNodes[stopNodePath];
          if (allNodesExp === stopNodeExp || jPath === stopNodeExp)
            return true;
        }
        return false;
      }
      __name(isItStopNode, "isItStopNode");
      function tagExpWithClosingIndex(xmlData, i3, closingChar = ">") {
        let attrBoundary;
        let tagExp = "";
        for (let index2 = i3; index2 < xmlData.length; index2++) {
          let ch2 = xmlData[index2];
          if (attrBoundary) {
            if (ch2 === attrBoundary)
              attrBoundary = "";
          } else if (ch2 === '"' || ch2 === "'") {
            attrBoundary = ch2;
          } else if (ch2 === closingChar[0]) {
            if (closingChar[1]) {
              if (xmlData[index2 + 1] === closingChar[1]) {
                return {
                  data: tagExp,
                  index: index2
                };
              }
            } else {
              return {
                data: tagExp,
                index: index2
              };
            }
          } else if (ch2 === "	") {
            ch2 = " ";
          }
          tagExp += ch2;
        }
      }
      __name(tagExpWithClosingIndex, "tagExpWithClosingIndex");
      function findClosingIndex(xmlData, str, i3, errMsg) {
        const closingIndex = xmlData.indexOf(str, i3);
        if (closingIndex === -1) {
          throw new Error(errMsg);
        } else {
          return closingIndex + str.length - 1;
        }
      }
      __name(findClosingIndex, "findClosingIndex");
      function readTagExp(xmlData, i3, removeNSPrefix, closingChar = ">") {
        const result = tagExpWithClosingIndex(xmlData, i3 + 1, closingChar);
        if (!result)
          return;
        let tagExp = result.data;
        const closeIndex = result.index;
        const separatorIndex = tagExp.search(/\s/);
        let tagName = tagExp;
        let attrExpPresent = true;
        if (separatorIndex !== -1) {
          tagName = tagExp.substring(0, separatorIndex);
          tagExp = tagExp.substring(separatorIndex + 1).trimStart();
        }
        const rawTagName = tagName;
        if (removeNSPrefix) {
          const colonIndex = tagName.indexOf(":");
          if (colonIndex !== -1) {
            tagName = tagName.substr(colonIndex + 1);
            attrExpPresent = tagName !== result.data.substr(colonIndex + 1);
          }
        }
        return {
          tagName,
          tagExp,
          closeIndex,
          attrExpPresent,
          rawTagName
        };
      }
      __name(readTagExp, "readTagExp");
      function readStopNodeData(xmlData, tagName, i3) {
        const startIndex = i3;
        let openTagCount = 1;
        for (; i3 < xmlData.length; i3++) {
          if (xmlData[i3] === "<") {
            if (xmlData[i3 + 1] === "/") {
              const closeIndex = findClosingIndex(xmlData, ">", i3, `${tagName} is not closed`);
              let closeTagName = xmlData.substring(i3 + 2, closeIndex).trim();
              if (closeTagName === tagName) {
                openTagCount--;
                if (openTagCount === 0) {
                  return {
                    tagContent: xmlData.substring(startIndex, i3),
                    i: closeIndex
                  };
                }
              }
              i3 = closeIndex;
            } else if (xmlData[i3 + 1] === "?") {
              const closeIndex = findClosingIndex(xmlData, "?>", i3 + 1, "StopNode is not closed.");
              i3 = closeIndex;
            } else if (xmlData.substr(i3 + 1, 3) === "!--") {
              const closeIndex = findClosingIndex(xmlData, "-->", i3 + 3, "StopNode is not closed.");
              i3 = closeIndex;
            } else if (xmlData.substr(i3 + 1, 2) === "![") {
              const closeIndex = findClosingIndex(xmlData, "]]>", i3, "StopNode is not closed.") - 2;
              i3 = closeIndex;
            } else {
              const tagData = readTagExp(xmlData, i3, ">");
              if (tagData) {
                const openTagName = tagData && tagData.tagName;
                if (openTagName === tagName && tagData.tagExp[tagData.tagExp.length - 1] !== "/") {
                  openTagCount++;
                }
                i3 = tagData.closeIndex;
              }
            }
          }
        }
      }
      __name(readStopNodeData, "readStopNodeData");
      function parseValue(val2, shouldParse, options) {
        if (shouldParse && typeof val2 === "string") {
          const newval = val2.trim();
          if (newval === "true")
            return true;
          else if (newval === "false")
            return false;
          else
            return toNumber(val2, options);
        } else {
          if (util.isExist(val2)) {
            return val2;
          } else {
            return "";
          }
        }
      }
      __name(parseValue, "parseValue");
      module2.exports = OrderedObjParser;
    }
  });

  // node_modules/fast-xml-parser/src/xmlparser/node2json.js
  var require_node2json = __commonJS({
    "node_modules/fast-xml-parser/src/xmlparser/node2json.js"(exports2) {
      "use strict";
      function prettify(node, options) {
        return compress(node, options);
      }
      __name(prettify, "prettify");
      function compress(arr, options, jPath) {
        let text;
        const compressedObj = {};
        for (let i3 = 0; i3 < arr.length; i3++) {
          const tagObj = arr[i3];
          const property = propName(tagObj);
          let newJpath = "";
          if (jPath === void 0)
            newJpath = property;
          else
            newJpath = jPath + "." + property;
          if (property === options.textNodeName) {
            if (text === void 0)
              text = tagObj[property];
            else
              text += "" + tagObj[property];
          } else if (property === void 0) {
            continue;
          } else if (tagObj[property]) {
            let val2 = compress(tagObj[property], options, newJpath);
            const isLeaf = isLeafTag(val2, options);
            if (tagObj[":@"]) {
              assignAttributes(val2, tagObj[":@"], newJpath, options);
            } else if (Object.keys(val2).length === 1 && val2[options.textNodeName] !== void 0 && !options.alwaysCreateTextNode) {
              val2 = val2[options.textNodeName];
            } else if (Object.keys(val2).length === 0) {
              if (options.alwaysCreateTextNode)
                val2[options.textNodeName] = "";
              else
                val2 = "";
            }
            if (compressedObj[property] !== void 0 && compressedObj.hasOwnProperty(property)) {
              if (!Array.isArray(compressedObj[property])) {
                compressedObj[property] = [compressedObj[property]];
              }
              compressedObj[property].push(val2);
            } else {
              if (options.isArray(property, newJpath, isLeaf)) {
                compressedObj[property] = [val2];
              } else {
                compressedObj[property] = val2;
              }
            }
          }
        }
        if (typeof text === "string") {
          if (text.length > 0)
            compressedObj[options.textNodeName] = text;
        } else if (text !== void 0)
          compressedObj[options.textNodeName] = text;
        return compressedObj;
      }
      __name(compress, "compress");
      function propName(obj) {
        const keys2 = Object.keys(obj);
        for (let i3 = 0; i3 < keys2.length; i3++) {
          const key = keys2[i3];
          if (key !== ":@")
            return key;
        }
      }
      __name(propName, "propName");
      function assignAttributes(obj, attrMap, jpath, options) {
        if (attrMap) {
          const keys2 = Object.keys(attrMap);
          const len = keys2.length;
          for (let i3 = 0; i3 < len; i3++) {
            const atrrName = keys2[i3];
            if (options.isArray(atrrName, jpath + "." + atrrName, true, true)) {
              obj[atrrName] = [attrMap[atrrName]];
            } else {
              obj[atrrName] = attrMap[atrrName];
            }
          }
        }
      }
      __name(assignAttributes, "assignAttributes");
      function isLeafTag(obj, options) {
        const { textNodeName } = options;
        const propCount = Object.keys(obj).length;
        if (propCount === 0) {
          return true;
        }
        if (propCount === 1 && (obj[textNodeName] || typeof obj[textNodeName] === "boolean" || obj[textNodeName] === 0)) {
          return true;
        }
        return false;
      }
      __name(isLeafTag, "isLeafTag");
      exports2.prettify = prettify;
    }
  });

  // node_modules/fast-xml-parser/src/xmlparser/XMLParser.js
  var require_XMLParser = __commonJS({
    "node_modules/fast-xml-parser/src/xmlparser/XMLParser.js"(exports2, module2) {
      var { buildOptions } = require_OptionsBuilder();
      var OrderedObjParser = require_OrderedObjParser();
      var { prettify } = require_node2json();
      var validator = require_validator();
      var XMLParser2 = class {
        static {
          __name(this, "XMLParser");
        }
        constructor(options) {
          this.externalEntities = {};
          this.options = buildOptions(options);
        }
        /**
         * Parse XML dats to JS object 
         * @param {string|Buffer} xmlData 
         * @param {boolean|Object} validationOption 
         */
        parse(xmlData, validationOption) {
          if (typeof xmlData === "string") {
          } else if (xmlData.toString) {
            xmlData = xmlData.toString();
          } else {
            throw new Error("XML data is accepted in String or Bytes[] form.");
          }
          if (validationOption) {
            if (validationOption === true)
              validationOption = {};
            const result = validator.validate(xmlData, validationOption);
            if (result !== true) {
              throw Error(`${result.err.msg}:${result.err.line}:${result.err.col}`);
            }
          }
          const orderedObjParser = new OrderedObjParser(this.options);
          orderedObjParser.addExternalEntities(this.externalEntities);
          const orderedResult = orderedObjParser.parseXml(xmlData);
          if (this.options.preserveOrder || orderedResult === void 0)
            return orderedResult;
          else
            return prettify(orderedResult, this.options);
        }
        /**
         * Add Entity which is not by default supported by this library
         * @param {string} key 
         * @param {string} value 
         */
        addEntity(key, value) {
          if (value.indexOf("&") !== -1) {
            throw new Error("Entity value can't have '&'");
          } else if (key.indexOf("&") !== -1 || key.indexOf(";") !== -1) {
            throw new Error("An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'");
          } else if (value === "&") {
            throw new Error("An entity with value '&' is not permitted");
          } else {
            this.externalEntities[key] = value;
          }
        }
      };
      module2.exports = XMLParser2;
    }
  });

  // node_modules/fast-xml-parser/src/xmlbuilder/orderedJs2Xml.js
  var require_orderedJs2Xml = __commonJS({
    "node_modules/fast-xml-parser/src/xmlbuilder/orderedJs2Xml.js"(exports2, module2) {
      var EOL = "\n";
      function toXml(jArray, options) {
        let indentation = "";
        if (options.format && options.indentBy.length > 0) {
          indentation = EOL;
        }
        return arrToStr(jArray, options, "", indentation);
      }
      __name(toXml, "toXml");
      function arrToStr(arr, options, jPath, indentation) {
        let xmlStr = "";
        let isPreviousElementTag = false;
        for (let i3 = 0; i3 < arr.length; i3++) {
          const tagObj = arr[i3];
          const tagName = propName(tagObj);
          if (tagName === void 0)
            continue;
          let newJPath = "";
          if (jPath.length === 0)
            newJPath = tagName;
          else
            newJPath = `${jPath}.${tagName}`;
          if (tagName === options.textNodeName) {
            let tagText = tagObj[tagName];
            if (!isStopNode(newJPath, options)) {
              tagText = options.tagValueProcessor(tagName, tagText);
              tagText = replaceEntitiesValue(tagText, options);
            }
            if (isPreviousElementTag) {
              xmlStr += indentation;
            }
            xmlStr += tagText;
            isPreviousElementTag = false;
            continue;
          } else if (tagName === options.cdataPropName) {
            if (isPreviousElementTag) {
              xmlStr += indentation;
            }
            xmlStr += `<![CDATA[${tagObj[tagName][0][options.textNodeName]}]]>`;
            isPreviousElementTag = false;
            continue;
          } else if (tagName === options.commentPropName) {
            xmlStr += indentation + `<!--${tagObj[tagName][0][options.textNodeName]}-->`;
            isPreviousElementTag = true;
            continue;
          } else if (tagName[0] === "?") {
            const attStr2 = attr_to_str(tagObj[":@"], options);
            const tempInd = tagName === "?xml" ? "" : indentation;
            let piTextNodeName = tagObj[tagName][0][options.textNodeName];
            piTextNodeName = piTextNodeName.length !== 0 ? " " + piTextNodeName : "";
            xmlStr += tempInd + `<${tagName}${piTextNodeName}${attStr2}?>`;
            isPreviousElementTag = true;
            continue;
          }
          let newIdentation = indentation;
          if (newIdentation !== "") {
            newIdentation += options.indentBy;
          }
          const attStr = attr_to_str(tagObj[":@"], options);
          const tagStart = indentation + `<${tagName}${attStr}`;
          const tagValue = arrToStr(tagObj[tagName], options, newJPath, newIdentation);
          if (options.unpairedTags.indexOf(tagName) !== -1) {
            if (options.suppressUnpairedNode)
              xmlStr += tagStart + ">";
            else
              xmlStr += tagStart + "/>";
          } else if ((!tagValue || tagValue.length === 0) && options.suppressEmptyNode) {
            xmlStr += tagStart + "/>";
          } else if (tagValue && tagValue.endsWith(">")) {
            xmlStr += tagStart + `>${tagValue}${indentation}</${tagName}>`;
          } else {
            xmlStr += tagStart + ">";
            if (tagValue && indentation !== "" && (tagValue.includes("/>") || tagValue.includes("</"))) {
              xmlStr += indentation + options.indentBy + tagValue + indentation;
            } else {
              xmlStr += tagValue;
            }
            xmlStr += `</${tagName}>`;
          }
          isPreviousElementTag = true;
        }
        return xmlStr;
      }
      __name(arrToStr, "arrToStr");
      function propName(obj) {
        const keys2 = Object.keys(obj);
        for (let i3 = 0; i3 < keys2.length; i3++) {
          const key = keys2[i3];
          if (!obj.hasOwnProperty(key))
            continue;
          if (key !== ":@")
            return key;
        }
      }
      __name(propName, "propName");
      function attr_to_str(attrMap, options) {
        let attrStr = "";
        if (attrMap && !options.ignoreAttributes) {
          for (let attr in attrMap) {
            if (!attrMap.hasOwnProperty(attr))
              continue;
            let attrVal = options.attributeValueProcessor(attr, attrMap[attr]);
            attrVal = replaceEntitiesValue(attrVal, options);
            if (attrVal === true && options.suppressBooleanAttributes) {
              attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}`;
            } else {
              attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}="${attrVal}"`;
            }
          }
        }
        return attrStr;
      }
      __name(attr_to_str, "attr_to_str");
      function isStopNode(jPath, options) {
        jPath = jPath.substr(0, jPath.length - options.textNodeName.length - 1);
        let tagName = jPath.substr(jPath.lastIndexOf(".") + 1);
        for (let index2 in options.stopNodes) {
          if (options.stopNodes[index2] === jPath || options.stopNodes[index2] === "*." + tagName)
            return true;
        }
        return false;
      }
      __name(isStopNode, "isStopNode");
      function replaceEntitiesValue(textValue, options) {
        if (textValue && textValue.length > 0 && options.processEntities) {
          for (let i3 = 0; i3 < options.entities.length; i3++) {
            const entity = options.entities[i3];
            textValue = textValue.replace(entity.regex, entity.val);
          }
        }
        return textValue;
      }
      __name(replaceEntitiesValue, "replaceEntitiesValue");
      module2.exports = toXml;
    }
  });

  // node_modules/fast-xml-parser/src/xmlbuilder/json2xml.js
  var require_json2xml = __commonJS({
    "node_modules/fast-xml-parser/src/xmlbuilder/json2xml.js"(exports2, module2) {
      "use strict";
      var buildFromOrderedJs = require_orderedJs2Xml();
      var defaultOptions3 = {
        attributeNamePrefix: "@_",
        attributesGroupName: false,
        textNodeName: "#text",
        ignoreAttributes: true,
        cdataPropName: false,
        format: false,
        indentBy: "  ",
        suppressEmptyNode: false,
        suppressUnpairedNode: true,
        suppressBooleanAttributes: true,
        tagValueProcessor: function(key, a3) {
          return a3;
        },
        attributeValueProcessor: function(attrName, a3) {
          return a3;
        },
        preserveOrder: false,
        commentPropName: false,
        unpairedTags: [],
        entities: [
          { regex: new RegExp("&", "g"), val: "&amp;" },
          //it must be on top
          { regex: new RegExp(">", "g"), val: "&gt;" },
          { regex: new RegExp("<", "g"), val: "&lt;" },
          { regex: new RegExp("'", "g"), val: "&apos;" },
          { regex: new RegExp('"', "g"), val: "&quot;" }
        ],
        processEntities: true,
        stopNodes: [],
        // transformTagName: false,
        // transformAttributeName: false,
        oneListGroup: false
      };
      function Builder(options) {
        this.options = Object.assign({}, defaultOptions3, options);
        if (this.options.ignoreAttributes || this.options.attributesGroupName) {
          this.isAttribute = function() {
            return false;
          };
        } else {
          this.attrPrefixLen = this.options.attributeNamePrefix.length;
          this.isAttribute = isAttribute;
        }
        this.processTextOrObjNode = processTextOrObjNode;
        if (this.options.format) {
          this.indentate = indentate;
          this.tagEndChar = ">\n";
          this.newLine = "\n";
        } else {
          this.indentate = function() {
            return "";
          };
          this.tagEndChar = ">";
          this.newLine = "";
        }
      }
      __name(Builder, "Builder");
      Builder.prototype.build = function(jObj) {
        if (this.options.preserveOrder) {
          return buildFromOrderedJs(jObj, this.options);
        } else {
          if (Array.isArray(jObj) && this.options.arrayNodeName && this.options.arrayNodeName.length > 1) {
            jObj = {
              [this.options.arrayNodeName]: jObj
            };
          }
          return this.j2x(jObj, 0).val;
        }
      };
      Builder.prototype.j2x = function(jObj, level2) {
        let attrStr = "";
        let val2 = "";
        for (let key in jObj) {
          if (!Object.prototype.hasOwnProperty.call(jObj, key))
            continue;
          if (typeof jObj[key] === "undefined") {
            if (this.isAttribute(key)) {
              val2 += "";
            }
          } else if (jObj[key] === null) {
            if (this.isAttribute(key)) {
              val2 += "";
            } else if (key[0] === "?") {
              val2 += this.indentate(level2) + "<" + key + "?" + this.tagEndChar;
            } else {
              val2 += this.indentate(level2) + "<" + key + "/" + this.tagEndChar;
            }
          } else if (jObj[key] instanceof Date) {
            val2 += this.buildTextValNode(jObj[key], key, "", level2);
          } else if (typeof jObj[key] !== "object") {
            const attr = this.isAttribute(key);
            if (attr) {
              attrStr += this.buildAttrPairStr(attr, "" + jObj[key]);
            } else {
              if (key === this.options.textNodeName) {
                let newval = this.options.tagValueProcessor(key, "" + jObj[key]);
                val2 += this.replaceEntitiesValue(newval);
              } else {
                val2 += this.buildTextValNode(jObj[key], key, "", level2);
              }
            }
          } else if (Array.isArray(jObj[key])) {
            const arrLen = jObj[key].length;
            let listTagVal = "";
            let listTagAttr = "";
            for (let j3 = 0; j3 < arrLen; j3++) {
              const item = jObj[key][j3];
              if (typeof item === "undefined") {
              } else if (item === null) {
                if (key[0] === "?")
                  val2 += this.indentate(level2) + "<" + key + "?" + this.tagEndChar;
                else
                  val2 += this.indentate(level2) + "<" + key + "/" + this.tagEndChar;
              } else if (typeof item === "object") {
                if (this.options.oneListGroup) {
                  const result = this.j2x(item, level2 + 1);
                  listTagVal += result.val;
                  if (this.options.attributesGroupName && item.hasOwnProperty(this.options.attributesGroupName)) {
                    listTagAttr += result.attrStr;
                  }
                } else {
                  listTagVal += this.processTextOrObjNode(item, key, level2);
                }
              } else {
                if (this.options.oneListGroup) {
                  let textValue = this.options.tagValueProcessor(key, item);
                  textValue = this.replaceEntitiesValue(textValue);
                  listTagVal += textValue;
                } else {
                  listTagVal += this.buildTextValNode(item, key, "", level2);
                }
              }
            }
            if (this.options.oneListGroup) {
              listTagVal = this.buildObjectNode(listTagVal, key, listTagAttr, level2);
            }
            val2 += listTagVal;
          } else {
            if (this.options.attributesGroupName && key === this.options.attributesGroupName) {
              const Ks = Object.keys(jObj[key]);
              const L5 = Ks.length;
              for (let j3 = 0; j3 < L5; j3++) {
                attrStr += this.buildAttrPairStr(Ks[j3], "" + jObj[key][Ks[j3]]);
              }
            } else {
              val2 += this.processTextOrObjNode(jObj[key], key, level2);
            }
          }
        }
        return { attrStr, val: val2 };
      };
      Builder.prototype.buildAttrPairStr = function(attrName, val2) {
        val2 = this.options.attributeValueProcessor(attrName, "" + val2);
        val2 = this.replaceEntitiesValue(val2);
        if (this.options.suppressBooleanAttributes && val2 === "true") {
          return " " + attrName;
        } else
          return " " + attrName + '="' + val2 + '"';
      };
      function processTextOrObjNode(object, key, level2) {
        const result = this.j2x(object, level2 + 1);
        if (object[this.options.textNodeName] !== void 0 && Object.keys(object).length === 1) {
          return this.buildTextValNode(object[this.options.textNodeName], key, result.attrStr, level2);
        } else {
          return this.buildObjectNode(result.val, key, result.attrStr, level2);
        }
      }
      __name(processTextOrObjNode, "processTextOrObjNode");
      Builder.prototype.buildObjectNode = function(val2, key, attrStr, level2) {
        if (val2 === "") {
          if (key[0] === "?")
            return this.indentate(level2) + "<" + key + attrStr + "?" + this.tagEndChar;
          else {
            return this.indentate(level2) + "<" + key + attrStr + this.closeTag(key) + this.tagEndChar;
          }
        } else {
          let tagEndExp = "</" + key + this.tagEndChar;
          let piClosingChar = "";
          if (key[0] === "?") {
            piClosingChar = "?";
            tagEndExp = "";
          }
          if ((attrStr || attrStr === "") && val2.indexOf("<") === -1) {
            return this.indentate(level2) + "<" + key + attrStr + piClosingChar + ">" + val2 + tagEndExp;
          } else if (this.options.commentPropName !== false && key === this.options.commentPropName && piClosingChar.length === 0) {
            return this.indentate(level2) + `<!--${val2}-->` + this.newLine;
          } else {
            return this.indentate(level2) + "<" + key + attrStr + piClosingChar + this.tagEndChar + val2 + this.indentate(level2) + tagEndExp;
          }
        }
      };
      Builder.prototype.closeTag = function(key) {
        let closeTag = "";
        if (this.options.unpairedTags.indexOf(key) !== -1) {
          if (!this.options.suppressUnpairedNode)
            closeTag = "/";
        } else if (this.options.suppressEmptyNode) {
          closeTag = "/";
        } else {
          closeTag = `></${key}`;
        }
        return closeTag;
      };
      Builder.prototype.buildTextValNode = function(val2, key, attrStr, level2) {
        if (this.options.cdataPropName !== false && key === this.options.cdataPropName) {
          return this.indentate(level2) + `<![CDATA[${val2}]]>` + this.newLine;
        } else if (this.options.commentPropName !== false && key === this.options.commentPropName) {
          return this.indentate(level2) + `<!--${val2}-->` + this.newLine;
        } else if (key[0] === "?") {
          return this.indentate(level2) + "<" + key + attrStr + "?" + this.tagEndChar;
        } else {
          let textValue = this.options.tagValueProcessor(key, val2);
          textValue = this.replaceEntitiesValue(textValue);
          if (textValue === "") {
            return this.indentate(level2) + "<" + key + attrStr + this.closeTag(key) + this.tagEndChar;
          } else {
            return this.indentate(level2) + "<" + key + attrStr + ">" + textValue + "</" + key + this.tagEndChar;
          }
        }
      };
      Builder.prototype.replaceEntitiesValue = function(textValue) {
        if (textValue && textValue.length > 0 && this.options.processEntities) {
          for (let i3 = 0; i3 < this.options.entities.length; i3++) {
            const entity = this.options.entities[i3];
            textValue = textValue.replace(entity.regex, entity.val);
          }
        }
        return textValue;
      };
      function indentate(level2) {
        return this.options.indentBy.repeat(level2);
      }
      __name(indentate, "indentate");
      function isAttribute(name) {
        if (name.startsWith(this.options.attributeNamePrefix) && name !== this.options.textNodeName) {
          return name.substr(this.attrPrefixLen);
        } else {
          return false;
        }
      }
      __name(isAttribute, "isAttribute");
      module2.exports = Builder;
    }
  });

  // node_modules/fast-xml-parser/src/fxp.js
  var require_fxp = __commonJS({
    "node_modules/fast-xml-parser/src/fxp.js"(exports2, module2) {
      "use strict";
      var validator = require_validator();
      var XMLParser2 = require_XMLParser();
      var XMLBuilder = require_json2xml();
      module2.exports = {
        XMLParser: XMLParser2,
        XMLValidator: validator,
        XMLBuilder
      };
    }
  });

  // node_modules/bowser/es5.js
  var require_es5 = __commonJS({
    "node_modules/bowser/es5.js"(exports2, module2) {
      !function(e3, t3) {
        "object" == typeof exports2 && "object" == typeof module2 ? module2.exports = t3() : "function" == typeof define && define.amd ? define([], t3) : "object" == typeof exports2 ? exports2.bowser = t3() : e3.bowser = t3();
      }(exports2, function() {
        return function(e3) {
          var t3 = {};
          function r3(n3) {
            if (t3[n3])
              return t3[n3].exports;
            var i3 = t3[n3] = { i: n3, l: false, exports: {} };
            return e3[n3].call(i3.exports, i3, i3.exports, r3), i3.l = true, i3.exports;
          }
          __name(r3, "r");
          return r3.m = e3, r3.c = t3, r3.d = function(e4, t4, n3) {
            r3.o(e4, t4) || Object.defineProperty(e4, t4, { enumerable: true, get: n3 });
          }, r3.r = function(e4) {
            "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e4, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e4, "__esModule", { value: true });
          }, r3.t = function(e4, t4) {
            if (1 & t4 && (e4 = r3(e4)), 8 & t4)
              return e4;
            if (4 & t4 && "object" == typeof e4 && e4 && e4.__esModule)
              return e4;
            var n3 = /* @__PURE__ */ Object.create(null);
            if (r3.r(n3), Object.defineProperty(n3, "default", { enumerable: true, value: e4 }), 2 & t4 && "string" != typeof e4)
              for (var i3 in e4)
                r3.d(n3, i3, function(t5) {
                  return e4[t5];
                }.bind(null, i3));
            return n3;
          }, r3.n = function(e4) {
            var t4 = e4 && e4.__esModule ? function() {
              return e4.default;
            } : function() {
              return e4;
            };
            return r3.d(t4, "a", t4), t4;
          }, r3.o = function(e4, t4) {
            return Object.prototype.hasOwnProperty.call(e4, t4);
          }, r3.p = "", r3(r3.s = 90);
        }({ 17: function(e3, t3, r3) {
          "use strict";
          t3.__esModule = true, t3.default = void 0;
          var n3 = r3(18), i3 = function() {
            function e4() {
            }
            __name(e4, "e");
            return e4.getFirstMatch = function(e5, t4) {
              var r4 = t4.match(e5);
              return r4 && r4.length > 0 && r4[1] || "";
            }, e4.getSecondMatch = function(e5, t4) {
              var r4 = t4.match(e5);
              return r4 && r4.length > 1 && r4[2] || "";
            }, e4.matchAndReturnConst = function(e5, t4, r4) {
              if (e5.test(t4))
                return r4;
            }, e4.getWindowsVersionName = function(e5) {
              switch (e5) {
                case "NT":
                  return "NT";
                case "XP":
                  return "XP";
                case "NT 5.0":
                  return "2000";
                case "NT 5.1":
                  return "XP";
                case "NT 5.2":
                  return "2003";
                case "NT 6.0":
                  return "Vista";
                case "NT 6.1":
                  return "7";
                case "NT 6.2":
                  return "8";
                case "NT 6.3":
                  return "8.1";
                case "NT 10.0":
                  return "10";
                default:
                  return;
              }
            }, e4.getMacOSVersionName = function(e5) {
              var t4 = e5.split(".").splice(0, 2).map(function(e6) {
                return parseInt(e6, 10) || 0;
              });
              if (t4.push(0), 10 === t4[0])
                switch (t4[1]) {
                  case 5:
                    return "Leopard";
                  case 6:
                    return "Snow Leopard";
                  case 7:
                    return "Lion";
                  case 8:
                    return "Mountain Lion";
                  case 9:
                    return "Mavericks";
                  case 10:
                    return "Yosemite";
                  case 11:
                    return "El Capitan";
                  case 12:
                    return "Sierra";
                  case 13:
                    return "High Sierra";
                  case 14:
                    return "Mojave";
                  case 15:
                    return "Catalina";
                  default:
                    return;
                }
            }, e4.getAndroidVersionName = function(e5) {
              var t4 = e5.split(".").splice(0, 2).map(function(e6) {
                return parseInt(e6, 10) || 0;
              });
              if (t4.push(0), !(1 === t4[0] && t4[1] < 5))
                return 1 === t4[0] && t4[1] < 6 ? "Cupcake" : 1 === t4[0] && t4[1] >= 6 ? "Donut" : 2 === t4[0] && t4[1] < 2 ? "Eclair" : 2 === t4[0] && 2 === t4[1] ? "Froyo" : 2 === t4[0] && t4[1] > 2 ? "Gingerbread" : 3 === t4[0] ? "Honeycomb" : 4 === t4[0] && t4[1] < 1 ? "Ice Cream Sandwich" : 4 === t4[0] && t4[1] < 4 ? "Jelly Bean" : 4 === t4[0] && t4[1] >= 4 ? "KitKat" : 5 === t4[0] ? "Lollipop" : 6 === t4[0] ? "Marshmallow" : 7 === t4[0] ? "Nougat" : 8 === t4[0] ? "Oreo" : 9 === t4[0] ? "Pie" : void 0;
            }, e4.getVersionPrecision = function(e5) {
              return e5.split(".").length;
            }, e4.compareVersions = function(t4, r4, n4) {
              void 0 === n4 && (n4 = false);
              var i4 = e4.getVersionPrecision(t4), s3 = e4.getVersionPrecision(r4), a3 = Math.max(i4, s3), o3 = 0, u3 = e4.map([t4, r4], function(t5) {
                var r5 = a3 - e4.getVersionPrecision(t5), n5 = t5 + new Array(r5 + 1).join(".0");
                return e4.map(n5.split("."), function(e5) {
                  return new Array(20 - e5.length).join("0") + e5;
                }).reverse();
              });
              for (n4 && (o3 = a3 - Math.min(i4, s3)), a3 -= 1; a3 >= o3; ) {
                if (u3[0][a3] > u3[1][a3])
                  return 1;
                if (u3[0][a3] === u3[1][a3]) {
                  if (a3 === o3)
                    return 0;
                  a3 -= 1;
                } else if (u3[0][a3] < u3[1][a3])
                  return -1;
              }
            }, e4.map = function(e5, t4) {
              var r4, n4 = [];
              if (Array.prototype.map)
                return Array.prototype.map.call(e5, t4);
              for (r4 = 0; r4 < e5.length; r4 += 1)
                n4.push(t4(e5[r4]));
              return n4;
            }, e4.find = function(e5, t4) {
              var r4, n4;
              if (Array.prototype.find)
                return Array.prototype.find.call(e5, t4);
              for (r4 = 0, n4 = e5.length; r4 < n4; r4 += 1) {
                var i4 = e5[r4];
                if (t4(i4, r4))
                  return i4;
              }
            }, e4.assign = function(e5) {
              for (var t4, r4, n4 = e5, i4 = arguments.length, s3 = new Array(i4 > 1 ? i4 - 1 : 0), a3 = 1; a3 < i4; a3++)
                s3[a3 - 1] = arguments[a3];
              if (Object.assign)
                return Object.assign.apply(Object, [e5].concat(s3));
              var o3 = /* @__PURE__ */ __name(function() {
                var e6 = s3[t4];
                "object" == typeof e6 && null !== e6 && Object.keys(e6).forEach(function(t5) {
                  n4[t5] = e6[t5];
                });
              }, "o");
              for (t4 = 0, r4 = s3.length; t4 < r4; t4 += 1)
                o3();
              return e5;
            }, e4.getBrowserAlias = function(e5) {
              return n3.BROWSER_ALIASES_MAP[e5];
            }, e4.getBrowserTypeByAlias = function(e5) {
              return n3.BROWSER_MAP[e5] || "";
            }, e4;
          }();
          t3.default = i3, e3.exports = t3.default;
        }, 18: function(e3, t3, r3) {
          "use strict";
          t3.__esModule = true, t3.ENGINE_MAP = t3.OS_MAP = t3.PLATFORMS_MAP = t3.BROWSER_MAP = t3.BROWSER_ALIASES_MAP = void 0;
          t3.BROWSER_ALIASES_MAP = { "Amazon Silk": "amazon_silk", "Android Browser": "android", Bada: "bada", BlackBerry: "blackberry", Chrome: "chrome", Chromium: "chromium", Electron: "electron", Epiphany: "epiphany", Firefox: "firefox", Focus: "focus", Generic: "generic", "Google Search": "google_search", Googlebot: "googlebot", "Internet Explorer": "ie", "K-Meleon": "k_meleon", Maxthon: "maxthon", "Microsoft Edge": "edge", "MZ Browser": "mz", "NAVER Whale Browser": "naver", Opera: "opera", "Opera Coast": "opera_coast", PhantomJS: "phantomjs", Puffin: "puffin", QupZilla: "qupzilla", QQ: "qq", QQLite: "qqlite", Safari: "safari", Sailfish: "sailfish", "Samsung Internet for Android": "samsung_internet", SeaMonkey: "seamonkey", Sleipnir: "sleipnir", Swing: "swing", Tizen: "tizen", "UC Browser": "uc", Vivaldi: "vivaldi", "WebOS Browser": "webos", WeChat: "wechat", "Yandex Browser": "yandex", Roku: "roku" };
          t3.BROWSER_MAP = { amazon_silk: "Amazon Silk", android: "Android Browser", bada: "Bada", blackberry: "BlackBerry", chrome: "Chrome", chromium: "Chromium", electron: "Electron", epiphany: "Epiphany", firefox: "Firefox", focus: "Focus", generic: "Generic", googlebot: "Googlebot", google_search: "Google Search", ie: "Internet Explorer", k_meleon: "K-Meleon", maxthon: "Maxthon", edge: "Microsoft Edge", mz: "MZ Browser", naver: "NAVER Whale Browser", opera: "Opera", opera_coast: "Opera Coast", phantomjs: "PhantomJS", puffin: "Puffin", qupzilla: "QupZilla", qq: "QQ Browser", qqlite: "QQ Browser Lite", safari: "Safari", sailfish: "Sailfish", samsung_internet: "Samsung Internet for Android", seamonkey: "SeaMonkey", sleipnir: "Sleipnir", swing: "Swing", tizen: "Tizen", uc: "UC Browser", vivaldi: "Vivaldi", webos: "WebOS Browser", wechat: "WeChat", yandex: "Yandex Browser" };
          t3.PLATFORMS_MAP = { tablet: "tablet", mobile: "mobile", desktop: "desktop", tv: "tv" };
          t3.OS_MAP = { WindowsPhone: "Windows Phone", Windows: "Windows", MacOS: "macOS", iOS: "iOS", Android: "Android", WebOS: "WebOS", BlackBerry: "BlackBerry", Bada: "Bada", Tizen: "Tizen", Linux: "Linux", ChromeOS: "Chrome OS", PlayStation4: "PlayStation 4", Roku: "Roku" };
          t3.ENGINE_MAP = { EdgeHTML: "EdgeHTML", Blink: "Blink", Trident: "Trident", Presto: "Presto", Gecko: "Gecko", WebKit: "WebKit" };
        }, 90: function(e3, t3, r3) {
          "use strict";
          t3.__esModule = true, t3.default = void 0;
          var n3, i3 = (n3 = r3(91)) && n3.__esModule ? n3 : { default: n3 }, s3 = r3(18);
          function a3(e4, t4) {
            for (var r4 = 0; r4 < t4.length; r4++) {
              var n4 = t4[r4];
              n4.enumerable = n4.enumerable || false, n4.configurable = true, "value" in n4 && (n4.writable = true), Object.defineProperty(e4, n4.key, n4);
            }
          }
          __name(a3, "a");
          var o3 = function() {
            function e4() {
            }
            __name(e4, "e");
            var t4, r4, n4;
            return e4.getParser = function(e5, t5) {
              if (void 0 === t5 && (t5 = false), "string" != typeof e5)
                throw new Error("UserAgent should be a string");
              return new i3.default(e5, t5);
            }, e4.parse = function(e5) {
              return new i3.default(e5).getResult();
            }, t4 = e4, n4 = [{ key: "BROWSER_MAP", get: function() {
              return s3.BROWSER_MAP;
            } }, { key: "ENGINE_MAP", get: function() {
              return s3.ENGINE_MAP;
            } }, { key: "OS_MAP", get: function() {
              return s3.OS_MAP;
            } }, { key: "PLATFORMS_MAP", get: function() {
              return s3.PLATFORMS_MAP;
            } }], (r4 = null) && a3(t4.prototype, r4), n4 && a3(t4, n4), e4;
          }();
          t3.default = o3, e3.exports = t3.default;
        }, 91: function(e3, t3, r3) {
          "use strict";
          t3.__esModule = true, t3.default = void 0;
          var n3 = u3(r3(92)), i3 = u3(r3(93)), s3 = u3(r3(94)), a3 = u3(r3(95)), o3 = u3(r3(17));
          function u3(e4) {
            return e4 && e4.__esModule ? e4 : { default: e4 };
          }
          __name(u3, "u");
          var d3 = function() {
            function e4(e5, t5) {
              if (void 0 === t5 && (t5 = false), null == e5 || "" === e5)
                throw new Error("UserAgent parameter can't be empty");
              this._ua = e5, this.parsedResult = {}, true !== t5 && this.parse();
            }
            __name(e4, "e");
            var t4 = e4.prototype;
            return t4.getUA = function() {
              return this._ua;
            }, t4.test = function(e5) {
              return e5.test(this._ua);
            }, t4.parseBrowser = function() {
              var e5 = this;
              this.parsedResult.browser = {};
              var t5 = o3.default.find(n3.default, function(t6) {
                if ("function" == typeof t6.test)
                  return t6.test(e5);
                if (t6.test instanceof Array)
                  return t6.test.some(function(t7) {
                    return e5.test(t7);
                  });
                throw new Error("Browser's test function is not valid");
              });
              return t5 && (this.parsedResult.browser = t5.describe(this.getUA())), this.parsedResult.browser;
            }, t4.getBrowser = function() {
              return this.parsedResult.browser ? this.parsedResult.browser : this.parseBrowser();
            }, t4.getBrowserName = function(e5) {
              return e5 ? String(this.getBrowser().name).toLowerCase() || "" : this.getBrowser().name || "";
            }, t4.getBrowserVersion = function() {
              return this.getBrowser().version;
            }, t4.getOS = function() {
              return this.parsedResult.os ? this.parsedResult.os : this.parseOS();
            }, t4.parseOS = function() {
              var e5 = this;
              this.parsedResult.os = {};
              var t5 = o3.default.find(i3.default, function(t6) {
                if ("function" == typeof t6.test)
                  return t6.test(e5);
                if (t6.test instanceof Array)
                  return t6.test.some(function(t7) {
                    return e5.test(t7);
                  });
                throw new Error("Browser's test function is not valid");
              });
              return t5 && (this.parsedResult.os = t5.describe(this.getUA())), this.parsedResult.os;
            }, t4.getOSName = function(e5) {
              var t5 = this.getOS().name;
              return e5 ? String(t5).toLowerCase() || "" : t5 || "";
            }, t4.getOSVersion = function() {
              return this.getOS().version;
            }, t4.getPlatform = function() {
              return this.parsedResult.platform ? this.parsedResult.platform : this.parsePlatform();
            }, t4.getPlatformType = function(e5) {
              void 0 === e5 && (e5 = false);
              var t5 = this.getPlatform().type;
              return e5 ? String(t5).toLowerCase() || "" : t5 || "";
            }, t4.parsePlatform = function() {
              var e5 = this;
              this.parsedResult.platform = {};
              var t5 = o3.default.find(s3.default, function(t6) {
                if ("function" == typeof t6.test)
                  return t6.test(e5);
                if (t6.test instanceof Array)
                  return t6.test.some(function(t7) {
                    return e5.test(t7);
                  });
                throw new Error("Browser's test function is not valid");
              });
              return t5 && (this.parsedResult.platform = t5.describe(this.getUA())), this.parsedResult.platform;
            }, t4.getEngine = function() {
              return this.parsedResult.engine ? this.parsedResult.engine : this.parseEngine();
            }, t4.getEngineName = function(e5) {
              return e5 ? String(this.getEngine().name).toLowerCase() || "" : this.getEngine().name || "";
            }, t4.parseEngine = function() {
              var e5 = this;
              this.parsedResult.engine = {};
              var t5 = o3.default.find(a3.default, function(t6) {
                if ("function" == typeof t6.test)
                  return t6.test(e5);
                if (t6.test instanceof Array)
                  return t6.test.some(function(t7) {
                    return e5.test(t7);
                  });
                throw new Error("Browser's test function is not valid");
              });
              return t5 && (this.parsedResult.engine = t5.describe(this.getUA())), this.parsedResult.engine;
            }, t4.parse = function() {
              return this.parseBrowser(), this.parseOS(), this.parsePlatform(), this.parseEngine(), this;
            }, t4.getResult = function() {
              return o3.default.assign({}, this.parsedResult);
            }, t4.satisfies = function(e5) {
              var t5 = this, r4 = {}, n4 = 0, i4 = {}, s4 = 0;
              if (Object.keys(e5).forEach(function(t6) {
                var a5 = e5[t6];
                "string" == typeof a5 ? (i4[t6] = a5, s4 += 1) : "object" == typeof a5 && (r4[t6] = a5, n4 += 1);
              }), n4 > 0) {
                var a4 = Object.keys(r4), u4 = o3.default.find(a4, function(e6) {
                  return t5.isOS(e6);
                });
                if (u4) {
                  var d4 = this.satisfies(r4[u4]);
                  if (void 0 !== d4)
                    return d4;
                }
                var c3 = o3.default.find(a4, function(e6) {
                  return t5.isPlatform(e6);
                });
                if (c3) {
                  var f3 = this.satisfies(r4[c3]);
                  if (void 0 !== f3)
                    return f3;
                }
              }
              if (s4 > 0) {
                var l3 = Object.keys(i4), h3 = o3.default.find(l3, function(e6) {
                  return t5.isBrowser(e6, true);
                });
                if (void 0 !== h3)
                  return this.compareVersion(i4[h3]);
              }
            }, t4.isBrowser = function(e5, t5) {
              void 0 === t5 && (t5 = false);
              var r4 = this.getBrowserName().toLowerCase(), n4 = e5.toLowerCase(), i4 = o3.default.getBrowserTypeByAlias(n4);
              return t5 && i4 && (n4 = i4.toLowerCase()), n4 === r4;
            }, t4.compareVersion = function(e5) {
              var t5 = [0], r4 = e5, n4 = false, i4 = this.getBrowserVersion();
              if ("string" == typeof i4)
                return ">" === e5[0] || "<" === e5[0] ? (r4 = e5.substr(1), "=" === e5[1] ? (n4 = true, r4 = e5.substr(2)) : t5 = [], ">" === e5[0] ? t5.push(1) : t5.push(-1)) : "=" === e5[0] ? r4 = e5.substr(1) : "~" === e5[0] && (n4 = true, r4 = e5.substr(1)), t5.indexOf(o3.default.compareVersions(i4, r4, n4)) > -1;
            }, t4.isOS = function(e5) {
              return this.getOSName(true) === String(e5).toLowerCase();
            }, t4.isPlatform = function(e5) {
              return this.getPlatformType(true) === String(e5).toLowerCase();
            }, t4.isEngine = function(e5) {
              return this.getEngineName(true) === String(e5).toLowerCase();
            }, t4.is = function(e5, t5) {
              return void 0 === t5 && (t5 = false), this.isBrowser(e5, t5) || this.isOS(e5) || this.isPlatform(e5);
            }, t4.some = function(e5) {
              var t5 = this;
              return void 0 === e5 && (e5 = []), e5.some(function(e6) {
                return t5.is(e6);
              });
            }, e4;
          }();
          t3.default = d3, e3.exports = t3.default;
        }, 92: function(e3, t3, r3) {
          "use strict";
          t3.__esModule = true, t3.default = void 0;
          var n3, i3 = (n3 = r3(17)) && n3.__esModule ? n3 : { default: n3 };
          var s3 = /version\/(\d+(\.?_?\d+)+)/i, a3 = [{ test: [/googlebot/i], describe: function(e4) {
            var t4 = { name: "Googlebot" }, r4 = i3.default.getFirstMatch(/googlebot\/(\d+(\.\d+))/i, e4) || i3.default.getFirstMatch(s3, e4);
            return r4 && (t4.version = r4), t4;
          } }, { test: [/opera/i], describe: function(e4) {
            var t4 = { name: "Opera" }, r4 = i3.default.getFirstMatch(s3, e4) || i3.default.getFirstMatch(/(?:opera)[\s/](\d+(\.?_?\d+)+)/i, e4);
            return r4 && (t4.version = r4), t4;
          } }, { test: [/opr\/|opios/i], describe: function(e4) {
            var t4 = { name: "Opera" }, r4 = i3.default.getFirstMatch(/(?:opr|opios)[\s/](\S+)/i, e4) || i3.default.getFirstMatch(s3, e4);
            return r4 && (t4.version = r4), t4;
          } }, { test: [/SamsungBrowser/i], describe: function(e4) {
            var t4 = { name: "Samsung Internet for Android" }, r4 = i3.default.getFirstMatch(s3, e4) || i3.default.getFirstMatch(/(?:SamsungBrowser)[\s/](\d+(\.?_?\d+)+)/i, e4);
            return r4 && (t4.version = r4), t4;
          } }, { test: [/Whale/i], describe: function(e4) {
            var t4 = { name: "NAVER Whale Browser" }, r4 = i3.default.getFirstMatch(s3, e4) || i3.default.getFirstMatch(/(?:whale)[\s/](\d+(?:\.\d+)+)/i, e4);
            return r4 && (t4.version = r4), t4;
          } }, { test: [/MZBrowser/i], describe: function(e4) {
            var t4 = { name: "MZ Browser" }, r4 = i3.default.getFirstMatch(/(?:MZBrowser)[\s/](\d+(?:\.\d+)+)/i, e4) || i3.default.getFirstMatch(s3, e4);
            return r4 && (t4.version = r4), t4;
          } }, { test: [/focus/i], describe: function(e4) {
            var t4 = { name: "Focus" }, r4 = i3.default.getFirstMatch(/(?:focus)[\s/](\d+(?:\.\d+)+)/i, e4) || i3.default.getFirstMatch(s3, e4);
            return r4 && (t4.version = r4), t4;
          } }, { test: [/swing/i], describe: function(e4) {
            var t4 = { name: "Swing" }, r4 = i3.default.getFirstMatch(/(?:swing)[\s/](\d+(?:\.\d+)+)/i, e4) || i3.default.getFirstMatch(s3, e4);
            return r4 && (t4.version = r4), t4;
          } }, { test: [/coast/i], describe: function(e4) {
            var t4 = { name: "Opera Coast" }, r4 = i3.default.getFirstMatch(s3, e4) || i3.default.getFirstMatch(/(?:coast)[\s/](\d+(\.?_?\d+)+)/i, e4);
            return r4 && (t4.version = r4), t4;
          } }, { test: [/opt\/\d+(?:.?_?\d+)+/i], describe: function(e4) {
            var t4 = { name: "Opera Touch" }, r4 = i3.default.getFirstMatch(/(?:opt)[\s/](\d+(\.?_?\d+)+)/i, e4) || i3.default.getFirstMatch(s3, e4);
            return r4 && (t4.version = r4), t4;
          } }, { test: [/yabrowser/i], describe: function(e4) {
            var t4 = { name: "Yandex Browser" }, r4 = i3.default.getFirstMatch(/(?:yabrowser)[\s/](\d+(\.?_?\d+)+)/i, e4) || i3.default.getFirstMatch(s3, e4);
            return r4 && (t4.version = r4), t4;
          } }, { test: [/ucbrowser/i], describe: function(e4) {
            var t4 = { name: "UC Browser" }, r4 = i3.default.getFirstMatch(s3, e4) || i3.default.getFirstMatch(/(?:ucbrowser)[\s/](\d+(\.?_?\d+)+)/i, e4);
            return r4 && (t4.version = r4), t4;
          } }, { test: [/Maxthon|mxios/i], describe: function(e4) {
            var t4 = { name: "Maxthon" }, r4 = i3.default.getFirstMatch(s3, e4) || i3.default.getFirstMatch(/(?:Maxthon|mxios)[\s/](\d+(\.?_?\d+)+)/i, e4);
            return r4 && (t4.version = r4), t4;
          } }, { test: [/epiphany/i], describe: function(e4) {
            var t4 = { name: "Epiphany" }, r4 = i3.default.getFirstMatch(s3, e4) || i3.default.getFirstMatch(/(?:epiphany)[\s/](\d+(\.?_?\d+)+)/i, e4);
            return r4 && (t4.version = r4), t4;
          } }, { test: [/puffin/i], describe: function(e4) {
            var t4 = { name: "Puffin" }, r4 = i3.default.getFirstMatch(s3, e4) || i3.default.getFirstMatch(/(?:puffin)[\s/](\d+(\.?_?\d+)+)/i, e4);
            return r4 && (t4.version = r4), t4;
          } }, { test: [/sleipnir/i], describe: function(e4) {
            var t4 = { name: "Sleipnir" }, r4 = i3.default.getFirstMatch(s3, e4) || i3.default.getFirstMatch(/(?:sleipnir)[\s/](\d+(\.?_?\d+)+)/i, e4);
            return r4 && (t4.version = r4), t4;
          } }, { test: [/k-meleon/i], describe: function(e4) {
            var t4 = { name: "K-Meleon" }, r4 = i3.default.getFirstMatch(s3, e4) || i3.default.getFirstMatch(/(?:k-meleon)[\s/](\d+(\.?_?\d+)+)/i, e4);
            return r4 && (t4.version = r4), t4;
          } }, { test: [/micromessenger/i], describe: function(e4) {
            var t4 = { name: "WeChat" }, r4 = i3.default.getFirstMatch(/(?:micromessenger)[\s/](\d+(\.?_?\d+)+)/i, e4) || i3.default.getFirstMatch(s3, e4);
            return r4 && (t4.version = r4), t4;
          } }, { test: [/qqbrowser/i], describe: function(e4) {
            var t4 = { name: /qqbrowserlite/i.test(e4) ? "QQ Browser Lite" : "QQ Browser" }, r4 = i3.default.getFirstMatch(/(?:qqbrowserlite|qqbrowser)[/](\d+(\.?_?\d+)+)/i, e4) || i3.default.getFirstMatch(s3, e4);
            return r4 && (t4.version = r4), t4;
          } }, { test: [/msie|trident/i], describe: function(e4) {
            var t4 = { name: "Internet Explorer" }, r4 = i3.default.getFirstMatch(/(?:msie |rv:)(\d+(\.?_?\d+)+)/i, e4);
            return r4 && (t4.version = r4), t4;
          } }, { test: [/\sedg\//i], describe: function(e4) {
            var t4 = { name: "Microsoft Edge" }, r4 = i3.default.getFirstMatch(/\sedg\/(\d+(\.?_?\d+)+)/i, e4);
            return r4 && (t4.version = r4), t4;
          } }, { test: [/edg([ea]|ios)/i], describe: function(e4) {
            var t4 = { name: "Microsoft Edge" }, r4 = i3.default.getSecondMatch(/edg([ea]|ios)\/(\d+(\.?_?\d+)+)/i, e4);
            return r4 && (t4.version = r4), t4;
          } }, { test: [/vivaldi/i], describe: function(e4) {
            var t4 = { name: "Vivaldi" }, r4 = i3.default.getFirstMatch(/vivaldi\/(\d+(\.?_?\d+)+)/i, e4);
            return r4 && (t4.version = r4), t4;
          } }, { test: [/seamonkey/i], describe: function(e4) {
            var t4 = { name: "SeaMonkey" }, r4 = i3.default.getFirstMatch(/seamonkey\/(\d+(\.?_?\d+)+)/i, e4);
            return r4 && (t4.version = r4), t4;
          } }, { test: [/sailfish/i], describe: function(e4) {
            var t4 = { name: "Sailfish" }, r4 = i3.default.getFirstMatch(/sailfish\s?browser\/(\d+(\.\d+)?)/i, e4);
            return r4 && (t4.version = r4), t4;
          } }, { test: [/silk/i], describe: function(e4) {
            var t4 = { name: "Amazon Silk" }, r4 = i3.default.getFirstMatch(/silk\/(\d+(\.?_?\d+)+)/i, e4);
            return r4 && (t4.version = r4), t4;
          } }, { test: [/phantom/i], describe: function(e4) {
            var t4 = { name: "PhantomJS" }, r4 = i3.default.getFirstMatch(/phantomjs\/(\d+(\.?_?\d+)+)/i, e4);
            return r4 && (t4.version = r4), t4;
          } }, { test: [/slimerjs/i], describe: function(e4) {
            var t4 = { name: "SlimerJS" }, r4 = i3.default.getFirstMatch(/slimerjs\/(\d+(\.?_?\d+)+)/i, e4);
            return r4 && (t4.version = r4), t4;
          } }, { test: [/blackberry|\bbb\d+/i, /rim\stablet/i], describe: function(e4) {
            var t4 = { name: "BlackBerry" }, r4 = i3.default.getFirstMatch(s3, e4) || i3.default.getFirstMatch(/blackberry[\d]+\/(\d+(\.?_?\d+)+)/i, e4);
            return r4 && (t4.version = r4), t4;
          } }, { test: [/(web|hpw)[o0]s/i], describe: function(e4) {
            var t4 = { name: "WebOS Browser" }, r4 = i3.default.getFirstMatch(s3, e4) || i3.default.getFirstMatch(/w(?:eb)?[o0]sbrowser\/(\d+(\.?_?\d+)+)/i, e4);
            return r4 && (t4.version = r4), t4;
          } }, { test: [/bada/i], describe: function(e4) {
            var t4 = { name: "Bada" }, r4 = i3.default.getFirstMatch(/dolfin\/(\d+(\.?_?\d+)+)/i, e4);
            return r4 && (t4.version = r4), t4;
          } }, { test: [/tizen/i], describe: function(e4) {
            var t4 = { name: "Tizen" }, r4 = i3.default.getFirstMatch(/(?:tizen\s?)?browser\/(\d+(\.?_?\d+)+)/i, e4) || i3.default.getFirstMatch(s3, e4);
            return r4 && (t4.version = r4), t4;
          } }, { test: [/qupzilla/i], describe: function(e4) {
            var t4 = { name: "QupZilla" }, r4 = i3.default.getFirstMatch(/(?:qupzilla)[\s/](\d+(\.?_?\d+)+)/i, e4) || i3.default.getFirstMatch(s3, e4);
            return r4 && (t4.version = r4), t4;
          } }, { test: [/firefox|iceweasel|fxios/i], describe: function(e4) {
            var t4 = { name: "Firefox" }, r4 = i3.default.getFirstMatch(/(?:firefox|iceweasel|fxios)[\s/](\d+(\.?_?\d+)+)/i, e4);
            return r4 && (t4.version = r4), t4;
          } }, { test: [/electron/i], describe: function(e4) {
            var t4 = { name: "Electron" }, r4 = i3.default.getFirstMatch(/(?:electron)\/(\d+(\.?_?\d+)+)/i, e4);
            return r4 && (t4.version = r4), t4;
          } }, { test: [/MiuiBrowser/i], describe: function(e4) {
            var t4 = { name: "Miui" }, r4 = i3.default.getFirstMatch(/(?:MiuiBrowser)[\s/](\d+(\.?_?\d+)+)/i, e4);
            return r4 && (t4.version = r4), t4;
          } }, { test: [/chromium/i], describe: function(e4) {
            var t4 = { name: "Chromium" }, r4 = i3.default.getFirstMatch(/(?:chromium)[\s/](\d+(\.?_?\d+)+)/i, e4) || i3.default.getFirstMatch(s3, e4);
            return r4 && (t4.version = r4), t4;
          } }, { test: [/chrome|crios|crmo/i], describe: function(e4) {
            var t4 = { name: "Chrome" }, r4 = i3.default.getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.?_?\d+)+)/i, e4);
            return r4 && (t4.version = r4), t4;
          } }, { test: [/GSA/i], describe: function(e4) {
            var t4 = { name: "Google Search" }, r4 = i3.default.getFirstMatch(/(?:GSA)\/(\d+(\.?_?\d+)+)/i, e4);
            return r4 && (t4.version = r4), t4;
          } }, { test: function(e4) {
            var t4 = !e4.test(/like android/i), r4 = e4.test(/android/i);
            return t4 && r4;
          }, describe: function(e4) {
            var t4 = { name: "Android Browser" }, r4 = i3.default.getFirstMatch(s3, e4);
            return r4 && (t4.version = r4), t4;
          } }, { test: [/playstation 4/i], describe: function(e4) {
            var t4 = { name: "PlayStation 4" }, r4 = i3.default.getFirstMatch(s3, e4);
            return r4 && (t4.version = r4), t4;
          } }, { test: [/safari|applewebkit/i], describe: function(e4) {
            var t4 = { name: "Safari" }, r4 = i3.default.getFirstMatch(s3, e4);
            return r4 && (t4.version = r4), t4;
          } }, { test: [/.*/i], describe: function(e4) {
            var t4 = -1 !== e4.search("\\(") ? /^(.*)\/(.*)[ \t]\((.*)/ : /^(.*)\/(.*) /;
            return { name: i3.default.getFirstMatch(t4, e4), version: i3.default.getSecondMatch(t4, e4) };
          } }];
          t3.default = a3, e3.exports = t3.default;
        }, 93: function(e3, t3, r3) {
          "use strict";
          t3.__esModule = true, t3.default = void 0;
          var n3, i3 = (n3 = r3(17)) && n3.__esModule ? n3 : { default: n3 }, s3 = r3(18);
          var a3 = [{ test: [/Roku\/DVP/], describe: function(e4) {
            var t4 = i3.default.getFirstMatch(/Roku\/DVP-(\d+\.\d+)/i, e4);
            return { name: s3.OS_MAP.Roku, version: t4 };
          } }, { test: [/windows phone/i], describe: function(e4) {
            var t4 = i3.default.getFirstMatch(/windows phone (?:os)?\s?(\d+(\.\d+)*)/i, e4);
            return { name: s3.OS_MAP.WindowsPhone, version: t4 };
          } }, { test: [/windows /i], describe: function(e4) {
            var t4 = i3.default.getFirstMatch(/Windows ((NT|XP)( \d\d?.\d)?)/i, e4), r4 = i3.default.getWindowsVersionName(t4);
            return { name: s3.OS_MAP.Windows, version: t4, versionName: r4 };
          } }, { test: [/Macintosh(.*?) FxiOS(.*?)\//], describe: function(e4) {
            var t4 = { name: s3.OS_MAP.iOS }, r4 = i3.default.getSecondMatch(/(Version\/)(\d[\d.]+)/, e4);
            return r4 && (t4.version = r4), t4;
          } }, { test: [/macintosh/i], describe: function(e4) {
            var t4 = i3.default.getFirstMatch(/mac os x (\d+(\.?_?\d+)+)/i, e4).replace(/[_\s]/g, "."), r4 = i3.default.getMacOSVersionName(t4), n4 = { name: s3.OS_MAP.MacOS, version: t4 };
            return r4 && (n4.versionName = r4), n4;
          } }, { test: [/(ipod|iphone|ipad)/i], describe: function(e4) {
            var t4 = i3.default.getFirstMatch(/os (\d+([_\s]\d+)*) like mac os x/i, e4).replace(/[_\s]/g, ".");
            return { name: s3.OS_MAP.iOS, version: t4 };
          } }, { test: function(e4) {
            var t4 = !e4.test(/like android/i), r4 = e4.test(/android/i);
            return t4 && r4;
          }, describe: function(e4) {
            var t4 = i3.default.getFirstMatch(/android[\s/-](\d+(\.\d+)*)/i, e4), r4 = i3.default.getAndroidVersionName(t4), n4 = { name: s3.OS_MAP.Android, version: t4 };
            return r4 && (n4.versionName = r4), n4;
          } }, { test: [/(web|hpw)[o0]s/i], describe: function(e4) {
            var t4 = i3.default.getFirstMatch(/(?:web|hpw)[o0]s\/(\d+(\.\d+)*)/i, e4), r4 = { name: s3.OS_MAP.WebOS };
            return t4 && t4.length && (r4.version = t4), r4;
          } }, { test: [/blackberry|\bbb\d+/i, /rim\stablet/i], describe: function(e4) {
            var t4 = i3.default.getFirstMatch(/rim\stablet\sos\s(\d+(\.\d+)*)/i, e4) || i3.default.getFirstMatch(/blackberry\d+\/(\d+([_\s]\d+)*)/i, e4) || i3.default.getFirstMatch(/\bbb(\d+)/i, e4);
            return { name: s3.OS_MAP.BlackBerry, version: t4 };
          } }, { test: [/bada/i], describe: function(e4) {
            var t4 = i3.default.getFirstMatch(/bada\/(\d+(\.\d+)*)/i, e4);
            return { name: s3.OS_MAP.Bada, version: t4 };
          } }, { test: [/tizen/i], describe: function(e4) {
            var t4 = i3.default.getFirstMatch(/tizen[/\s](\d+(\.\d+)*)/i, e4);
            return { name: s3.OS_MAP.Tizen, version: t4 };
          } }, { test: [/linux/i], describe: function() {
            return { name: s3.OS_MAP.Linux };
          } }, { test: [/CrOS/], describe: function() {
            return { name: s3.OS_MAP.ChromeOS };
          } }, { test: [/PlayStation 4/], describe: function(e4) {
            var t4 = i3.default.getFirstMatch(/PlayStation 4[/\s](\d+(\.\d+)*)/i, e4);
            return { name: s3.OS_MAP.PlayStation4, version: t4 };
          } }];
          t3.default = a3, e3.exports = t3.default;
        }, 94: function(e3, t3, r3) {
          "use strict";
          t3.__esModule = true, t3.default = void 0;
          var n3, i3 = (n3 = r3(17)) && n3.__esModule ? n3 : { default: n3 }, s3 = r3(18);
          var a3 = [{ test: [/googlebot/i], describe: function() {
            return { type: "bot", vendor: "Google" };
          } }, { test: [/huawei/i], describe: function(e4) {
            var t4 = i3.default.getFirstMatch(/(can-l01)/i, e4) && "Nova", r4 = { type: s3.PLATFORMS_MAP.mobile, vendor: "Huawei" };
            return t4 && (r4.model = t4), r4;
          } }, { test: [/nexus\s*(?:7|8|9|10).*/i], describe: function() {
            return { type: s3.PLATFORMS_MAP.tablet, vendor: "Nexus" };
          } }, { test: [/ipad/i], describe: function() {
            return { type: s3.PLATFORMS_MAP.tablet, vendor: "Apple", model: "iPad" };
          } }, { test: [/Macintosh(.*?) FxiOS(.*?)\//], describe: function() {
            return { type: s3.PLATFORMS_MAP.tablet, vendor: "Apple", model: "iPad" };
          } }, { test: [/kftt build/i], describe: function() {
            return { type: s3.PLATFORMS_MAP.tablet, vendor: "Amazon", model: "Kindle Fire HD 7" };
          } }, { test: [/silk/i], describe: function() {
            return { type: s3.PLATFORMS_MAP.tablet, vendor: "Amazon" };
          } }, { test: [/tablet(?! pc)/i], describe: function() {
            return { type: s3.PLATFORMS_MAP.tablet };
          } }, { test: function(e4) {
            var t4 = e4.test(/ipod|iphone/i), r4 = e4.test(/like (ipod|iphone)/i);
            return t4 && !r4;
          }, describe: function(e4) {
            var t4 = i3.default.getFirstMatch(/(ipod|iphone)/i, e4);
            return { type: s3.PLATFORMS_MAP.mobile, vendor: "Apple", model: t4 };
          } }, { test: [/nexus\s*[0-6].*/i, /galaxy nexus/i], describe: function() {
            return { type: s3.PLATFORMS_MAP.mobile, vendor: "Nexus" };
          } }, { test: [/[^-]mobi/i], describe: function() {
            return { type: s3.PLATFORMS_MAP.mobile };
          } }, { test: function(e4) {
            return "blackberry" === e4.getBrowserName(true);
          }, describe: function() {
            return { type: s3.PLATFORMS_MAP.mobile, vendor: "BlackBerry" };
          } }, { test: function(e4) {
            return "bada" === e4.getBrowserName(true);
          }, describe: function() {
            return { type: s3.PLATFORMS_MAP.mobile };
          } }, { test: function(e4) {
            return "windows phone" === e4.getBrowserName();
          }, describe: function() {
            return { type: s3.PLATFORMS_MAP.mobile, vendor: "Microsoft" };
          } }, { test: function(e4) {
            var t4 = Number(String(e4.getOSVersion()).split(".")[0]);
            return "android" === e4.getOSName(true) && t4 >= 3;
          }, describe: function() {
            return { type: s3.PLATFORMS_MAP.tablet };
          } }, { test: function(e4) {
            return "android" === e4.getOSName(true);
          }, describe: function() {
            return { type: s3.PLATFORMS_MAP.mobile };
          } }, { test: function(e4) {
            return "macos" === e4.getOSName(true);
          }, describe: function() {
            return { type: s3.PLATFORMS_MAP.desktop, vendor: "Apple" };
          } }, { test: function(e4) {
            return "windows" === e4.getOSName(true);
          }, describe: function() {
            return { type: s3.PLATFORMS_MAP.desktop };
          } }, { test: function(e4) {
            return "linux" === e4.getOSName(true);
          }, describe: function() {
            return { type: s3.PLATFORMS_MAP.desktop };
          } }, { test: function(e4) {
            return "playstation 4" === e4.getOSName(true);
          }, describe: function() {
            return { type: s3.PLATFORMS_MAP.tv };
          } }, { test: function(e4) {
            return "roku" === e4.getOSName(true);
          }, describe: function() {
            return { type: s3.PLATFORMS_MAP.tv };
          } }];
          t3.default = a3, e3.exports = t3.default;
        }, 95: function(e3, t3, r3) {
          "use strict";
          t3.__esModule = true, t3.default = void 0;
          var n3, i3 = (n3 = r3(17)) && n3.__esModule ? n3 : { default: n3 }, s3 = r3(18);
          var a3 = [{ test: function(e4) {
            return "microsoft edge" === e4.getBrowserName(true);
          }, describe: function(e4) {
            if (/\sedg\//i.test(e4))
              return { name: s3.ENGINE_MAP.Blink };
            var t4 = i3.default.getFirstMatch(/edge\/(\d+(\.?_?\d+)+)/i, e4);
            return { name: s3.ENGINE_MAP.EdgeHTML, version: t4 };
          } }, { test: [/trident/i], describe: function(e4) {
            var t4 = { name: s3.ENGINE_MAP.Trident }, r4 = i3.default.getFirstMatch(/trident\/(\d+(\.?_?\d+)+)/i, e4);
            return r4 && (t4.version = r4), t4;
          } }, { test: function(e4) {
            return e4.test(/presto/i);
          }, describe: function(e4) {
            var t4 = { name: s3.ENGINE_MAP.Presto }, r4 = i3.default.getFirstMatch(/presto\/(\d+(\.?_?\d+)+)/i, e4);
            return r4 && (t4.version = r4), t4;
          } }, { test: function(e4) {
            var t4 = e4.test(/gecko/i), r4 = e4.test(/like gecko/i);
            return t4 && !r4;
          }, describe: function(e4) {
            var t4 = { name: s3.ENGINE_MAP.Gecko }, r4 = i3.default.getFirstMatch(/gecko\/(\d+(\.?_?\d+)+)/i, e4);
            return r4 && (t4.version = r4), t4;
          } }, { test: [/(apple)?webkit\/537\.36/i], describe: function() {
            return { name: s3.ENGINE_MAP.Blink };
          } }, { test: [/(apple)?webkit/i], describe: function(e4) {
            var t4 = { name: s3.ENGINE_MAP.WebKit }, r4 = i3.default.getFirstMatch(/webkit\/(\d+(\.?_?\d+)+)/i, e4);
            return r4 && (t4.version = r4), t4;
          } }];
          t3.default = a3, e3.exports = t3.default;
        } });
      });
    }
  });

  // node_modules/@hotwired/turbo/dist/turbo.es2017-esm.js
  var turbo_es2017_esm_exports = {};
  __export(turbo_es2017_esm_exports, {
    FetchEnctype: () => FetchEnctype,
    FetchMethod: () => FetchMethod,
    FetchRequest: () => FetchRequest,
    FetchResponse: () => FetchResponse,
    FrameElement: () => FrameElement,
    FrameLoadingStyle: () => FrameLoadingStyle,
    FrameRenderer: () => FrameRenderer,
    PageRenderer: () => PageRenderer,
    PageSnapshot: () => PageSnapshot,
    StreamActions: () => StreamActions,
    StreamElement: () => StreamElement,
    StreamSourceElement: () => StreamSourceElement,
    cache: () => cache,
    clearCache: () => clearCache,
    connectStreamSource: () => connectStreamSource,
    disconnectStreamSource: () => disconnectStreamSource,
    fetch: () => fetchWithTurboHeaders,
    fetchEnctypeFromString: () => fetchEnctypeFromString,
    fetchMethodFromString: () => fetchMethodFromString,
    isSafe: () => isSafe,
    navigator: () => navigator$1,
    registerAdapter: () => registerAdapter,
    renderStreamMessage: () => renderStreamMessage,
    session: () => session,
    setConfirmMethod: () => setConfirmMethod,
    setFormMode: () => setFormMode,
    setProgressBarDelay: () => setProgressBarDelay,
    start: () => start,
    visit: () => visit
  });
  (function(prototype) {
    if (typeof prototype.requestSubmit == "function")
      return;
    prototype.requestSubmit = function(submitter) {
      if (submitter) {
        validateSubmitter(submitter, this);
        submitter.click();
      } else {
        submitter = document.createElement("input");
        submitter.type = "submit";
        submitter.hidden = true;
        this.appendChild(submitter);
        submitter.click();
        this.removeChild(submitter);
      }
    };
    function validateSubmitter(submitter, form) {
      submitter instanceof HTMLElement || raise(TypeError, "parameter 1 is not of type 'HTMLElement'");
      submitter.type == "submit" || raise(TypeError, "The specified element is not a submit button");
      submitter.form == form || raise(DOMException, "The specified element is not owned by this form element", "NotFoundError");
    }
    __name(validateSubmitter, "validateSubmitter");
    function raise(errorConstructor, message, name) {
      throw new errorConstructor("Failed to execute 'requestSubmit' on 'HTMLFormElement': " + message + ".", name);
    }
    __name(raise, "raise");
  })(HTMLFormElement.prototype);
  var submittersByForm = /* @__PURE__ */ new WeakMap();
  function findSubmitterFromClickTarget(target) {
    const element = target instanceof Element ? target : target instanceof Node ? target.parentElement : null;
    const candidate = element ? element.closest("input, button") : null;
    return candidate?.type == "submit" ? candidate : null;
  }
  __name(findSubmitterFromClickTarget, "findSubmitterFromClickTarget");
  function clickCaptured(event) {
    const submitter = findSubmitterFromClickTarget(event.target);
    if (submitter && submitter.form) {
      submittersByForm.set(submitter.form, submitter);
    }
  }
  __name(clickCaptured, "clickCaptured");
  (function() {
    if ("submitter" in Event.prototype)
      return;
    let prototype = window.Event.prototype;
    if ("SubmitEvent" in window) {
      const prototypeOfSubmitEvent = window.SubmitEvent.prototype;
      if (/Apple Computer/.test(navigator.vendor) && !("submitter" in prototypeOfSubmitEvent)) {
        prototype = prototypeOfSubmitEvent;
      } else {
        return;
      }
    }
    addEventListener("click", clickCaptured, true);
    Object.defineProperty(prototype, "submitter", {
      get() {
        if (this.type == "submit" && this.target instanceof HTMLFormElement) {
          return submittersByForm.get(this.target);
        }
      }
    });
  })();
  var FrameLoadingStyle = {
    eager: "eager",
    lazy: "lazy"
  };
  var FrameElement = class _FrameElement extends HTMLElement {
    static {
      __name(this, "FrameElement");
    }
    static delegateConstructor = void 0;
    loaded = Promise.resolve();
    static get observedAttributes() {
      return ["disabled", "loading", "src"];
    }
    constructor() {
      super();
      this.delegate = new _FrameElement.delegateConstructor(this);
    }
    connectedCallback() {
      this.delegate.connect();
    }
    disconnectedCallback() {
      this.delegate.disconnect();
    }
    reload() {
      return this.delegate.sourceURLReloaded();
    }
    attributeChangedCallback(name) {
      if (name == "loading") {
        this.delegate.loadingStyleChanged();
      } else if (name == "src") {
        this.delegate.sourceURLChanged();
      } else if (name == "disabled") {
        this.delegate.disabledChanged();
      }
    }
    /**
     * Gets the URL to lazily load source HTML from
     */
    get src() {
      return this.getAttribute("src");
    }
    /**
     * Sets the URL to lazily load source HTML from
     */
    set src(value) {
      if (value) {
        this.setAttribute("src", value);
      } else {
        this.removeAttribute("src");
      }
    }
    /**
     * Gets the refresh mode for the frame.
     */
    get refresh() {
      return this.getAttribute("refresh");
    }
    /**
     * Sets the refresh mode for the frame.
     */
    set refresh(value) {
      if (value) {
        this.setAttribute("refresh", value);
      } else {
        this.removeAttribute("refresh");
      }
    }
    /**
     * Determines if the element is loading
     */
    get loading() {
      return frameLoadingStyleFromString(this.getAttribute("loading") || "");
    }
    /**
     * Sets the value of if the element is loading
     */
    set loading(value) {
      if (value) {
        this.setAttribute("loading", value);
      } else {
        this.removeAttribute("loading");
      }
    }
    /**
     * Gets the disabled state of the frame.
     *
     * If disabled, no requests will be intercepted by the frame.
     */
    get disabled() {
      return this.hasAttribute("disabled");
    }
    /**
     * Sets the disabled state of the frame.
     *
     * If disabled, no requests will be intercepted by the frame.
     */
    set disabled(value) {
      if (value) {
        this.setAttribute("disabled", "");
      } else {
        this.removeAttribute("disabled");
      }
    }
    /**
     * Gets the autoscroll state of the frame.
     *
     * If true, the frame will be scrolled into view automatically on update.
     */
    get autoscroll() {
      return this.hasAttribute("autoscroll");
    }
    /**
     * Sets the autoscroll state of the frame.
     *
     * If true, the frame will be scrolled into view automatically on update.
     */
    set autoscroll(value) {
      if (value) {
        this.setAttribute("autoscroll", "");
      } else {
        this.removeAttribute("autoscroll");
      }
    }
    /**
     * Determines if the element has finished loading
     */
    get complete() {
      return !this.delegate.isLoading;
    }
    /**
     * Gets the active state of the frame.
     *
     * If inactive, source changes will not be observed.
     */
    get isActive() {
      return this.ownerDocument === document && !this.isPreview;
    }
    /**
     * Sets the active state of the frame.
     *
     * If inactive, source changes will not be observed.
     */
    get isPreview() {
      return this.ownerDocument?.documentElement?.hasAttribute("data-turbo-preview");
    }
  };
  function frameLoadingStyleFromString(style) {
    switch (style.toLowerCase()) {
      case "lazy":
        return FrameLoadingStyle.lazy;
      default:
        return FrameLoadingStyle.eager;
    }
  }
  __name(frameLoadingStyleFromString, "frameLoadingStyleFromString");
  function expandURL(locatable) {
    return new URL(locatable.toString(), document.baseURI);
  }
  __name(expandURL, "expandURL");
  function getAnchor(url) {
    let anchorMatch;
    if (url.hash) {
      return url.hash.slice(1);
    } else if (anchorMatch = url.href.match(/#(.*)$/)) {
      return anchorMatch[1];
    }
  }
  __name(getAnchor, "getAnchor");
  function getAction$1(form, submitter) {
    const action = submitter?.getAttribute("formaction") || form.getAttribute("action") || form.action;
    return expandURL(action);
  }
  __name(getAction$1, "getAction$1");
  function getExtension(url) {
    return (getLastPathComponent(url).match(/\.[^.]*$/) || [])[0] || "";
  }
  __name(getExtension, "getExtension");
  function isHTML(url) {
    return !!getExtension(url).match(/^(?:|\.(?:htm|html|xhtml|php))$/);
  }
  __name(isHTML, "isHTML");
  function isPrefixedBy(baseURL, url) {
    const prefix = getPrefix(url);
    return baseURL.href === expandURL(prefix).href || baseURL.href.startsWith(prefix);
  }
  __name(isPrefixedBy, "isPrefixedBy");
  function locationIsVisitable(location2, rootLocation) {
    return isPrefixedBy(location2, rootLocation) && isHTML(location2);
  }
  __name(locationIsVisitable, "locationIsVisitable");
  function getRequestURL(url) {
    const anchor = getAnchor(url);
    return anchor != null ? url.href.slice(0, -(anchor.length + 1)) : url.href;
  }
  __name(getRequestURL, "getRequestURL");
  function toCacheKey(url) {
    return getRequestURL(url);
  }
  __name(toCacheKey, "toCacheKey");
  function urlsAreEqual(left, right) {
    return expandURL(left).href == expandURL(right).href;
  }
  __name(urlsAreEqual, "urlsAreEqual");
  function getPathComponents(url) {
    return url.pathname.split("/").slice(1);
  }
  __name(getPathComponents, "getPathComponents");
  function getLastPathComponent(url) {
    return getPathComponents(url).slice(-1)[0];
  }
  __name(getLastPathComponent, "getLastPathComponent");
  function getPrefix(url) {
    return addTrailingSlash(url.origin + url.pathname);
  }
  __name(getPrefix, "getPrefix");
  function addTrailingSlash(value) {
    return value.endsWith("/") ? value : value + "/";
  }
  __name(addTrailingSlash, "addTrailingSlash");
  var FetchResponse = class {
    static {
      __name(this, "FetchResponse");
    }
    constructor(response) {
      this.response = response;
    }
    get succeeded() {
      return this.response.ok;
    }
    get failed() {
      return !this.succeeded;
    }
    get clientError() {
      return this.statusCode >= 400 && this.statusCode <= 499;
    }
    get serverError() {
      return this.statusCode >= 500 && this.statusCode <= 599;
    }
    get redirected() {
      return this.response.redirected;
    }
    get location() {
      return expandURL(this.response.url);
    }
    get isHTML() {
      return this.contentType && this.contentType.match(/^(?:text\/([^\s;,]+\b)?html|application\/xhtml\+xml)\b/);
    }
    get statusCode() {
      return this.response.status;
    }
    get contentType() {
      return this.header("Content-Type");
    }
    get responseText() {
      return this.response.clone().text();
    }
    get responseHTML() {
      if (this.isHTML) {
        return this.response.clone().text();
      } else {
        return Promise.resolve(void 0);
      }
    }
    header(name) {
      return this.response.headers.get(name);
    }
  };
  function activateScriptElement(element) {
    if (element.getAttribute("data-turbo-eval") == "false") {
      return element;
    } else {
      const createdScriptElement = document.createElement("script");
      const cspNonce = getMetaContent("csp-nonce");
      if (cspNonce) {
        createdScriptElement.nonce = cspNonce;
      }
      createdScriptElement.textContent = element.textContent;
      createdScriptElement.async = false;
      copyElementAttributes(createdScriptElement, element);
      return createdScriptElement;
    }
  }
  __name(activateScriptElement, "activateScriptElement");
  function copyElementAttributes(destinationElement, sourceElement) {
    for (const { name, value } of sourceElement.attributes) {
      destinationElement.setAttribute(name, value);
    }
  }
  __name(copyElementAttributes, "copyElementAttributes");
  function createDocumentFragment(html) {
    const template = document.createElement("template");
    template.innerHTML = html;
    return template.content;
  }
  __name(createDocumentFragment, "createDocumentFragment");
  function dispatch(eventName, { target, cancelable, detail } = {}) {
    const event = new CustomEvent(eventName, {
      cancelable,
      bubbles: true,
      composed: true,
      detail
    });
    if (target && target.isConnected) {
      target.dispatchEvent(event);
    } else {
      document.documentElement.dispatchEvent(event);
    }
    return event;
  }
  __name(dispatch, "dispatch");
  function nextRepaint() {
    if (document.visibilityState === "hidden") {
      return nextEventLoopTick();
    } else {
      return nextAnimationFrame();
    }
  }
  __name(nextRepaint, "nextRepaint");
  function nextAnimationFrame() {
    return new Promise((resolve) => requestAnimationFrame(() => resolve()));
  }
  __name(nextAnimationFrame, "nextAnimationFrame");
  function nextEventLoopTick() {
    return new Promise((resolve) => setTimeout(() => resolve(), 0));
  }
  __name(nextEventLoopTick, "nextEventLoopTick");
  function nextMicrotask() {
    return Promise.resolve();
  }
  __name(nextMicrotask, "nextMicrotask");
  function parseHTMLDocument(html = "") {
    return new DOMParser().parseFromString(html, "text/html");
  }
  __name(parseHTMLDocument, "parseHTMLDocument");
  function unindent(strings, ...values) {
    const lines = interpolate(strings, values).replace(/^\n/, "").split("\n");
    const match2 = lines[0].match(/^\s+/);
    const indent = match2 ? match2[0].length : 0;
    return lines.map((line) => line.slice(indent)).join("\n");
  }
  __name(unindent, "unindent");
  function interpolate(strings, values) {
    return strings.reduce((result, string, i3) => {
      const value = values[i3] == void 0 ? "" : values[i3];
      return result + string + value;
    }, "");
  }
  __name(interpolate, "interpolate");
  function uuid() {
    return Array.from({ length: 36 }).map((_2, i3) => {
      if (i3 == 8 || i3 == 13 || i3 == 18 || i3 == 23) {
        return "-";
      } else if (i3 == 14) {
        return "4";
      } else if (i3 == 19) {
        return (Math.floor(Math.random() * 4) + 8).toString(16);
      } else {
        return Math.floor(Math.random() * 15).toString(16);
      }
    }).join("");
  }
  __name(uuid, "uuid");
  function getAttribute(attributeName, ...elements) {
    for (const value of elements.map((element) => element?.getAttribute(attributeName))) {
      if (typeof value == "string")
        return value;
    }
    return null;
  }
  __name(getAttribute, "getAttribute");
  function hasAttribute(attributeName, ...elements) {
    return elements.some((element) => element && element.hasAttribute(attributeName));
  }
  __name(hasAttribute, "hasAttribute");
  function markAsBusy(...elements) {
    for (const element of elements) {
      if (element.localName == "turbo-frame") {
        element.setAttribute("busy", "");
      }
      element.setAttribute("aria-busy", "true");
    }
  }
  __name(markAsBusy, "markAsBusy");
  function clearBusyState(...elements) {
    for (const element of elements) {
      if (element.localName == "turbo-frame") {
        element.removeAttribute("busy");
      }
      element.removeAttribute("aria-busy");
    }
  }
  __name(clearBusyState, "clearBusyState");
  function waitForLoad(element, timeoutInMilliseconds = 2e3) {
    return new Promise((resolve) => {
      const onComplete = /* @__PURE__ */ __name(() => {
        element.removeEventListener("error", onComplete);
        element.removeEventListener("load", onComplete);
        resolve();
      }, "onComplete");
      element.addEventListener("load", onComplete, { once: true });
      element.addEventListener("error", onComplete, { once: true });
      setTimeout(resolve, timeoutInMilliseconds);
    });
  }
  __name(waitForLoad, "waitForLoad");
  function getHistoryMethodForAction(action) {
    switch (action) {
      case "replace":
        return history.replaceState;
      case "advance":
      case "restore":
        return history.pushState;
    }
  }
  __name(getHistoryMethodForAction, "getHistoryMethodForAction");
  function isAction(action) {
    return action == "advance" || action == "replace" || action == "restore";
  }
  __name(isAction, "isAction");
  function getVisitAction(...elements) {
    const action = getAttribute("data-turbo-action", ...elements);
    return isAction(action) ? action : null;
  }
  __name(getVisitAction, "getVisitAction");
  function getMetaElement(name) {
    return document.querySelector(`meta[name="${name}"]`);
  }
  __name(getMetaElement, "getMetaElement");
  function getMetaContent(name) {
    const element = getMetaElement(name);
    return element && element.content;
  }
  __name(getMetaContent, "getMetaContent");
  function setMetaContent(name, content) {
    let element = getMetaElement(name);
    if (!element) {
      element = document.createElement("meta");
      element.setAttribute("name", name);
      document.head.appendChild(element);
    }
    element.setAttribute("content", content);
    return element;
  }
  __name(setMetaContent, "setMetaContent");
  function findClosestRecursively(element, selector) {
    if (element instanceof Element) {
      return element.closest(selector) || findClosestRecursively(element.assignedSlot || element.getRootNode()?.host, selector);
    }
  }
  __name(findClosestRecursively, "findClosestRecursively");
  function elementIsFocusable(element) {
    const inertDisabledOrHidden = "[inert], :disabled, [hidden], details:not([open]), dialog:not([open])";
    return !!element && element.closest(inertDisabledOrHidden) == null && typeof element.focus == "function";
  }
  __name(elementIsFocusable, "elementIsFocusable");
  function queryAutofocusableElement(elementOrDocumentFragment) {
    return Array.from(elementOrDocumentFragment.querySelectorAll("[autofocus]")).find(elementIsFocusable);
  }
  __name(queryAutofocusableElement, "queryAutofocusableElement");
  async function around(callback, reader) {
    const before = reader();
    callback();
    await nextAnimationFrame();
    const after = reader();
    return [before, after];
  }
  __name(around, "around");
  function doesNotTargetIFrame(anchor) {
    if (anchor.hasAttribute("target")) {
      for (const element of document.getElementsByName(anchor.target)) {
        if (element instanceof HTMLIFrameElement)
          return false;
      }
    }
    return true;
  }
  __name(doesNotTargetIFrame, "doesNotTargetIFrame");
  function findLinkFromClickTarget(target) {
    return findClosestRecursively(target, "a[href]:not([target^=_]):not([download])");
  }
  __name(findLinkFromClickTarget, "findLinkFromClickTarget");
  function getLocationForLink(link) {
    return expandURL(link.getAttribute("href") || "");
  }
  __name(getLocationForLink, "getLocationForLink");
  function debounce(fn, delay) {
    let timeoutId = null;
    return (...args) => {
      const callback = /* @__PURE__ */ __name(() => fn.apply(this, args), "callback");
      clearTimeout(timeoutId);
      timeoutId = setTimeout(callback, delay);
    };
  }
  __name(debounce, "debounce");
  var LimitedSet = class extends Set {
    static {
      __name(this, "LimitedSet");
    }
    constructor(maxSize) {
      super();
      this.maxSize = maxSize;
    }
    add(value) {
      if (this.size >= this.maxSize) {
        const iterator = this.values();
        const oldestValue = iterator.next().value;
        this.delete(oldestValue);
      }
      super.add(value);
    }
  };
  var recentRequests = new LimitedSet(20);
  var nativeFetch = window.fetch;
  function fetchWithTurboHeaders(url, options = {}) {
    const modifiedHeaders = new Headers(options.headers || {});
    const requestUID = uuid();
    recentRequests.add(requestUID);
    modifiedHeaders.append("X-Turbo-Request-Id", requestUID);
    return nativeFetch(url, {
      ...options,
      headers: modifiedHeaders
    });
  }
  __name(fetchWithTurboHeaders, "fetchWithTurboHeaders");
  function fetchMethodFromString(method) {
    switch (method.toLowerCase()) {
      case "get":
        return FetchMethod.get;
      case "post":
        return FetchMethod.post;
      case "put":
        return FetchMethod.put;
      case "patch":
        return FetchMethod.patch;
      case "delete":
        return FetchMethod.delete;
    }
  }
  __name(fetchMethodFromString, "fetchMethodFromString");
  var FetchMethod = {
    get: "get",
    post: "post",
    put: "put",
    patch: "patch",
    delete: "delete"
  };
  function fetchEnctypeFromString(encoding) {
    switch (encoding.toLowerCase()) {
      case FetchEnctype.multipart:
        return FetchEnctype.multipart;
      case FetchEnctype.plain:
        return FetchEnctype.plain;
      default:
        return FetchEnctype.urlEncoded;
    }
  }
  __name(fetchEnctypeFromString, "fetchEnctypeFromString");
  var FetchEnctype = {
    urlEncoded: "application/x-www-form-urlencoded",
    multipart: "multipart/form-data",
    plain: "text/plain"
  };
  var FetchRequest = class {
    static {
      __name(this, "FetchRequest");
    }
    abortController = new AbortController();
    #resolveRequestPromise = (_value) => {
    };
    constructor(delegate, method, location2, requestBody = new URLSearchParams(), target = null, enctype = FetchEnctype.urlEncoded) {
      const [url, body] = buildResourceAndBody(expandURL(location2), method, requestBody, enctype);
      this.delegate = delegate;
      this.url = url;
      this.target = target;
      this.fetchOptions = {
        credentials: "same-origin",
        redirect: "follow",
        method,
        headers: { ...this.defaultHeaders },
        body,
        signal: this.abortSignal,
        referrer: this.delegate.referrer?.href
      };
      this.enctype = enctype;
    }
    get method() {
      return this.fetchOptions.method;
    }
    set method(value) {
      const fetchBody = this.isSafe ? this.url.searchParams : this.fetchOptions.body || new FormData();
      const fetchMethod = fetchMethodFromString(value) || FetchMethod.get;
      this.url.search = "";
      const [url, body] = buildResourceAndBody(this.url, fetchMethod, fetchBody, this.enctype);
      this.url = url;
      this.fetchOptions.body = body;
      this.fetchOptions.method = fetchMethod;
    }
    get headers() {
      return this.fetchOptions.headers;
    }
    set headers(value) {
      this.fetchOptions.headers = value;
    }
    get body() {
      if (this.isSafe) {
        return this.url.searchParams;
      } else {
        return this.fetchOptions.body;
      }
    }
    set body(value) {
      this.fetchOptions.body = value;
    }
    get location() {
      return this.url;
    }
    get params() {
      return this.url.searchParams;
    }
    get entries() {
      return this.body ? Array.from(this.body.entries()) : [];
    }
    cancel() {
      this.abortController.abort();
    }
    async perform() {
      const { fetchOptions } = this;
      this.delegate.prepareRequest(this);
      const event = await this.#allowRequestToBeIntercepted(fetchOptions);
      try {
        this.delegate.requestStarted(this);
        if (event.detail.fetchRequest) {
          this.response = event.detail.fetchRequest.response;
        } else {
          this.response = fetchWithTurboHeaders(this.url.href, fetchOptions);
        }
        const response = await this.response;
        return await this.receive(response);
      } catch (error) {
        if (error.name !== "AbortError") {
          if (this.#willDelegateErrorHandling(error)) {
            this.delegate.requestErrored(this, error);
          }
          throw error;
        }
      } finally {
        this.delegate.requestFinished(this);
      }
    }
    async receive(response) {
      const fetchResponse = new FetchResponse(response);
      const event = dispatch("turbo:before-fetch-response", {
        cancelable: true,
        detail: { fetchResponse },
        target: this.target
      });
      if (event.defaultPrevented) {
        this.delegate.requestPreventedHandlingResponse(this, fetchResponse);
      } else if (fetchResponse.succeeded) {
        this.delegate.requestSucceededWithResponse(this, fetchResponse);
      } else {
        this.delegate.requestFailedWithResponse(this, fetchResponse);
      }
      return fetchResponse;
    }
    get defaultHeaders() {
      return {
        Accept: "text/html, application/xhtml+xml"
      };
    }
    get isSafe() {
      return isSafe(this.method);
    }
    get abortSignal() {
      return this.abortController.signal;
    }
    acceptResponseType(mimeType) {
      this.headers["Accept"] = [mimeType, this.headers["Accept"]].join(", ");
    }
    async #allowRequestToBeIntercepted(fetchOptions) {
      const requestInterception = new Promise((resolve) => this.#resolveRequestPromise = resolve);
      const event = dispatch("turbo:before-fetch-request", {
        cancelable: true,
        detail: {
          fetchOptions,
          url: this.url,
          resume: this.#resolveRequestPromise
        },
        target: this.target
      });
      this.url = event.detail.url;
      if (event.defaultPrevented)
        await requestInterception;
      return event;
    }
    #willDelegateErrorHandling(error) {
      const event = dispatch("turbo:fetch-request-error", {
        target: this.target,
        cancelable: true,
        detail: { request: this, error }
      });
      return !event.defaultPrevented;
    }
  };
  function isSafe(fetchMethod) {
    return fetchMethodFromString(fetchMethod) == FetchMethod.get;
  }
  __name(isSafe, "isSafe");
  function buildResourceAndBody(resource, method, requestBody, enctype) {
    const searchParams = Array.from(requestBody).length > 0 ? new URLSearchParams(entriesExcludingFiles(requestBody)) : resource.searchParams;
    if (isSafe(method)) {
      return [mergeIntoURLSearchParams(resource, searchParams), null];
    } else if (enctype == FetchEnctype.urlEncoded) {
      return [resource, searchParams];
    } else {
      return [resource, requestBody];
    }
  }
  __name(buildResourceAndBody, "buildResourceAndBody");
  function entriesExcludingFiles(requestBody) {
    const entries = [];
    for (const [name, value] of requestBody) {
      if (value instanceof File)
        continue;
      else
        entries.push([name, value]);
    }
    return entries;
  }
  __name(entriesExcludingFiles, "entriesExcludingFiles");
  function mergeIntoURLSearchParams(url, requestBody) {
    const searchParams = new URLSearchParams(entriesExcludingFiles(requestBody));
    url.search = searchParams.toString();
    return url;
  }
  __name(mergeIntoURLSearchParams, "mergeIntoURLSearchParams");
  var AppearanceObserver = class {
    static {
      __name(this, "AppearanceObserver");
    }
    started = false;
    constructor(delegate, element) {
      this.delegate = delegate;
      this.element = element;
      this.intersectionObserver = new IntersectionObserver(this.intersect);
    }
    start() {
      if (!this.started) {
        this.started = true;
        this.intersectionObserver.observe(this.element);
      }
    }
    stop() {
      if (this.started) {
        this.started = false;
        this.intersectionObserver.unobserve(this.element);
      }
    }
    intersect = (entries) => {
      const lastEntry = entries.slice(-1)[0];
      if (lastEntry?.isIntersecting) {
        this.delegate.elementAppearedInViewport(this.element);
      }
    };
  };
  var StreamMessage = class {
    static {
      __name(this, "StreamMessage");
    }
    static contentType = "text/vnd.turbo-stream.html";
    static wrap(message) {
      if (typeof message == "string") {
        return new this(createDocumentFragment(message));
      } else {
        return message;
      }
    }
    constructor(fragment) {
      this.fragment = importStreamElements(fragment);
    }
  };
  function importStreamElements(fragment) {
    for (const element of fragment.querySelectorAll("turbo-stream")) {
      const streamElement = document.importNode(element, true);
      for (const inertScriptElement of streamElement.templateElement.content.querySelectorAll("script")) {
        inertScriptElement.replaceWith(activateScriptElement(inertScriptElement));
      }
      element.replaceWith(streamElement);
    }
    return fragment;
  }
  __name(importStreamElements, "importStreamElements");
  var PREFETCH_DELAY = 100;
  var PrefetchCache = class {
    static {
      __name(this, "PrefetchCache");
    }
    #prefetchTimeout = null;
    #prefetched = null;
    get(url) {
      if (this.#prefetched && this.#prefetched.url === url && this.#prefetched.expire > Date.now()) {
        return this.#prefetched.request;
      }
    }
    setLater(url, request, ttl) {
      this.clear();
      this.#prefetchTimeout = setTimeout(() => {
        request.perform();
        this.set(url, request, ttl);
        this.#prefetchTimeout = null;
      }, PREFETCH_DELAY);
    }
    set(url, request, ttl) {
      this.#prefetched = { url, request, expire: new Date((/* @__PURE__ */ new Date()).getTime() + ttl) };
    }
    clear() {
      if (this.#prefetchTimeout)
        clearTimeout(this.#prefetchTimeout);
      this.#prefetched = null;
    }
  };
  var cacheTtl = 10 * 1e3;
  var prefetchCache = new PrefetchCache();
  var FormSubmissionState = {
    initialized: "initialized",
    requesting: "requesting",
    waiting: "waiting",
    receiving: "receiving",
    stopping: "stopping",
    stopped: "stopped"
  };
  var FormSubmission = class _FormSubmission {
    static {
      __name(this, "FormSubmission");
    }
    state = FormSubmissionState.initialized;
    static confirmMethod(message, _element, _submitter) {
      return Promise.resolve(confirm(message));
    }
    constructor(delegate, formElement, submitter, mustRedirect = false) {
      const method = getMethod(formElement, submitter);
      const action = getAction(getFormAction(formElement, submitter), method);
      const body = buildFormData(formElement, submitter);
      const enctype = getEnctype(formElement, submitter);
      this.delegate = delegate;
      this.formElement = formElement;
      this.submitter = submitter;
      this.fetchRequest = new FetchRequest(this, method, action, body, formElement, enctype);
      this.mustRedirect = mustRedirect;
    }
    get method() {
      return this.fetchRequest.method;
    }
    set method(value) {
      this.fetchRequest.method = value;
    }
    get action() {
      return this.fetchRequest.url.toString();
    }
    set action(value) {
      this.fetchRequest.url = expandURL(value);
    }
    get body() {
      return this.fetchRequest.body;
    }
    get enctype() {
      return this.fetchRequest.enctype;
    }
    get isSafe() {
      return this.fetchRequest.isSafe;
    }
    get location() {
      return this.fetchRequest.url;
    }
    // The submission process
    async start() {
      const { initialized, requesting } = FormSubmissionState;
      const confirmationMessage = getAttribute("data-turbo-confirm", this.submitter, this.formElement);
      if (typeof confirmationMessage === "string") {
        const answer = await _FormSubmission.confirmMethod(confirmationMessage, this.formElement, this.submitter);
        if (!answer) {
          return;
        }
      }
      if (this.state == initialized) {
        this.state = requesting;
        return this.fetchRequest.perform();
      }
    }
    stop() {
      const { stopping, stopped } = FormSubmissionState;
      if (this.state != stopping && this.state != stopped) {
        this.state = stopping;
        this.fetchRequest.cancel();
        return true;
      }
    }
    // Fetch request delegate
    prepareRequest(request) {
      if (!request.isSafe) {
        const token = getCookieValue(getMetaContent("csrf-param")) || getMetaContent("csrf-token");
        if (token) {
          request.headers["X-CSRF-Token"] = token;
        }
      }
      if (this.requestAcceptsTurboStreamResponse(request)) {
        request.acceptResponseType(StreamMessage.contentType);
      }
    }
    requestStarted(_request) {
      this.state = FormSubmissionState.waiting;
      this.submitter?.setAttribute("disabled", "");
      this.setSubmitsWith();
      markAsBusy(this.formElement);
      dispatch("turbo:submit-start", {
        target: this.formElement,
        detail: { formSubmission: this }
      });
      this.delegate.formSubmissionStarted(this);
    }
    requestPreventedHandlingResponse(request, response) {
      prefetchCache.clear();
      this.result = { success: response.succeeded, fetchResponse: response };
    }
    requestSucceededWithResponse(request, response) {
      if (response.clientError || response.serverError) {
        this.delegate.formSubmissionFailedWithResponse(this, response);
        return;
      }
      prefetchCache.clear();
      if (this.requestMustRedirect(request) && responseSucceededWithoutRedirect(response)) {
        const error = new Error("Form responses must redirect to another location");
        this.delegate.formSubmissionErrored(this, error);
      } else {
        this.state = FormSubmissionState.receiving;
        this.result = { success: true, fetchResponse: response };
        this.delegate.formSubmissionSucceededWithResponse(this, response);
      }
    }
    requestFailedWithResponse(request, response) {
      this.result = { success: false, fetchResponse: response };
      this.delegate.formSubmissionFailedWithResponse(this, response);
    }
    requestErrored(request, error) {
      this.result = { success: false, error };
      this.delegate.formSubmissionErrored(this, error);
    }
    requestFinished(_request) {
      this.state = FormSubmissionState.stopped;
      this.submitter?.removeAttribute("disabled");
      this.resetSubmitterText();
      clearBusyState(this.formElement);
      dispatch("turbo:submit-end", {
        target: this.formElement,
        detail: { formSubmission: this, ...this.result }
      });
      this.delegate.formSubmissionFinished(this);
    }
    // Private
    setSubmitsWith() {
      if (!this.submitter || !this.submitsWith)
        return;
      if (this.submitter.matches("button")) {
        this.originalSubmitText = this.submitter.innerHTML;
        this.submitter.innerHTML = this.submitsWith;
      } else if (this.submitter.matches("input")) {
        const input = this.submitter;
        this.originalSubmitText = input.value;
        input.value = this.submitsWith;
      }
    }
    resetSubmitterText() {
      if (!this.submitter || !this.originalSubmitText)
        return;
      if (this.submitter.matches("button")) {
        this.submitter.innerHTML = this.originalSubmitText;
      } else if (this.submitter.matches("input")) {
        const input = this.submitter;
        input.value = this.originalSubmitText;
      }
    }
    requestMustRedirect(request) {
      return !request.isSafe && this.mustRedirect;
    }
    requestAcceptsTurboStreamResponse(request) {
      return !request.isSafe || hasAttribute("data-turbo-stream", this.submitter, this.formElement);
    }
    get submitsWith() {
      return this.submitter?.getAttribute("data-turbo-submits-with");
    }
  };
  function buildFormData(formElement, submitter) {
    const formData = new FormData(formElement);
    const name = submitter?.getAttribute("name");
    const value = submitter?.getAttribute("value");
    if (name) {
      formData.append(name, value || "");
    }
    return formData;
  }
  __name(buildFormData, "buildFormData");
  function getCookieValue(cookieName) {
    if (cookieName != null) {
      const cookies = document.cookie ? document.cookie.split("; ") : [];
      const cookie = cookies.find((cookie2) => cookie2.startsWith(cookieName));
      if (cookie) {
        const value = cookie.split("=").slice(1).join("=");
        return value ? decodeURIComponent(value) : void 0;
      }
    }
  }
  __name(getCookieValue, "getCookieValue");
  function responseSucceededWithoutRedirect(response) {
    return response.statusCode == 200 && !response.redirected;
  }
  __name(responseSucceededWithoutRedirect, "responseSucceededWithoutRedirect");
  function getFormAction(formElement, submitter) {
    const formElementAction = typeof formElement.action === "string" ? formElement.action : null;
    if (submitter?.hasAttribute("formaction")) {
      return submitter.getAttribute("formaction") || "";
    } else {
      return formElement.getAttribute("action") || formElementAction || "";
    }
  }
  __name(getFormAction, "getFormAction");
  function getAction(formAction, fetchMethod) {
    const action = expandURL(formAction);
    if (isSafe(fetchMethod)) {
      action.search = "";
    }
    return action;
  }
  __name(getAction, "getAction");
  function getMethod(formElement, submitter) {
    const method = submitter?.getAttribute("formmethod") || formElement.getAttribute("method") || "";
    return fetchMethodFromString(method.toLowerCase()) || FetchMethod.get;
  }
  __name(getMethod, "getMethod");
  function getEnctype(formElement, submitter) {
    return fetchEnctypeFromString(submitter?.getAttribute("formenctype") || formElement.enctype);
  }
  __name(getEnctype, "getEnctype");
  var Snapshot = class {
    static {
      __name(this, "Snapshot");
    }
    constructor(element) {
      this.element = element;
    }
    get activeElement() {
      return this.element.ownerDocument.activeElement;
    }
    get children() {
      return [...this.element.children];
    }
    hasAnchor(anchor) {
      return this.getElementForAnchor(anchor) != null;
    }
    getElementForAnchor(anchor) {
      return anchor ? this.element.querySelector(`[id='${anchor}'], a[name='${anchor}']`) : null;
    }
    get isConnected() {
      return this.element.isConnected;
    }
    get firstAutofocusableElement() {
      return queryAutofocusableElement(this.element);
    }
    get permanentElements() {
      return queryPermanentElementsAll(this.element);
    }
    getPermanentElementById(id) {
      return getPermanentElementById(this.element, id);
    }
    getPermanentElementMapForSnapshot(snapshot) {
      const permanentElementMap = {};
      for (const currentPermanentElement of this.permanentElements) {
        const { id } = currentPermanentElement;
        const newPermanentElement = snapshot.getPermanentElementById(id);
        if (newPermanentElement) {
          permanentElementMap[id] = [currentPermanentElement, newPermanentElement];
        }
      }
      return permanentElementMap;
    }
  };
  function getPermanentElementById(node, id) {
    return node.querySelector(`#${id}[data-turbo-permanent]`);
  }
  __name(getPermanentElementById, "getPermanentElementById");
  function queryPermanentElementsAll(node) {
    return node.querySelectorAll("[id][data-turbo-permanent]");
  }
  __name(queryPermanentElementsAll, "queryPermanentElementsAll");
  var FormSubmitObserver = class {
    static {
      __name(this, "FormSubmitObserver");
    }
    started = false;
    constructor(delegate, eventTarget) {
      this.delegate = delegate;
      this.eventTarget = eventTarget;
    }
    start() {
      if (!this.started) {
        this.eventTarget.addEventListener("submit", this.submitCaptured, true);
        this.started = true;
      }
    }
    stop() {
      if (this.started) {
        this.eventTarget.removeEventListener("submit", this.submitCaptured, true);
        this.started = false;
      }
    }
    submitCaptured = () => {
      this.eventTarget.removeEventListener("submit", this.submitBubbled, false);
      this.eventTarget.addEventListener("submit", this.submitBubbled, false);
    };
    submitBubbled = (event) => {
      if (!event.defaultPrevented) {
        const form = event.target instanceof HTMLFormElement ? event.target : void 0;
        const submitter = event.submitter || void 0;
        if (form && submissionDoesNotDismissDialog(form, submitter) && submissionDoesNotTargetIFrame(form, submitter) && this.delegate.willSubmitForm(form, submitter)) {
          event.preventDefault();
          event.stopImmediatePropagation();
          this.delegate.formSubmitted(form, submitter);
        }
      }
    };
  };
  function submissionDoesNotDismissDialog(form, submitter) {
    const method = submitter?.getAttribute("formmethod") || form.getAttribute("method");
    return method != "dialog";
  }
  __name(submissionDoesNotDismissDialog, "submissionDoesNotDismissDialog");
  function submissionDoesNotTargetIFrame(form, submitter) {
    if (submitter?.hasAttribute("formtarget") || form.hasAttribute("target")) {
      const target = submitter?.getAttribute("formtarget") || form.target;
      for (const element of document.getElementsByName(target)) {
        if (element instanceof HTMLIFrameElement)
          return false;
      }
      return true;
    } else {
      return true;
    }
  }
  __name(submissionDoesNotTargetIFrame, "submissionDoesNotTargetIFrame");
  var View = class {
    static {
      __name(this, "View");
    }
    #resolveRenderPromise = (_value) => {
    };
    #resolveInterceptionPromise = (_value) => {
    };
    constructor(delegate, element) {
      this.delegate = delegate;
      this.element = element;
    }
    // Scrolling
    scrollToAnchor(anchor) {
      const element = this.snapshot.getElementForAnchor(anchor);
      if (element) {
        this.scrollToElement(element);
        this.focusElement(element);
      } else {
        this.scrollToPosition({ x: 0, y: 0 });
      }
    }
    scrollToAnchorFromLocation(location2) {
      this.scrollToAnchor(getAnchor(location2));
    }
    scrollToElement(element) {
      element.scrollIntoView();
    }
    focusElement(element) {
      if (element instanceof HTMLElement) {
        if (element.hasAttribute("tabindex")) {
          element.focus();
        } else {
          element.setAttribute("tabindex", "-1");
          element.focus();
          element.removeAttribute("tabindex");
        }
      }
    }
    scrollToPosition({ x: x3, y: y3 }) {
      this.scrollRoot.scrollTo(x3, y3);
    }
    scrollToTop() {
      this.scrollToPosition({ x: 0, y: 0 });
    }
    get scrollRoot() {
      return window;
    }
    // Rendering
    async render(renderer) {
      const { isPreview, shouldRender, willRender, newSnapshot: snapshot } = renderer;
      const shouldInvalidate = willRender;
      if (shouldRender) {
        try {
          this.renderPromise = new Promise((resolve) => this.#resolveRenderPromise = resolve);
          this.renderer = renderer;
          await this.prepareToRenderSnapshot(renderer);
          const renderInterception = new Promise((resolve) => this.#resolveInterceptionPromise = resolve);
          const options = { resume: this.#resolveInterceptionPromise, render: this.renderer.renderElement, renderMethod: this.renderer.renderMethod };
          const immediateRender = this.delegate.allowsImmediateRender(snapshot, options);
          if (!immediateRender)
            await renderInterception;
          await this.renderSnapshot(renderer);
          this.delegate.viewRenderedSnapshot(snapshot, isPreview, this.renderer.renderMethod);
          this.delegate.preloadOnLoadLinksForView(this.element);
          this.finishRenderingSnapshot(renderer);
        } finally {
          delete this.renderer;
          this.#resolveRenderPromise(void 0);
          delete this.renderPromise;
        }
      } else if (shouldInvalidate) {
        this.invalidate(renderer.reloadReason);
      }
    }
    invalidate(reason) {
      this.delegate.viewInvalidated(reason);
    }
    async prepareToRenderSnapshot(renderer) {
      this.markAsPreview(renderer.isPreview);
      await renderer.prepareToRender();
    }
    markAsPreview(isPreview) {
      if (isPreview) {
        this.element.setAttribute("data-turbo-preview", "");
      } else {
        this.element.removeAttribute("data-turbo-preview");
      }
    }
    markVisitDirection(direction) {
      this.element.setAttribute("data-turbo-visit-direction", direction);
    }
    unmarkVisitDirection() {
      this.element.removeAttribute("data-turbo-visit-direction");
    }
    async renderSnapshot(renderer) {
      await renderer.render();
    }
    finishRenderingSnapshot(renderer) {
      renderer.finishRendering();
    }
  };
  var FrameView = class extends View {
    static {
      __name(this, "FrameView");
    }
    missing() {
      this.element.innerHTML = `<strong class="turbo-frame-error">Content missing</strong>`;
    }
    get snapshot() {
      return new Snapshot(this.element);
    }
  };
  var LinkInterceptor = class {
    static {
      __name(this, "LinkInterceptor");
    }
    constructor(delegate, element) {
      this.delegate = delegate;
      this.element = element;
    }
    start() {
      this.element.addEventListener("click", this.clickBubbled);
      document.addEventListener("turbo:click", this.linkClicked);
      document.addEventListener("turbo:before-visit", this.willVisit);
    }
    stop() {
      this.element.removeEventListener("click", this.clickBubbled);
      document.removeEventListener("turbo:click", this.linkClicked);
      document.removeEventListener("turbo:before-visit", this.willVisit);
    }
    clickBubbled = (event) => {
      if (this.respondsToEventTarget(event.target)) {
        this.clickEvent = event;
      } else {
        delete this.clickEvent;
      }
    };
    linkClicked = (event) => {
      if (this.clickEvent && this.respondsToEventTarget(event.target) && event.target instanceof Element) {
        if (this.delegate.shouldInterceptLinkClick(event.target, event.detail.url, event.detail.originalEvent)) {
          this.clickEvent.preventDefault();
          event.preventDefault();
          this.delegate.linkClickIntercepted(event.target, event.detail.url, event.detail.originalEvent);
        }
      }
      delete this.clickEvent;
    };
    willVisit = (_event) => {
      delete this.clickEvent;
    };
    respondsToEventTarget(target) {
      const element = target instanceof Element ? target : target instanceof Node ? target.parentElement : null;
      return element && element.closest("turbo-frame, html") == this.element;
    }
  };
  var LinkClickObserver = class {
    static {
      __name(this, "LinkClickObserver");
    }
    started = false;
    constructor(delegate, eventTarget) {
      this.delegate = delegate;
      this.eventTarget = eventTarget;
    }
    start() {
      if (!this.started) {
        this.eventTarget.addEventListener("click", this.clickCaptured, true);
        this.started = true;
      }
    }
    stop() {
      if (this.started) {
        this.eventTarget.removeEventListener("click", this.clickCaptured, true);
        this.started = false;
      }
    }
    clickCaptured = () => {
      this.eventTarget.removeEventListener("click", this.clickBubbled, false);
      this.eventTarget.addEventListener("click", this.clickBubbled, false);
    };
    clickBubbled = (event) => {
      if (event instanceof MouseEvent && this.clickEventIsSignificant(event)) {
        const target = event.composedPath && event.composedPath()[0] || event.target;
        const link = findLinkFromClickTarget(target);
        if (link && doesNotTargetIFrame(link)) {
          const location2 = getLocationForLink(link);
          if (this.delegate.willFollowLinkToLocation(link, location2, event)) {
            event.preventDefault();
            this.delegate.followedLinkToLocation(link, location2);
          }
        }
      }
    };
    clickEventIsSignificant(event) {
      return !(event.target && event.target.isContentEditable || event.defaultPrevented || event.which > 1 || event.altKey || event.ctrlKey || event.metaKey || event.shiftKey);
    }
  };
  var FormLinkClickObserver = class {
    static {
      __name(this, "FormLinkClickObserver");
    }
    constructor(delegate, element) {
      this.delegate = delegate;
      this.linkInterceptor = new LinkClickObserver(this, element);
    }
    start() {
      this.linkInterceptor.start();
    }
    stop() {
      this.linkInterceptor.stop();
    }
    // Link hover observer delegate
    canPrefetchRequestToLocation(link, location2) {
      return false;
    }
    prefetchAndCacheRequestToLocation(link, location2) {
      return;
    }
    // Link click observer delegate
    willFollowLinkToLocation(link, location2, originalEvent) {
      return this.delegate.willSubmitFormLinkToLocation(link, location2, originalEvent) && (link.hasAttribute("data-turbo-method") || link.hasAttribute("data-turbo-stream"));
    }
    followedLinkToLocation(link, location2) {
      const form = document.createElement("form");
      const type = "hidden";
      for (const [name, value] of location2.searchParams) {
        form.append(Object.assign(document.createElement("input"), { type, name, value }));
      }
      const action = Object.assign(location2, { search: "" });
      form.setAttribute("data-turbo", "true");
      form.setAttribute("action", action.href);
      form.setAttribute("hidden", "");
      const method = link.getAttribute("data-turbo-method");
      if (method)
        form.setAttribute("method", method);
      const turboFrame = link.getAttribute("data-turbo-frame");
      if (turboFrame)
        form.setAttribute("data-turbo-frame", turboFrame);
      const turboAction = getVisitAction(link);
      if (turboAction)
        form.setAttribute("data-turbo-action", turboAction);
      const turboConfirm = link.getAttribute("data-turbo-confirm");
      if (turboConfirm)
        form.setAttribute("data-turbo-confirm", turboConfirm);
      const turboStream = link.hasAttribute("data-turbo-stream");
      if (turboStream)
        form.setAttribute("data-turbo-stream", "");
      this.delegate.submittedFormLinkToLocation(link, location2, form);
      document.body.appendChild(form);
      form.addEventListener("turbo:submit-end", () => form.remove(), { once: true });
      requestAnimationFrame(() => form.requestSubmit());
    }
  };
  var Bardo = class {
    static {
      __name(this, "Bardo");
    }
    static async preservingPermanentElements(delegate, permanentElementMap, callback) {
      const bardo = new this(delegate, permanentElementMap);
      bardo.enter();
      await callback();
      bardo.leave();
    }
    constructor(delegate, permanentElementMap) {
      this.delegate = delegate;
      this.permanentElementMap = permanentElementMap;
    }
    enter() {
      for (const id in this.permanentElementMap) {
        const [currentPermanentElement, newPermanentElement] = this.permanentElementMap[id];
        this.delegate.enteringBardo(currentPermanentElement, newPermanentElement);
        this.replaceNewPermanentElementWithPlaceholder(newPermanentElement);
      }
    }
    leave() {
      for (const id in this.permanentElementMap) {
        const [currentPermanentElement] = this.permanentElementMap[id];
        this.replaceCurrentPermanentElementWithClone(currentPermanentElement);
        this.replacePlaceholderWithPermanentElement(currentPermanentElement);
        this.delegate.leavingBardo(currentPermanentElement);
      }
    }
    replaceNewPermanentElementWithPlaceholder(permanentElement) {
      const placeholder = createPlaceholderForPermanentElement(permanentElement);
      permanentElement.replaceWith(placeholder);
    }
    replaceCurrentPermanentElementWithClone(permanentElement) {
      const clone2 = permanentElement.cloneNode(true);
      permanentElement.replaceWith(clone2);
    }
    replacePlaceholderWithPermanentElement(permanentElement) {
      const placeholder = this.getPlaceholderById(permanentElement.id);
      placeholder?.replaceWith(permanentElement);
    }
    getPlaceholderById(id) {
      return this.placeholders.find((element) => element.content == id);
    }
    get placeholders() {
      return [...document.querySelectorAll("meta[name=turbo-permanent-placeholder][content]")];
    }
  };
  function createPlaceholderForPermanentElement(permanentElement) {
    const element = document.createElement("meta");
    element.setAttribute("name", "turbo-permanent-placeholder");
    element.setAttribute("content", permanentElement.id);
    return element;
  }
  __name(createPlaceholderForPermanentElement, "createPlaceholderForPermanentElement");
  var Renderer = class {
    static {
      __name(this, "Renderer");
    }
    #activeElement = null;
    constructor(currentSnapshot, newSnapshot, renderElement, isPreview, willRender = true) {
      this.currentSnapshot = currentSnapshot;
      this.newSnapshot = newSnapshot;
      this.isPreview = isPreview;
      this.willRender = willRender;
      this.renderElement = renderElement;
      this.promise = new Promise((resolve, reject) => this.resolvingFunctions = { resolve, reject });
    }
    get shouldRender() {
      return true;
    }
    get reloadReason() {
      return;
    }
    prepareToRender() {
      return;
    }
    render() {
    }
    finishRendering() {
      if (this.resolvingFunctions) {
        this.resolvingFunctions.resolve();
        delete this.resolvingFunctions;
      }
    }
    async preservingPermanentElements(callback) {
      await Bardo.preservingPermanentElements(this, this.permanentElementMap, callback);
    }
    focusFirstAutofocusableElement() {
      const element = this.connectedSnapshot.firstAutofocusableElement;
      if (element) {
        element.focus();
      }
    }
    // Bardo delegate
    enteringBardo(currentPermanentElement) {
      if (this.#activeElement)
        return;
      if (currentPermanentElement.contains(this.currentSnapshot.activeElement)) {
        this.#activeElement = this.currentSnapshot.activeElement;
      }
    }
    leavingBardo(currentPermanentElement) {
      if (currentPermanentElement.contains(this.#activeElement) && this.#activeElement instanceof HTMLElement) {
        this.#activeElement.focus();
        this.#activeElement = null;
      }
    }
    get connectedSnapshot() {
      return this.newSnapshot.isConnected ? this.newSnapshot : this.currentSnapshot;
    }
    get currentElement() {
      return this.currentSnapshot.element;
    }
    get newElement() {
      return this.newSnapshot.element;
    }
    get permanentElementMap() {
      return this.currentSnapshot.getPermanentElementMapForSnapshot(this.newSnapshot);
    }
    get renderMethod() {
      return "replace";
    }
  };
  var FrameRenderer = class extends Renderer {
    static {
      __name(this, "FrameRenderer");
    }
    static renderElement(currentElement, newElement) {
      const destinationRange = document.createRange();
      destinationRange.selectNodeContents(currentElement);
      destinationRange.deleteContents();
      const frameElement = newElement;
      const sourceRange = frameElement.ownerDocument?.createRange();
      if (sourceRange) {
        sourceRange.selectNodeContents(frameElement);
        currentElement.appendChild(sourceRange.extractContents());
      }
    }
    constructor(delegate, currentSnapshot, newSnapshot, renderElement, isPreview, willRender = true) {
      super(currentSnapshot, newSnapshot, renderElement, isPreview, willRender);
      this.delegate = delegate;
    }
    get shouldRender() {
      return true;
    }
    async render() {
      await nextRepaint();
      this.preservingPermanentElements(() => {
        this.loadFrameElement();
      });
      this.scrollFrameIntoView();
      await nextRepaint();
      this.focusFirstAutofocusableElement();
      await nextRepaint();
      this.activateScriptElements();
    }
    loadFrameElement() {
      this.delegate.willRenderFrame(this.currentElement, this.newElement);
      this.renderElement(this.currentElement, this.newElement);
    }
    scrollFrameIntoView() {
      if (this.currentElement.autoscroll || this.newElement.autoscroll) {
        const element = this.currentElement.firstElementChild;
        const block = readScrollLogicalPosition(this.currentElement.getAttribute("data-autoscroll-block"), "end");
        const behavior = readScrollBehavior(this.currentElement.getAttribute("data-autoscroll-behavior"), "auto");
        if (element) {
          element.scrollIntoView({ block, behavior });
          return true;
        }
      }
      return false;
    }
    activateScriptElements() {
      for (const inertScriptElement of this.newScriptElements) {
        const activatedScriptElement = activateScriptElement(inertScriptElement);
        inertScriptElement.replaceWith(activatedScriptElement);
      }
    }
    get newScriptElements() {
      return this.currentElement.querySelectorAll("script");
    }
  };
  function readScrollLogicalPosition(value, defaultValue) {
    if (value == "end" || value == "start" || value == "center" || value == "nearest") {
      return value;
    } else {
      return defaultValue;
    }
  }
  __name(readScrollLogicalPosition, "readScrollLogicalPosition");
  function readScrollBehavior(value, defaultValue) {
    if (value == "auto" || value == "smooth") {
      return value;
    } else {
      return defaultValue;
    }
  }
  __name(readScrollBehavior, "readScrollBehavior");
  var ProgressBar = class _ProgressBar {
    static {
      __name(this, "ProgressBar");
    }
    static animationDuration = 300;
    /*ms*/
    static get defaultCSS() {
      return unindent`
      .turbo-progress-bar {
        position: fixed;
        display: block;
        top: 0;
        left: 0;
        height: 3px;
        background: #0076ff;
        z-index: 2147483647;
        transition:
          width ${_ProgressBar.animationDuration}ms ease-out,
          opacity ${_ProgressBar.animationDuration / 2}ms ${_ProgressBar.animationDuration / 2}ms ease-in;
        transform: translate3d(0, 0, 0);
      }
    `;
    }
    hiding = false;
    value = 0;
    visible = false;
    constructor() {
      this.stylesheetElement = this.createStylesheetElement();
      this.progressElement = this.createProgressElement();
      this.installStylesheetElement();
      this.setValue(0);
    }
    show() {
      if (!this.visible) {
        this.visible = true;
        this.installProgressElement();
        this.startTrickling();
      }
    }
    hide() {
      if (this.visible && !this.hiding) {
        this.hiding = true;
        this.fadeProgressElement(() => {
          this.uninstallProgressElement();
          this.stopTrickling();
          this.visible = false;
          this.hiding = false;
        });
      }
    }
    setValue(value) {
      this.value = value;
      this.refresh();
    }
    // Private
    installStylesheetElement() {
      document.head.insertBefore(this.stylesheetElement, document.head.firstChild);
    }
    installProgressElement() {
      this.progressElement.style.width = "0";
      this.progressElement.style.opacity = "1";
      document.documentElement.insertBefore(this.progressElement, document.body);
      this.refresh();
    }
    fadeProgressElement(callback) {
      this.progressElement.style.opacity = "0";
      setTimeout(callback, _ProgressBar.animationDuration * 1.5);
    }
    uninstallProgressElement() {
      if (this.progressElement.parentNode) {
        document.documentElement.removeChild(this.progressElement);
      }
    }
    startTrickling() {
      if (!this.trickleInterval) {
        this.trickleInterval = window.setInterval(this.trickle, _ProgressBar.animationDuration);
      }
    }
    stopTrickling() {
      window.clearInterval(this.trickleInterval);
      delete this.trickleInterval;
    }
    trickle = () => {
      this.setValue(this.value + Math.random() / 100);
    };
    refresh() {
      requestAnimationFrame(() => {
        this.progressElement.style.width = `${10 + this.value * 90}%`;
      });
    }
    createStylesheetElement() {
      const element = document.createElement("style");
      element.type = "text/css";
      element.textContent = _ProgressBar.defaultCSS;
      if (this.cspNonce) {
        element.nonce = this.cspNonce;
      }
      return element;
    }
    createProgressElement() {
      const element = document.createElement("div");
      element.className = "turbo-progress-bar";
      return element;
    }
    get cspNonce() {
      return getMetaContent("csp-nonce");
    }
  };
  var HeadSnapshot = class extends Snapshot {
    static {
      __name(this, "HeadSnapshot");
    }
    detailsByOuterHTML = this.children.filter((element) => !elementIsNoscript(element)).map((element) => elementWithoutNonce(element)).reduce((result, element) => {
      const { outerHTML } = element;
      const details = outerHTML in result ? result[outerHTML] : {
        type: elementType(element),
        tracked: elementIsTracked(element),
        elements: []
      };
      return {
        ...result,
        [outerHTML]: {
          ...details,
          elements: [...details.elements, element]
        }
      };
    }, {});
    get trackedElementSignature() {
      return Object.keys(this.detailsByOuterHTML).filter((outerHTML) => this.detailsByOuterHTML[outerHTML].tracked).join("");
    }
    getScriptElementsNotInSnapshot(snapshot) {
      return this.getElementsMatchingTypeNotInSnapshot("script", snapshot);
    }
    getStylesheetElementsNotInSnapshot(snapshot) {
      return this.getElementsMatchingTypeNotInSnapshot("stylesheet", snapshot);
    }
    getElementsMatchingTypeNotInSnapshot(matchedType, snapshot) {
      return Object.keys(this.detailsByOuterHTML).filter((outerHTML) => !(outerHTML in snapshot.detailsByOuterHTML)).map((outerHTML) => this.detailsByOuterHTML[outerHTML]).filter(({ type }) => type == matchedType).map(({ elements: [element] }) => element);
    }
    get provisionalElements() {
      return Object.keys(this.detailsByOuterHTML).reduce((result, outerHTML) => {
        const { type, tracked, elements } = this.detailsByOuterHTML[outerHTML];
        if (type == null && !tracked) {
          return [...result, ...elements];
        } else if (elements.length > 1) {
          return [...result, ...elements.slice(1)];
        } else {
          return result;
        }
      }, []);
    }
    getMetaValue(name) {
      const element = this.findMetaElementByName(name);
      return element ? element.getAttribute("content") : null;
    }
    findMetaElementByName(name) {
      return Object.keys(this.detailsByOuterHTML).reduce((result, outerHTML) => {
        const {
          elements: [element]
        } = this.detailsByOuterHTML[outerHTML];
        return elementIsMetaElementWithName(element, name) ? element : result;
      }, void 0 | void 0);
    }
  };
  function elementType(element) {
    if (elementIsScript(element)) {
      return "script";
    } else if (elementIsStylesheet(element)) {
      return "stylesheet";
    }
  }
  __name(elementType, "elementType");
  function elementIsTracked(element) {
    return element.getAttribute("data-turbo-track") == "reload";
  }
  __name(elementIsTracked, "elementIsTracked");
  function elementIsScript(element) {
    const tagName = element.localName;
    return tagName == "script";
  }
  __name(elementIsScript, "elementIsScript");
  function elementIsNoscript(element) {
    const tagName = element.localName;
    return tagName == "noscript";
  }
  __name(elementIsNoscript, "elementIsNoscript");
  function elementIsStylesheet(element) {
    const tagName = element.localName;
    return tagName == "style" || tagName == "link" && element.getAttribute("rel") == "stylesheet";
  }
  __name(elementIsStylesheet, "elementIsStylesheet");
  function elementIsMetaElementWithName(element, name) {
    const tagName = element.localName;
    return tagName == "meta" && element.getAttribute("name") == name;
  }
  __name(elementIsMetaElementWithName, "elementIsMetaElementWithName");
  function elementWithoutNonce(element) {
    if (element.hasAttribute("nonce")) {
      element.setAttribute("nonce", "");
    }
    return element;
  }
  __name(elementWithoutNonce, "elementWithoutNonce");
  var PageSnapshot = class _PageSnapshot extends Snapshot {
    static {
      __name(this, "PageSnapshot");
    }
    static fromHTMLString(html = "") {
      return this.fromDocument(parseHTMLDocument(html));
    }
    static fromElement(element) {
      return this.fromDocument(element.ownerDocument);
    }
    static fromDocument({ documentElement, body, head }) {
      return new this(documentElement, body, new HeadSnapshot(head));
    }
    constructor(documentElement, body, headSnapshot) {
      super(body);
      this.documentElement = documentElement;
      this.headSnapshot = headSnapshot;
    }
    clone() {
      const clonedElement = this.element.cloneNode(true);
      const selectElements = this.element.querySelectorAll("select");
      const clonedSelectElements = clonedElement.querySelectorAll("select");
      for (const [index2, source] of selectElements.entries()) {
        const clone2 = clonedSelectElements[index2];
        for (const option2 of clone2.selectedOptions)
          option2.selected = false;
        for (const option2 of source.selectedOptions)
          clone2.options[option2.index].selected = true;
      }
      for (const clonedPasswordInput of clonedElement.querySelectorAll('input[type="password"]')) {
        clonedPasswordInput.value = "";
      }
      return new _PageSnapshot(this.documentElement, clonedElement, this.headSnapshot);
    }
    get lang() {
      return this.documentElement.getAttribute("lang");
    }
    get headElement() {
      return this.headSnapshot.element;
    }
    get rootLocation() {
      const root2 = this.getSetting("root") ?? "/";
      return expandURL(root2);
    }
    get cacheControlValue() {
      return this.getSetting("cache-control");
    }
    get isPreviewable() {
      return this.cacheControlValue != "no-preview";
    }
    get isCacheable() {
      return this.cacheControlValue != "no-cache";
    }
    get isVisitable() {
      return this.getSetting("visit-control") != "reload";
    }
    get prefersViewTransitions() {
      return this.headSnapshot.getMetaValue("view-transition") === "same-origin";
    }
    get shouldMorphPage() {
      return this.getSetting("refresh-method") === "morph";
    }
    get shouldPreserveScrollPosition() {
      return this.getSetting("refresh-scroll") === "preserve";
    }
    // Private
    getSetting(name) {
      return this.headSnapshot.getMetaValue(`turbo-${name}`);
    }
  };
  var ViewTransitioner = class {
    static {
      __name(this, "ViewTransitioner");
    }
    #viewTransitionStarted = false;
    #lastOperation = Promise.resolve();
    renderChange(useViewTransition, render) {
      if (useViewTransition && this.viewTransitionsAvailable && !this.#viewTransitionStarted) {
        this.#viewTransitionStarted = true;
        this.#lastOperation = this.#lastOperation.then(async () => {
          await document.startViewTransition(render).finished;
        });
      } else {
        this.#lastOperation = this.#lastOperation.then(render);
      }
      return this.#lastOperation;
    }
    get viewTransitionsAvailable() {
      return document.startViewTransition;
    }
  };
  var defaultOptions = {
    action: "advance",
    historyChanged: false,
    visitCachedSnapshot: () => {
    },
    willRender: true,
    updateHistory: true,
    shouldCacheSnapshot: true,
    acceptsStreamResponse: false
  };
  var TimingMetric = {
    visitStart: "visitStart",
    requestStart: "requestStart",
    requestEnd: "requestEnd",
    visitEnd: "visitEnd"
  };
  var VisitState = {
    initialized: "initialized",
    started: "started",
    canceled: "canceled",
    failed: "failed",
    completed: "completed"
  };
  var SystemStatusCode = {
    networkFailure: 0,
    timeoutFailure: -1,
    contentTypeMismatch: -2
  };
  var Direction = {
    advance: "forward",
    restore: "back",
    replace: "none"
  };
  var Visit = class {
    static {
      __name(this, "Visit");
    }
    identifier = uuid();
    // Required by turbo-ios
    timingMetrics = {};
    followedRedirect = false;
    historyChanged = false;
    scrolled = false;
    shouldCacheSnapshot = true;
    acceptsStreamResponse = false;
    snapshotCached = false;
    state = VisitState.initialized;
    viewTransitioner = new ViewTransitioner();
    constructor(delegate, location2, restorationIdentifier, options = {}) {
      this.delegate = delegate;
      this.location = location2;
      this.restorationIdentifier = restorationIdentifier || uuid();
      const {
        action,
        historyChanged,
        referrer,
        snapshot,
        snapshotHTML,
        response,
        visitCachedSnapshot,
        willRender,
        updateHistory,
        shouldCacheSnapshot,
        acceptsStreamResponse,
        direction
      } = {
        ...defaultOptions,
        ...options
      };
      this.action = action;
      this.historyChanged = historyChanged;
      this.referrer = referrer;
      this.snapshot = snapshot;
      this.snapshotHTML = snapshotHTML;
      this.response = response;
      this.isSamePage = this.delegate.locationWithActionIsSamePage(this.location, this.action);
      this.isPageRefresh = this.view.isPageRefresh(this);
      this.visitCachedSnapshot = visitCachedSnapshot;
      this.willRender = willRender;
      this.updateHistory = updateHistory;
      this.scrolled = !willRender;
      this.shouldCacheSnapshot = shouldCacheSnapshot;
      this.acceptsStreamResponse = acceptsStreamResponse;
      this.direction = direction || Direction[action];
    }
    get adapter() {
      return this.delegate.adapter;
    }
    get view() {
      return this.delegate.view;
    }
    get history() {
      return this.delegate.history;
    }
    get restorationData() {
      return this.history.getRestorationDataForIdentifier(this.restorationIdentifier);
    }
    get silent() {
      return this.isSamePage;
    }
    start() {
      if (this.state == VisitState.initialized) {
        this.recordTimingMetric(TimingMetric.visitStart);
        this.state = VisitState.started;
        this.adapter.visitStarted(this);
        this.delegate.visitStarted(this);
      }
    }
    cancel() {
      if (this.state == VisitState.started) {
        if (this.request) {
          this.request.cancel();
        }
        this.cancelRender();
        this.state = VisitState.canceled;
      }
    }
    complete() {
      if (this.state == VisitState.started) {
        this.recordTimingMetric(TimingMetric.visitEnd);
        this.adapter.visitCompleted(this);
        this.state = VisitState.completed;
        this.followRedirect();
        if (!this.followedRedirect) {
          this.delegate.visitCompleted(this);
        }
      }
    }
    fail() {
      if (this.state == VisitState.started) {
        this.state = VisitState.failed;
        this.adapter.visitFailed(this);
        this.delegate.visitCompleted(this);
      }
    }
    changeHistory() {
      if (!this.historyChanged && this.updateHistory) {
        const actionForHistory = this.location.href === this.referrer?.href ? "replace" : this.action;
        const method = getHistoryMethodForAction(actionForHistory);
        this.history.update(method, this.location, this.restorationIdentifier);
        this.historyChanged = true;
      }
    }
    issueRequest() {
      if (this.hasPreloadedResponse()) {
        this.simulateRequest();
      } else if (this.shouldIssueRequest() && !this.request) {
        this.request = new FetchRequest(this, FetchMethod.get, this.location);
        this.request.perform();
      }
    }
    simulateRequest() {
      if (this.response) {
        this.startRequest();
        this.recordResponse();
        this.finishRequest();
      }
    }
    startRequest() {
      this.recordTimingMetric(TimingMetric.requestStart);
      this.adapter.visitRequestStarted(this);
    }
    recordResponse(response = this.response) {
      this.response = response;
      if (response) {
        const { statusCode } = response;
        if (isSuccessful(statusCode)) {
          this.adapter.visitRequestCompleted(this);
        } else {
          this.adapter.visitRequestFailedWithStatusCode(this, statusCode);
        }
      }
    }
    finishRequest() {
      this.recordTimingMetric(TimingMetric.requestEnd);
      this.adapter.visitRequestFinished(this);
    }
    loadResponse() {
      if (this.response) {
        const { statusCode, responseHTML } = this.response;
        this.render(async () => {
          if (this.shouldCacheSnapshot)
            this.cacheSnapshot();
          if (this.view.renderPromise)
            await this.view.renderPromise;
          if (isSuccessful(statusCode) && responseHTML != null) {
            const snapshot = PageSnapshot.fromHTMLString(responseHTML);
            await this.renderPageSnapshot(snapshot, false);
            this.adapter.visitRendered(this);
            this.complete();
          } else {
            await this.view.renderError(PageSnapshot.fromHTMLString(responseHTML), this);
            this.adapter.visitRendered(this);
            this.fail();
          }
        });
      }
    }
    getCachedSnapshot() {
      const snapshot = this.view.getCachedSnapshotForLocation(this.location) || this.getPreloadedSnapshot();
      if (snapshot && (!getAnchor(this.location) || snapshot.hasAnchor(getAnchor(this.location)))) {
        if (this.action == "restore" || snapshot.isPreviewable) {
          return snapshot;
        }
      }
    }
    getPreloadedSnapshot() {
      if (this.snapshotHTML) {
        return PageSnapshot.fromHTMLString(this.snapshotHTML);
      }
    }
    hasCachedSnapshot() {
      return this.getCachedSnapshot() != null;
    }
    loadCachedSnapshot() {
      const snapshot = this.getCachedSnapshot();
      if (snapshot) {
        const isPreview = this.shouldIssueRequest();
        this.render(async () => {
          this.cacheSnapshot();
          if (this.isSamePage || this.isPageRefresh) {
            this.adapter.visitRendered(this);
          } else {
            if (this.view.renderPromise)
              await this.view.renderPromise;
            await this.renderPageSnapshot(snapshot, isPreview);
            this.adapter.visitRendered(this);
            if (!isPreview) {
              this.complete();
            }
          }
        });
      }
    }
    followRedirect() {
      if (this.redirectedToLocation && !this.followedRedirect && this.response?.redirected) {
        this.adapter.visitProposedToLocation(this.redirectedToLocation, {
          action: "replace",
          response: this.response,
          shouldCacheSnapshot: false,
          willRender: false
        });
        this.followedRedirect = true;
      }
    }
    goToSamePageAnchor() {
      if (this.isSamePage) {
        this.render(async () => {
          this.cacheSnapshot();
          this.performScroll();
          this.changeHistory();
          this.adapter.visitRendered(this);
        });
      }
    }
    // Fetch request delegate
    prepareRequest(request) {
      if (this.acceptsStreamResponse) {
        request.acceptResponseType(StreamMessage.contentType);
      }
    }
    requestStarted() {
      this.startRequest();
    }
    requestPreventedHandlingResponse(_request, _response) {
    }
    async requestSucceededWithResponse(request, response) {
      const responseHTML = await response.responseHTML;
      const { redirected, statusCode } = response;
      if (responseHTML == void 0) {
        this.recordResponse({
          statusCode: SystemStatusCode.contentTypeMismatch,
          redirected
        });
      } else {
        this.redirectedToLocation = response.redirected ? response.location : void 0;
        this.recordResponse({ statusCode, responseHTML, redirected });
      }
    }
    async requestFailedWithResponse(request, response) {
      const responseHTML = await response.responseHTML;
      const { redirected, statusCode } = response;
      if (responseHTML == void 0) {
        this.recordResponse({
          statusCode: SystemStatusCode.contentTypeMismatch,
          redirected
        });
      } else {
        this.recordResponse({ statusCode, responseHTML, redirected });
      }
    }
    requestErrored(_request, _error) {
      this.recordResponse({
        statusCode: SystemStatusCode.networkFailure,
        redirected: false
      });
    }
    requestFinished() {
      this.finishRequest();
    }
    // Scrolling
    performScroll() {
      if (!this.scrolled && !this.view.forceReloaded && !this.view.shouldPreserveScrollPosition(this)) {
        if (this.action == "restore") {
          this.scrollToRestoredPosition() || this.scrollToAnchor() || this.view.scrollToTop();
        } else {
          this.scrollToAnchor() || this.view.scrollToTop();
        }
        if (this.isSamePage) {
          this.delegate.visitScrolledToSamePageLocation(this.view.lastRenderedLocation, this.location);
        }
        this.scrolled = true;
      }
    }
    scrollToRestoredPosition() {
      const { scrollPosition } = this.restorationData;
      if (scrollPosition) {
        this.view.scrollToPosition(scrollPosition);
        return true;
      }
    }
    scrollToAnchor() {
      const anchor = getAnchor(this.location);
      if (anchor != null) {
        this.view.scrollToAnchor(anchor);
        return true;
      }
    }
    // Instrumentation
    recordTimingMetric(metric) {
      this.timingMetrics[metric] = (/* @__PURE__ */ new Date()).getTime();
    }
    getTimingMetrics() {
      return { ...this.timingMetrics };
    }
    // Private
    getHistoryMethodForAction(action) {
      switch (action) {
        case "replace":
          return history.replaceState;
        case "advance":
        case "restore":
          return history.pushState;
      }
    }
    hasPreloadedResponse() {
      return typeof this.response == "object";
    }
    shouldIssueRequest() {
      if (this.isSamePage) {
        return false;
      } else if (this.action == "restore") {
        return !this.hasCachedSnapshot();
      } else {
        return this.willRender;
      }
    }
    cacheSnapshot() {
      if (!this.snapshotCached) {
        this.view.cacheSnapshot(this.snapshot).then((snapshot) => snapshot && this.visitCachedSnapshot(snapshot));
        this.snapshotCached = true;
      }
    }
    async render(callback) {
      this.cancelRender();
      this.frame = await nextRepaint();
      await callback();
      delete this.frame;
    }
    async renderPageSnapshot(snapshot, isPreview) {
      await this.viewTransitioner.renderChange(this.view.shouldTransitionTo(snapshot), async () => {
        await this.view.renderPage(snapshot, isPreview, this.willRender, this);
        this.performScroll();
      });
    }
    cancelRender() {
      if (this.frame) {
        cancelAnimationFrame(this.frame);
        delete this.frame;
      }
    }
  };
  function isSuccessful(statusCode) {
    return statusCode >= 200 && statusCode < 300;
  }
  __name(isSuccessful, "isSuccessful");
  var BrowserAdapter = class {
    static {
      __name(this, "BrowserAdapter");
    }
    progressBar = new ProgressBar();
    constructor(session2) {
      this.session = session2;
    }
    visitProposedToLocation(location2, options) {
      if (locationIsVisitable(location2, this.navigator.rootLocation)) {
        this.navigator.startVisit(location2, options?.restorationIdentifier || uuid(), options);
      } else {
        window.location.href = location2.toString();
      }
    }
    visitStarted(visit2) {
      this.location = visit2.location;
      visit2.loadCachedSnapshot();
      visit2.issueRequest();
      visit2.goToSamePageAnchor();
    }
    visitRequestStarted(visit2) {
      this.progressBar.setValue(0);
      if (visit2.hasCachedSnapshot() || visit2.action != "restore") {
        this.showVisitProgressBarAfterDelay();
      } else {
        this.showProgressBar();
      }
    }
    visitRequestCompleted(visit2) {
      visit2.loadResponse();
    }
    visitRequestFailedWithStatusCode(visit2, statusCode) {
      switch (statusCode) {
        case SystemStatusCode.networkFailure:
        case SystemStatusCode.timeoutFailure:
        case SystemStatusCode.contentTypeMismatch:
          return this.reload({
            reason: "request_failed",
            context: {
              statusCode
            }
          });
        default:
          return visit2.loadResponse();
      }
    }
    visitRequestFinished(_visit) {
    }
    visitCompleted(_visit) {
      this.progressBar.setValue(1);
      this.hideVisitProgressBar();
    }
    pageInvalidated(reason) {
      this.reload(reason);
    }
    visitFailed(_visit) {
      this.progressBar.setValue(1);
      this.hideVisitProgressBar();
    }
    visitRendered(_visit) {
    }
    // Form Submission Delegate
    formSubmissionStarted(_formSubmission) {
      this.progressBar.setValue(0);
      this.showFormProgressBarAfterDelay();
    }
    formSubmissionFinished(_formSubmission) {
      this.progressBar.setValue(1);
      this.hideFormProgressBar();
    }
    // Private
    showVisitProgressBarAfterDelay() {
      this.visitProgressBarTimeout = window.setTimeout(this.showProgressBar, this.session.progressBarDelay);
    }
    hideVisitProgressBar() {
      this.progressBar.hide();
      if (this.visitProgressBarTimeout != null) {
        window.clearTimeout(this.visitProgressBarTimeout);
        delete this.visitProgressBarTimeout;
      }
    }
    showFormProgressBarAfterDelay() {
      if (this.formProgressBarTimeout == null) {
        this.formProgressBarTimeout = window.setTimeout(this.showProgressBar, this.session.progressBarDelay);
      }
    }
    hideFormProgressBar() {
      this.progressBar.hide();
      if (this.formProgressBarTimeout != null) {
        window.clearTimeout(this.formProgressBarTimeout);
        delete this.formProgressBarTimeout;
      }
    }
    showProgressBar = () => {
      this.progressBar.show();
    };
    reload(reason) {
      dispatch("turbo:reload", { detail: reason });
      window.location.href = this.location?.toString() || window.location.href;
    }
    get navigator() {
      return this.session.navigator;
    }
  };
  var CacheObserver = class {
    static {
      __name(this, "CacheObserver");
    }
    selector = "[data-turbo-temporary]";
    deprecatedSelector = "[data-turbo-cache=false]";
    started = false;
    start() {
      if (!this.started) {
        this.started = true;
        addEventListener("turbo:before-cache", this.removeTemporaryElements, false);
      }
    }
    stop() {
      if (this.started) {
        this.started = false;
        removeEventListener("turbo:before-cache", this.removeTemporaryElements, false);
      }
    }
    removeTemporaryElements = (_event) => {
      for (const element of this.temporaryElements) {
        element.remove();
      }
    };
    get temporaryElements() {
      return [...document.querySelectorAll(this.selector), ...this.temporaryElementsWithDeprecation];
    }
    get temporaryElementsWithDeprecation() {
      const elements = document.querySelectorAll(this.deprecatedSelector);
      if (elements.length) {
        console.warn(
          `The ${this.deprecatedSelector} selector is deprecated and will be removed in a future version. Use ${this.selector} instead.`
        );
      }
      return [...elements];
    }
  };
  var FrameRedirector = class {
    static {
      __name(this, "FrameRedirector");
    }
    constructor(session2, element) {
      this.session = session2;
      this.element = element;
      this.linkInterceptor = new LinkInterceptor(this, element);
      this.formSubmitObserver = new FormSubmitObserver(this, element);
    }
    start() {
      this.linkInterceptor.start();
      this.formSubmitObserver.start();
    }
    stop() {
      this.linkInterceptor.stop();
      this.formSubmitObserver.stop();
    }
    // Link interceptor delegate
    shouldInterceptLinkClick(element, _location, _event) {
      return this.#shouldRedirect(element);
    }
    linkClickIntercepted(element, url, event) {
      const frame = this.#findFrameElement(element);
      if (frame) {
        frame.delegate.linkClickIntercepted(element, url, event);
      }
    }
    // Form submit observer delegate
    willSubmitForm(element, submitter) {
      return element.closest("turbo-frame") == null && this.#shouldSubmit(element, submitter) && this.#shouldRedirect(element, submitter);
    }
    formSubmitted(element, submitter) {
      const frame = this.#findFrameElement(element, submitter);
      if (frame) {
        frame.delegate.formSubmitted(element, submitter);
      }
    }
    #shouldSubmit(form, submitter) {
      const action = getAction$1(form, submitter);
      const meta = this.element.ownerDocument.querySelector(`meta[name="turbo-root"]`);
      const rootLocation = expandURL(meta?.content ?? "/");
      return this.#shouldRedirect(form, submitter) && locationIsVisitable(action, rootLocation);
    }
    #shouldRedirect(element, submitter) {
      const isNavigatable = element instanceof HTMLFormElement ? this.session.submissionIsNavigatable(element, submitter) : this.session.elementIsNavigatable(element);
      if (isNavigatable) {
        const frame = this.#findFrameElement(element, submitter);
        return frame ? frame != element.closest("turbo-frame") : false;
      } else {
        return false;
      }
    }
    #findFrameElement(element, submitter) {
      const id = submitter?.getAttribute("data-turbo-frame") || element.getAttribute("data-turbo-frame");
      if (id && id != "_top") {
        const frame = this.element.querySelector(`#${id}:not([disabled])`);
        if (frame instanceof FrameElement) {
          return frame;
        }
      }
    }
  };
  var History = class {
    static {
      __name(this, "History");
    }
    location;
    restorationIdentifier = uuid();
    restorationData = {};
    started = false;
    pageLoaded = false;
    currentIndex = 0;
    constructor(delegate) {
      this.delegate = delegate;
    }
    start() {
      if (!this.started) {
        addEventListener("popstate", this.onPopState, false);
        addEventListener("load", this.onPageLoad, false);
        this.currentIndex = history.state?.turbo?.restorationIndex || 0;
        this.started = true;
        this.replace(new URL(window.location.href));
      }
    }
    stop() {
      if (this.started) {
        removeEventListener("popstate", this.onPopState, false);
        removeEventListener("load", this.onPageLoad, false);
        this.started = false;
      }
    }
    push(location2, restorationIdentifier) {
      this.update(history.pushState, location2, restorationIdentifier);
    }
    replace(location2, restorationIdentifier) {
      this.update(history.replaceState, location2, restorationIdentifier);
    }
    update(method, location2, restorationIdentifier = uuid()) {
      if (method === history.pushState)
        ++this.currentIndex;
      const state = { turbo: { restorationIdentifier, restorationIndex: this.currentIndex } };
      method.call(history, state, "", location2.href);
      this.location = location2;
      this.restorationIdentifier = restorationIdentifier;
    }
    // Restoration data
    getRestorationDataForIdentifier(restorationIdentifier) {
      return this.restorationData[restorationIdentifier] || {};
    }
    updateRestorationData(additionalData) {
      const { restorationIdentifier } = this;
      const restorationData = this.restorationData[restorationIdentifier];
      this.restorationData[restorationIdentifier] = {
        ...restorationData,
        ...additionalData
      };
    }
    // Scroll restoration
    assumeControlOfScrollRestoration() {
      if (!this.previousScrollRestoration) {
        this.previousScrollRestoration = history.scrollRestoration ?? "auto";
        history.scrollRestoration = "manual";
      }
    }
    relinquishControlOfScrollRestoration() {
      if (this.previousScrollRestoration) {
        history.scrollRestoration = this.previousScrollRestoration;
        delete this.previousScrollRestoration;
      }
    }
    // Event handlers
    onPopState = (event) => {
      if (this.shouldHandlePopState()) {
        const { turbo } = event.state || {};
        if (turbo) {
          this.location = new URL(window.location.href);
          const { restorationIdentifier, restorationIndex } = turbo;
          this.restorationIdentifier = restorationIdentifier;
          const direction = restorationIndex > this.currentIndex ? "forward" : "back";
          this.delegate.historyPoppedToLocationWithRestorationIdentifierAndDirection(this.location, restorationIdentifier, direction);
          this.currentIndex = restorationIndex;
        }
      }
    };
    onPageLoad = async (_event) => {
      await nextMicrotask();
      this.pageLoaded = true;
    };
    // Private
    shouldHandlePopState() {
      return this.pageIsLoaded();
    }
    pageIsLoaded() {
      return this.pageLoaded || document.readyState == "complete";
    }
  };
  var LinkPrefetchObserver = class {
    static {
      __name(this, "LinkPrefetchObserver");
    }
    started = false;
    #prefetchedLink = null;
    constructor(delegate, eventTarget) {
      this.delegate = delegate;
      this.eventTarget = eventTarget;
    }
    start() {
      if (this.started)
        return;
      if (this.eventTarget.readyState === "loading") {
        this.eventTarget.addEventListener("DOMContentLoaded", this.#enable, { once: true });
      } else {
        this.#enable();
      }
    }
    stop() {
      if (!this.started)
        return;
      this.eventTarget.removeEventListener("mouseenter", this.#tryToPrefetchRequest, {
        capture: true,
        passive: true
      });
      this.eventTarget.removeEventListener("mouseleave", this.#cancelRequestIfObsolete, {
        capture: true,
        passive: true
      });
      this.eventTarget.removeEventListener("turbo:before-fetch-request", this.#tryToUsePrefetchedRequest, true);
      this.started = false;
    }
    #enable = () => {
      this.eventTarget.addEventListener("mouseenter", this.#tryToPrefetchRequest, {
        capture: true,
        passive: true
      });
      this.eventTarget.addEventListener("mouseleave", this.#cancelRequestIfObsolete, {
        capture: true,
        passive: true
      });
      this.eventTarget.addEventListener("turbo:before-fetch-request", this.#tryToUsePrefetchedRequest, true);
      this.started = true;
    };
    #tryToPrefetchRequest = (event) => {
      if (getMetaContent("turbo-prefetch") === "false")
        return;
      const target = event.target;
      const isLink = target.matches && target.matches("a[href]:not([target^=_]):not([download])");
      if (isLink && this.#isPrefetchable(target)) {
        const link = target;
        const location2 = getLocationForLink(link);
        if (this.delegate.canPrefetchRequestToLocation(link, location2)) {
          this.#prefetchedLink = link;
          const fetchRequest = new FetchRequest(
            this,
            FetchMethod.get,
            location2,
            new URLSearchParams(),
            target
          );
          prefetchCache.setLater(location2.toString(), fetchRequest, this.#cacheTtl);
        }
      }
    };
    #cancelRequestIfObsolete = (event) => {
      if (event.target === this.#prefetchedLink)
        this.#cancelPrefetchRequest();
    };
    #cancelPrefetchRequest = () => {
      prefetchCache.clear();
      this.#prefetchedLink = null;
    };
    #tryToUsePrefetchedRequest = (event) => {
      if (event.target.tagName !== "FORM" && event.detail.fetchOptions.method === "get") {
        const cached = prefetchCache.get(event.detail.url.toString());
        if (cached) {
          event.detail.fetchRequest = cached;
        }
        prefetchCache.clear();
      }
    };
    prepareRequest(request) {
      const link = request.target;
      request.headers["X-Sec-Purpose"] = "prefetch";
      const turboFrame = link.closest("turbo-frame");
      const turboFrameTarget = link.getAttribute("data-turbo-frame") || turboFrame?.getAttribute("target") || turboFrame?.id;
      if (turboFrameTarget && turboFrameTarget !== "_top") {
        request.headers["Turbo-Frame"] = turboFrameTarget;
      }
    }
    // Fetch request interface
    requestSucceededWithResponse() {
    }
    requestStarted(fetchRequest) {
    }
    requestErrored(fetchRequest) {
    }
    requestFinished(fetchRequest) {
    }
    requestPreventedHandlingResponse(fetchRequest, fetchResponse) {
    }
    requestFailedWithResponse(fetchRequest, fetchResponse) {
    }
    get #cacheTtl() {
      return Number(getMetaContent("turbo-prefetch-cache-time")) || cacheTtl;
    }
    #isPrefetchable(link) {
      const href = link.getAttribute("href");
      if (!href)
        return false;
      if (unfetchableLink(link))
        return false;
      if (linkToTheSamePage(link))
        return false;
      if (linkOptsOut(link))
        return false;
      if (nonSafeLink(link))
        return false;
      if (eventPrevented(link))
        return false;
      return true;
    }
  };
  var unfetchableLink = /* @__PURE__ */ __name((link) => {
    return link.origin !== document.location.origin || !["http:", "https:"].includes(link.protocol) || link.hasAttribute("target");
  }, "unfetchableLink");
  var linkToTheSamePage = /* @__PURE__ */ __name((link) => {
    return link.pathname + link.search === document.location.pathname + document.location.search || link.href.startsWith("#");
  }, "linkToTheSamePage");
  var linkOptsOut = /* @__PURE__ */ __name((link) => {
    if (link.getAttribute("data-turbo-prefetch") === "false")
      return true;
    if (link.getAttribute("data-turbo") === "false")
      return true;
    const turboPrefetchParent = findClosestRecursively(link, "[data-turbo-prefetch]");
    if (turboPrefetchParent && turboPrefetchParent.getAttribute("data-turbo-prefetch") === "false")
      return true;
    return false;
  }, "linkOptsOut");
  var nonSafeLink = /* @__PURE__ */ __name((link) => {
    const turboMethod = link.getAttribute("data-turbo-method");
    if (turboMethod && turboMethod.toLowerCase() !== "get")
      return true;
    if (isUJS(link))
      return true;
    if (link.hasAttribute("data-turbo-confirm"))
      return true;
    if (link.hasAttribute("data-turbo-stream"))
      return true;
    return false;
  }, "nonSafeLink");
  var isUJS = /* @__PURE__ */ __name((link) => {
    return link.hasAttribute("data-remote") || link.hasAttribute("data-behavior") || link.hasAttribute("data-confirm") || link.hasAttribute("data-method");
  }, "isUJS");
  var eventPrevented = /* @__PURE__ */ __name((link) => {
    const event = dispatch("turbo:before-prefetch", { target: link, cancelable: true });
    return event.defaultPrevented;
  }, "eventPrevented");
  var Navigator = class {
    static {
      __name(this, "Navigator");
    }
    constructor(delegate) {
      this.delegate = delegate;
    }
    proposeVisit(location2, options = {}) {
      if (this.delegate.allowsVisitingLocationWithAction(location2, options.action)) {
        this.delegate.visitProposedToLocation(location2, options);
      }
    }
    startVisit(locatable, restorationIdentifier, options = {}) {
      this.stop();
      this.currentVisit = new Visit(this, expandURL(locatable), restorationIdentifier, {
        referrer: this.location,
        ...options
      });
      this.currentVisit.start();
    }
    submitForm(form, submitter) {
      this.stop();
      this.formSubmission = new FormSubmission(this, form, submitter, true);
      this.formSubmission.start();
    }
    stop() {
      if (this.formSubmission) {
        this.formSubmission.stop();
        delete this.formSubmission;
      }
      if (this.currentVisit) {
        this.currentVisit.cancel();
        delete this.currentVisit;
      }
    }
    get adapter() {
      return this.delegate.adapter;
    }
    get view() {
      return this.delegate.view;
    }
    get rootLocation() {
      return this.view.snapshot.rootLocation;
    }
    get history() {
      return this.delegate.history;
    }
    // Form submission delegate
    formSubmissionStarted(formSubmission) {
      if (typeof this.adapter.formSubmissionStarted === "function") {
        this.adapter.formSubmissionStarted(formSubmission);
      }
    }
    async formSubmissionSucceededWithResponse(formSubmission, fetchResponse) {
      if (formSubmission == this.formSubmission) {
        const responseHTML = await fetchResponse.responseHTML;
        if (responseHTML) {
          const shouldCacheSnapshot = formSubmission.isSafe;
          if (!shouldCacheSnapshot) {
            this.view.clearSnapshotCache();
          }
          const { statusCode, redirected } = fetchResponse;
          const action = this.#getActionForFormSubmission(formSubmission, fetchResponse);
          const visitOptions = {
            action,
            shouldCacheSnapshot,
            response: { statusCode, responseHTML, redirected }
          };
          this.proposeVisit(fetchResponse.location, visitOptions);
        }
      }
    }
    async formSubmissionFailedWithResponse(formSubmission, fetchResponse) {
      const responseHTML = await fetchResponse.responseHTML;
      if (responseHTML) {
        const snapshot = PageSnapshot.fromHTMLString(responseHTML);
        if (fetchResponse.serverError) {
          await this.view.renderError(snapshot, this.currentVisit);
        } else {
          await this.view.renderPage(snapshot, false, true, this.currentVisit);
        }
        if (!snapshot.shouldPreserveScrollPosition) {
          this.view.scrollToTop();
        }
        this.view.clearSnapshotCache();
      }
    }
    formSubmissionErrored(formSubmission, error) {
      console.error(error);
    }
    formSubmissionFinished(formSubmission) {
      if (typeof this.adapter.formSubmissionFinished === "function") {
        this.adapter.formSubmissionFinished(formSubmission);
      }
    }
    // Visit delegate
    visitStarted(visit2) {
      this.delegate.visitStarted(visit2);
    }
    visitCompleted(visit2) {
      this.delegate.visitCompleted(visit2);
    }
    locationWithActionIsSamePage(location2, action) {
      const anchor = getAnchor(location2);
      const currentAnchor = getAnchor(this.view.lastRenderedLocation);
      const isRestorationToTop = action === "restore" && typeof anchor === "undefined";
      return action !== "replace" && getRequestURL(location2) === getRequestURL(this.view.lastRenderedLocation) && (isRestorationToTop || anchor != null && anchor !== currentAnchor);
    }
    visitScrolledToSamePageLocation(oldURL, newURL) {
      this.delegate.visitScrolledToSamePageLocation(oldURL, newURL);
    }
    // Visits
    get location() {
      return this.history.location;
    }
    get restorationIdentifier() {
      return this.history.restorationIdentifier;
    }
    #getActionForFormSubmission(formSubmission, fetchResponse) {
      const { submitter, formElement } = formSubmission;
      return getVisitAction(submitter, formElement) || this.#getDefaultAction(fetchResponse);
    }
    #getDefaultAction(fetchResponse) {
      const sameLocationRedirect = fetchResponse.redirected && fetchResponse.location.href === this.location?.href;
      return sameLocationRedirect ? "replace" : "advance";
    }
  };
  var PageStage = {
    initial: 0,
    loading: 1,
    interactive: 2,
    complete: 3
  };
  var PageObserver = class {
    static {
      __name(this, "PageObserver");
    }
    stage = PageStage.initial;
    started = false;
    constructor(delegate) {
      this.delegate = delegate;
    }
    start() {
      if (!this.started) {
        if (this.stage == PageStage.initial) {
          this.stage = PageStage.loading;
        }
        document.addEventListener("readystatechange", this.interpretReadyState, false);
        addEventListener("pagehide", this.pageWillUnload, false);
        this.started = true;
      }
    }
    stop() {
      if (this.started) {
        document.removeEventListener("readystatechange", this.interpretReadyState, false);
        removeEventListener("pagehide", this.pageWillUnload, false);
        this.started = false;
      }
    }
    interpretReadyState = () => {
      const { readyState } = this;
      if (readyState == "interactive") {
        this.pageIsInteractive();
      } else if (readyState == "complete") {
        this.pageIsComplete();
      }
    };
    pageIsInteractive() {
      if (this.stage == PageStage.loading) {
        this.stage = PageStage.interactive;
        this.delegate.pageBecameInteractive();
      }
    }
    pageIsComplete() {
      this.pageIsInteractive();
      if (this.stage == PageStage.interactive) {
        this.stage = PageStage.complete;
        this.delegate.pageLoaded();
      }
    }
    pageWillUnload = () => {
      this.delegate.pageWillUnload();
    };
    get readyState() {
      return document.readyState;
    }
  };
  var ScrollObserver = class {
    static {
      __name(this, "ScrollObserver");
    }
    started = false;
    constructor(delegate) {
      this.delegate = delegate;
    }
    start() {
      if (!this.started) {
        addEventListener("scroll", this.onScroll, false);
        this.onScroll();
        this.started = true;
      }
    }
    stop() {
      if (this.started) {
        removeEventListener("scroll", this.onScroll, false);
        this.started = false;
      }
    }
    onScroll = () => {
      this.updatePosition({ x: window.pageXOffset, y: window.pageYOffset });
    };
    // Private
    updatePosition(position) {
      this.delegate.scrollPositionChanged(position);
    }
  };
  var StreamMessageRenderer = class {
    static {
      __name(this, "StreamMessageRenderer");
    }
    render({ fragment }) {
      Bardo.preservingPermanentElements(this, getPermanentElementMapForFragment(fragment), () => {
        withAutofocusFromFragment(fragment, () => {
          withPreservedFocus(() => {
            document.documentElement.appendChild(fragment);
          });
        });
      });
    }
    // Bardo delegate
    enteringBardo(currentPermanentElement, newPermanentElement) {
      newPermanentElement.replaceWith(currentPermanentElement.cloneNode(true));
    }
    leavingBardo() {
    }
  };
  function getPermanentElementMapForFragment(fragment) {
    const permanentElementsInDocument = queryPermanentElementsAll(document.documentElement);
    const permanentElementMap = {};
    for (const permanentElementInDocument of permanentElementsInDocument) {
      const { id } = permanentElementInDocument;
      for (const streamElement of fragment.querySelectorAll("turbo-stream")) {
        const elementInStream = getPermanentElementById(streamElement.templateElement.content, id);
        if (elementInStream) {
          permanentElementMap[id] = [permanentElementInDocument, elementInStream];
        }
      }
    }
    return permanentElementMap;
  }
  __name(getPermanentElementMapForFragment, "getPermanentElementMapForFragment");
  async function withAutofocusFromFragment(fragment, callback) {
    const generatedID = `turbo-stream-autofocus-${uuid()}`;
    const turboStreams = fragment.querySelectorAll("turbo-stream");
    const elementWithAutofocus = firstAutofocusableElementInStreams(turboStreams);
    let willAutofocusId = null;
    if (elementWithAutofocus) {
      if (elementWithAutofocus.id) {
        willAutofocusId = elementWithAutofocus.id;
      } else {
        willAutofocusId = generatedID;
      }
      elementWithAutofocus.id = willAutofocusId;
    }
    callback();
    await nextRepaint();
    const hasNoActiveElement = document.activeElement == null || document.activeElement == document.body;
    if (hasNoActiveElement && willAutofocusId) {
      const elementToAutofocus = document.getElementById(willAutofocusId);
      if (elementIsFocusable(elementToAutofocus)) {
        elementToAutofocus.focus();
      }
      if (elementToAutofocus && elementToAutofocus.id == generatedID) {
        elementToAutofocus.removeAttribute("id");
      }
    }
  }
  __name(withAutofocusFromFragment, "withAutofocusFromFragment");
  async function withPreservedFocus(callback) {
    const [activeElementBeforeRender, activeElementAfterRender] = await around(callback, () => document.activeElement);
    const restoreFocusTo = activeElementBeforeRender && activeElementBeforeRender.id;
    if (restoreFocusTo) {
      const elementToFocus = document.getElementById(restoreFocusTo);
      if (elementIsFocusable(elementToFocus) && elementToFocus != activeElementAfterRender) {
        elementToFocus.focus();
      }
    }
  }
  __name(withPreservedFocus, "withPreservedFocus");
  function firstAutofocusableElementInStreams(nodeListOfStreamElements) {
    for (const streamElement of nodeListOfStreamElements) {
      const elementWithAutofocus = queryAutofocusableElement(streamElement.templateElement.content);
      if (elementWithAutofocus)
        return elementWithAutofocus;
    }
    return null;
  }
  __name(firstAutofocusableElementInStreams, "firstAutofocusableElementInStreams");
  var StreamObserver = class {
    static {
      __name(this, "StreamObserver");
    }
    sources = /* @__PURE__ */ new Set();
    #started = false;
    constructor(delegate) {
      this.delegate = delegate;
    }
    start() {
      if (!this.#started) {
        this.#started = true;
        addEventListener("turbo:before-fetch-response", this.inspectFetchResponse, false);
      }
    }
    stop() {
      if (this.#started) {
        this.#started = false;
        removeEventListener("turbo:before-fetch-response", this.inspectFetchResponse, false);
      }
    }
    connectStreamSource(source) {
      if (!this.streamSourceIsConnected(source)) {
        this.sources.add(source);
        source.addEventListener("message", this.receiveMessageEvent, false);
      }
    }
    disconnectStreamSource(source) {
      if (this.streamSourceIsConnected(source)) {
        this.sources.delete(source);
        source.removeEventListener("message", this.receiveMessageEvent, false);
      }
    }
    streamSourceIsConnected(source) {
      return this.sources.has(source);
    }
    inspectFetchResponse = (event) => {
      const response = fetchResponseFromEvent(event);
      if (response && fetchResponseIsStream(response)) {
        event.preventDefault();
        this.receiveMessageResponse(response);
      }
    };
    receiveMessageEvent = (event) => {
      if (this.#started && typeof event.data == "string") {
        this.receiveMessageHTML(event.data);
      }
    };
    async receiveMessageResponse(response) {
      const html = await response.responseHTML;
      if (html) {
        this.receiveMessageHTML(html);
      }
    }
    receiveMessageHTML(html) {
      this.delegate.receivedMessageFromStream(StreamMessage.wrap(html));
    }
  };
  function fetchResponseFromEvent(event) {
    const fetchResponse = event.detail?.fetchResponse;
    if (fetchResponse instanceof FetchResponse) {
      return fetchResponse;
    }
  }
  __name(fetchResponseFromEvent, "fetchResponseFromEvent");
  function fetchResponseIsStream(response) {
    const contentType = response.contentType ?? "";
    return contentType.startsWith(StreamMessage.contentType);
  }
  __name(fetchResponseIsStream, "fetchResponseIsStream");
  var ErrorRenderer = class extends Renderer {
    static {
      __name(this, "ErrorRenderer");
    }
    static renderElement(currentElement, newElement) {
      const { documentElement, body } = document;
      documentElement.replaceChild(newElement, body);
    }
    async render() {
      this.replaceHeadAndBody();
      this.activateScriptElements();
    }
    replaceHeadAndBody() {
      const { documentElement, head } = document;
      documentElement.replaceChild(this.newHead, head);
      this.renderElement(this.currentElement, this.newElement);
    }
    activateScriptElements() {
      for (const replaceableElement of this.scriptElements) {
        const parentNode = replaceableElement.parentNode;
        if (parentNode) {
          const element = activateScriptElement(replaceableElement);
          parentNode.replaceChild(element, replaceableElement);
        }
      }
    }
    get newHead() {
      return this.newSnapshot.headSnapshot.element;
    }
    get scriptElements() {
      return document.documentElement.querySelectorAll("script");
    }
  };
  var Idiomorph = /* @__PURE__ */ function() {
    let EMPTY_SET = /* @__PURE__ */ new Set();
    let defaults4 = {
      morphStyle: "outerHTML",
      callbacks: {
        beforeNodeAdded: noOp,
        afterNodeAdded: noOp,
        beforeNodeMorphed: noOp,
        afterNodeMorphed: noOp,
        beforeNodeRemoved: noOp,
        afterNodeRemoved: noOp,
        beforeAttributeUpdated: noOp
      },
      head: {
        style: "merge",
        shouldPreserve: function(elt) {
          return elt.getAttribute("im-preserve") === "true";
        },
        shouldReAppend: function(elt) {
          return elt.getAttribute("im-re-append") === "true";
        },
        shouldRemove: noOp,
        afterHeadMorphed: noOp
      }
    };
    function morph(oldNode, newContent, config4 = {}) {
      if (oldNode instanceof Document) {
        oldNode = oldNode.documentElement;
      }
      if (typeof newContent === "string") {
        newContent = parseContent(newContent);
      }
      let normalizedContent = normalizeContent(newContent);
      let ctx = createMorphContext(oldNode, normalizedContent, config4);
      return morphNormalizedContent(oldNode, normalizedContent, ctx);
    }
    __name(morph, "morph");
    function morphNormalizedContent(oldNode, normalizedNewContent, ctx) {
      if (ctx.head.block) {
        let oldHead = oldNode.querySelector("head");
        let newHead = normalizedNewContent.querySelector("head");
        if (oldHead && newHead) {
          let promises = handleHeadElement(newHead, oldHead, ctx);
          Promise.all(promises).then(function() {
            morphNormalizedContent(oldNode, normalizedNewContent, Object.assign(ctx, {
              head: {
                block: false,
                ignore: true
              }
            }));
          });
          return;
        }
      }
      if (ctx.morphStyle === "innerHTML") {
        morphChildren(normalizedNewContent, oldNode, ctx);
        return oldNode.children;
      } else if (ctx.morphStyle === "outerHTML" || ctx.morphStyle == null) {
        let bestMatch = findBestNodeMatch(normalizedNewContent, oldNode, ctx);
        let previousSibling = bestMatch?.previousSibling;
        let nextSibling = bestMatch?.nextSibling;
        let morphedNode = morphOldNodeTo(oldNode, bestMatch, ctx);
        if (bestMatch) {
          return insertSiblings(previousSibling, morphedNode, nextSibling);
        } else {
          return [];
        }
      } else {
        throw "Do not understand how to morph style " + ctx.morphStyle;
      }
    }
    __name(morphNormalizedContent, "morphNormalizedContent");
    function ignoreValueOfActiveElement(possibleActiveElement, ctx) {
      return ctx.ignoreActiveValue && possibleActiveElement === document.activeElement && possibleActiveElement !== document.body;
    }
    __name(ignoreValueOfActiveElement, "ignoreValueOfActiveElement");
    function morphOldNodeTo(oldNode, newContent, ctx) {
      if (ctx.ignoreActive && oldNode === document.activeElement)
        ;
      else if (newContent == null) {
        if (ctx.callbacks.beforeNodeRemoved(oldNode) === false)
          return oldNode;
        oldNode.remove();
        ctx.callbacks.afterNodeRemoved(oldNode);
        return null;
      } else if (!isSoftMatch(oldNode, newContent)) {
        if (ctx.callbacks.beforeNodeRemoved(oldNode) === false)
          return oldNode;
        if (ctx.callbacks.beforeNodeAdded(newContent) === false)
          return oldNode;
        oldNode.parentElement.replaceChild(newContent, oldNode);
        ctx.callbacks.afterNodeAdded(newContent);
        ctx.callbacks.afterNodeRemoved(oldNode);
        return newContent;
      } else {
        if (ctx.callbacks.beforeNodeMorphed(oldNode, newContent) === false)
          return oldNode;
        if (oldNode instanceof HTMLHeadElement && ctx.head.ignore)
          ;
        else if (oldNode instanceof HTMLHeadElement && ctx.head.style !== "morph") {
          handleHeadElement(newContent, oldNode, ctx);
        } else {
          syncNodeFrom(newContent, oldNode, ctx);
          if (!ignoreValueOfActiveElement(oldNode, ctx)) {
            morphChildren(newContent, oldNode, ctx);
          }
        }
        ctx.callbacks.afterNodeMorphed(oldNode, newContent);
        return oldNode;
      }
    }
    __name(morphOldNodeTo, "morphOldNodeTo");
    function morphChildren(newParent, oldParent, ctx) {
      let nextNewChild = newParent.firstChild;
      let insertionPoint = oldParent.firstChild;
      let newChild;
      while (nextNewChild) {
        newChild = nextNewChild;
        nextNewChild = newChild.nextSibling;
        if (insertionPoint == null) {
          if (ctx.callbacks.beforeNodeAdded(newChild) === false)
            return;
          oldParent.appendChild(newChild);
          ctx.callbacks.afterNodeAdded(newChild);
          removeIdsFromConsideration(ctx, newChild);
          continue;
        }
        if (isIdSetMatch(newChild, insertionPoint, ctx)) {
          morphOldNodeTo(insertionPoint, newChild, ctx);
          insertionPoint = insertionPoint.nextSibling;
          removeIdsFromConsideration(ctx, newChild);
          continue;
        }
        let idSetMatch = findIdSetMatch(newParent, oldParent, newChild, insertionPoint, ctx);
        if (idSetMatch) {
          insertionPoint = removeNodesBetween(insertionPoint, idSetMatch, ctx);
          morphOldNodeTo(idSetMatch, newChild, ctx);
          removeIdsFromConsideration(ctx, newChild);
          continue;
        }
        let softMatch = findSoftMatch(newParent, oldParent, newChild, insertionPoint, ctx);
        if (softMatch) {
          insertionPoint = removeNodesBetween(insertionPoint, softMatch, ctx);
          morphOldNodeTo(softMatch, newChild, ctx);
          removeIdsFromConsideration(ctx, newChild);
          continue;
        }
        if (ctx.callbacks.beforeNodeAdded(newChild) === false)
          return;
        oldParent.insertBefore(newChild, insertionPoint);
        ctx.callbacks.afterNodeAdded(newChild);
        removeIdsFromConsideration(ctx, newChild);
      }
      while (insertionPoint !== null) {
        let tempNode = insertionPoint;
        insertionPoint = insertionPoint.nextSibling;
        removeNode(tempNode, ctx);
      }
    }
    __name(morphChildren, "morphChildren");
    function ignoreAttribute(attr, to, updateType, ctx) {
      if (attr === "value" && ctx.ignoreActiveValue && to === document.activeElement) {
        return true;
      }
      return ctx.callbacks.beforeAttributeUpdated(attr, to, updateType) === false;
    }
    __name(ignoreAttribute, "ignoreAttribute");
    function syncNodeFrom(from, to, ctx) {
      let type = from.nodeType;
      if (type === 1) {
        const fromAttributes = from.attributes;
        const toAttributes = to.attributes;
        for (const fromAttribute of fromAttributes) {
          if (ignoreAttribute(fromAttribute.name, to, "update", ctx)) {
            continue;
          }
          if (to.getAttribute(fromAttribute.name) !== fromAttribute.value) {
            to.setAttribute(fromAttribute.name, fromAttribute.value);
          }
        }
        for (let i3 = toAttributes.length - 1; 0 <= i3; i3--) {
          const toAttribute = toAttributes[i3];
          if (ignoreAttribute(toAttribute.name, to, "remove", ctx)) {
            continue;
          }
          if (!from.hasAttribute(toAttribute.name)) {
            to.removeAttribute(toAttribute.name);
          }
        }
      }
      if (type === 8 || type === 3) {
        if (to.nodeValue !== from.nodeValue) {
          to.nodeValue = from.nodeValue;
        }
      }
      if (!ignoreValueOfActiveElement(to, ctx)) {
        syncInputValue(from, to, ctx);
      }
    }
    __name(syncNodeFrom, "syncNodeFrom");
    function syncBooleanAttribute(from, to, attributeName, ctx) {
      if (from[attributeName] !== to[attributeName]) {
        let ignoreUpdate = ignoreAttribute(attributeName, to, "update", ctx);
        if (!ignoreUpdate) {
          to[attributeName] = from[attributeName];
        }
        if (from[attributeName]) {
          if (!ignoreUpdate) {
            to.setAttribute(attributeName, from[attributeName]);
          }
        } else {
          if (!ignoreAttribute(attributeName, to, "remove", ctx)) {
            to.removeAttribute(attributeName);
          }
        }
      }
    }
    __name(syncBooleanAttribute, "syncBooleanAttribute");
    function syncInputValue(from, to, ctx) {
      if (from instanceof HTMLInputElement && to instanceof HTMLInputElement && from.type !== "file") {
        let fromValue = from.value;
        let toValue = to.value;
        syncBooleanAttribute(from, to, "checked", ctx);
        syncBooleanAttribute(from, to, "disabled", ctx);
        if (!from.hasAttribute("value")) {
          if (!ignoreAttribute("value", to, "remove", ctx)) {
            to.value = "";
            to.removeAttribute("value");
          }
        } else if (fromValue !== toValue) {
          if (!ignoreAttribute("value", to, "update", ctx)) {
            to.setAttribute("value", fromValue);
            to.value = fromValue;
          }
        }
      } else if (from instanceof HTMLOptionElement) {
        syncBooleanAttribute(from, to, "selected", ctx);
      } else if (from instanceof HTMLTextAreaElement && to instanceof HTMLTextAreaElement) {
        let fromValue = from.value;
        let toValue = to.value;
        if (ignoreAttribute("value", to, "update", ctx)) {
          return;
        }
        if (fromValue !== toValue) {
          to.value = fromValue;
        }
        if (to.firstChild && to.firstChild.nodeValue !== fromValue) {
          to.firstChild.nodeValue = fromValue;
        }
      }
    }
    __name(syncInputValue, "syncInputValue");
    function handleHeadElement(newHeadTag, currentHead, ctx) {
      let added = [];
      let removed = [];
      let preserved = [];
      let nodesToAppend = [];
      let headMergeStyle = ctx.head.style;
      let srcToNewHeadNodes = /* @__PURE__ */ new Map();
      for (const newHeadChild of newHeadTag.children) {
        srcToNewHeadNodes.set(newHeadChild.outerHTML, newHeadChild);
      }
      for (const currentHeadElt of currentHead.children) {
        let inNewContent = srcToNewHeadNodes.has(currentHeadElt.outerHTML);
        let isReAppended = ctx.head.shouldReAppend(currentHeadElt);
        let isPreserved = ctx.head.shouldPreserve(currentHeadElt);
        if (inNewContent || isPreserved) {
          if (isReAppended) {
            removed.push(currentHeadElt);
          } else {
            srcToNewHeadNodes.delete(currentHeadElt.outerHTML);
            preserved.push(currentHeadElt);
          }
        } else {
          if (headMergeStyle === "append") {
            if (isReAppended) {
              removed.push(currentHeadElt);
              nodesToAppend.push(currentHeadElt);
            }
          } else {
            if (ctx.head.shouldRemove(currentHeadElt) !== false) {
              removed.push(currentHeadElt);
            }
          }
        }
      }
      nodesToAppend.push(...srcToNewHeadNodes.values());
      let promises = [];
      for (const newNode of nodesToAppend) {
        let newElt = document.createRange().createContextualFragment(newNode.outerHTML).firstChild;
        if (ctx.callbacks.beforeNodeAdded(newElt) !== false) {
          if (newElt.href || newElt.src) {
            let resolve = null;
            let promise = new Promise(function(_resolve) {
              resolve = _resolve;
            });
            newElt.addEventListener("load", function() {
              resolve();
            });
            promises.push(promise);
          }
          currentHead.appendChild(newElt);
          ctx.callbacks.afterNodeAdded(newElt);
          added.push(newElt);
        }
      }
      for (const removedElement of removed) {
        if (ctx.callbacks.beforeNodeRemoved(removedElement) !== false) {
          currentHead.removeChild(removedElement);
          ctx.callbacks.afterNodeRemoved(removedElement);
        }
      }
      ctx.head.afterHeadMorphed(currentHead, { added, kept: preserved, removed });
      return promises;
    }
    __name(handleHeadElement, "handleHeadElement");
    function noOp() {
    }
    __name(noOp, "noOp");
    function mergeDefaults(config4) {
      let finalConfig = {};
      Object.assign(finalConfig, defaults4);
      Object.assign(finalConfig, config4);
      finalConfig.callbacks = {};
      Object.assign(finalConfig.callbacks, defaults4.callbacks);
      Object.assign(finalConfig.callbacks, config4.callbacks);
      finalConfig.head = {};
      Object.assign(finalConfig.head, defaults4.head);
      Object.assign(finalConfig.head, config4.head);
      return finalConfig;
    }
    __name(mergeDefaults, "mergeDefaults");
    function createMorphContext(oldNode, newContent, config4) {
      config4 = mergeDefaults(config4);
      return {
        target: oldNode,
        newContent,
        config: config4,
        morphStyle: config4.morphStyle,
        ignoreActive: config4.ignoreActive,
        ignoreActiveValue: config4.ignoreActiveValue,
        idMap: createIdMap(oldNode, newContent),
        deadIds: /* @__PURE__ */ new Set(),
        callbacks: config4.callbacks,
        head: config4.head
      };
    }
    __name(createMorphContext, "createMorphContext");
    function isIdSetMatch(node1, node2, ctx) {
      if (node1 == null || node2 == null) {
        return false;
      }
      if (node1.nodeType === node2.nodeType && node1.tagName === node2.tagName) {
        if (node1.id !== "" && node1.id === node2.id) {
          return true;
        } else {
          return getIdIntersectionCount(ctx, node1, node2) > 0;
        }
      }
      return false;
    }
    __name(isIdSetMatch, "isIdSetMatch");
    function isSoftMatch(node1, node2) {
      if (node1 == null || node2 == null) {
        return false;
      }
      return node1.nodeType === node2.nodeType && node1.tagName === node2.tagName;
    }
    __name(isSoftMatch, "isSoftMatch");
    function removeNodesBetween(startInclusive, endExclusive, ctx) {
      while (startInclusive !== endExclusive) {
        let tempNode = startInclusive;
        startInclusive = startInclusive.nextSibling;
        removeNode(tempNode, ctx);
      }
      removeIdsFromConsideration(ctx, endExclusive);
      return endExclusive.nextSibling;
    }
    __name(removeNodesBetween, "removeNodesBetween");
    function findIdSetMatch(newContent, oldParent, newChild, insertionPoint, ctx) {
      let newChildPotentialIdCount = getIdIntersectionCount(ctx, newChild, oldParent);
      let potentialMatch = null;
      if (newChildPotentialIdCount > 0) {
        let potentialMatch2 = insertionPoint;
        let otherMatchCount = 0;
        while (potentialMatch2 != null) {
          if (isIdSetMatch(newChild, potentialMatch2, ctx)) {
            return potentialMatch2;
          }
          otherMatchCount += getIdIntersectionCount(ctx, potentialMatch2, newContent);
          if (otherMatchCount > newChildPotentialIdCount) {
            return null;
          }
          potentialMatch2 = potentialMatch2.nextSibling;
        }
      }
      return potentialMatch;
    }
    __name(findIdSetMatch, "findIdSetMatch");
    function findSoftMatch(newContent, oldParent, newChild, insertionPoint, ctx) {
      let potentialSoftMatch = insertionPoint;
      let nextSibling = newChild.nextSibling;
      let siblingSoftMatchCount = 0;
      while (potentialSoftMatch != null) {
        if (getIdIntersectionCount(ctx, potentialSoftMatch, newContent) > 0) {
          return null;
        }
        if (isSoftMatch(newChild, potentialSoftMatch)) {
          return potentialSoftMatch;
        }
        if (isSoftMatch(nextSibling, potentialSoftMatch)) {
          siblingSoftMatchCount++;
          nextSibling = nextSibling.nextSibling;
          if (siblingSoftMatchCount >= 2) {
            return null;
          }
        }
        potentialSoftMatch = potentialSoftMatch.nextSibling;
      }
      return potentialSoftMatch;
    }
    __name(findSoftMatch, "findSoftMatch");
    function parseContent(newContent) {
      let parser = new DOMParser();
      let contentWithSvgsRemoved = newContent.replace(/<svg(\s[^>]*>|>)([\s\S]*?)<\/svg>/gim, "");
      if (contentWithSvgsRemoved.match(/<\/html>/) || contentWithSvgsRemoved.match(/<\/head>/) || contentWithSvgsRemoved.match(/<\/body>/)) {
        let content = parser.parseFromString(newContent, "text/html");
        if (contentWithSvgsRemoved.match(/<\/html>/)) {
          content.generatedByIdiomorph = true;
          return content;
        } else {
          let htmlElement = content.firstChild;
          if (htmlElement) {
            htmlElement.generatedByIdiomorph = true;
            return htmlElement;
          } else {
            return null;
          }
        }
      } else {
        let responseDoc = parser.parseFromString("<body><template>" + newContent + "</template></body>", "text/html");
        let content = responseDoc.body.querySelector("template").content;
        content.generatedByIdiomorph = true;
        return content;
      }
    }
    __name(parseContent, "parseContent");
    function normalizeContent(newContent) {
      if (newContent == null) {
        const dummyParent = document.createElement("div");
        return dummyParent;
      } else if (newContent.generatedByIdiomorph) {
        return newContent;
      } else if (newContent instanceof Node) {
        const dummyParent = document.createElement("div");
        dummyParent.append(newContent);
        return dummyParent;
      } else {
        const dummyParent = document.createElement("div");
        for (const elt of [...newContent]) {
          dummyParent.append(elt);
        }
        return dummyParent;
      }
    }
    __name(normalizeContent, "normalizeContent");
    function insertSiblings(previousSibling, morphedNode, nextSibling) {
      let stack = [];
      let added = [];
      while (previousSibling != null) {
        stack.push(previousSibling);
        previousSibling = previousSibling.previousSibling;
      }
      while (stack.length > 0) {
        let node = stack.pop();
        added.push(node);
        morphedNode.parentElement.insertBefore(node, morphedNode);
      }
      added.push(morphedNode);
      while (nextSibling != null) {
        stack.push(nextSibling);
        added.push(nextSibling);
        nextSibling = nextSibling.nextSibling;
      }
      while (stack.length > 0) {
        morphedNode.parentElement.insertBefore(stack.pop(), morphedNode.nextSibling);
      }
      return added;
    }
    __name(insertSiblings, "insertSiblings");
    function findBestNodeMatch(newContent, oldNode, ctx) {
      let currentElement;
      currentElement = newContent.firstChild;
      let bestElement = currentElement;
      let score = 0;
      while (currentElement) {
        let newScore = scoreElement(currentElement, oldNode, ctx);
        if (newScore > score) {
          bestElement = currentElement;
          score = newScore;
        }
        currentElement = currentElement.nextSibling;
      }
      return bestElement;
    }
    __name(findBestNodeMatch, "findBestNodeMatch");
    function scoreElement(node1, node2, ctx) {
      if (isSoftMatch(node1, node2)) {
        return 0.5 + getIdIntersectionCount(ctx, node1, node2);
      }
      return 0;
    }
    __name(scoreElement, "scoreElement");
    function removeNode(tempNode, ctx) {
      removeIdsFromConsideration(ctx, tempNode);
      if (ctx.callbacks.beforeNodeRemoved(tempNode) === false)
        return;
      tempNode.remove();
      ctx.callbacks.afterNodeRemoved(tempNode);
    }
    __name(removeNode, "removeNode");
    function isIdInConsideration(ctx, id) {
      return !ctx.deadIds.has(id);
    }
    __name(isIdInConsideration, "isIdInConsideration");
    function idIsWithinNode(ctx, id, targetNode) {
      let idSet = ctx.idMap.get(targetNode) || EMPTY_SET;
      return idSet.has(id);
    }
    __name(idIsWithinNode, "idIsWithinNode");
    function removeIdsFromConsideration(ctx, node) {
      let idSet = ctx.idMap.get(node) || EMPTY_SET;
      for (const id of idSet) {
        ctx.deadIds.add(id);
      }
    }
    __name(removeIdsFromConsideration, "removeIdsFromConsideration");
    function getIdIntersectionCount(ctx, node1, node2) {
      let sourceSet = ctx.idMap.get(node1) || EMPTY_SET;
      let matchCount = 0;
      for (const id of sourceSet) {
        if (isIdInConsideration(ctx, id) && idIsWithinNode(ctx, id, node2)) {
          ++matchCount;
        }
      }
      return matchCount;
    }
    __name(getIdIntersectionCount, "getIdIntersectionCount");
    function populateIdMapForNode(node, idMap) {
      let nodeParent = node.parentElement;
      let idElements = node.querySelectorAll("[id]");
      for (const elt of idElements) {
        let current = elt;
        while (current !== nodeParent && current != null) {
          let idSet = idMap.get(current);
          if (idSet == null) {
            idSet = /* @__PURE__ */ new Set();
            idMap.set(current, idSet);
          }
          idSet.add(elt.id);
          current = current.parentElement;
        }
      }
    }
    __name(populateIdMapForNode, "populateIdMapForNode");
    function createIdMap(oldContent, newContent) {
      let idMap = /* @__PURE__ */ new Map();
      populateIdMapForNode(oldContent, idMap);
      populateIdMapForNode(newContent, idMap);
      return idMap;
    }
    __name(createIdMap, "createIdMap");
    return {
      morph,
      defaults: defaults4
    };
  }();
  var PageRenderer = class extends Renderer {
    static {
      __name(this, "PageRenderer");
    }
    static renderElement(currentElement, newElement) {
      if (document.body && newElement instanceof HTMLBodyElement) {
        document.body.replaceWith(newElement);
      } else {
        document.documentElement.appendChild(newElement);
      }
    }
    get shouldRender() {
      return this.newSnapshot.isVisitable && this.trackedElementsAreIdentical;
    }
    get reloadReason() {
      if (!this.newSnapshot.isVisitable) {
        return {
          reason: "turbo_visit_control_is_reload"
        };
      }
      if (!this.trackedElementsAreIdentical) {
        return {
          reason: "tracked_element_mismatch"
        };
      }
    }
    async prepareToRender() {
      this.#setLanguage();
      await this.mergeHead();
    }
    async render() {
      if (this.willRender) {
        await this.replaceBody();
      }
    }
    finishRendering() {
      super.finishRendering();
      if (!this.isPreview) {
        this.focusFirstAutofocusableElement();
      }
    }
    get currentHeadSnapshot() {
      return this.currentSnapshot.headSnapshot;
    }
    get newHeadSnapshot() {
      return this.newSnapshot.headSnapshot;
    }
    get newElement() {
      return this.newSnapshot.element;
    }
    #setLanguage() {
      const { documentElement } = this.currentSnapshot;
      const { lang } = this.newSnapshot;
      if (lang) {
        documentElement.setAttribute("lang", lang);
      } else {
        documentElement.removeAttribute("lang");
      }
    }
    async mergeHead() {
      const mergedHeadElements = this.mergeProvisionalElements();
      const newStylesheetElements = this.copyNewHeadStylesheetElements();
      this.copyNewHeadScriptElements();
      await mergedHeadElements;
      await newStylesheetElements;
      if (this.willRender) {
        this.removeUnusedDynamicStylesheetElements();
      }
    }
    async replaceBody() {
      await this.preservingPermanentElements(async () => {
        this.activateNewBody();
        await this.assignNewBody();
      });
    }
    get trackedElementsAreIdentical() {
      return this.currentHeadSnapshot.trackedElementSignature == this.newHeadSnapshot.trackedElementSignature;
    }
    async copyNewHeadStylesheetElements() {
      const loadingElements = [];
      for (const element of this.newHeadStylesheetElements) {
        loadingElements.push(waitForLoad(element));
        document.head.appendChild(element);
      }
      await Promise.all(loadingElements);
    }
    copyNewHeadScriptElements() {
      for (const element of this.newHeadScriptElements) {
        document.head.appendChild(activateScriptElement(element));
      }
    }
    removeUnusedDynamicStylesheetElements() {
      for (const element of this.unusedDynamicStylesheetElements) {
        document.head.removeChild(element);
      }
    }
    async mergeProvisionalElements() {
      const newHeadElements = [...this.newHeadProvisionalElements];
      for (const element of this.currentHeadProvisionalElements) {
        if (!this.isCurrentElementInElementList(element, newHeadElements)) {
          document.head.removeChild(element);
        }
      }
      for (const element of newHeadElements) {
        document.head.appendChild(element);
      }
    }
    isCurrentElementInElementList(element, elementList) {
      for (const [index2, newElement] of elementList.entries()) {
        if (element.tagName == "TITLE") {
          if (newElement.tagName != "TITLE") {
            continue;
          }
          if (element.innerHTML == newElement.innerHTML) {
            elementList.splice(index2, 1);
            return true;
          }
        }
        if (newElement.isEqualNode(element)) {
          elementList.splice(index2, 1);
          return true;
        }
      }
      return false;
    }
    removeCurrentHeadProvisionalElements() {
      for (const element of this.currentHeadProvisionalElements) {
        document.head.removeChild(element);
      }
    }
    copyNewHeadProvisionalElements() {
      for (const element of this.newHeadProvisionalElements) {
        document.head.appendChild(element);
      }
    }
    activateNewBody() {
      document.adoptNode(this.newElement);
      this.activateNewBodyScriptElements();
    }
    activateNewBodyScriptElements() {
      for (const inertScriptElement of this.newBodyScriptElements) {
        const activatedScriptElement = activateScriptElement(inertScriptElement);
        inertScriptElement.replaceWith(activatedScriptElement);
      }
    }
    async assignNewBody() {
      await this.renderElement(this.currentElement, this.newElement);
    }
    get unusedDynamicStylesheetElements() {
      return this.oldHeadStylesheetElements.filter((element) => {
        return element.getAttribute("data-turbo-track") === "dynamic";
      });
    }
    get oldHeadStylesheetElements() {
      return this.currentHeadSnapshot.getStylesheetElementsNotInSnapshot(this.newHeadSnapshot);
    }
    get newHeadStylesheetElements() {
      return this.newHeadSnapshot.getStylesheetElementsNotInSnapshot(this.currentHeadSnapshot);
    }
    get newHeadScriptElements() {
      return this.newHeadSnapshot.getScriptElementsNotInSnapshot(this.currentHeadSnapshot);
    }
    get currentHeadProvisionalElements() {
      return this.currentHeadSnapshot.provisionalElements;
    }
    get newHeadProvisionalElements() {
      return this.newHeadSnapshot.provisionalElements;
    }
    get newBodyScriptElements() {
      return this.newElement.querySelectorAll("script");
    }
  };
  var MorphRenderer = class extends PageRenderer {
    static {
      __name(this, "MorphRenderer");
    }
    async render() {
      if (this.willRender)
        await this.#morphBody();
    }
    get renderMethod() {
      return "morph";
    }
    // Private
    async #morphBody() {
      this.#morphElements(this.currentElement, this.newElement);
      this.#reloadRemoteFrames();
      dispatch("turbo:morph", {
        detail: {
          currentElement: this.currentElement,
          newElement: this.newElement
        }
      });
    }
    #morphElements(currentElement, newElement, morphStyle = "outerHTML") {
      this.isMorphingTurboFrame = this.#isFrameReloadedWithMorph(currentElement);
      Idiomorph.morph(currentElement, newElement, {
        morphStyle,
        callbacks: {
          beforeNodeAdded: this.#shouldAddElement,
          beforeNodeMorphed: this.#shouldMorphElement,
          beforeAttributeUpdated: this.#shouldUpdateAttribute,
          beforeNodeRemoved: this.#shouldRemoveElement,
          afterNodeMorphed: this.#didMorphElement
        }
      });
    }
    #shouldAddElement = (node) => {
      return !(node.id && node.hasAttribute("data-turbo-permanent") && document.getElementById(node.id));
    };
    #shouldMorphElement = (oldNode, newNode) => {
      if (oldNode instanceof HTMLElement) {
        if (!oldNode.hasAttribute("data-turbo-permanent") && (this.isMorphingTurboFrame || !this.#isFrameReloadedWithMorph(oldNode))) {
          const event = dispatch("turbo:before-morph-element", {
            cancelable: true,
            target: oldNode,
            detail: {
              newElement: newNode
            }
          });
          return !event.defaultPrevented;
        } else {
          return false;
        }
      }
    };
    #shouldUpdateAttribute = (attributeName, target, mutationType) => {
      const event = dispatch("turbo:before-morph-attribute", { cancelable: true, target, detail: { attributeName, mutationType } });
      return !event.defaultPrevented;
    };
    #didMorphElement = (oldNode, newNode) => {
      if (newNode instanceof HTMLElement) {
        dispatch("turbo:morph-element", {
          target: oldNode,
          detail: {
            newElement: newNode
          }
        });
      }
    };
    #shouldRemoveElement = (node) => {
      return this.#shouldMorphElement(node);
    };
    #reloadRemoteFrames() {
      this.#remoteFrames().forEach((frame) => {
        if (this.#isFrameReloadedWithMorph(frame)) {
          this.#renderFrameWithMorph(frame);
          frame.reload();
        }
      });
    }
    #renderFrameWithMorph(frame) {
      frame.addEventListener("turbo:before-frame-render", (event) => {
        event.detail.render = this.#morphFrameUpdate;
      }, { once: true });
    }
    #morphFrameUpdate = (currentElement, newElement) => {
      dispatch("turbo:before-frame-morph", {
        target: currentElement,
        detail: { currentElement, newElement }
      });
      this.#morphElements(currentElement, newElement.children, "innerHTML");
    };
    #isFrameReloadedWithMorph(element) {
      return element.src && element.refresh === "morph";
    }
    #remoteFrames() {
      return Array.from(document.querySelectorAll("turbo-frame[src]")).filter((frame) => {
        return !frame.closest("[data-turbo-permanent]");
      });
    }
  };
  var SnapshotCache = class {
    static {
      __name(this, "SnapshotCache");
    }
    keys = [];
    snapshots = {};
    constructor(size) {
      this.size = size;
    }
    has(location2) {
      return toCacheKey(location2) in this.snapshots;
    }
    get(location2) {
      if (this.has(location2)) {
        const snapshot = this.read(location2);
        this.touch(location2);
        return snapshot;
      }
    }
    put(location2, snapshot) {
      this.write(location2, snapshot);
      this.touch(location2);
      return snapshot;
    }
    clear() {
      this.snapshots = {};
    }
    // Private
    read(location2) {
      return this.snapshots[toCacheKey(location2)];
    }
    write(location2, snapshot) {
      this.snapshots[toCacheKey(location2)] = snapshot;
    }
    touch(location2) {
      const key = toCacheKey(location2);
      const index2 = this.keys.indexOf(key);
      if (index2 > -1)
        this.keys.splice(index2, 1);
      this.keys.unshift(key);
      this.trim();
    }
    trim() {
      for (const key of this.keys.splice(this.size)) {
        delete this.snapshots[key];
      }
    }
  };
  var PageView = class extends View {
    static {
      __name(this, "PageView");
    }
    snapshotCache = new SnapshotCache(10);
    lastRenderedLocation = new URL(location.href);
    forceReloaded = false;
    shouldTransitionTo(newSnapshot) {
      return this.snapshot.prefersViewTransitions && newSnapshot.prefersViewTransitions;
    }
    renderPage(snapshot, isPreview = false, willRender = true, visit2) {
      const shouldMorphPage = this.isPageRefresh(visit2) && this.snapshot.shouldMorphPage;
      const rendererClass = shouldMorphPage ? MorphRenderer : PageRenderer;
      const renderer = new rendererClass(this.snapshot, snapshot, PageRenderer.renderElement, isPreview, willRender);
      if (!renderer.shouldRender) {
        this.forceReloaded = true;
      } else {
        visit2?.changeHistory();
      }
      return this.render(renderer);
    }
    renderError(snapshot, visit2) {
      visit2?.changeHistory();
      const renderer = new ErrorRenderer(this.snapshot, snapshot, ErrorRenderer.renderElement, false);
      return this.render(renderer);
    }
    clearSnapshotCache() {
      this.snapshotCache.clear();
    }
    async cacheSnapshot(snapshot = this.snapshot) {
      if (snapshot.isCacheable) {
        this.delegate.viewWillCacheSnapshot();
        const { lastRenderedLocation: location2 } = this;
        await nextEventLoopTick();
        const cachedSnapshot = snapshot.clone();
        this.snapshotCache.put(location2, cachedSnapshot);
        return cachedSnapshot;
      }
    }
    getCachedSnapshotForLocation(location2) {
      return this.snapshotCache.get(location2);
    }
    isPageRefresh(visit2) {
      return !visit2 || this.lastRenderedLocation.pathname === visit2.location.pathname && visit2.action === "replace";
    }
    shouldPreserveScrollPosition(visit2) {
      return this.isPageRefresh(visit2) && this.snapshot.shouldPreserveScrollPosition;
    }
    get snapshot() {
      return PageSnapshot.fromElement(this.element);
    }
  };
  var Preloader = class {
    static {
      __name(this, "Preloader");
    }
    selector = "a[data-turbo-preload]";
    constructor(delegate, snapshotCache) {
      this.delegate = delegate;
      this.snapshotCache = snapshotCache;
    }
    start() {
      if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", this.#preloadAll);
      } else {
        this.preloadOnLoadLinksForView(document.body);
      }
    }
    stop() {
      document.removeEventListener("DOMContentLoaded", this.#preloadAll);
    }
    preloadOnLoadLinksForView(element) {
      for (const link of element.querySelectorAll(this.selector)) {
        if (this.delegate.shouldPreloadLink(link)) {
          this.preloadURL(link);
        }
      }
    }
    async preloadURL(link) {
      const location2 = new URL(link.href);
      if (this.snapshotCache.has(location2)) {
        return;
      }
      const fetchRequest = new FetchRequest(this, FetchMethod.get, location2, new URLSearchParams(), link);
      await fetchRequest.perform();
    }
    // Fetch request delegate
    prepareRequest(fetchRequest) {
      fetchRequest.headers["X-Sec-Purpose"] = "prefetch";
    }
    async requestSucceededWithResponse(fetchRequest, fetchResponse) {
      try {
        const responseHTML = await fetchResponse.responseHTML;
        const snapshot = PageSnapshot.fromHTMLString(responseHTML);
        this.snapshotCache.put(fetchRequest.url, snapshot);
      } catch (_2) {
      }
    }
    requestStarted(fetchRequest) {
    }
    requestErrored(fetchRequest) {
    }
    requestFinished(fetchRequest) {
    }
    requestPreventedHandlingResponse(fetchRequest, fetchResponse) {
    }
    requestFailedWithResponse(fetchRequest, fetchResponse) {
    }
    #preloadAll = () => {
      this.preloadOnLoadLinksForView(document.body);
    };
  };
  var Cache = class {
    static {
      __name(this, "Cache");
    }
    constructor(session2) {
      this.session = session2;
    }
    clear() {
      this.session.clearCache();
    }
    resetCacheControl() {
      this.#setCacheControl("");
    }
    exemptPageFromCache() {
      this.#setCacheControl("no-cache");
    }
    exemptPageFromPreview() {
      this.#setCacheControl("no-preview");
    }
    #setCacheControl(value) {
      setMetaContent("turbo-cache-control", value);
    }
  };
  var Session = class {
    static {
      __name(this, "Session");
    }
    navigator = new Navigator(this);
    history = new History(this);
    view = new PageView(this, document.documentElement);
    adapter = new BrowserAdapter(this);
    pageObserver = new PageObserver(this);
    cacheObserver = new CacheObserver();
    linkPrefetchObserver = new LinkPrefetchObserver(this, document);
    linkClickObserver = new LinkClickObserver(this, window);
    formSubmitObserver = new FormSubmitObserver(this, document);
    scrollObserver = new ScrollObserver(this);
    streamObserver = new StreamObserver(this);
    formLinkClickObserver = new FormLinkClickObserver(this, document.documentElement);
    frameRedirector = new FrameRedirector(this, document.documentElement);
    streamMessageRenderer = new StreamMessageRenderer();
    cache = new Cache(this);
    drive = true;
    enabled = true;
    progressBarDelay = 500;
    started = false;
    formMode = "on";
    #pageRefreshDebouncePeriod = 150;
    constructor(recentRequests2) {
      this.recentRequests = recentRequests2;
      this.preloader = new Preloader(this, this.view.snapshotCache);
      this.debouncedRefresh = this.refresh;
      this.pageRefreshDebouncePeriod = this.pageRefreshDebouncePeriod;
    }
    start() {
      if (!this.started) {
        this.pageObserver.start();
        this.cacheObserver.start();
        this.linkPrefetchObserver.start();
        this.formLinkClickObserver.start();
        this.linkClickObserver.start();
        this.formSubmitObserver.start();
        this.scrollObserver.start();
        this.streamObserver.start();
        this.frameRedirector.start();
        this.history.start();
        this.preloader.start();
        this.started = true;
        this.enabled = true;
      }
    }
    disable() {
      this.enabled = false;
    }
    stop() {
      if (this.started) {
        this.pageObserver.stop();
        this.cacheObserver.stop();
        this.linkPrefetchObserver.stop();
        this.formLinkClickObserver.stop();
        this.linkClickObserver.stop();
        this.formSubmitObserver.stop();
        this.scrollObserver.stop();
        this.streamObserver.stop();
        this.frameRedirector.stop();
        this.history.stop();
        this.preloader.stop();
        this.started = false;
      }
    }
    registerAdapter(adapter) {
      this.adapter = adapter;
    }
    visit(location2, options = {}) {
      const frameElement = options.frame ? document.getElementById(options.frame) : null;
      if (frameElement instanceof FrameElement) {
        const action = options.action || getVisitAction(frameElement);
        frameElement.delegate.proposeVisitIfNavigatedWithAction(frameElement, action);
        frameElement.src = location2.toString();
      } else {
        this.navigator.proposeVisit(expandURL(location2), options);
      }
    }
    refresh(url, requestId) {
      const isRecentRequest = requestId && this.recentRequests.has(requestId);
      if (!isRecentRequest) {
        this.visit(url, { action: "replace", shouldCacheSnapshot: false });
      }
    }
    connectStreamSource(source) {
      this.streamObserver.connectStreamSource(source);
    }
    disconnectStreamSource(source) {
      this.streamObserver.disconnectStreamSource(source);
    }
    renderStreamMessage(message) {
      this.streamMessageRenderer.render(StreamMessage.wrap(message));
    }
    clearCache() {
      this.view.clearSnapshotCache();
    }
    setProgressBarDelay(delay) {
      this.progressBarDelay = delay;
    }
    setFormMode(mode) {
      this.formMode = mode;
    }
    get location() {
      return this.history.location;
    }
    get restorationIdentifier() {
      return this.history.restorationIdentifier;
    }
    get pageRefreshDebouncePeriod() {
      return this.#pageRefreshDebouncePeriod;
    }
    set pageRefreshDebouncePeriod(value) {
      this.refresh = debounce(this.debouncedRefresh.bind(this), value);
      this.#pageRefreshDebouncePeriod = value;
    }
    // Preloader delegate
    shouldPreloadLink(element) {
      const isUnsafe = element.hasAttribute("data-turbo-method");
      const isStream = element.hasAttribute("data-turbo-stream");
      const frameTarget = element.getAttribute("data-turbo-frame");
      const frame = frameTarget == "_top" ? null : document.getElementById(frameTarget) || findClosestRecursively(element, "turbo-frame:not([disabled])");
      if (isUnsafe || isStream || frame instanceof FrameElement) {
        return false;
      } else {
        const location2 = new URL(element.href);
        return this.elementIsNavigatable(element) && locationIsVisitable(location2, this.snapshot.rootLocation);
      }
    }
    // History delegate
    historyPoppedToLocationWithRestorationIdentifierAndDirection(location2, restorationIdentifier, direction) {
      if (this.enabled) {
        this.navigator.startVisit(location2, restorationIdentifier, {
          action: "restore",
          historyChanged: true,
          direction
        });
      } else {
        this.adapter.pageInvalidated({
          reason: "turbo_disabled"
        });
      }
    }
    // Scroll observer delegate
    scrollPositionChanged(position) {
      this.history.updateRestorationData({ scrollPosition: position });
    }
    // Form click observer delegate
    willSubmitFormLinkToLocation(link, location2) {
      return this.elementIsNavigatable(link) && locationIsVisitable(location2, this.snapshot.rootLocation);
    }
    submittedFormLinkToLocation() {
    }
    // Link hover observer delegate
    canPrefetchRequestToLocation(link, location2) {
      return this.elementIsNavigatable(link) && locationIsVisitable(location2, this.snapshot.rootLocation);
    }
    // Link click observer delegate
    willFollowLinkToLocation(link, location2, event) {
      return this.elementIsNavigatable(link) && locationIsVisitable(location2, this.snapshot.rootLocation) && this.applicationAllowsFollowingLinkToLocation(link, location2, event);
    }
    followedLinkToLocation(link, location2) {
      const action = this.getActionForLink(link);
      const acceptsStreamResponse = link.hasAttribute("data-turbo-stream");
      this.visit(location2.href, { action, acceptsStreamResponse });
    }
    // Navigator delegate
    allowsVisitingLocationWithAction(location2, action) {
      return this.locationWithActionIsSamePage(location2, action) || this.applicationAllowsVisitingLocation(location2);
    }
    visitProposedToLocation(location2, options) {
      extendURLWithDeprecatedProperties(location2);
      this.adapter.visitProposedToLocation(location2, options);
    }
    // Visit delegate
    visitStarted(visit2) {
      if (!visit2.acceptsStreamResponse) {
        markAsBusy(document.documentElement);
        this.view.markVisitDirection(visit2.direction);
      }
      extendURLWithDeprecatedProperties(visit2.location);
      if (!visit2.silent) {
        this.notifyApplicationAfterVisitingLocation(visit2.location, visit2.action);
      }
    }
    visitCompleted(visit2) {
      this.view.unmarkVisitDirection();
      clearBusyState(document.documentElement);
      this.notifyApplicationAfterPageLoad(visit2.getTimingMetrics());
    }
    locationWithActionIsSamePage(location2, action) {
      return this.navigator.locationWithActionIsSamePage(location2, action);
    }
    visitScrolledToSamePageLocation(oldURL, newURL) {
      this.notifyApplicationAfterVisitingSamePageLocation(oldURL, newURL);
    }
    // Form submit observer delegate
    willSubmitForm(form, submitter) {
      const action = getAction$1(form, submitter);
      return this.submissionIsNavigatable(form, submitter) && locationIsVisitable(expandURL(action), this.snapshot.rootLocation);
    }
    formSubmitted(form, submitter) {
      this.navigator.submitForm(form, submitter);
    }
    // Page observer delegate
    pageBecameInteractive() {
      this.view.lastRenderedLocation = this.location;
      this.notifyApplicationAfterPageLoad();
    }
    pageLoaded() {
      this.history.assumeControlOfScrollRestoration();
    }
    pageWillUnload() {
      this.history.relinquishControlOfScrollRestoration();
    }
    // Stream observer delegate
    receivedMessageFromStream(message) {
      this.renderStreamMessage(message);
    }
    // Page view delegate
    viewWillCacheSnapshot() {
      if (!this.navigator.currentVisit?.silent) {
        this.notifyApplicationBeforeCachingSnapshot();
      }
    }
    allowsImmediateRender({ element }, options) {
      const event = this.notifyApplicationBeforeRender(element, options);
      const {
        defaultPrevented,
        detail: { render }
      } = event;
      if (this.view.renderer && render) {
        this.view.renderer.renderElement = render;
      }
      return !defaultPrevented;
    }
    viewRenderedSnapshot(_snapshot, _isPreview, renderMethod) {
      this.view.lastRenderedLocation = this.history.location;
      this.notifyApplicationAfterRender(renderMethod);
    }
    preloadOnLoadLinksForView(element) {
      this.preloader.preloadOnLoadLinksForView(element);
    }
    viewInvalidated(reason) {
      this.adapter.pageInvalidated(reason);
    }
    // Frame element
    frameLoaded(frame) {
      this.notifyApplicationAfterFrameLoad(frame);
    }
    frameRendered(fetchResponse, frame) {
      this.notifyApplicationAfterFrameRender(fetchResponse, frame);
    }
    // Application events
    applicationAllowsFollowingLinkToLocation(link, location2, ev) {
      const event = this.notifyApplicationAfterClickingLinkToLocation(link, location2, ev);
      return !event.defaultPrevented;
    }
    applicationAllowsVisitingLocation(location2) {
      const event = this.notifyApplicationBeforeVisitingLocation(location2);
      return !event.defaultPrevented;
    }
    notifyApplicationAfterClickingLinkToLocation(link, location2, event) {
      return dispatch("turbo:click", {
        target: link,
        detail: { url: location2.href, originalEvent: event },
        cancelable: true
      });
    }
    notifyApplicationBeforeVisitingLocation(location2) {
      return dispatch("turbo:before-visit", {
        detail: { url: location2.href },
        cancelable: true
      });
    }
    notifyApplicationAfterVisitingLocation(location2, action) {
      return dispatch("turbo:visit", { detail: { url: location2.href, action } });
    }
    notifyApplicationBeforeCachingSnapshot() {
      return dispatch("turbo:before-cache");
    }
    notifyApplicationBeforeRender(newBody, options) {
      return dispatch("turbo:before-render", {
        detail: { newBody, ...options },
        cancelable: true
      });
    }
    notifyApplicationAfterRender(renderMethod) {
      return dispatch("turbo:render", { detail: { renderMethod } });
    }
    notifyApplicationAfterPageLoad(timing = {}) {
      return dispatch("turbo:load", {
        detail: { url: this.location.href, timing }
      });
    }
    notifyApplicationAfterVisitingSamePageLocation(oldURL, newURL) {
      dispatchEvent(
        new HashChangeEvent("hashchange", {
          oldURL: oldURL.toString(),
          newURL: newURL.toString()
        })
      );
    }
    notifyApplicationAfterFrameLoad(frame) {
      return dispatch("turbo:frame-load", { target: frame });
    }
    notifyApplicationAfterFrameRender(fetchResponse, frame) {
      return dispatch("turbo:frame-render", {
        detail: { fetchResponse },
        target: frame,
        cancelable: true
      });
    }
    // Helpers
    submissionIsNavigatable(form, submitter) {
      if (this.formMode == "off") {
        return false;
      } else {
        const submitterIsNavigatable = submitter ? this.elementIsNavigatable(submitter) : true;
        if (this.formMode == "optin") {
          return submitterIsNavigatable && form.closest('[data-turbo="true"]') != null;
        } else {
          return submitterIsNavigatable && this.elementIsNavigatable(form);
        }
      }
    }
    elementIsNavigatable(element) {
      const container = findClosestRecursively(element, "[data-turbo]");
      const withinFrame = findClosestRecursively(element, "turbo-frame");
      if (this.drive || withinFrame) {
        if (container) {
          return container.getAttribute("data-turbo") != "false";
        } else {
          return true;
        }
      } else {
        if (container) {
          return container.getAttribute("data-turbo") == "true";
        } else {
          return false;
        }
      }
    }
    // Private
    getActionForLink(link) {
      return getVisitAction(link) || "advance";
    }
    get snapshot() {
      return this.view.snapshot;
    }
  };
  function extendURLWithDeprecatedProperties(url) {
    Object.defineProperties(url, deprecatedLocationPropertyDescriptors);
  }
  __name(extendURLWithDeprecatedProperties, "extendURLWithDeprecatedProperties");
  var deprecatedLocationPropertyDescriptors = {
    absoluteURL: {
      get() {
        return this.toString();
      }
    }
  };
  var session = new Session(recentRequests);
  var { cache, navigator: navigator$1 } = session;
  function start() {
    session.start();
  }
  __name(start, "start");
  function registerAdapter(adapter) {
    session.registerAdapter(adapter);
  }
  __name(registerAdapter, "registerAdapter");
  function visit(location2, options) {
    session.visit(location2, options);
  }
  __name(visit, "visit");
  function connectStreamSource(source) {
    session.connectStreamSource(source);
  }
  __name(connectStreamSource, "connectStreamSource");
  function disconnectStreamSource(source) {
    session.disconnectStreamSource(source);
  }
  __name(disconnectStreamSource, "disconnectStreamSource");
  function renderStreamMessage(message) {
    session.renderStreamMessage(message);
  }
  __name(renderStreamMessage, "renderStreamMessage");
  function clearCache() {
    console.warn(
      "Please replace `Turbo.clearCache()` with `Turbo.cache.clear()`. The top-level function is deprecated and will be removed in a future version of Turbo.`"
    );
    session.clearCache();
  }
  __name(clearCache, "clearCache");
  function setProgressBarDelay(delay) {
    session.setProgressBarDelay(delay);
  }
  __name(setProgressBarDelay, "setProgressBarDelay");
  function setConfirmMethod(confirmMethod) {
    FormSubmission.confirmMethod = confirmMethod;
  }
  __name(setConfirmMethod, "setConfirmMethod");
  function setFormMode(mode) {
    session.setFormMode(mode);
  }
  __name(setFormMode, "setFormMode");
  var Turbo = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    navigator: navigator$1,
    session,
    cache,
    PageRenderer,
    PageSnapshot,
    FrameRenderer,
    fetch: fetchWithTurboHeaders,
    start,
    registerAdapter,
    visit,
    connectStreamSource,
    disconnectStreamSource,
    renderStreamMessage,
    clearCache,
    setProgressBarDelay,
    setConfirmMethod,
    setFormMode
  });
  var TurboFrameMissingError = class extends Error {
    static {
      __name(this, "TurboFrameMissingError");
    }
  };
  var FrameController = class {
    static {
      __name(this, "FrameController");
    }
    fetchResponseLoaded = (_fetchResponse) => Promise.resolve();
    #currentFetchRequest = null;
    #resolveVisitPromise = () => {
    };
    #connected = false;
    #hasBeenLoaded = false;
    #ignoredAttributes = /* @__PURE__ */ new Set();
    action = null;
    constructor(element) {
      this.element = element;
      this.view = new FrameView(this, this.element);
      this.appearanceObserver = new AppearanceObserver(this, this.element);
      this.formLinkClickObserver = new FormLinkClickObserver(this, this.element);
      this.linkInterceptor = new LinkInterceptor(this, this.element);
      this.restorationIdentifier = uuid();
      this.formSubmitObserver = new FormSubmitObserver(this, this.element);
    }
    // Frame delegate
    connect() {
      if (!this.#connected) {
        this.#connected = true;
        if (this.loadingStyle == FrameLoadingStyle.lazy) {
          this.appearanceObserver.start();
        } else {
          this.#loadSourceURL();
        }
        this.formLinkClickObserver.start();
        this.linkInterceptor.start();
        this.formSubmitObserver.start();
      }
    }
    disconnect() {
      if (this.#connected) {
        this.#connected = false;
        this.appearanceObserver.stop();
        this.formLinkClickObserver.stop();
        this.linkInterceptor.stop();
        this.formSubmitObserver.stop();
      }
    }
    disabledChanged() {
      if (this.loadingStyle == FrameLoadingStyle.eager) {
        this.#loadSourceURL();
      }
    }
    sourceURLChanged() {
      if (this.#isIgnoringChangesTo("src"))
        return;
      if (this.element.isConnected) {
        this.complete = false;
      }
      if (this.loadingStyle == FrameLoadingStyle.eager || this.#hasBeenLoaded) {
        this.#loadSourceURL();
      }
    }
    sourceURLReloaded() {
      const { src } = this.element;
      this.element.removeAttribute("complete");
      this.element.src = null;
      this.element.src = src;
      return this.element.loaded;
    }
    loadingStyleChanged() {
      if (this.loadingStyle == FrameLoadingStyle.lazy) {
        this.appearanceObserver.start();
      } else {
        this.appearanceObserver.stop();
        this.#loadSourceURL();
      }
    }
    async #loadSourceURL() {
      if (this.enabled && this.isActive && !this.complete && this.sourceURL) {
        this.element.loaded = this.#visit(expandURL(this.sourceURL));
        this.appearanceObserver.stop();
        await this.element.loaded;
        this.#hasBeenLoaded = true;
      }
    }
    async loadResponse(fetchResponse) {
      if (fetchResponse.redirected || fetchResponse.succeeded && fetchResponse.isHTML) {
        this.sourceURL = fetchResponse.response.url;
      }
      try {
        const html = await fetchResponse.responseHTML;
        if (html) {
          const document2 = parseHTMLDocument(html);
          const pageSnapshot = PageSnapshot.fromDocument(document2);
          if (pageSnapshot.isVisitable) {
            await this.#loadFrameResponse(fetchResponse, document2);
          } else {
            await this.#handleUnvisitableFrameResponse(fetchResponse);
          }
        }
      } finally {
        this.fetchResponseLoaded = () => Promise.resolve();
      }
    }
    // Appearance observer delegate
    elementAppearedInViewport(element) {
      this.proposeVisitIfNavigatedWithAction(element, getVisitAction(element));
      this.#loadSourceURL();
    }
    // Form link click observer delegate
    willSubmitFormLinkToLocation(link) {
      return this.#shouldInterceptNavigation(link);
    }
    submittedFormLinkToLocation(link, _location, form) {
      const frame = this.#findFrameElement(link);
      if (frame)
        form.setAttribute("data-turbo-frame", frame.id);
    }
    // Link interceptor delegate
    shouldInterceptLinkClick(element, _location, _event) {
      return this.#shouldInterceptNavigation(element);
    }
    linkClickIntercepted(element, location2) {
      this.#navigateFrame(element, location2);
    }
    // Form submit observer delegate
    willSubmitForm(element, submitter) {
      return element.closest("turbo-frame") == this.element && this.#shouldInterceptNavigation(element, submitter);
    }
    formSubmitted(element, submitter) {
      if (this.formSubmission) {
        this.formSubmission.stop();
      }
      this.formSubmission = new FormSubmission(this, element, submitter);
      const { fetchRequest } = this.formSubmission;
      this.prepareRequest(fetchRequest);
      this.formSubmission.start();
    }
    // Fetch request delegate
    prepareRequest(request) {
      request.headers["Turbo-Frame"] = this.id;
      if (this.currentNavigationElement?.hasAttribute("data-turbo-stream")) {
        request.acceptResponseType(StreamMessage.contentType);
      }
    }
    requestStarted(_request) {
      markAsBusy(this.element);
    }
    requestPreventedHandlingResponse(_request, _response) {
      this.#resolveVisitPromise();
    }
    async requestSucceededWithResponse(request, response) {
      await this.loadResponse(response);
      this.#resolveVisitPromise();
    }
    async requestFailedWithResponse(request, response) {
      await this.loadResponse(response);
      this.#resolveVisitPromise();
    }
    requestErrored(request, error) {
      console.error(error);
      this.#resolveVisitPromise();
    }
    requestFinished(_request) {
      clearBusyState(this.element);
    }
    // Form submission delegate
    formSubmissionStarted({ formElement }) {
      markAsBusy(formElement, this.#findFrameElement(formElement));
    }
    formSubmissionSucceededWithResponse(formSubmission, response) {
      const frame = this.#findFrameElement(formSubmission.formElement, formSubmission.submitter);
      frame.delegate.proposeVisitIfNavigatedWithAction(frame, getVisitAction(formSubmission.submitter, formSubmission.formElement, frame));
      frame.delegate.loadResponse(response);
      if (!formSubmission.isSafe) {
        session.clearCache();
      }
    }
    formSubmissionFailedWithResponse(formSubmission, fetchResponse) {
      this.element.delegate.loadResponse(fetchResponse);
      session.clearCache();
    }
    formSubmissionErrored(formSubmission, error) {
      console.error(error);
    }
    formSubmissionFinished({ formElement }) {
      clearBusyState(formElement, this.#findFrameElement(formElement));
    }
    // View delegate
    allowsImmediateRender({ element: newFrame }, options) {
      const event = dispatch("turbo:before-frame-render", {
        target: this.element,
        detail: { newFrame, ...options },
        cancelable: true
      });
      const {
        defaultPrevented,
        detail: { render }
      } = event;
      if (this.view.renderer && render) {
        this.view.renderer.renderElement = render;
      }
      return !defaultPrevented;
    }
    viewRenderedSnapshot(_snapshot, _isPreview, _renderMethod) {
    }
    preloadOnLoadLinksForView(element) {
      session.preloadOnLoadLinksForView(element);
    }
    viewInvalidated() {
    }
    // Frame renderer delegate
    willRenderFrame(currentElement, _newElement) {
      this.previousFrameElement = currentElement.cloneNode(true);
    }
    visitCachedSnapshot = ({ element }) => {
      const frame = element.querySelector("#" + this.element.id);
      if (frame && this.previousFrameElement) {
        frame.replaceChildren(...this.previousFrameElement.children);
      }
      delete this.previousFrameElement;
    };
    // Private
    async #loadFrameResponse(fetchResponse, document2) {
      const newFrameElement = await this.extractForeignFrameElement(document2.body);
      if (newFrameElement) {
        const snapshot = new Snapshot(newFrameElement);
        const renderer = new FrameRenderer(this, this.view.snapshot, snapshot, FrameRenderer.renderElement, false, false);
        if (this.view.renderPromise)
          await this.view.renderPromise;
        this.changeHistory();
        await this.view.render(renderer);
        this.complete = true;
        session.frameRendered(fetchResponse, this.element);
        session.frameLoaded(this.element);
        await this.fetchResponseLoaded(fetchResponse);
      } else if (this.#willHandleFrameMissingFromResponse(fetchResponse)) {
        this.#handleFrameMissingFromResponse(fetchResponse);
      }
    }
    async #visit(url) {
      const request = new FetchRequest(this, FetchMethod.get, url, new URLSearchParams(), this.element);
      this.#currentFetchRequest?.cancel();
      this.#currentFetchRequest = request;
      return new Promise((resolve) => {
        this.#resolveVisitPromise = () => {
          this.#resolveVisitPromise = () => {
          };
          this.#currentFetchRequest = null;
          resolve();
        };
        request.perform();
      });
    }
    #navigateFrame(element, url, submitter) {
      const frame = this.#findFrameElement(element, submitter);
      frame.delegate.proposeVisitIfNavigatedWithAction(frame, getVisitAction(submitter, element, frame));
      this.#withCurrentNavigationElement(element, () => {
        frame.src = url;
      });
    }
    proposeVisitIfNavigatedWithAction(frame, action = null) {
      this.action = action;
      if (this.action) {
        const pageSnapshot = PageSnapshot.fromElement(frame).clone();
        const { visitCachedSnapshot } = frame.delegate;
        frame.delegate.fetchResponseLoaded = async (fetchResponse) => {
          if (frame.src) {
            const { statusCode, redirected } = fetchResponse;
            const responseHTML = await fetchResponse.responseHTML;
            const response = { statusCode, redirected, responseHTML };
            const options = {
              response,
              visitCachedSnapshot,
              willRender: false,
              updateHistory: false,
              restorationIdentifier: this.restorationIdentifier,
              snapshot: pageSnapshot
            };
            if (this.action)
              options.action = this.action;
            session.visit(frame.src, options);
          }
        };
      }
    }
    changeHistory() {
      if (this.action) {
        const method = getHistoryMethodForAction(this.action);
        session.history.update(method, expandURL(this.element.src || ""), this.restorationIdentifier);
      }
    }
    async #handleUnvisitableFrameResponse(fetchResponse) {
      console.warn(
        `The response (${fetchResponse.statusCode}) from <turbo-frame id="${this.element.id}"> is performing a full page visit due to turbo-visit-control.`
      );
      await this.#visitResponse(fetchResponse.response);
    }
    #willHandleFrameMissingFromResponse(fetchResponse) {
      this.element.setAttribute("complete", "");
      const response = fetchResponse.response;
      const visit2 = /* @__PURE__ */ __name(async (url, options) => {
        if (url instanceof Response) {
          this.#visitResponse(url);
        } else {
          session.visit(url, options);
        }
      }, "visit");
      const event = dispatch("turbo:frame-missing", {
        target: this.element,
        detail: { response, visit: visit2 },
        cancelable: true
      });
      return !event.defaultPrevented;
    }
    #handleFrameMissingFromResponse(fetchResponse) {
      this.view.missing();
      this.#throwFrameMissingError(fetchResponse);
    }
    #throwFrameMissingError(fetchResponse) {
      const message = `The response (${fetchResponse.statusCode}) did not contain the expected <turbo-frame id="${this.element.id}"> and will be ignored. To perform a full page visit instead, set turbo-visit-control to reload.`;
      throw new TurboFrameMissingError(message);
    }
    async #visitResponse(response) {
      const wrapped = new FetchResponse(response);
      const responseHTML = await wrapped.responseHTML;
      const { location: location2, redirected, statusCode } = wrapped;
      return session.visit(location2, { response: { redirected, statusCode, responseHTML } });
    }
    #findFrameElement(element, submitter) {
      const id = getAttribute("data-turbo-frame", submitter, element) || this.element.getAttribute("target");
      return getFrameElementById(id) ?? this.element;
    }
    async extractForeignFrameElement(container) {
      let element;
      const id = CSS.escape(this.id);
      try {
        element = activateElement(container.querySelector(`turbo-frame#${id}`), this.sourceURL);
        if (element) {
          return element;
        }
        element = activateElement(container.querySelector(`turbo-frame[src][recurse~=${id}]`), this.sourceURL);
        if (element) {
          await element.loaded;
          return await this.extractForeignFrameElement(element);
        }
      } catch (error) {
        console.error(error);
        return new FrameElement();
      }
      return null;
    }
    #formActionIsVisitable(form, submitter) {
      const action = getAction$1(form, submitter);
      return locationIsVisitable(expandURL(action), this.rootLocation);
    }
    #shouldInterceptNavigation(element, submitter) {
      const id = getAttribute("data-turbo-frame", submitter, element) || this.element.getAttribute("target");
      if (element instanceof HTMLFormElement && !this.#formActionIsVisitable(element, submitter)) {
        return false;
      }
      if (!this.enabled || id == "_top") {
        return false;
      }
      if (id) {
        const frameElement = getFrameElementById(id);
        if (frameElement) {
          return !frameElement.disabled;
        }
      }
      if (!session.elementIsNavigatable(element)) {
        return false;
      }
      if (submitter && !session.elementIsNavigatable(submitter)) {
        return false;
      }
      return true;
    }
    // Computed properties
    get id() {
      return this.element.id;
    }
    get enabled() {
      return !this.element.disabled;
    }
    get sourceURL() {
      if (this.element.src) {
        return this.element.src;
      }
    }
    set sourceURL(sourceURL) {
      this.#ignoringChangesToAttribute("src", () => {
        this.element.src = sourceURL ?? null;
      });
    }
    get loadingStyle() {
      return this.element.loading;
    }
    get isLoading() {
      return this.formSubmission !== void 0 || this.#resolveVisitPromise() !== void 0;
    }
    get complete() {
      return this.element.hasAttribute("complete");
    }
    set complete(value) {
      if (value) {
        this.element.setAttribute("complete", "");
      } else {
        this.element.removeAttribute("complete");
      }
    }
    get isActive() {
      return this.element.isActive && this.#connected;
    }
    get rootLocation() {
      const meta = this.element.ownerDocument.querySelector(`meta[name="turbo-root"]`);
      const root2 = meta?.content ?? "/";
      return expandURL(root2);
    }
    #isIgnoringChangesTo(attributeName) {
      return this.#ignoredAttributes.has(attributeName);
    }
    #ignoringChangesToAttribute(attributeName, callback) {
      this.#ignoredAttributes.add(attributeName);
      callback();
      this.#ignoredAttributes.delete(attributeName);
    }
    #withCurrentNavigationElement(element, callback) {
      this.currentNavigationElement = element;
      callback();
      delete this.currentNavigationElement;
    }
  };
  function getFrameElementById(id) {
    if (id != null) {
      const element = document.getElementById(id);
      if (element instanceof FrameElement) {
        return element;
      }
    }
  }
  __name(getFrameElementById, "getFrameElementById");
  function activateElement(element, currentURL) {
    if (element) {
      const src = element.getAttribute("src");
      if (src != null && currentURL != null && urlsAreEqual(src, currentURL)) {
        throw new Error(`Matching <turbo-frame id="${element.id}"> element has a source URL which references itself`);
      }
      if (element.ownerDocument !== document) {
        element = document.importNode(element, true);
      }
      if (element instanceof FrameElement) {
        element.connectedCallback();
        element.disconnectedCallback();
        return element;
      }
    }
  }
  __name(activateElement, "activateElement");
  var StreamActions = {
    after() {
      this.targetElements.forEach((e3) => e3.parentElement?.insertBefore(this.templateContent, e3.nextSibling));
    },
    append() {
      this.removeDuplicateTargetChildren();
      this.targetElements.forEach((e3) => e3.append(this.templateContent));
    },
    before() {
      this.targetElements.forEach((e3) => e3.parentElement?.insertBefore(this.templateContent, e3));
    },
    prepend() {
      this.removeDuplicateTargetChildren();
      this.targetElements.forEach((e3) => e3.prepend(this.templateContent));
    },
    remove() {
      this.targetElements.forEach((e3) => e3.remove());
    },
    replace() {
      this.targetElements.forEach((e3) => e3.replaceWith(this.templateContent));
    },
    update() {
      this.targetElements.forEach((targetElement) => {
        targetElement.innerHTML = "";
        targetElement.append(this.templateContent);
      });
    },
    refresh() {
      session.refresh(this.baseURI, this.requestId);
    }
  };
  var StreamElement = class _StreamElement extends HTMLElement {
    static {
      __name(this, "StreamElement");
    }
    static async renderElement(newElement) {
      await newElement.performAction();
    }
    async connectedCallback() {
      try {
        await this.render();
      } catch (error) {
        console.error(error);
      } finally {
        this.disconnect();
      }
    }
    async render() {
      return this.renderPromise ??= (async () => {
        const event = this.beforeRenderEvent;
        if (this.dispatchEvent(event)) {
          await nextRepaint();
          await event.detail.render(this);
        }
      })();
    }
    disconnect() {
      try {
        this.remove();
      } catch {
      }
    }
    /**
     * Removes duplicate children (by ID)
     */
    removeDuplicateTargetChildren() {
      this.duplicateChildren.forEach((c3) => c3.remove());
    }
    /**
     * Gets the list of duplicate children (i.e. those with the same ID)
     */
    get duplicateChildren() {
      const existingChildren = this.targetElements.flatMap((e3) => [...e3.children]).filter((c3) => !!c3.id);
      const newChildrenIds = [...this.templateContent?.children || []].filter((c3) => !!c3.id).map((c3) => c3.id);
      return existingChildren.filter((c3) => newChildrenIds.includes(c3.id));
    }
    /**
     * Gets the action function to be performed.
     */
    get performAction() {
      if (this.action) {
        const actionFunction = StreamActions[this.action];
        if (actionFunction) {
          return actionFunction;
        }
        this.#raise("unknown action");
      }
      this.#raise("action attribute is missing");
    }
    /**
     * Gets the target elements which the template will be rendered to.
     */
    get targetElements() {
      if (this.target) {
        return this.targetElementsById;
      } else if (this.targets) {
        return this.targetElementsByQuery;
      } else {
        this.#raise("target or targets attribute is missing");
      }
    }
    /**
     * Gets the contents of the main `<template>`.
     */
    get templateContent() {
      return this.templateElement.content.cloneNode(true);
    }
    /**
     * Gets the main `<template>` used for rendering
     */
    get templateElement() {
      if (this.firstElementChild === null) {
        const template = this.ownerDocument.createElement("template");
        this.appendChild(template);
        return template;
      } else if (this.firstElementChild instanceof HTMLTemplateElement) {
        return this.firstElementChild;
      }
      this.#raise("first child element must be a <template> element");
    }
    /**
     * Gets the current action.
     */
    get action() {
      return this.getAttribute("action");
    }
    /**
     * Gets the current target (an element ID) to which the result will
     * be rendered.
     */
    get target() {
      return this.getAttribute("target");
    }
    /**
     * Gets the current "targets" selector (a CSS selector)
     */
    get targets() {
      return this.getAttribute("targets");
    }
    /**
     * Reads the request-id attribute
     */
    get requestId() {
      return this.getAttribute("request-id");
    }
    #raise(message) {
      throw new Error(`${this.description}: ${message}`);
    }
    get description() {
      return (this.outerHTML.match(/<[^>]+>/) ?? [])[0] ?? "<turbo-stream>";
    }
    get beforeRenderEvent() {
      return new CustomEvent("turbo:before-stream-render", {
        bubbles: true,
        cancelable: true,
        detail: { newStream: this, render: _StreamElement.renderElement }
      });
    }
    get targetElementsById() {
      const element = this.ownerDocument?.getElementById(this.target);
      if (element !== null) {
        return [element];
      } else {
        return [];
      }
    }
    get targetElementsByQuery() {
      const elements = this.ownerDocument?.querySelectorAll(this.targets);
      if (elements.length !== 0) {
        return Array.prototype.slice.call(elements);
      } else {
        return [];
      }
    }
  };
  var StreamSourceElement = class extends HTMLElement {
    static {
      __name(this, "StreamSourceElement");
    }
    streamSource = null;
    connectedCallback() {
      this.streamSource = this.src.match(/^ws{1,2}:/) ? new WebSocket(this.src) : new EventSource(this.src);
      connectStreamSource(this.streamSource);
    }
    disconnectedCallback() {
      if (this.streamSource) {
        this.streamSource.close();
        disconnectStreamSource(this.streamSource);
      }
    }
    get src() {
      return this.getAttribute("src") || "";
    }
  };
  FrameElement.delegateConstructor = FrameController;
  if (customElements.get("turbo-frame") === void 0) {
    customElements.define("turbo-frame", FrameElement);
  }
  if (customElements.get("turbo-stream") === void 0) {
    customElements.define("turbo-stream", StreamElement);
  }
  if (customElements.get("turbo-stream-source") === void 0) {
    customElements.define("turbo-stream-source", StreamSourceElement);
  }
  (() => {
    let element = document.currentScript;
    if (!element)
      return;
    if (element.hasAttribute("data-turbo-suppress-warning"))
      return;
    element = element.parentElement;
    while (element) {
      if (element == document.body) {
        return console.warn(
          unindent`
        You are loading Turbo from a <script> element inside the <body> element. This is probably not what you meant to do!

        Load your application’s JavaScript bundle inside the <head> element instead. <script> elements in <body> are evaluated with each page change.

        For more information, see: https://turbo.hotwired.dev/handbook/building#working-with-script-elements

        ——
        Suppress this warning by adding a "data-turbo-suppress-warning" attribute to: %s
      `,
          element.outerHTML
        );
      }
      element = element.parentElement;
    }
  })();
  window.Turbo = { ...Turbo, StreamActions };
  start();

  // node_modules/@hotwired/turbo-rails/app/javascript/turbo/cable.js
  var consumer;
  async function getConsumer() {
    return consumer || setConsumer(createConsumer2().then(setConsumer));
  }
  __name(getConsumer, "getConsumer");
  function setConsumer(newConsumer) {
    return consumer = newConsumer;
  }
  __name(setConsumer, "setConsumer");
  async function createConsumer2() {
    const { createConsumer: createConsumer3 } = await Promise.resolve().then(() => (init_src(), src_exports));
    return createConsumer3();
  }
  __name(createConsumer2, "createConsumer");
  async function subscribeTo(channel, mixin) {
    const { subscriptions } = await getConsumer();
    return subscriptions.create(channel, mixin);
  }
  __name(subscribeTo, "subscribeTo");

  // node_modules/@hotwired/turbo-rails/app/javascript/turbo/snakeize.js
  function walk(obj) {
    if (!obj || typeof obj !== "object")
      return obj;
    if (obj instanceof Date || obj instanceof RegExp)
      return obj;
    if (Array.isArray(obj))
      return obj.map(walk);
    return Object.keys(obj).reduce(function(acc, key) {
      var camel = key[0].toLowerCase() + key.slice(1).replace(/([A-Z]+)/g, function(m3, x3) {
        return "_" + x3.toLowerCase();
      });
      acc[camel] = walk(obj[key]);
      return acc;
    }, {});
  }
  __name(walk, "walk");

  // node_modules/@hotwired/turbo-rails/app/javascript/turbo/cable_stream_source_element.js
  var TurboCableStreamSourceElement = class extends HTMLElement {
    static {
      __name(this, "TurboCableStreamSourceElement");
    }
    async connectedCallback() {
      connectStreamSource(this);
      this.subscription = await subscribeTo(this.channel, {
        received: this.dispatchMessageEvent.bind(this),
        connected: this.subscriptionConnected.bind(this),
        disconnected: this.subscriptionDisconnected.bind(this)
      });
    }
    disconnectedCallback() {
      disconnectStreamSource(this);
      if (this.subscription)
        this.subscription.unsubscribe();
    }
    dispatchMessageEvent(data) {
      const event = new MessageEvent("message", { data });
      return this.dispatchEvent(event);
    }
    subscriptionConnected() {
      this.setAttribute("connected", "");
    }
    subscriptionDisconnected() {
      this.removeAttribute("connected");
    }
    get channel() {
      const channel = this.getAttribute("channel");
      const signed_stream_name = this.getAttribute("signed-stream-name");
      return { channel, signed_stream_name, ...walk({ ...this.dataset }) };
    }
  };
  if (customElements.get("turbo-cable-stream-source") === void 0) {
    customElements.define("turbo-cable-stream-source", TurboCableStreamSourceElement);
  }

  // node_modules/@hotwired/turbo-rails/app/javascript/turbo/fetch_requests.js
  function encodeMethodIntoRequestBody(event) {
    if (event.target instanceof HTMLFormElement) {
      const { target: form, detail: { fetchOptions } } = event;
      form.addEventListener("turbo:submit-start", ({ detail: { formSubmission: { submitter } } }) => {
        const body = isBodyInit(fetchOptions.body) ? fetchOptions.body : new URLSearchParams();
        const method = determineFetchMethod(submitter, body, form);
        if (!/get/i.test(method)) {
          if (/post/i.test(method)) {
            body.delete("_method");
          } else {
            body.set("_method", method);
          }
          fetchOptions.method = "post";
        }
      }, { once: true });
    }
  }
  __name(encodeMethodIntoRequestBody, "encodeMethodIntoRequestBody");
  function determineFetchMethod(submitter, body, form) {
    const formMethod = determineFormMethod(submitter);
    const overrideMethod = body.get("_method");
    const method = form.getAttribute("method") || "get";
    if (typeof formMethod == "string") {
      return formMethod;
    } else if (typeof overrideMethod == "string") {
      return overrideMethod;
    } else {
      return method;
    }
  }
  __name(determineFetchMethod, "determineFetchMethod");
  function determineFormMethod(submitter) {
    if (submitter instanceof HTMLButtonElement || submitter instanceof HTMLInputElement) {
      if (submitter.name === "_method") {
        return submitter.value;
      } else if (submitter.hasAttribute("formmethod")) {
        return submitter.formMethod;
      } else {
        return null;
      }
    } else {
      return null;
    }
  }
  __name(determineFormMethod, "determineFormMethod");
  function isBodyInit(body) {
    return body instanceof FormData || body instanceof URLSearchParams;
  }
  __name(isBodyInit, "isBodyInit");

  // node_modules/@hotwired/turbo-rails/app/javascript/turbo/index.js
  window.Turbo = turbo_es2017_esm_exports;
  addEventListener("turbo:before-fetch-request", encodeMethodIntoRequestBody);

  // node_modules/@johanhalse/musculus/dist/musculus.js
  var mixins_default = {
    camelize: function(value) {
      return value.replace(
        /(?:[_-])([a-z0-9])/g,
        (_2, char) => char.toUpperCase()
      );
    },
    dasherize: function(value) {
      const dash = value.replace(
        /([A-Z])/g,
        (_2, char) => `-${char.toLowerCase()}`
      );
      return dash.startsWith("-") ? dash.substr(1) : dash;
    }
  };
  var Application = class {
    static {
      __name(this, "Application");
    }
    constructor() {
      this.controllers = {};
    }
    start(dom) {
      this.window = window;
      this.document = document;
      this.connect();
    }
    connect() {
      for (let key in this.controllers) {
        this.window.customElements.define(key, this.controllers[key]);
      }
    }
    register(controller) {
      let controllerName = this.dasherize(controller.name.replace("Default", ""));
      this.controllers[controllerName] = controller;
    }
  };
  Object.assign(Application.prototype, mixins_default);
  var application = new Application();
  var Controller = class extends window.HTMLElement {
    static {
      __name(this, "Controller");
    }
    constructor() {
      super();
      this.element = this;
      this.descriptorPattern = /^(?:(.+?)(?:\.(.+?))?(?:@(window|document))?->)?(.+?)(?:#([^:]+?))(?::(.+))?$/;
    }
    bindAction(action) {
      if (action.identifier != this.name) {
        return;
      }
      action.boundFn = this[action.methodName].bind(this);
      action.listener = action.eventTarget.addEventListener(
        action.eventName || this.defaultEventName(action.eventTarget),
        action.boundFn,
        false
      );
    }
    parseAction(el) {
      const actions = el.dataset.action.split(" ");
      return actions.map(this.parseActionDescriptorString(el).bind(this));
    }
    parseActionDescriptorString(el) {
      return function(descriptorString) {
        const source = descriptorString.trim();
        const matches2 = source.match(this.descriptorPattern) || [];
        let eventName = matches2[1];
        let keyFilter = matches2[2];
        if (keyFilter && !["keydown", "keyup", "keypress"].includes(eventName)) {
          eventName += `.${keyFilter}`;
          keyFilter = "";
        }
        return {
          eventTarget: this.parseEventTarget(matches2[3]) || el,
          eventName,
          eventOptions: matches2[6] ? this.parseEventOptions(matches2[6]) : {},
          identifier: matches2[4],
          methodName: matches2[5],
          keyFilter
        };
      };
    }
    parseEventTarget(eventTargetName) {
      if (eventTargetName == "window") {
        return window;
      }
      if (eventTargetName == "document") {
        return document;
      }
    }
    parseEventOptions(eventOptions) {
      return eventOptions.split(":").reduce(
        (options, token) => Object.assign(options, {
          [token.replace(/^!/, "")]: !/^!/.test(token)
        }),
        {}
      );
    }
    defineTargets() {
      if (this.constructor.targets == void 0) {
        return;
      }
      this.constructor.targets.forEach(this.mapTargets.bind(this));
    }
    mapTargets(targetName) {
      const targets = this.querySelectorAll(
        `[data-${this.name}-target="${targetName}"]`
      );
      this[targetName + "Targets"] = Array.from(targets);
      this[targetName + "Target"] = targets[0];
    }
    defineValues() {
      if (this.constructor.values == void 0) {
        return;
      }
      const keys2 = Object.keys(this.constructor.values);
      keys2.forEach(this.mapValues(this.constructor.values).bind(this));
    }
    mapValues(values) {
      return function(key) {
        this[key + "Value"] = this.parseValue(key, values[key]);
      };
    }
    parseValue(key, keyType) {
      const dataKey = this.camelize(`${this.name}-${key}-value`);
      const val2 = this.dataset[dataKey];
      if (val2 == void 0) {
        return void 0;
      }
      switch (keyType) {
        case Array:
          return JSON.parse(val2);
        case Boolean:
          return !(val2 == "0" || val2 == "false");
        case Number:
          return Number(val2);
        case Object:
          return JSON.parse(val2);
        default:
          return val2;
      }
    }
    attachActions() {
      const actionElements = Array.from(
        this.querySelectorAll("[data-action]")
      );
      if (this.dataset.action) {
        actionElements.push(this);
      }
      this.actions = actionElements.flatMap(this.parseAction.bind(this));
      this.actions.forEach(this.bindAction.bind(this));
    }
    connectedCallback() {
      this.name = this.dasherize(this.constructor.name).replace("-controller-default", "").replace("-controller", "");
      this.attachActions();
      this.defineValues();
      this.defineTargets();
      this.connect && this.connect();
    }
    disconnectedCallback() {
      this.disconnect && this.disconnect();
    }
    dasherize(value) {
      const dash = value.replace(
        /([A-Z])/g,
        (_2, char) => `-${char.toLowerCase()}`
      );
      return dash.startsWith("-") ? dash.substr(1) : dash;
    }
    defaultEventName(el) {
      switch (el.nodeName) {
        case "DETAILS":
          return "toggle";
        case "FORM":
          return "submit";
        case "INPUT":
          if (el.type.toLowerCase() == "submit") {
            return "click";
          }
          return "input";
        case "SELECT":
          return "change";
        case "TEXTAREA":
          return "change";
        default:
          return "click";
      }
    }
  };
  Object.assign(Controller.prototype, mixins_default);

  // app/javascript/controllers/admin_cleave_controller.js
  var AdminCleaveController = class extends Controller {
    static {
      __name(this, "AdminCleaveController");
    }
    connect() {
      const input = this.querySelector("input");
      if (input.autocomplete == "cc-number") {
        this.cc({ target: input });
      } else {
        this.cleave({ target: input });
      }
    }
    cleave(e3) {
      const amount = parseInt(e3.target.value.replaceAll(" ", ""));
      if (isNaN(amount)) {
        return;
      }
      e3.target.value = parseInt(amount).toLocaleString("en").replaceAll(",", " ");
    }
    cc(e3) {
      const amount = e3.target.value.replaceAll(" ", "");
      const result = [];
      for (let i3 = 0; i3 < amount.length; i3 += 4) {
        result.push(amount.slice(i3, i3 + 4));
      }
      e3.target.value = result.join(" ");
    }
  };

  // app/javascript/controllers/admin_tab_controller.js
  var AdminTabController = class extends Controller {
    static {
      __name(this, "AdminTabController");
    }
    connect() {
      document.querySelectorAll("admin-tab-controller label").forEach(this.setCurrent.bind(this));
    }
    mark(e3) {
      document.querySelectorAll("admin-tab-controller label").forEach(this.unselect);
      this.select(e3.target);
    }
    setCurrent(target) {
      const checkbox = document.getElementById(target.getAttribute("for"));
      if (checkbox.checked) {
        this.select(target);
      } else {
        this.unselect(target);
      }
    }
    unselect(target) {
      target.classList.add("bg-neutral-200", "hover:bg-neutral-300");
      target.classList.remove("bg-cyan-200");
    }
    select(target) {
      target.classList.remove("bg-neutral-200", "hover:bg-neutral-300");
      target.classList.add("bg-cyan-200");
    }
  };

  // node_modules/js-cookie/dist/js.cookie.mjs
  function assign(target) {
    for (var i3 = 1; i3 < arguments.length; i3++) {
      var source = arguments[i3];
      for (var key in source) {
        target[key] = source[key];
      }
    }
    return target;
  }
  __name(assign, "assign");
  var defaultConverter = {
    read: function(value) {
      if (value[0] === '"') {
        value = value.slice(1, -1);
      }
      return value.replace(/(%[\dA-F]{2})+/gi, decodeURIComponent);
    },
    write: function(value) {
      return encodeURIComponent(value).replace(
        /%(2[346BF]|3[AC-F]|40|5[BDE]|60|7[BCD])/g,
        decodeURIComponent
      );
    }
  };
  function init(converter, defaultAttributes) {
    function set(name, value, attributes) {
      if (typeof document === "undefined") {
        return;
      }
      attributes = assign({}, defaultAttributes, attributes);
      if (typeof attributes.expires === "number") {
        attributes.expires = new Date(Date.now() + attributes.expires * 864e5);
      }
      if (attributes.expires) {
        attributes.expires = attributes.expires.toUTCString();
      }
      name = encodeURIComponent(name).replace(/%(2[346B]|5E|60|7C)/g, decodeURIComponent).replace(/[()]/g, escape);
      var stringifiedAttributes = "";
      for (var attributeName in attributes) {
        if (!attributes[attributeName]) {
          continue;
        }
        stringifiedAttributes += "; " + attributeName;
        if (attributes[attributeName] === true) {
          continue;
        }
        stringifiedAttributes += "=" + attributes[attributeName].split(";")[0];
      }
      return document.cookie = name + "=" + converter.write(value, name) + stringifiedAttributes;
    }
    __name(set, "set");
    function get(name) {
      if (typeof document === "undefined" || arguments.length && !name) {
        return;
      }
      var cookies = document.cookie ? document.cookie.split("; ") : [];
      var jar = {};
      for (var i3 = 0; i3 < cookies.length; i3++) {
        var parts = cookies[i3].split("=");
        var value = parts.slice(1).join("=");
        try {
          var found = decodeURIComponent(parts[0]);
          jar[found] = converter.read(value, found);
          if (name === found) {
            break;
          }
        } catch (e3) {
        }
      }
      return name ? jar[name] : jar;
    }
    __name(get, "get");
    return Object.create(
      {
        set,
        get,
        remove: function(name, attributes) {
          set(
            name,
            "",
            assign({}, attributes, {
              expires: -1
            })
          );
        },
        withAttributes: function(attributes) {
          return init(this.converter, assign({}, this.attributes, attributes));
        },
        withConverter: function(converter2) {
          return init(assign({}, this.converter, converter2), this.attributes);
        }
      },
      {
        attributes: { value: Object.freeze(defaultAttributes) },
        converter: { value: Object.freeze(converter) }
      }
    );
  }
  __name(init, "init");
  var api = init(defaultConverter, { path: "/" });

  // app/javascript/controllers/back_to_scope_controller.js
  var BackToScopeController = class extends Controller {
    static {
      __name(this, "BackToScopeController");
    }
    click(e3) {
      const resource = this.dataset["resource"];
      const url = api.get(`return_to_${resource}_tab`);
      if (url) {
        e3.preventDefault();
        window.Turbo.visit(e3.target.href + "?scope=" + url);
      }
    }
  };

  // app/javascript/controllers/batch_action_controller.js
  var BatchActionController = class extends Controller {
    static {
      __name(this, "BatchActionController");
    }
    static targets = ["actionbar", "all", "checkbox"];
    checkbox(e3) {
      if (this.checkboxTargets.some(this.isChecked)) {
        this.showActions();
      } else {
        this.hideActions();
      }
    }
    isChecked(checkbox) {
      return checkbox.checked;
    }
    showActions() {
      this.actionbarTarget.classList.remove("hidden");
      this.allTarget.checked = true;
    }
    hideActions() {
      this.actionbarTarget.classList.add("hidden");
      this.allTarget.checked = false;
    }
  };

  // app/javascript/controllers/clickable_row_controller.js
  var ClickableRowController = class extends Controller {
    static {
      __name(this, "ClickableRowController");
    }
    connect() {
      this.querySelectorAll("[data-link]").forEach(this.addHoverClasses);
    }
    addHoverClasses(tr) {
      tr.classList.add("cursor-pointer", "hover:bg-neutral-200");
    }
    click(e3) {
      if (e3.target.tagName == "A" || e3.target.tagName == "INPUT") {
        return true;
      }
      const link = e3.target.closest("tr").dataset["link"];
      if (e3.which == 2 || e3.which == 4 || e3.metaKey || e3.ctrlKey) {
        window.open(link, "_blank");
      } else {
        e3.preventDefault();
        window.Turbo.visit(link);
      }
    }
  };

  // ../highway/node_modules/@johanhalse/musculus/dist/musculus.js
  var mixins_default2 = {
    camelize: function(value) {
      return value.replace(
        /(?:[_-])([a-z0-9])/g,
        (_2, char) => char.toUpperCase()
      );
    },
    dasherize: function(value) {
      const dash = value.replace(
        /([A-Z])/g,
        (_2, char) => `-${char.toLowerCase()}`
      );
      return dash.startsWith("-") ? dash.substr(1) : dash;
    }
  };
  var Application2 = class {
    static {
      __name(this, "Application");
    }
    constructor() {
      this.controllers = {};
    }
    start(dom) {
      this.window = window;
      this.document = document;
      this.connect();
    }
    connect() {
      for (let key in this.controllers) {
        this.window.customElements.define(key, this.controllers[key]);
      }
    }
    register(controller) {
      let controllerName = this.dasherize(controller.name.replace("Default", ""));
      this.controllers[controllerName] = controller;
    }
  };
  Object.assign(Application2.prototype, mixins_default2);
  var application2 = new Application2();
  var Controller2 = class extends window.HTMLElement {
    static {
      __name(this, "Controller");
    }
    constructor() {
      super();
      this.element = this;
      this.descriptorPattern = /^(?:(.+?)(?:\.(.+?))?(?:@(window|document))?->)?(.+?)(?:#([^:]+?))(?::(.+))?$/;
    }
    bindAction(action) {
      if (action.identifier != this.name) {
        return;
      }
      action.boundFn = this[action.methodName].bind(this);
      action.listener = action.eventTarget.addEventListener(
        action.eventName || this.defaultEventName(action.eventTarget),
        action.boundFn,
        false
      );
    }
    parseAction(el) {
      const actions = el.dataset.action.split(" ");
      return actions.map(this.parseActionDescriptorString(el).bind(this));
    }
    parseActionDescriptorString(el) {
      return function(descriptorString) {
        const source = descriptorString.trim();
        const matches2 = source.match(this.descriptorPattern) || [];
        let eventName = matches2[1];
        let keyFilter = matches2[2];
        if (keyFilter && !["keydown", "keyup", "keypress"].includes(eventName)) {
          eventName += `.${keyFilter}`;
          keyFilter = "";
        }
        return {
          eventTarget: this.parseEventTarget(matches2[3]) || el,
          eventName,
          eventOptions: matches2[6] ? this.parseEventOptions(matches2[6]) : {},
          identifier: matches2[4],
          methodName: matches2[5],
          keyFilter
        };
      };
    }
    parseEventTarget(eventTargetName) {
      if (eventTargetName == "window") {
        return window;
      }
      if (eventTargetName == "document") {
        return document;
      }
    }
    parseEventOptions(eventOptions) {
      return eventOptions.split(":").reduce(
        (options, token) => Object.assign(options, {
          [token.replace(/^!/, "")]: !/^!/.test(token)
        }),
        {}
      );
    }
    defineTargets() {
      if (this.constructor.targets == void 0) {
        return;
      }
      this.constructor.targets.forEach(this.mapTargets.bind(this));
    }
    mapTargets(targetName) {
      const targets = this.querySelectorAll(
        `[data-${this.name}-target="${targetName}"]`
      );
      this[targetName + "Targets"] = Array.from(targets);
      this[targetName + "Target"] = targets[0];
    }
    defineValues() {
      if (this.constructor.values == void 0) {
        return;
      }
      const keys2 = Object.keys(this.constructor.values);
      keys2.forEach(this.mapValues(this.constructor.values).bind(this));
    }
    mapValues(values) {
      return function(key) {
        this[key + "Value"] = this.parseValue(key, values[key]);
      };
    }
    parseValue(key, keyType) {
      const dataKey = this.camelize(`${this.name}-${key}-value`);
      const val2 = this.dataset[dataKey];
      if (val2 == void 0) {
        return void 0;
      }
      switch (keyType) {
        case Array:
          return JSON.parse(val2);
        case Boolean:
          return !(val2 == "0" || val2 == "false");
        case Number:
          return Number(val2);
        case Object:
          return JSON.parse(val2);
        default:
          return val2;
      }
    }
    attachActions() {
      const actionElements = Array.from(
        this.querySelectorAll("[data-action]")
      );
      if (this.dataset.action) {
        actionElements.push(this);
      }
      this.actions = actionElements.flatMap(this.parseAction.bind(this));
      this.actions.forEach(this.bindAction.bind(this));
    }
    connectedCallback() {
      this.name = this.dasherize(this.constructor.name).replace("-controller-default", "").replace("-controller", "");
      this.attachActions();
      this.defineValues();
      this.defineTargets();
      this.connect && this.connect();
    }
    disconnectedCallback() {
      this.disconnect && this.disconnect();
    }
    dasherize(value) {
      const dash = value.replace(
        /([A-Z])/g,
        (_2, char) => `-${char.toLowerCase()}`
      );
      return dash.startsWith("-") ? dash.substr(1) : dash;
    }
    defaultEventName(el) {
      switch (el.nodeName) {
        case "DETAILS":
          return "toggle";
        case "FORM":
          return "submit";
        case "INPUT":
          if (el.type.toLowerCase() == "submit") {
            return "click";
          }
          return "input";
        case "SELECT":
          return "change";
        case "TEXTAREA":
          return "change";
        default:
          return "click";
      }
    }
  };
  Object.assign(Controller2.prototype, mixins_default2);

  // ../highway/app/javascript/admin/commission_calculator_controller.js
  var CommissionCalculatorController = class extends Controller2 {
    static {
      __name(this, "CommissionCalculatorController");
    }
    static targets = ["salePrice", "commission", "vat", "totalCommission"];
    priceChanged(e3) {
      const price = this.parseInt(this.salePriceTarget.value);
      const commission = Math.round(price * 0.06);
      this.commissionTarget.value = this.clamp(commission, 4e3, 6e4);
      this.cleave(this.commissionTarget);
      this.updateTotalCommission();
    }
    cleave(input) {
      const amount = parseInt(input.value.replaceAll(" ", ""));
      if (isNaN(amount)) {
        return;
      }
      input.value = parseInt(amount).toLocaleString("en").replaceAll(",", " ");
    }
    updateTotalCommission(e3) {
      const commission = this.parseInt(this.commissionTarget.value);
      const vat = this.parseFloat(this.vatTarget.value);
      this.totalCommissionTarget.value = commission * vat;
      this.cleave(this.totalCommissionTarget);
    }
    updateVat(e3) {
      const total = this.parseInt(this.totalCommissionTarget.value);
      const vat = this.parseFloat(this.vatTarget.value);
      this.commissionTarget.value = total / vat;
      this.cleave(this.commissionTarget);
    }
    clamp(num, min, max) {
      return Math.min(Math.max(num, min), max);
    }
    parseInt(num) {
      return parseInt(num.replaceAll(" ", ""));
    }
    parseFloat(num) {
      return parseFloat(num.replaceAll(" ", ""));
    }
  };

  // node_modules/flatpickr/dist/esm/types/options.js
  var HOOKS = [
    "onChange",
    "onClose",
    "onDayCreate",
    "onDestroy",
    "onKeyDown",
    "onMonthChange",
    "onOpen",
    "onParseConfig",
    "onReady",
    "onValueUpdate",
    "onYearChange",
    "onPreCalendarPosition"
  ];
  var defaults = {
    _disable: [],
    allowInput: false,
    allowInvalidPreload: false,
    altFormat: "F j, Y",
    altInput: false,
    altInputClass: "form-control input",
    animate: typeof window === "object" && window.navigator.userAgent.indexOf("MSIE") === -1,
    ariaDateFormat: "F j, Y",
    autoFillDefaultTime: true,
    clickOpens: true,
    closeOnSelect: true,
    conjunction: ", ",
    dateFormat: "Y-m-d",
    defaultHour: 12,
    defaultMinute: 0,
    defaultSeconds: 0,
    disable: [],
    disableMobile: false,
    enableSeconds: false,
    enableTime: false,
    errorHandler: function(err) {
      return typeof console !== "undefined" && console.warn(err);
    },
    getWeek: function(givenDate) {
      var date = new Date(givenDate.getTime());
      date.setHours(0, 0, 0, 0);
      date.setDate(date.getDate() + 3 - (date.getDay() + 6) % 7);
      var week1 = new Date(date.getFullYear(), 0, 4);
      return 1 + Math.round(((date.getTime() - week1.getTime()) / 864e5 - 3 + (week1.getDay() + 6) % 7) / 7);
    },
    hourIncrement: 1,
    ignoredFocusElements: [],
    inline: false,
    locale: "default",
    minuteIncrement: 5,
    mode: "single",
    monthSelectorType: "dropdown",
    nextArrow: "<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 17 17'><g></g><path d='M13.207 8.472l-7.854 7.854-0.707-0.707 7.146-7.146-7.146-7.148 0.707-0.707 7.854 7.854z' /></svg>",
    noCalendar: false,
    now: /* @__PURE__ */ new Date(),
    onChange: [],
    onClose: [],
    onDayCreate: [],
    onDestroy: [],
    onKeyDown: [],
    onMonthChange: [],
    onOpen: [],
    onParseConfig: [],
    onReady: [],
    onValueUpdate: [],
    onYearChange: [],
    onPreCalendarPosition: [],
    plugins: [],
    position: "auto",
    positionElement: void 0,
    prevArrow: "<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 17 17'><g></g><path d='M5.207 8.471l7.146 7.147-0.707 0.707-7.853-7.854 7.854-7.853 0.707 0.707-7.147 7.146z' /></svg>",
    shorthandCurrentMonth: false,
    showMonths: 1,
    static: false,
    time_24hr: false,
    weekNumbers: false,
    wrap: false
  };

  // node_modules/flatpickr/dist/esm/l10n/default.js
  var english = {
    weekdays: {
      shorthand: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
      longhand: [
        "Sunday",
        "Monday",
        "Tuesday",
        "Wednesday",
        "Thursday",
        "Friday",
        "Saturday"
      ]
    },
    months: {
      shorthand: [
        "Jan",
        "Feb",
        "Mar",
        "Apr",
        "May",
        "Jun",
        "Jul",
        "Aug",
        "Sep",
        "Oct",
        "Nov",
        "Dec"
      ],
      longhand: [
        "January",
        "February",
        "March",
        "April",
        "May",
        "June",
        "July",
        "August",
        "September",
        "October",
        "November",
        "December"
      ]
    },
    daysInMonth: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
    firstDayOfWeek: 0,
    ordinal: function(nth) {
      var s3 = nth % 100;
      if (s3 > 3 && s3 < 21)
        return "th";
      switch (s3 % 10) {
        case 1:
          return "st";
        case 2:
          return "nd";
        case 3:
          return "rd";
        default:
          return "th";
      }
    },
    rangeSeparator: " to ",
    weekAbbreviation: "Wk",
    scrollTitle: "Scroll to increment",
    toggleTitle: "Click to toggle",
    amPM: ["AM", "PM"],
    yearAriaLabel: "Year",
    monthAriaLabel: "Month",
    hourAriaLabel: "Hour",
    minuteAriaLabel: "Minute",
    time_24hr: false
  };
  var default_default = english;

  // node_modules/flatpickr/dist/esm/utils/index.js
  var pad = /* @__PURE__ */ __name(function(number, length) {
    if (length === void 0) {
      length = 2;
    }
    return ("000" + number).slice(length * -1);
  }, "pad");
  var int = /* @__PURE__ */ __name(function(bool) {
    return bool === true ? 1 : 0;
  }, "int");
  function debounce2(fn, wait) {
    var t3;
    return function() {
      var _this = this;
      var args = arguments;
      clearTimeout(t3);
      t3 = setTimeout(function() {
        return fn.apply(_this, args);
      }, wait);
    };
  }
  __name(debounce2, "debounce");
  var arrayify = /* @__PURE__ */ __name(function(obj) {
    return obj instanceof Array ? obj : [obj];
  }, "arrayify");

  // node_modules/flatpickr/dist/esm/utils/dom.js
  function toggleClass(elem, className, bool) {
    if (bool === true)
      return elem.classList.add(className);
    elem.classList.remove(className);
  }
  __name(toggleClass, "toggleClass");
  function createElement(tag, className, content) {
    var e3 = window.document.createElement(tag);
    className = className || "";
    content = content || "";
    e3.className = className;
    if (content !== void 0)
      e3.textContent = content;
    return e3;
  }
  __name(createElement, "createElement");
  function clearNode(node) {
    while (node.firstChild)
      node.removeChild(node.firstChild);
  }
  __name(clearNode, "clearNode");
  function findParent(node, condition) {
    if (condition(node))
      return node;
    else if (node.parentNode)
      return findParent(node.parentNode, condition);
    return void 0;
  }
  __name(findParent, "findParent");
  function createNumberInput(inputClassName, opts) {
    var wrapper = createElement("div", "numInputWrapper"), numInput = createElement("input", "numInput " + inputClassName), arrowUp = createElement("span", "arrowUp"), arrowDown = createElement("span", "arrowDown");
    if (navigator.userAgent.indexOf("MSIE 9.0") === -1) {
      numInput.type = "number";
    } else {
      numInput.type = "text";
      numInput.pattern = "\\d*";
    }
    if (opts !== void 0)
      for (var key in opts)
        numInput.setAttribute(key, opts[key]);
    wrapper.appendChild(numInput);
    wrapper.appendChild(arrowUp);
    wrapper.appendChild(arrowDown);
    return wrapper;
  }
  __name(createNumberInput, "createNumberInput");
  function getEventTarget(event) {
    try {
      if (typeof event.composedPath === "function") {
        var path = event.composedPath();
        return path[0];
      }
      return event.target;
    } catch (error) {
      return event.target;
    }
  }
  __name(getEventTarget, "getEventTarget");

  // node_modules/flatpickr/dist/esm/utils/formatting.js
  var doNothing = /* @__PURE__ */ __name(function() {
    return void 0;
  }, "doNothing");
  var monthToStr = /* @__PURE__ */ __name(function(monthNumber, shorthand, locale) {
    return locale.months[shorthand ? "shorthand" : "longhand"][monthNumber];
  }, "monthToStr");
  var revFormat = {
    D: doNothing,
    F: function(dateObj, monthName, locale) {
      dateObj.setMonth(locale.months.longhand.indexOf(monthName));
    },
    G: function(dateObj, hour) {
      dateObj.setHours((dateObj.getHours() >= 12 ? 12 : 0) + parseFloat(hour));
    },
    H: function(dateObj, hour) {
      dateObj.setHours(parseFloat(hour));
    },
    J: function(dateObj, day) {
      dateObj.setDate(parseFloat(day));
    },
    K: function(dateObj, amPM, locale) {
      dateObj.setHours(dateObj.getHours() % 12 + 12 * int(new RegExp(locale.amPM[1], "i").test(amPM)));
    },
    M: function(dateObj, shortMonth, locale) {
      dateObj.setMonth(locale.months.shorthand.indexOf(shortMonth));
    },
    S: function(dateObj, seconds) {
      dateObj.setSeconds(parseFloat(seconds));
    },
    U: function(_2, unixSeconds) {
      return new Date(parseFloat(unixSeconds) * 1e3);
    },
    W: function(dateObj, weekNum, locale) {
      var weekNumber = parseInt(weekNum);
      var date = new Date(dateObj.getFullYear(), 0, 2 + (weekNumber - 1) * 7, 0, 0, 0, 0);
      date.setDate(date.getDate() - date.getDay() + locale.firstDayOfWeek);
      return date;
    },
    Y: function(dateObj, year) {
      dateObj.setFullYear(parseFloat(year));
    },
    Z: function(_2, ISODate) {
      return new Date(ISODate);
    },
    d: function(dateObj, day) {
      dateObj.setDate(parseFloat(day));
    },
    h: function(dateObj, hour) {
      dateObj.setHours((dateObj.getHours() >= 12 ? 12 : 0) + parseFloat(hour));
    },
    i: function(dateObj, minutes) {
      dateObj.setMinutes(parseFloat(minutes));
    },
    j: function(dateObj, day) {
      dateObj.setDate(parseFloat(day));
    },
    l: doNothing,
    m: function(dateObj, month) {
      dateObj.setMonth(parseFloat(month) - 1);
    },
    n: function(dateObj, month) {
      dateObj.setMonth(parseFloat(month) - 1);
    },
    s: function(dateObj, seconds) {
      dateObj.setSeconds(parseFloat(seconds));
    },
    u: function(_2, unixMillSeconds) {
      return new Date(parseFloat(unixMillSeconds));
    },
    w: doNothing,
    y: function(dateObj, year) {
      dateObj.setFullYear(2e3 + parseFloat(year));
    }
  };
  var tokenRegex = {
    D: "",
    F: "",
    G: "(\\d\\d|\\d)",
    H: "(\\d\\d|\\d)",
    J: "(\\d\\d|\\d)\\w+",
    K: "",
    M: "",
    S: "(\\d\\d|\\d)",
    U: "(.+)",
    W: "(\\d\\d|\\d)",
    Y: "(\\d{4})",
    Z: "(.+)",
    d: "(\\d\\d|\\d)",
    h: "(\\d\\d|\\d)",
    i: "(\\d\\d|\\d)",
    j: "(\\d\\d|\\d)",
    l: "",
    m: "(\\d\\d|\\d)",
    n: "(\\d\\d|\\d)",
    s: "(\\d\\d|\\d)",
    u: "(.+)",
    w: "(\\d\\d|\\d)",
    y: "(\\d{2})"
  };
  var formats = {
    Z: function(date) {
      return date.toISOString();
    },
    D: function(date, locale, options) {
      return locale.weekdays.shorthand[formats.w(date, locale, options)];
    },
    F: function(date, locale, options) {
      return monthToStr(formats.n(date, locale, options) - 1, false, locale);
    },
    G: function(date, locale, options) {
      return pad(formats.h(date, locale, options));
    },
    H: function(date) {
      return pad(date.getHours());
    },
    J: function(date, locale) {
      return locale.ordinal !== void 0 ? date.getDate() + locale.ordinal(date.getDate()) : date.getDate();
    },
    K: function(date, locale) {
      return locale.amPM[int(date.getHours() > 11)];
    },
    M: function(date, locale) {
      return monthToStr(date.getMonth(), true, locale);
    },
    S: function(date) {
      return pad(date.getSeconds());
    },
    U: function(date) {
      return date.getTime() / 1e3;
    },
    W: function(date, _2, options) {
      return options.getWeek(date);
    },
    Y: function(date) {
      return pad(date.getFullYear(), 4);
    },
    d: function(date) {
      return pad(date.getDate());
    },
    h: function(date) {
      return date.getHours() % 12 ? date.getHours() % 12 : 12;
    },
    i: function(date) {
      return pad(date.getMinutes());
    },
    j: function(date) {
      return date.getDate();
    },
    l: function(date, locale) {
      return locale.weekdays.longhand[date.getDay()];
    },
    m: function(date) {
      return pad(date.getMonth() + 1);
    },
    n: function(date) {
      return date.getMonth() + 1;
    },
    s: function(date) {
      return date.getSeconds();
    },
    u: function(date) {
      return date.getTime();
    },
    w: function(date) {
      return date.getDay();
    },
    y: function(date) {
      return String(date.getFullYear()).substring(2);
    }
  };

  // node_modules/flatpickr/dist/esm/utils/dates.js
  var createDateFormatter = /* @__PURE__ */ __name(function(_a) {
    var _b = _a.config, config4 = _b === void 0 ? defaults : _b, _c = _a.l10n, l10n = _c === void 0 ? english : _c, _d = _a.isMobile, isMobile = _d === void 0 ? false : _d;
    return function(dateObj, frmt, overrideLocale) {
      var locale = overrideLocale || l10n;
      if (config4.formatDate !== void 0 && !isMobile) {
        return config4.formatDate(dateObj, frmt, locale);
      }
      return frmt.split("").map(function(c3, i3, arr) {
        return formats[c3] && arr[i3 - 1] !== "\\" ? formats[c3](dateObj, locale, config4) : c3 !== "\\" ? c3 : "";
      }).join("");
    };
  }, "createDateFormatter");
  var createDateParser = /* @__PURE__ */ __name(function(_a) {
    var _b = _a.config, config4 = _b === void 0 ? defaults : _b, _c = _a.l10n, l10n = _c === void 0 ? english : _c;
    return function(date, givenFormat, timeless, customLocale) {
      if (date !== 0 && !date)
        return void 0;
      var locale = customLocale || l10n;
      var parsedDate;
      var dateOrig = date;
      if (date instanceof Date)
        parsedDate = new Date(date.getTime());
      else if (typeof date !== "string" && date.toFixed !== void 0)
        parsedDate = new Date(date);
      else if (typeof date === "string") {
        var format = givenFormat || (config4 || defaults).dateFormat;
        var datestr = String(date).trim();
        if (datestr === "today") {
          parsedDate = /* @__PURE__ */ new Date();
          timeless = true;
        } else if (config4 && config4.parseDate) {
          parsedDate = config4.parseDate(date, format);
        } else if (/Z$/.test(datestr) || /GMT$/.test(datestr)) {
          parsedDate = new Date(date);
        } else {
          var matched = void 0, ops = [];
          for (var i3 = 0, matchIndex = 0, regexStr = ""; i3 < format.length; i3++) {
            var token = format[i3];
            var isBackSlash = token === "\\";
            var escaped = format[i3 - 1] === "\\" || isBackSlash;
            if (tokenRegex[token] && !escaped) {
              regexStr += tokenRegex[token];
              var match2 = new RegExp(regexStr).exec(date);
              if (match2 && (matched = true)) {
                ops[token !== "Y" ? "push" : "unshift"]({
                  fn: revFormat[token],
                  val: match2[++matchIndex]
                });
              }
            } else if (!isBackSlash)
              regexStr += ".";
          }
          parsedDate = !config4 || !config4.noCalendar ? new Date((/* @__PURE__ */ new Date()).getFullYear(), 0, 1, 0, 0, 0, 0) : new Date((/* @__PURE__ */ new Date()).setHours(0, 0, 0, 0));
          ops.forEach(function(_a2) {
            var fn = _a2.fn, val2 = _a2.val;
            return parsedDate = fn(parsedDate, val2, locale) || parsedDate;
          });
          parsedDate = matched ? parsedDate : void 0;
        }
      }
      if (!(parsedDate instanceof Date && !isNaN(parsedDate.getTime()))) {
        config4.errorHandler(new Error("Invalid date provided: " + dateOrig));
        return void 0;
      }
      if (timeless === true)
        parsedDate.setHours(0, 0, 0, 0);
      return parsedDate;
    };
  }, "createDateParser");
  function compareDates(date1, date2, timeless) {
    if (timeless === void 0) {
      timeless = true;
    }
    if (timeless !== false) {
      return new Date(date1.getTime()).setHours(0, 0, 0, 0) - new Date(date2.getTime()).setHours(0, 0, 0, 0);
    }
    return date1.getTime() - date2.getTime();
  }
  __name(compareDates, "compareDates");
  var isBetween = /* @__PURE__ */ __name(function(ts, ts1, ts2) {
    return ts > Math.min(ts1, ts2) && ts < Math.max(ts1, ts2);
  }, "isBetween");
  var calculateSecondsSinceMidnight = /* @__PURE__ */ __name(function(hours, minutes, seconds) {
    return hours * 3600 + minutes * 60 + seconds;
  }, "calculateSecondsSinceMidnight");
  var parseSeconds = /* @__PURE__ */ __name(function(secondsSinceMidnight) {
    var hours = Math.floor(secondsSinceMidnight / 3600), minutes = (secondsSinceMidnight - hours * 3600) / 60;
    return [hours, minutes, secondsSinceMidnight - hours * 3600 - minutes * 60];
  }, "parseSeconds");
  var duration = {
    DAY: 864e5
  };
  function getDefaultHours(config4) {
    var hours = config4.defaultHour;
    var minutes = config4.defaultMinute;
    var seconds = config4.defaultSeconds;
    if (config4.minDate !== void 0) {
      var minHour = config4.minDate.getHours();
      var minMinutes = config4.minDate.getMinutes();
      var minSeconds = config4.minDate.getSeconds();
      if (hours < minHour) {
        hours = minHour;
      }
      if (hours === minHour && minutes < minMinutes) {
        minutes = minMinutes;
      }
      if (hours === minHour && minutes === minMinutes && seconds < minSeconds)
        seconds = config4.minDate.getSeconds();
    }
    if (config4.maxDate !== void 0) {
      var maxHr = config4.maxDate.getHours();
      var maxMinutes = config4.maxDate.getMinutes();
      hours = Math.min(hours, maxHr);
      if (hours === maxHr)
        minutes = Math.min(maxMinutes, minutes);
      if (hours === maxHr && minutes === maxMinutes)
        seconds = config4.maxDate.getSeconds();
    }
    return { hours, minutes, seconds };
  }
  __name(getDefaultHours, "getDefaultHours");

  // node_modules/flatpickr/dist/esm/utils/polyfills.js
  if (typeof Object.assign !== "function") {
    Object.assign = function(target) {
      var args = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
      }
      if (!target) {
        throw TypeError("Cannot convert undefined or null to object");
      }
      var _loop_1 = /* @__PURE__ */ __name(function(source2) {
        if (source2) {
          Object.keys(source2).forEach(function(key) {
            return target[key] = source2[key];
          });
        }
      }, "_loop_1");
      for (var _a = 0, args_1 = args; _a < args_1.length; _a++) {
        var source = args_1[_a];
        _loop_1(source);
      }
      return target;
    };
  }

  // node_modules/flatpickr/dist/esm/index.js
  var __assign = function() {
    __assign = Object.assign || function(t3) {
      for (var s3, i3 = 1, n3 = arguments.length; i3 < n3; i3++) {
        s3 = arguments[i3];
        for (var p3 in s3)
          if (Object.prototype.hasOwnProperty.call(s3, p3))
            t3[p3] = s3[p3];
      }
      return t3;
    };
    return __assign.apply(this, arguments);
  };
  var __spreadArrays = function() {
    for (var s3 = 0, i3 = 0, il = arguments.length; i3 < il; i3++)
      s3 += arguments[i3].length;
    for (var r3 = Array(s3), k3 = 0, i3 = 0; i3 < il; i3++)
      for (var a3 = arguments[i3], j3 = 0, jl = a3.length; j3 < jl; j3++, k3++)
        r3[k3] = a3[j3];
    return r3;
  };
  var DEBOUNCED_CHANGE_MS = 300;
  function FlatpickrInstance(element, instanceConfig) {
    var self2 = {
      config: __assign(__assign({}, defaults), flatpickr.defaultConfig),
      l10n: default_default
    };
    self2.parseDate = createDateParser({ config: self2.config, l10n: self2.l10n });
    self2._handlers = [];
    self2.pluginElements = [];
    self2.loadedPlugins = [];
    self2._bind = bind;
    self2._setHoursFromDate = setHoursFromDate;
    self2._positionCalendar = positionCalendar;
    self2.changeMonth = changeMonth;
    self2.changeYear = changeYear;
    self2.clear = clear;
    self2.close = close;
    self2.onMouseOver = onMouseOver;
    self2._createElement = createElement;
    self2.createDay = createDay;
    self2.destroy = destroy2;
    self2.isEnabled = isEnabled;
    self2.jumpToDate = jumpToDate;
    self2.updateValue = updateValue;
    self2.open = open;
    self2.redraw = redraw;
    self2.set = set;
    self2.setDate = setDate;
    self2.toggle = toggle;
    function setupHelperFunctions() {
      self2.utils = {
        getDaysInMonth: function(month, yr) {
          if (month === void 0) {
            month = self2.currentMonth;
          }
          if (yr === void 0) {
            yr = self2.currentYear;
          }
          if (month === 1 && (yr % 4 === 0 && yr % 100 !== 0 || yr % 400 === 0))
            return 29;
          return self2.l10n.daysInMonth[month];
        }
      };
    }
    __name(setupHelperFunctions, "setupHelperFunctions");
    function init2() {
      self2.element = self2.input = element;
      self2.isOpen = false;
      parseConfig();
      setupLocale();
      setupInputs();
      setupDates();
      setupHelperFunctions();
      if (!self2.isMobile)
        build();
      bindEvents();
      if (self2.selectedDates.length || self2.config.noCalendar) {
        if (self2.config.enableTime) {
          setHoursFromDate(self2.config.noCalendar ? self2.latestSelectedDateObj : void 0);
        }
        updateValue(false);
      }
      setCalendarWidth();
      var isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
      if (!self2.isMobile && isSafari) {
        positionCalendar();
      }
      triggerEvent("onReady");
    }
    __name(init2, "init");
    function getClosestActiveElement() {
      var _a;
      return ((_a = self2.calendarContainer) === null || _a === void 0 ? void 0 : _a.getRootNode()).activeElement || document.activeElement;
    }
    __name(getClosestActiveElement, "getClosestActiveElement");
    function bindToInstance(fn) {
      return fn.bind(self2);
    }
    __name(bindToInstance, "bindToInstance");
    function setCalendarWidth() {
      var config4 = self2.config;
      if (config4.weekNumbers === false && config4.showMonths === 1) {
        return;
      } else if (config4.noCalendar !== true) {
        window.requestAnimationFrame(function() {
          if (self2.calendarContainer !== void 0) {
            self2.calendarContainer.style.visibility = "hidden";
            self2.calendarContainer.style.display = "block";
          }
          if (self2.daysContainer !== void 0) {
            var daysWidth = (self2.days.offsetWidth + 1) * config4.showMonths;
            self2.daysContainer.style.width = daysWidth + "px";
            self2.calendarContainer.style.width = daysWidth + (self2.weekWrapper !== void 0 ? self2.weekWrapper.offsetWidth : 0) + "px";
            self2.calendarContainer.style.removeProperty("visibility");
            self2.calendarContainer.style.removeProperty("display");
          }
        });
      }
    }
    __name(setCalendarWidth, "setCalendarWidth");
    function updateTime(e3) {
      if (self2.selectedDates.length === 0) {
        var defaultDate = self2.config.minDate === void 0 || compareDates(/* @__PURE__ */ new Date(), self2.config.minDate) >= 0 ? /* @__PURE__ */ new Date() : new Date(self2.config.minDate.getTime());
        var defaults4 = getDefaultHours(self2.config);
        defaultDate.setHours(defaults4.hours, defaults4.minutes, defaults4.seconds, defaultDate.getMilliseconds());
        self2.selectedDates = [defaultDate];
        self2.latestSelectedDateObj = defaultDate;
      }
      if (e3 !== void 0 && e3.type !== "blur") {
        timeWrapper(e3);
      }
      var prevValue = self2._input.value;
      setHoursFromInputs();
      updateValue();
      if (self2._input.value !== prevValue) {
        self2._debouncedChange();
      }
    }
    __name(updateTime, "updateTime");
    function ampm2military(hour, amPM) {
      return hour % 12 + 12 * int(amPM === self2.l10n.amPM[1]);
    }
    __name(ampm2military, "ampm2military");
    function military2ampm(hour) {
      switch (hour % 24) {
        case 0:
        case 12:
          return 12;
        default:
          return hour % 12;
      }
    }
    __name(military2ampm, "military2ampm");
    function setHoursFromInputs() {
      if (self2.hourElement === void 0 || self2.minuteElement === void 0)
        return;
      var hours = (parseInt(self2.hourElement.value.slice(-2), 10) || 0) % 24, minutes = (parseInt(self2.minuteElement.value, 10) || 0) % 60, seconds = self2.secondElement !== void 0 ? (parseInt(self2.secondElement.value, 10) || 0) % 60 : 0;
      if (self2.amPM !== void 0) {
        hours = ampm2military(hours, self2.amPM.textContent);
      }
      var limitMinHours = self2.config.minTime !== void 0 || self2.config.minDate && self2.minDateHasTime && self2.latestSelectedDateObj && compareDates(self2.latestSelectedDateObj, self2.config.minDate, true) === 0;
      var limitMaxHours = self2.config.maxTime !== void 0 || self2.config.maxDate && self2.maxDateHasTime && self2.latestSelectedDateObj && compareDates(self2.latestSelectedDateObj, self2.config.maxDate, true) === 0;
      if (self2.config.maxTime !== void 0 && self2.config.minTime !== void 0 && self2.config.minTime > self2.config.maxTime) {
        var minBound = calculateSecondsSinceMidnight(self2.config.minTime.getHours(), self2.config.minTime.getMinutes(), self2.config.minTime.getSeconds());
        var maxBound = calculateSecondsSinceMidnight(self2.config.maxTime.getHours(), self2.config.maxTime.getMinutes(), self2.config.maxTime.getSeconds());
        var currentTime = calculateSecondsSinceMidnight(hours, minutes, seconds);
        if (currentTime > maxBound && currentTime < minBound) {
          var result = parseSeconds(minBound);
          hours = result[0];
          minutes = result[1];
          seconds = result[2];
        }
      } else {
        if (limitMaxHours) {
          var maxTime = self2.config.maxTime !== void 0 ? self2.config.maxTime : self2.config.maxDate;
          hours = Math.min(hours, maxTime.getHours());
          if (hours === maxTime.getHours())
            minutes = Math.min(minutes, maxTime.getMinutes());
          if (minutes === maxTime.getMinutes())
            seconds = Math.min(seconds, maxTime.getSeconds());
        }
        if (limitMinHours) {
          var minTime = self2.config.minTime !== void 0 ? self2.config.minTime : self2.config.minDate;
          hours = Math.max(hours, minTime.getHours());
          if (hours === minTime.getHours() && minutes < minTime.getMinutes())
            minutes = minTime.getMinutes();
          if (minutes === minTime.getMinutes())
            seconds = Math.max(seconds, minTime.getSeconds());
        }
      }
      setHours(hours, minutes, seconds);
    }
    __name(setHoursFromInputs, "setHoursFromInputs");
    function setHoursFromDate(dateObj) {
      var date = dateObj || self2.latestSelectedDateObj;
      if (date && date instanceof Date) {
        setHours(date.getHours(), date.getMinutes(), date.getSeconds());
      }
    }
    __name(setHoursFromDate, "setHoursFromDate");
    function setHours(hours, minutes, seconds) {
      if (self2.latestSelectedDateObj !== void 0) {
        self2.latestSelectedDateObj.setHours(hours % 24, minutes, seconds || 0, 0);
      }
      if (!self2.hourElement || !self2.minuteElement || self2.isMobile)
        return;
      self2.hourElement.value = pad(!self2.config.time_24hr ? (12 + hours) % 12 + 12 * int(hours % 12 === 0) : hours);
      self2.minuteElement.value = pad(minutes);
      if (self2.amPM !== void 0)
        self2.amPM.textContent = self2.l10n.amPM[int(hours >= 12)];
      if (self2.secondElement !== void 0)
        self2.secondElement.value = pad(seconds);
    }
    __name(setHours, "setHours");
    function onYearInput(event) {
      var eventTarget = getEventTarget(event);
      var year = parseInt(eventTarget.value) + (event.delta || 0);
      if (year / 1e3 > 1 || event.key === "Enter" && !/[^\d]/.test(year.toString())) {
        changeYear(year);
      }
    }
    __name(onYearInput, "onYearInput");
    function bind(element2, event, handler, options) {
      if (event instanceof Array)
        return event.forEach(function(ev) {
          return bind(element2, ev, handler, options);
        });
      if (element2 instanceof Array)
        return element2.forEach(function(el) {
          return bind(el, event, handler, options);
        });
      element2.addEventListener(event, handler, options);
      self2._handlers.push({
        remove: function() {
          return element2.removeEventListener(event, handler, options);
        }
      });
    }
    __name(bind, "bind");
    function triggerChange() {
      triggerEvent("onChange");
    }
    __name(triggerChange, "triggerChange");
    function bindEvents() {
      if (self2.config.wrap) {
        ["open", "close", "toggle", "clear"].forEach(function(evt) {
          Array.prototype.forEach.call(self2.element.querySelectorAll("[data-" + evt + "]"), function(el) {
            return bind(el, "click", self2[evt]);
          });
        });
      }
      if (self2.isMobile) {
        setupMobile();
        return;
      }
      var debouncedResize = debounce2(onResize, 50);
      self2._debouncedChange = debounce2(triggerChange, DEBOUNCED_CHANGE_MS);
      if (self2.daysContainer && !/iPhone|iPad|iPod/i.test(navigator.userAgent))
        bind(self2.daysContainer, "mouseover", function(e3) {
          if (self2.config.mode === "range")
            onMouseOver(getEventTarget(e3));
        });
      bind(self2._input, "keydown", onKeyDown);
      if (self2.calendarContainer !== void 0) {
        bind(self2.calendarContainer, "keydown", onKeyDown);
      }
      if (!self2.config.inline && !self2.config.static)
        bind(window, "resize", debouncedResize);
      if (window.ontouchstart !== void 0)
        bind(window.document, "touchstart", documentClick);
      else
        bind(window.document, "mousedown", documentClick);
      bind(window.document, "focus", documentClick, { capture: true });
      if (self2.config.clickOpens === true) {
        bind(self2._input, "focus", self2.open);
        bind(self2._input, "click", self2.open);
      }
      if (self2.daysContainer !== void 0) {
        bind(self2.monthNav, "click", onMonthNavClick);
        bind(self2.monthNav, ["keyup", "increment"], onYearInput);
        bind(self2.daysContainer, "click", selectDate);
      }
      if (self2.timeContainer !== void 0 && self2.minuteElement !== void 0 && self2.hourElement !== void 0) {
        var selText = /* @__PURE__ */ __name(function(e3) {
          return getEventTarget(e3).select();
        }, "selText");
        bind(self2.timeContainer, ["increment"], updateTime);
        bind(self2.timeContainer, "blur", updateTime, { capture: true });
        bind(self2.timeContainer, "click", timeIncrement);
        bind([self2.hourElement, self2.minuteElement], ["focus", "click"], selText);
        if (self2.secondElement !== void 0)
          bind(self2.secondElement, "focus", function() {
            return self2.secondElement && self2.secondElement.select();
          });
        if (self2.amPM !== void 0) {
          bind(self2.amPM, "click", function(e3) {
            updateTime(e3);
          });
        }
      }
      if (self2.config.allowInput) {
        bind(self2._input, "blur", onBlur);
      }
    }
    __name(bindEvents, "bindEvents");
    function jumpToDate(jumpDate, triggerChange2) {
      var jumpTo = jumpDate !== void 0 ? self2.parseDate(jumpDate) : self2.latestSelectedDateObj || (self2.config.minDate && self2.config.minDate > self2.now ? self2.config.minDate : self2.config.maxDate && self2.config.maxDate < self2.now ? self2.config.maxDate : self2.now);
      var oldYear = self2.currentYear;
      var oldMonth = self2.currentMonth;
      try {
        if (jumpTo !== void 0) {
          self2.currentYear = jumpTo.getFullYear();
          self2.currentMonth = jumpTo.getMonth();
        }
      } catch (e3) {
        e3.message = "Invalid date supplied: " + jumpTo;
        self2.config.errorHandler(e3);
      }
      if (triggerChange2 && self2.currentYear !== oldYear) {
        triggerEvent("onYearChange");
        buildMonthSwitch();
      }
      if (triggerChange2 && (self2.currentYear !== oldYear || self2.currentMonth !== oldMonth)) {
        triggerEvent("onMonthChange");
      }
      self2.redraw();
    }
    __name(jumpToDate, "jumpToDate");
    function timeIncrement(e3) {
      var eventTarget = getEventTarget(e3);
      if (~eventTarget.className.indexOf("arrow"))
        incrementNumInput(e3, eventTarget.classList.contains("arrowUp") ? 1 : -1);
    }
    __name(timeIncrement, "timeIncrement");
    function incrementNumInput(e3, delta, inputElem) {
      var target = e3 && getEventTarget(e3);
      var input = inputElem || target && target.parentNode && target.parentNode.firstChild;
      var event = createEvent("increment");
      event.delta = delta;
      input && input.dispatchEvent(event);
    }
    __name(incrementNumInput, "incrementNumInput");
    function build() {
      var fragment = window.document.createDocumentFragment();
      self2.calendarContainer = createElement("div", "flatpickr-calendar");
      self2.calendarContainer.tabIndex = -1;
      if (!self2.config.noCalendar) {
        fragment.appendChild(buildMonthNav());
        self2.innerContainer = createElement("div", "flatpickr-innerContainer");
        if (self2.config.weekNumbers) {
          var _a = buildWeeks(), weekWrapper = _a.weekWrapper, weekNumbers = _a.weekNumbers;
          self2.innerContainer.appendChild(weekWrapper);
          self2.weekNumbers = weekNumbers;
          self2.weekWrapper = weekWrapper;
        }
        self2.rContainer = createElement("div", "flatpickr-rContainer");
        self2.rContainer.appendChild(buildWeekdays());
        if (!self2.daysContainer) {
          self2.daysContainer = createElement("div", "flatpickr-days");
          self2.daysContainer.tabIndex = -1;
        }
        buildDays();
        self2.rContainer.appendChild(self2.daysContainer);
        self2.innerContainer.appendChild(self2.rContainer);
        fragment.appendChild(self2.innerContainer);
      }
      if (self2.config.enableTime) {
        fragment.appendChild(buildTime());
      }
      toggleClass(self2.calendarContainer, "rangeMode", self2.config.mode === "range");
      toggleClass(self2.calendarContainer, "animate", self2.config.animate === true);
      toggleClass(self2.calendarContainer, "multiMonth", self2.config.showMonths > 1);
      self2.calendarContainer.appendChild(fragment);
      var customAppend = self2.config.appendTo !== void 0 && self2.config.appendTo.nodeType !== void 0;
      if (self2.config.inline || self2.config.static) {
        self2.calendarContainer.classList.add(self2.config.inline ? "inline" : "static");
        if (self2.config.inline) {
          if (!customAppend && self2.element.parentNode)
            self2.element.parentNode.insertBefore(self2.calendarContainer, self2._input.nextSibling);
          else if (self2.config.appendTo !== void 0)
            self2.config.appendTo.appendChild(self2.calendarContainer);
        }
        if (self2.config.static) {
          var wrapper = createElement("div", "flatpickr-wrapper");
          if (self2.element.parentNode)
            self2.element.parentNode.insertBefore(wrapper, self2.element);
          wrapper.appendChild(self2.element);
          if (self2.altInput)
            wrapper.appendChild(self2.altInput);
          wrapper.appendChild(self2.calendarContainer);
        }
      }
      if (!self2.config.static && !self2.config.inline)
        (self2.config.appendTo !== void 0 ? self2.config.appendTo : window.document.body).appendChild(self2.calendarContainer);
    }
    __name(build, "build");
    function createDay(className, date, _dayNumber, i3) {
      var dateIsEnabled = isEnabled(date, true), dayElement = createElement("span", className, date.getDate().toString());
      dayElement.dateObj = date;
      dayElement.$i = i3;
      dayElement.setAttribute("aria-label", self2.formatDate(date, self2.config.ariaDateFormat));
      if (className.indexOf("hidden") === -1 && compareDates(date, self2.now) === 0) {
        self2.todayDateElem = dayElement;
        dayElement.classList.add("today");
        dayElement.setAttribute("aria-current", "date");
      }
      if (dateIsEnabled) {
        dayElement.tabIndex = -1;
        if (isDateSelected(date)) {
          dayElement.classList.add("selected");
          self2.selectedDateElem = dayElement;
          if (self2.config.mode === "range") {
            toggleClass(dayElement, "startRange", self2.selectedDates[0] && compareDates(date, self2.selectedDates[0], true) === 0);
            toggleClass(dayElement, "endRange", self2.selectedDates[1] && compareDates(date, self2.selectedDates[1], true) === 0);
            if (className === "nextMonthDay")
              dayElement.classList.add("inRange");
          }
        }
      } else {
        dayElement.classList.add("flatpickr-disabled");
      }
      if (self2.config.mode === "range") {
        if (isDateInRange(date) && !isDateSelected(date))
          dayElement.classList.add("inRange");
      }
      if (self2.weekNumbers && self2.config.showMonths === 1 && className !== "prevMonthDay" && i3 % 7 === 6) {
        self2.weekNumbers.insertAdjacentHTML("beforeend", "<span class='flatpickr-day'>" + self2.config.getWeek(date) + "</span>");
      }
      triggerEvent("onDayCreate", dayElement);
      return dayElement;
    }
    __name(createDay, "createDay");
    function focusOnDayElem(targetNode) {
      targetNode.focus();
      if (self2.config.mode === "range")
        onMouseOver(targetNode);
    }
    __name(focusOnDayElem, "focusOnDayElem");
    function getFirstAvailableDay(delta) {
      var startMonth = delta > 0 ? 0 : self2.config.showMonths - 1;
      var endMonth = delta > 0 ? self2.config.showMonths : -1;
      for (var m3 = startMonth; m3 != endMonth; m3 += delta) {
        var month = self2.daysContainer.children[m3];
        var startIndex = delta > 0 ? 0 : month.children.length - 1;
        var endIndex = delta > 0 ? month.children.length : -1;
        for (var i3 = startIndex; i3 != endIndex; i3 += delta) {
          var c3 = month.children[i3];
          if (c3.className.indexOf("hidden") === -1 && isEnabled(c3.dateObj))
            return c3;
        }
      }
      return void 0;
    }
    __name(getFirstAvailableDay, "getFirstAvailableDay");
    function getNextAvailableDay(current, delta) {
      var givenMonth = current.className.indexOf("Month") === -1 ? current.dateObj.getMonth() : self2.currentMonth;
      var endMonth = delta > 0 ? self2.config.showMonths : -1;
      var loopDelta = delta > 0 ? 1 : -1;
      for (var m3 = givenMonth - self2.currentMonth; m3 != endMonth; m3 += loopDelta) {
        var month = self2.daysContainer.children[m3];
        var startIndex = givenMonth - self2.currentMonth === m3 ? current.$i + delta : delta < 0 ? month.children.length - 1 : 0;
        var numMonthDays = month.children.length;
        for (var i3 = startIndex; i3 >= 0 && i3 < numMonthDays && i3 != (delta > 0 ? numMonthDays : -1); i3 += loopDelta) {
          var c3 = month.children[i3];
          if (c3.className.indexOf("hidden") === -1 && isEnabled(c3.dateObj) && Math.abs(current.$i - i3) >= Math.abs(delta))
            return focusOnDayElem(c3);
        }
      }
      self2.changeMonth(loopDelta);
      focusOnDay(getFirstAvailableDay(loopDelta), 0);
      return void 0;
    }
    __name(getNextAvailableDay, "getNextAvailableDay");
    function focusOnDay(current, offset) {
      var activeElement = getClosestActiveElement();
      var dayFocused = isInView(activeElement || document.body);
      var startElem = current !== void 0 ? current : dayFocused ? activeElement : self2.selectedDateElem !== void 0 && isInView(self2.selectedDateElem) ? self2.selectedDateElem : self2.todayDateElem !== void 0 && isInView(self2.todayDateElem) ? self2.todayDateElem : getFirstAvailableDay(offset > 0 ? 1 : -1);
      if (startElem === void 0) {
        self2._input.focus();
      } else if (!dayFocused) {
        focusOnDayElem(startElem);
      } else {
        getNextAvailableDay(startElem, offset);
      }
    }
    __name(focusOnDay, "focusOnDay");
    function buildMonthDays(year, month) {
      var firstOfMonth = (new Date(year, month, 1).getDay() - self2.l10n.firstDayOfWeek + 7) % 7;
      var prevMonthDays = self2.utils.getDaysInMonth((month - 1 + 12) % 12, year);
      var daysInMonth = self2.utils.getDaysInMonth(month, year), days = window.document.createDocumentFragment(), isMultiMonth = self2.config.showMonths > 1, prevMonthDayClass = isMultiMonth ? "prevMonthDay hidden" : "prevMonthDay", nextMonthDayClass = isMultiMonth ? "nextMonthDay hidden" : "nextMonthDay";
      var dayNumber = prevMonthDays + 1 - firstOfMonth, dayIndex = 0;
      for (; dayNumber <= prevMonthDays; dayNumber++, dayIndex++) {
        days.appendChild(createDay("flatpickr-day " + prevMonthDayClass, new Date(year, month - 1, dayNumber), dayNumber, dayIndex));
      }
      for (dayNumber = 1; dayNumber <= daysInMonth; dayNumber++, dayIndex++) {
        days.appendChild(createDay("flatpickr-day", new Date(year, month, dayNumber), dayNumber, dayIndex));
      }
      for (var dayNum = daysInMonth + 1; dayNum <= 42 - firstOfMonth && (self2.config.showMonths === 1 || dayIndex % 7 !== 0); dayNum++, dayIndex++) {
        days.appendChild(createDay("flatpickr-day " + nextMonthDayClass, new Date(year, month + 1, dayNum % daysInMonth), dayNum, dayIndex));
      }
      var dayContainer = createElement("div", "dayContainer");
      dayContainer.appendChild(days);
      return dayContainer;
    }
    __name(buildMonthDays, "buildMonthDays");
    function buildDays() {
      if (self2.daysContainer === void 0) {
        return;
      }
      clearNode(self2.daysContainer);
      if (self2.weekNumbers)
        clearNode(self2.weekNumbers);
      var frag = document.createDocumentFragment();
      for (var i3 = 0; i3 < self2.config.showMonths; i3++) {
        var d3 = new Date(self2.currentYear, self2.currentMonth, 1);
        d3.setMonth(self2.currentMonth + i3);
        frag.appendChild(buildMonthDays(d3.getFullYear(), d3.getMonth()));
      }
      self2.daysContainer.appendChild(frag);
      self2.days = self2.daysContainer.firstChild;
      if (self2.config.mode === "range" && self2.selectedDates.length === 1) {
        onMouseOver();
      }
    }
    __name(buildDays, "buildDays");
    function buildMonthSwitch() {
      if (self2.config.showMonths > 1 || self2.config.monthSelectorType !== "dropdown")
        return;
      var shouldBuildMonth = /* @__PURE__ */ __name(function(month2) {
        if (self2.config.minDate !== void 0 && self2.currentYear === self2.config.minDate.getFullYear() && month2 < self2.config.minDate.getMonth()) {
          return false;
        }
        return !(self2.config.maxDate !== void 0 && self2.currentYear === self2.config.maxDate.getFullYear() && month2 > self2.config.maxDate.getMonth());
      }, "shouldBuildMonth");
      self2.monthsDropdownContainer.tabIndex = -1;
      self2.monthsDropdownContainer.innerHTML = "";
      for (var i3 = 0; i3 < 12; i3++) {
        if (!shouldBuildMonth(i3))
          continue;
        var month = createElement("option", "flatpickr-monthDropdown-month");
        month.value = new Date(self2.currentYear, i3).getMonth().toString();
        month.textContent = monthToStr(i3, self2.config.shorthandCurrentMonth, self2.l10n);
        month.tabIndex = -1;
        if (self2.currentMonth === i3) {
          month.selected = true;
        }
        self2.monthsDropdownContainer.appendChild(month);
      }
    }
    __name(buildMonthSwitch, "buildMonthSwitch");
    function buildMonth() {
      var container = createElement("div", "flatpickr-month");
      var monthNavFragment = window.document.createDocumentFragment();
      var monthElement;
      if (self2.config.showMonths > 1 || self2.config.monthSelectorType === "static") {
        monthElement = createElement("span", "cur-month");
      } else {
        self2.monthsDropdownContainer = createElement("select", "flatpickr-monthDropdown-months");
        self2.monthsDropdownContainer.setAttribute("aria-label", self2.l10n.monthAriaLabel);
        bind(self2.monthsDropdownContainer, "change", function(e3) {
          var target = getEventTarget(e3);
          var selectedMonth = parseInt(target.value, 10);
          self2.changeMonth(selectedMonth - self2.currentMonth);
          triggerEvent("onMonthChange");
        });
        buildMonthSwitch();
        monthElement = self2.monthsDropdownContainer;
      }
      var yearInput = createNumberInput("cur-year", { tabindex: "-1" });
      var yearElement = yearInput.getElementsByTagName("input")[0];
      yearElement.setAttribute("aria-label", self2.l10n.yearAriaLabel);
      if (self2.config.minDate) {
        yearElement.setAttribute("min", self2.config.minDate.getFullYear().toString());
      }
      if (self2.config.maxDate) {
        yearElement.setAttribute("max", self2.config.maxDate.getFullYear().toString());
        yearElement.disabled = !!self2.config.minDate && self2.config.minDate.getFullYear() === self2.config.maxDate.getFullYear();
      }
      var currentMonth = createElement("div", "flatpickr-current-month");
      currentMonth.appendChild(monthElement);
      currentMonth.appendChild(yearInput);
      monthNavFragment.appendChild(currentMonth);
      container.appendChild(monthNavFragment);
      return {
        container,
        yearElement,
        monthElement
      };
    }
    __name(buildMonth, "buildMonth");
    function buildMonths() {
      clearNode(self2.monthNav);
      self2.monthNav.appendChild(self2.prevMonthNav);
      if (self2.config.showMonths) {
        self2.yearElements = [];
        self2.monthElements = [];
      }
      for (var m3 = self2.config.showMonths; m3--; ) {
        var month = buildMonth();
        self2.yearElements.push(month.yearElement);
        self2.monthElements.push(month.monthElement);
        self2.monthNav.appendChild(month.container);
      }
      self2.monthNav.appendChild(self2.nextMonthNav);
    }
    __name(buildMonths, "buildMonths");
    function buildMonthNav() {
      self2.monthNav = createElement("div", "flatpickr-months");
      self2.yearElements = [];
      self2.monthElements = [];
      self2.prevMonthNav = createElement("span", "flatpickr-prev-month");
      self2.prevMonthNav.innerHTML = self2.config.prevArrow;
      self2.nextMonthNav = createElement("span", "flatpickr-next-month");
      self2.nextMonthNav.innerHTML = self2.config.nextArrow;
      buildMonths();
      Object.defineProperty(self2, "_hidePrevMonthArrow", {
        get: function() {
          return self2.__hidePrevMonthArrow;
        },
        set: function(bool) {
          if (self2.__hidePrevMonthArrow !== bool) {
            toggleClass(self2.prevMonthNav, "flatpickr-disabled", bool);
            self2.__hidePrevMonthArrow = bool;
          }
        }
      });
      Object.defineProperty(self2, "_hideNextMonthArrow", {
        get: function() {
          return self2.__hideNextMonthArrow;
        },
        set: function(bool) {
          if (self2.__hideNextMonthArrow !== bool) {
            toggleClass(self2.nextMonthNav, "flatpickr-disabled", bool);
            self2.__hideNextMonthArrow = bool;
          }
        }
      });
      self2.currentYearElement = self2.yearElements[0];
      updateNavigationCurrentMonth();
      return self2.monthNav;
    }
    __name(buildMonthNav, "buildMonthNav");
    function buildTime() {
      self2.calendarContainer.classList.add("hasTime");
      if (self2.config.noCalendar)
        self2.calendarContainer.classList.add("noCalendar");
      var defaults4 = getDefaultHours(self2.config);
      self2.timeContainer = createElement("div", "flatpickr-time");
      self2.timeContainer.tabIndex = -1;
      var separator = createElement("span", "flatpickr-time-separator", ":");
      var hourInput = createNumberInput("flatpickr-hour", {
        "aria-label": self2.l10n.hourAriaLabel
      });
      self2.hourElement = hourInput.getElementsByTagName("input")[0];
      var minuteInput = createNumberInput("flatpickr-minute", {
        "aria-label": self2.l10n.minuteAriaLabel
      });
      self2.minuteElement = minuteInput.getElementsByTagName("input")[0];
      self2.hourElement.tabIndex = self2.minuteElement.tabIndex = -1;
      self2.hourElement.value = pad(self2.latestSelectedDateObj ? self2.latestSelectedDateObj.getHours() : self2.config.time_24hr ? defaults4.hours : military2ampm(defaults4.hours));
      self2.minuteElement.value = pad(self2.latestSelectedDateObj ? self2.latestSelectedDateObj.getMinutes() : defaults4.minutes);
      self2.hourElement.setAttribute("step", self2.config.hourIncrement.toString());
      self2.minuteElement.setAttribute("step", self2.config.minuteIncrement.toString());
      self2.hourElement.setAttribute("min", self2.config.time_24hr ? "0" : "1");
      self2.hourElement.setAttribute("max", self2.config.time_24hr ? "23" : "12");
      self2.hourElement.setAttribute("maxlength", "2");
      self2.minuteElement.setAttribute("min", "0");
      self2.minuteElement.setAttribute("max", "59");
      self2.minuteElement.setAttribute("maxlength", "2");
      self2.timeContainer.appendChild(hourInput);
      self2.timeContainer.appendChild(separator);
      self2.timeContainer.appendChild(minuteInput);
      if (self2.config.time_24hr)
        self2.timeContainer.classList.add("time24hr");
      if (self2.config.enableSeconds) {
        self2.timeContainer.classList.add("hasSeconds");
        var secondInput = createNumberInput("flatpickr-second");
        self2.secondElement = secondInput.getElementsByTagName("input")[0];
        self2.secondElement.value = pad(self2.latestSelectedDateObj ? self2.latestSelectedDateObj.getSeconds() : defaults4.seconds);
        self2.secondElement.setAttribute("step", self2.minuteElement.getAttribute("step"));
        self2.secondElement.setAttribute("min", "0");
        self2.secondElement.setAttribute("max", "59");
        self2.secondElement.setAttribute("maxlength", "2");
        self2.timeContainer.appendChild(createElement("span", "flatpickr-time-separator", ":"));
        self2.timeContainer.appendChild(secondInput);
      }
      if (!self2.config.time_24hr) {
        self2.amPM = createElement("span", "flatpickr-am-pm", self2.l10n.amPM[int((self2.latestSelectedDateObj ? self2.hourElement.value : self2.config.defaultHour) > 11)]);
        self2.amPM.title = self2.l10n.toggleTitle;
        self2.amPM.tabIndex = -1;
        self2.timeContainer.appendChild(self2.amPM);
      }
      return self2.timeContainer;
    }
    __name(buildTime, "buildTime");
    function buildWeekdays() {
      if (!self2.weekdayContainer)
        self2.weekdayContainer = createElement("div", "flatpickr-weekdays");
      else
        clearNode(self2.weekdayContainer);
      for (var i3 = self2.config.showMonths; i3--; ) {
        var container = createElement("div", "flatpickr-weekdaycontainer");
        self2.weekdayContainer.appendChild(container);
      }
      updateWeekdays();
      return self2.weekdayContainer;
    }
    __name(buildWeekdays, "buildWeekdays");
    function updateWeekdays() {
      if (!self2.weekdayContainer) {
        return;
      }
      var firstDayOfWeek = self2.l10n.firstDayOfWeek;
      var weekdays = __spreadArrays(self2.l10n.weekdays.shorthand);
      if (firstDayOfWeek > 0 && firstDayOfWeek < weekdays.length) {
        weekdays = __spreadArrays(weekdays.splice(firstDayOfWeek, weekdays.length), weekdays.splice(0, firstDayOfWeek));
      }
      for (var i3 = self2.config.showMonths; i3--; ) {
        self2.weekdayContainer.children[i3].innerHTML = "\n      <span class='flatpickr-weekday'>\n        " + weekdays.join("</span><span class='flatpickr-weekday'>") + "\n      </span>\n      ";
      }
    }
    __name(updateWeekdays, "updateWeekdays");
    function buildWeeks() {
      self2.calendarContainer.classList.add("hasWeeks");
      var weekWrapper = createElement("div", "flatpickr-weekwrapper");
      weekWrapper.appendChild(createElement("span", "flatpickr-weekday", self2.l10n.weekAbbreviation));
      var weekNumbers = createElement("div", "flatpickr-weeks");
      weekWrapper.appendChild(weekNumbers);
      return {
        weekWrapper,
        weekNumbers
      };
    }
    __name(buildWeeks, "buildWeeks");
    function changeMonth(value, isOffset) {
      if (isOffset === void 0) {
        isOffset = true;
      }
      var delta = isOffset ? value : value - self2.currentMonth;
      if (delta < 0 && self2._hidePrevMonthArrow === true || delta > 0 && self2._hideNextMonthArrow === true)
        return;
      self2.currentMonth += delta;
      if (self2.currentMonth < 0 || self2.currentMonth > 11) {
        self2.currentYear += self2.currentMonth > 11 ? 1 : -1;
        self2.currentMonth = (self2.currentMonth + 12) % 12;
        triggerEvent("onYearChange");
        buildMonthSwitch();
      }
      buildDays();
      triggerEvent("onMonthChange");
      updateNavigationCurrentMonth();
    }
    __name(changeMonth, "changeMonth");
    function clear(triggerChangeEvent, toInitial) {
      if (triggerChangeEvent === void 0) {
        triggerChangeEvent = true;
      }
      if (toInitial === void 0) {
        toInitial = true;
      }
      self2.input.value = "";
      if (self2.altInput !== void 0)
        self2.altInput.value = "";
      if (self2.mobileInput !== void 0)
        self2.mobileInput.value = "";
      self2.selectedDates = [];
      self2.latestSelectedDateObj = void 0;
      if (toInitial === true) {
        self2.currentYear = self2._initialDate.getFullYear();
        self2.currentMonth = self2._initialDate.getMonth();
      }
      if (self2.config.enableTime === true) {
        var _a = getDefaultHours(self2.config), hours = _a.hours, minutes = _a.minutes, seconds = _a.seconds;
        setHours(hours, minutes, seconds);
      }
      self2.redraw();
      if (triggerChangeEvent)
        triggerEvent("onChange");
    }
    __name(clear, "clear");
    function close() {
      self2.isOpen = false;
      if (!self2.isMobile) {
        if (self2.calendarContainer !== void 0) {
          self2.calendarContainer.classList.remove("open");
        }
        if (self2._input !== void 0) {
          self2._input.classList.remove("active");
        }
      }
      triggerEvent("onClose");
    }
    __name(close, "close");
    function destroy2() {
      if (self2.config !== void 0)
        triggerEvent("onDestroy");
      for (var i3 = self2._handlers.length; i3--; ) {
        self2._handlers[i3].remove();
      }
      self2._handlers = [];
      if (self2.mobileInput) {
        if (self2.mobileInput.parentNode)
          self2.mobileInput.parentNode.removeChild(self2.mobileInput);
        self2.mobileInput = void 0;
      } else if (self2.calendarContainer && self2.calendarContainer.parentNode) {
        if (self2.config.static && self2.calendarContainer.parentNode) {
          var wrapper = self2.calendarContainer.parentNode;
          wrapper.lastChild && wrapper.removeChild(wrapper.lastChild);
          if (wrapper.parentNode) {
            while (wrapper.firstChild)
              wrapper.parentNode.insertBefore(wrapper.firstChild, wrapper);
            wrapper.parentNode.removeChild(wrapper);
          }
        } else
          self2.calendarContainer.parentNode.removeChild(self2.calendarContainer);
      }
      if (self2.altInput) {
        self2.input.type = "text";
        if (self2.altInput.parentNode)
          self2.altInput.parentNode.removeChild(self2.altInput);
        delete self2.altInput;
      }
      if (self2.input) {
        self2.input.type = self2.input._type;
        self2.input.classList.remove("flatpickr-input");
        self2.input.removeAttribute("readonly");
      }
      [
        "_showTimeInput",
        "latestSelectedDateObj",
        "_hideNextMonthArrow",
        "_hidePrevMonthArrow",
        "__hideNextMonthArrow",
        "__hidePrevMonthArrow",
        "isMobile",
        "isOpen",
        "selectedDateElem",
        "minDateHasTime",
        "maxDateHasTime",
        "days",
        "daysContainer",
        "_input",
        "_positionElement",
        "innerContainer",
        "rContainer",
        "monthNav",
        "todayDateElem",
        "calendarContainer",
        "weekdayContainer",
        "prevMonthNav",
        "nextMonthNav",
        "monthsDropdownContainer",
        "currentMonthElement",
        "currentYearElement",
        "navigationCurrentMonth",
        "selectedDateElem",
        "config"
      ].forEach(function(k3) {
        try {
          delete self2[k3];
        } catch (_2) {
        }
      });
    }
    __name(destroy2, "destroy");
    function isCalendarElem(elem) {
      return self2.calendarContainer.contains(elem);
    }
    __name(isCalendarElem, "isCalendarElem");
    function documentClick(e3) {
      if (self2.isOpen && !self2.config.inline) {
        var eventTarget_1 = getEventTarget(e3);
        var isCalendarElement = isCalendarElem(eventTarget_1);
        var isInput = eventTarget_1 === self2.input || eventTarget_1 === self2.altInput || self2.element.contains(eventTarget_1) || e3.path && e3.path.indexOf && (~e3.path.indexOf(self2.input) || ~e3.path.indexOf(self2.altInput));
        var lostFocus = !isInput && !isCalendarElement && !isCalendarElem(e3.relatedTarget);
        var isIgnored = !self2.config.ignoredFocusElements.some(function(elem) {
          return elem.contains(eventTarget_1);
        });
        if (lostFocus && isIgnored) {
          if (self2.config.allowInput) {
            self2.setDate(self2._input.value, false, self2.config.altInput ? self2.config.altFormat : self2.config.dateFormat);
          }
          if (self2.timeContainer !== void 0 && self2.minuteElement !== void 0 && self2.hourElement !== void 0 && self2.input.value !== "" && self2.input.value !== void 0) {
            updateTime();
          }
          self2.close();
          if (self2.config && self2.config.mode === "range" && self2.selectedDates.length === 1)
            self2.clear(false);
        }
      }
    }
    __name(documentClick, "documentClick");
    function changeYear(newYear) {
      if (!newYear || self2.config.minDate && newYear < self2.config.minDate.getFullYear() || self2.config.maxDate && newYear > self2.config.maxDate.getFullYear())
        return;
      var newYearNum = newYear, isNewYear = self2.currentYear !== newYearNum;
      self2.currentYear = newYearNum || self2.currentYear;
      if (self2.config.maxDate && self2.currentYear === self2.config.maxDate.getFullYear()) {
        self2.currentMonth = Math.min(self2.config.maxDate.getMonth(), self2.currentMonth);
      } else if (self2.config.minDate && self2.currentYear === self2.config.minDate.getFullYear()) {
        self2.currentMonth = Math.max(self2.config.minDate.getMonth(), self2.currentMonth);
      }
      if (isNewYear) {
        self2.redraw();
        triggerEvent("onYearChange");
        buildMonthSwitch();
      }
    }
    __name(changeYear, "changeYear");
    function isEnabled(date, timeless) {
      var _a;
      if (timeless === void 0) {
        timeless = true;
      }
      var dateToCheck = self2.parseDate(date, void 0, timeless);
      if (self2.config.minDate && dateToCheck && compareDates(dateToCheck, self2.config.minDate, timeless !== void 0 ? timeless : !self2.minDateHasTime) < 0 || self2.config.maxDate && dateToCheck && compareDates(dateToCheck, self2.config.maxDate, timeless !== void 0 ? timeless : !self2.maxDateHasTime) > 0)
        return false;
      if (!self2.config.enable && self2.config.disable.length === 0)
        return true;
      if (dateToCheck === void 0)
        return false;
      var bool = !!self2.config.enable, array = (_a = self2.config.enable) !== null && _a !== void 0 ? _a : self2.config.disable;
      for (var i3 = 0, d3 = void 0; i3 < array.length; i3++) {
        d3 = array[i3];
        if (typeof d3 === "function" && d3(dateToCheck))
          return bool;
        else if (d3 instanceof Date && dateToCheck !== void 0 && d3.getTime() === dateToCheck.getTime())
          return bool;
        else if (typeof d3 === "string") {
          var parsed = self2.parseDate(d3, void 0, true);
          return parsed && parsed.getTime() === dateToCheck.getTime() ? bool : !bool;
        } else if (typeof d3 === "object" && dateToCheck !== void 0 && d3.from && d3.to && dateToCheck.getTime() >= d3.from.getTime() && dateToCheck.getTime() <= d3.to.getTime())
          return bool;
      }
      return !bool;
    }
    __name(isEnabled, "isEnabled");
    function isInView(elem) {
      if (self2.daysContainer !== void 0)
        return elem.className.indexOf("hidden") === -1 && elem.className.indexOf("flatpickr-disabled") === -1 && self2.daysContainer.contains(elem);
      return false;
    }
    __name(isInView, "isInView");
    function onBlur(e3) {
      var isInput = e3.target === self2._input;
      var valueChanged = self2._input.value.trimEnd() !== getDateStr();
      if (isInput && valueChanged && !(e3.relatedTarget && isCalendarElem(e3.relatedTarget))) {
        self2.setDate(self2._input.value, true, e3.target === self2.altInput ? self2.config.altFormat : self2.config.dateFormat);
      }
    }
    __name(onBlur, "onBlur");
    function onKeyDown(e3) {
      var eventTarget = getEventTarget(e3);
      var isInput = self2.config.wrap ? element.contains(eventTarget) : eventTarget === self2._input;
      var allowInput = self2.config.allowInput;
      var allowKeydown = self2.isOpen && (!allowInput || !isInput);
      var allowInlineKeydown = self2.config.inline && isInput && !allowInput;
      if (e3.keyCode === 13 && isInput) {
        if (allowInput) {
          self2.setDate(self2._input.value, true, eventTarget === self2.altInput ? self2.config.altFormat : self2.config.dateFormat);
          self2.close();
          return eventTarget.blur();
        } else {
          self2.open();
        }
      } else if (isCalendarElem(eventTarget) || allowKeydown || allowInlineKeydown) {
        var isTimeObj = !!self2.timeContainer && self2.timeContainer.contains(eventTarget);
        switch (e3.keyCode) {
          case 13:
            if (isTimeObj) {
              e3.preventDefault();
              updateTime();
              focusAndClose();
            } else
              selectDate(e3);
            break;
          case 27:
            e3.preventDefault();
            focusAndClose();
            break;
          case 8:
          case 46:
            if (isInput && !self2.config.allowInput) {
              e3.preventDefault();
              self2.clear();
            }
            break;
          case 37:
          case 39:
            if (!isTimeObj && !isInput) {
              e3.preventDefault();
              var activeElement = getClosestActiveElement();
              if (self2.daysContainer !== void 0 && (allowInput === false || activeElement && isInView(activeElement))) {
                var delta_1 = e3.keyCode === 39 ? 1 : -1;
                if (!e3.ctrlKey)
                  focusOnDay(void 0, delta_1);
                else {
                  e3.stopPropagation();
                  changeMonth(delta_1);
                  focusOnDay(getFirstAvailableDay(1), 0);
                }
              }
            } else if (self2.hourElement)
              self2.hourElement.focus();
            break;
          case 38:
          case 40:
            e3.preventDefault();
            var delta = e3.keyCode === 40 ? 1 : -1;
            if (self2.daysContainer && eventTarget.$i !== void 0 || eventTarget === self2.input || eventTarget === self2.altInput) {
              if (e3.ctrlKey) {
                e3.stopPropagation();
                changeYear(self2.currentYear - delta);
                focusOnDay(getFirstAvailableDay(1), 0);
              } else if (!isTimeObj)
                focusOnDay(void 0, delta * 7);
            } else if (eventTarget === self2.currentYearElement) {
              changeYear(self2.currentYear - delta);
            } else if (self2.config.enableTime) {
              if (!isTimeObj && self2.hourElement)
                self2.hourElement.focus();
              updateTime(e3);
              self2._debouncedChange();
            }
            break;
          case 9:
            if (isTimeObj) {
              var elems = [
                self2.hourElement,
                self2.minuteElement,
                self2.secondElement,
                self2.amPM
              ].concat(self2.pluginElements).filter(function(x3) {
                return x3;
              });
              var i3 = elems.indexOf(eventTarget);
              if (i3 !== -1) {
                var target = elems[i3 + (e3.shiftKey ? -1 : 1)];
                e3.preventDefault();
                (target || self2._input).focus();
              }
            } else if (!self2.config.noCalendar && self2.daysContainer && self2.daysContainer.contains(eventTarget) && e3.shiftKey) {
              e3.preventDefault();
              self2._input.focus();
            }
            break;
          default:
            break;
        }
      }
      if (self2.amPM !== void 0 && eventTarget === self2.amPM) {
        switch (e3.key) {
          case self2.l10n.amPM[0].charAt(0):
          case self2.l10n.amPM[0].charAt(0).toLowerCase():
            self2.amPM.textContent = self2.l10n.amPM[0];
            setHoursFromInputs();
            updateValue();
            break;
          case self2.l10n.amPM[1].charAt(0):
          case self2.l10n.amPM[1].charAt(0).toLowerCase():
            self2.amPM.textContent = self2.l10n.amPM[1];
            setHoursFromInputs();
            updateValue();
            break;
        }
      }
      if (isInput || isCalendarElem(eventTarget)) {
        triggerEvent("onKeyDown", e3);
      }
    }
    __name(onKeyDown, "onKeyDown");
    function onMouseOver(elem, cellClass) {
      if (cellClass === void 0) {
        cellClass = "flatpickr-day";
      }
      if (self2.selectedDates.length !== 1 || elem && (!elem.classList.contains(cellClass) || elem.classList.contains("flatpickr-disabled")))
        return;
      var hoverDate = elem ? elem.dateObj.getTime() : self2.days.firstElementChild.dateObj.getTime(), initialDate = self2.parseDate(self2.selectedDates[0], void 0, true).getTime(), rangeStartDate = Math.min(hoverDate, self2.selectedDates[0].getTime()), rangeEndDate = Math.max(hoverDate, self2.selectedDates[0].getTime());
      var containsDisabled = false;
      var minRange = 0, maxRange = 0;
      for (var t3 = rangeStartDate; t3 < rangeEndDate; t3 += duration.DAY) {
        if (!isEnabled(new Date(t3), true)) {
          containsDisabled = containsDisabled || t3 > rangeStartDate && t3 < rangeEndDate;
          if (t3 < initialDate && (!minRange || t3 > minRange))
            minRange = t3;
          else if (t3 > initialDate && (!maxRange || t3 < maxRange))
            maxRange = t3;
        }
      }
      var hoverableCells = Array.from(self2.rContainer.querySelectorAll("*:nth-child(-n+" + self2.config.showMonths + ") > ." + cellClass));
      hoverableCells.forEach(function(dayElem) {
        var date = dayElem.dateObj;
        var timestamp = date.getTime();
        var outOfRange = minRange > 0 && timestamp < minRange || maxRange > 0 && timestamp > maxRange;
        if (outOfRange) {
          dayElem.classList.add("notAllowed");
          ["inRange", "startRange", "endRange"].forEach(function(c3) {
            dayElem.classList.remove(c3);
          });
          return;
        } else if (containsDisabled && !outOfRange)
          return;
        ["startRange", "inRange", "endRange", "notAllowed"].forEach(function(c3) {
          dayElem.classList.remove(c3);
        });
        if (elem !== void 0) {
          elem.classList.add(hoverDate <= self2.selectedDates[0].getTime() ? "startRange" : "endRange");
          if (initialDate < hoverDate && timestamp === initialDate)
            dayElem.classList.add("startRange");
          else if (initialDate > hoverDate && timestamp === initialDate)
            dayElem.classList.add("endRange");
          if (timestamp >= minRange && (maxRange === 0 || timestamp <= maxRange) && isBetween(timestamp, initialDate, hoverDate))
            dayElem.classList.add("inRange");
        }
      });
    }
    __name(onMouseOver, "onMouseOver");
    function onResize() {
      if (self2.isOpen && !self2.config.static && !self2.config.inline)
        positionCalendar();
    }
    __name(onResize, "onResize");
    function open(e3, positionElement) {
      if (positionElement === void 0) {
        positionElement = self2._positionElement;
      }
      if (self2.isMobile === true) {
        if (e3) {
          e3.preventDefault();
          var eventTarget = getEventTarget(e3);
          if (eventTarget) {
            eventTarget.blur();
          }
        }
        if (self2.mobileInput !== void 0) {
          self2.mobileInput.focus();
          self2.mobileInput.click();
        }
        triggerEvent("onOpen");
        return;
      } else if (self2._input.disabled || self2.config.inline) {
        return;
      }
      var wasOpen = self2.isOpen;
      self2.isOpen = true;
      if (!wasOpen) {
        self2.calendarContainer.classList.add("open");
        self2._input.classList.add("active");
        triggerEvent("onOpen");
        positionCalendar(positionElement);
      }
      if (self2.config.enableTime === true && self2.config.noCalendar === true) {
        if (self2.config.allowInput === false && (e3 === void 0 || !self2.timeContainer.contains(e3.relatedTarget))) {
          setTimeout(function() {
            return self2.hourElement.select();
          }, 50);
        }
      }
    }
    __name(open, "open");
    function minMaxDateSetter(type) {
      return function(date) {
        var dateObj = self2.config["_" + type + "Date"] = self2.parseDate(date, self2.config.dateFormat);
        var inverseDateObj = self2.config["_" + (type === "min" ? "max" : "min") + "Date"];
        if (dateObj !== void 0) {
          self2[type === "min" ? "minDateHasTime" : "maxDateHasTime"] = dateObj.getHours() > 0 || dateObj.getMinutes() > 0 || dateObj.getSeconds() > 0;
        }
        if (self2.selectedDates) {
          self2.selectedDates = self2.selectedDates.filter(function(d3) {
            return isEnabled(d3);
          });
          if (!self2.selectedDates.length && type === "min")
            setHoursFromDate(dateObj);
          updateValue();
        }
        if (self2.daysContainer) {
          redraw();
          if (dateObj !== void 0)
            self2.currentYearElement[type] = dateObj.getFullYear().toString();
          else
            self2.currentYearElement.removeAttribute(type);
          self2.currentYearElement.disabled = !!inverseDateObj && dateObj !== void 0 && inverseDateObj.getFullYear() === dateObj.getFullYear();
        }
      };
    }
    __name(minMaxDateSetter, "minMaxDateSetter");
    function parseConfig() {
      var boolOpts = [
        "wrap",
        "weekNumbers",
        "allowInput",
        "allowInvalidPreload",
        "clickOpens",
        "time_24hr",
        "enableTime",
        "noCalendar",
        "altInput",
        "shorthandCurrentMonth",
        "inline",
        "static",
        "enableSeconds",
        "disableMobile"
      ];
      var userConfig = __assign(__assign({}, JSON.parse(JSON.stringify(element.dataset || {}))), instanceConfig);
      var formats3 = {};
      self2.config.parseDate = userConfig.parseDate;
      self2.config.formatDate = userConfig.formatDate;
      Object.defineProperty(self2.config, "enable", {
        get: function() {
          return self2.config._enable;
        },
        set: function(dates) {
          self2.config._enable = parseDateRules(dates);
        }
      });
      Object.defineProperty(self2.config, "disable", {
        get: function() {
          return self2.config._disable;
        },
        set: function(dates) {
          self2.config._disable = parseDateRules(dates);
        }
      });
      var timeMode = userConfig.mode === "time";
      if (!userConfig.dateFormat && (userConfig.enableTime || timeMode)) {
        var defaultDateFormat = flatpickr.defaultConfig.dateFormat || defaults.dateFormat;
        formats3.dateFormat = userConfig.noCalendar || timeMode ? "H:i" + (userConfig.enableSeconds ? ":S" : "") : defaultDateFormat + " H:i" + (userConfig.enableSeconds ? ":S" : "");
      }
      if (userConfig.altInput && (userConfig.enableTime || timeMode) && !userConfig.altFormat) {
        var defaultAltFormat = flatpickr.defaultConfig.altFormat || defaults.altFormat;
        formats3.altFormat = userConfig.noCalendar || timeMode ? "h:i" + (userConfig.enableSeconds ? ":S K" : " K") : defaultAltFormat + (" h:i" + (userConfig.enableSeconds ? ":S" : "") + " K");
      }
      Object.defineProperty(self2.config, "minDate", {
        get: function() {
          return self2.config._minDate;
        },
        set: minMaxDateSetter("min")
      });
      Object.defineProperty(self2.config, "maxDate", {
        get: function() {
          return self2.config._maxDate;
        },
        set: minMaxDateSetter("max")
      });
      var minMaxTimeSetter = /* @__PURE__ */ __name(function(type) {
        return function(val2) {
          self2.config[type === "min" ? "_minTime" : "_maxTime"] = self2.parseDate(val2, "H:i:S");
        };
      }, "minMaxTimeSetter");
      Object.defineProperty(self2.config, "minTime", {
        get: function() {
          return self2.config._minTime;
        },
        set: minMaxTimeSetter("min")
      });
      Object.defineProperty(self2.config, "maxTime", {
        get: function() {
          return self2.config._maxTime;
        },
        set: minMaxTimeSetter("max")
      });
      if (userConfig.mode === "time") {
        self2.config.noCalendar = true;
        self2.config.enableTime = true;
      }
      Object.assign(self2.config, formats3, userConfig);
      for (var i3 = 0; i3 < boolOpts.length; i3++)
        self2.config[boolOpts[i3]] = self2.config[boolOpts[i3]] === true || self2.config[boolOpts[i3]] === "true";
      HOOKS.filter(function(hook) {
        return self2.config[hook] !== void 0;
      }).forEach(function(hook) {
        self2.config[hook] = arrayify(self2.config[hook] || []).map(bindToInstance);
      });
      self2.isMobile = !self2.config.disableMobile && !self2.config.inline && self2.config.mode === "single" && !self2.config.disable.length && !self2.config.enable && !self2.config.weekNumbers && /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
      for (var i3 = 0; i3 < self2.config.plugins.length; i3++) {
        var pluginConf = self2.config.plugins[i3](self2) || {};
        for (var key in pluginConf) {
          if (HOOKS.indexOf(key) > -1) {
            self2.config[key] = arrayify(pluginConf[key]).map(bindToInstance).concat(self2.config[key]);
          } else if (typeof userConfig[key] === "undefined")
            self2.config[key] = pluginConf[key];
        }
      }
      if (!userConfig.altInputClass) {
        self2.config.altInputClass = getInputElem().className + " " + self2.config.altInputClass;
      }
      triggerEvent("onParseConfig");
    }
    __name(parseConfig, "parseConfig");
    function getInputElem() {
      return self2.config.wrap ? element.querySelector("[data-input]") : element;
    }
    __name(getInputElem, "getInputElem");
    function setupLocale() {
      if (typeof self2.config.locale !== "object" && typeof flatpickr.l10ns[self2.config.locale] === "undefined")
        self2.config.errorHandler(new Error("flatpickr: invalid locale " + self2.config.locale));
      self2.l10n = __assign(__assign({}, flatpickr.l10ns.default), typeof self2.config.locale === "object" ? self2.config.locale : self2.config.locale !== "default" ? flatpickr.l10ns[self2.config.locale] : void 0);
      tokenRegex.D = "(" + self2.l10n.weekdays.shorthand.join("|") + ")";
      tokenRegex.l = "(" + self2.l10n.weekdays.longhand.join("|") + ")";
      tokenRegex.M = "(" + self2.l10n.months.shorthand.join("|") + ")";
      tokenRegex.F = "(" + self2.l10n.months.longhand.join("|") + ")";
      tokenRegex.K = "(" + self2.l10n.amPM[0] + "|" + self2.l10n.amPM[1] + "|" + self2.l10n.amPM[0].toLowerCase() + "|" + self2.l10n.amPM[1].toLowerCase() + ")";
      var userConfig = __assign(__assign({}, instanceConfig), JSON.parse(JSON.stringify(element.dataset || {})));
      if (userConfig.time_24hr === void 0 && flatpickr.defaultConfig.time_24hr === void 0) {
        self2.config.time_24hr = self2.l10n.time_24hr;
      }
      self2.formatDate = createDateFormatter(self2);
      self2.parseDate = createDateParser({ config: self2.config, l10n: self2.l10n });
    }
    __name(setupLocale, "setupLocale");
    function positionCalendar(customPositionElement) {
      if (typeof self2.config.position === "function") {
        return void self2.config.position(self2, customPositionElement);
      }
      if (self2.calendarContainer === void 0)
        return;
      triggerEvent("onPreCalendarPosition");
      var positionElement = customPositionElement || self2._positionElement;
      var calendarHeight = Array.prototype.reduce.call(self2.calendarContainer.children, function(acc, child) {
        return acc + child.offsetHeight;
      }, 0), calendarWidth = self2.calendarContainer.offsetWidth, configPos = self2.config.position.split(" "), configPosVertical = configPos[0], configPosHorizontal = configPos.length > 1 ? configPos[1] : null, inputBounds = positionElement.getBoundingClientRect(), distanceFromBottom = window.innerHeight - inputBounds.bottom, showOnTop = configPosVertical === "above" || configPosVertical !== "below" && distanceFromBottom < calendarHeight && inputBounds.top > calendarHeight;
      var top = window.pageYOffset + inputBounds.top + (!showOnTop ? positionElement.offsetHeight + 2 : -calendarHeight - 2);
      toggleClass(self2.calendarContainer, "arrowTop", !showOnTop);
      toggleClass(self2.calendarContainer, "arrowBottom", showOnTop);
      if (self2.config.inline)
        return;
      var left = window.pageXOffset + inputBounds.left;
      var isCenter = false;
      var isRight = false;
      if (configPosHorizontal === "center") {
        left -= (calendarWidth - inputBounds.width) / 2;
        isCenter = true;
      } else if (configPosHorizontal === "right") {
        left -= calendarWidth - inputBounds.width;
        isRight = true;
      }
      toggleClass(self2.calendarContainer, "arrowLeft", !isCenter && !isRight);
      toggleClass(self2.calendarContainer, "arrowCenter", isCenter);
      toggleClass(self2.calendarContainer, "arrowRight", isRight);
      var right = window.document.body.offsetWidth - (window.pageXOffset + inputBounds.right);
      var rightMost = left + calendarWidth > window.document.body.offsetWidth;
      var centerMost = right + calendarWidth > window.document.body.offsetWidth;
      toggleClass(self2.calendarContainer, "rightMost", rightMost);
      if (self2.config.static)
        return;
      self2.calendarContainer.style.top = top + "px";
      if (!rightMost) {
        self2.calendarContainer.style.left = left + "px";
        self2.calendarContainer.style.right = "auto";
      } else if (!centerMost) {
        self2.calendarContainer.style.left = "auto";
        self2.calendarContainer.style.right = right + "px";
      } else {
        var doc = getDocumentStyleSheet();
        if (doc === void 0)
          return;
        var bodyWidth = window.document.body.offsetWidth;
        var centerLeft = Math.max(0, bodyWidth / 2 - calendarWidth / 2);
        var centerBefore = ".flatpickr-calendar.centerMost:before";
        var centerAfter = ".flatpickr-calendar.centerMost:after";
        var centerIndex = doc.cssRules.length;
        var centerStyle = "{left:" + inputBounds.left + "px;right:auto;}";
        toggleClass(self2.calendarContainer, "rightMost", false);
        toggleClass(self2.calendarContainer, "centerMost", true);
        doc.insertRule(centerBefore + "," + centerAfter + centerStyle, centerIndex);
        self2.calendarContainer.style.left = centerLeft + "px";
        self2.calendarContainer.style.right = "auto";
      }
    }
    __name(positionCalendar, "positionCalendar");
    function getDocumentStyleSheet() {
      var editableSheet = null;
      for (var i3 = 0; i3 < document.styleSheets.length; i3++) {
        var sheet = document.styleSheets[i3];
        if (!sheet.cssRules)
          continue;
        try {
          sheet.cssRules;
        } catch (err) {
          continue;
        }
        editableSheet = sheet;
        break;
      }
      return editableSheet != null ? editableSheet : createStyleSheet();
    }
    __name(getDocumentStyleSheet, "getDocumentStyleSheet");
    function createStyleSheet() {
      var style = document.createElement("style");
      document.head.appendChild(style);
      return style.sheet;
    }
    __name(createStyleSheet, "createStyleSheet");
    function redraw() {
      if (self2.config.noCalendar || self2.isMobile)
        return;
      buildMonthSwitch();
      updateNavigationCurrentMonth();
      buildDays();
    }
    __name(redraw, "redraw");
    function focusAndClose() {
      self2._input.focus();
      if (window.navigator.userAgent.indexOf("MSIE") !== -1 || navigator.msMaxTouchPoints !== void 0) {
        setTimeout(self2.close, 0);
      } else {
        self2.close();
      }
    }
    __name(focusAndClose, "focusAndClose");
    function selectDate(e3) {
      e3.preventDefault();
      e3.stopPropagation();
      var isSelectable = /* @__PURE__ */ __name(function(day) {
        return day.classList && day.classList.contains("flatpickr-day") && !day.classList.contains("flatpickr-disabled") && !day.classList.contains("notAllowed");
      }, "isSelectable");
      var t3 = findParent(getEventTarget(e3), isSelectable);
      if (t3 === void 0)
        return;
      var target = t3;
      var selectedDate = self2.latestSelectedDateObj = new Date(target.dateObj.getTime());
      var shouldChangeMonth = (selectedDate.getMonth() < self2.currentMonth || selectedDate.getMonth() > self2.currentMonth + self2.config.showMonths - 1) && self2.config.mode !== "range";
      self2.selectedDateElem = target;
      if (self2.config.mode === "single")
        self2.selectedDates = [selectedDate];
      else if (self2.config.mode === "multiple") {
        var selectedIndex = isDateSelected(selectedDate);
        if (selectedIndex)
          self2.selectedDates.splice(parseInt(selectedIndex), 1);
        else
          self2.selectedDates.push(selectedDate);
      } else if (self2.config.mode === "range") {
        if (self2.selectedDates.length === 2) {
          self2.clear(false, false);
        }
        self2.latestSelectedDateObj = selectedDate;
        self2.selectedDates.push(selectedDate);
        if (compareDates(selectedDate, self2.selectedDates[0], true) !== 0)
          self2.selectedDates.sort(function(a3, b3) {
            return a3.getTime() - b3.getTime();
          });
      }
      setHoursFromInputs();
      if (shouldChangeMonth) {
        var isNewYear = self2.currentYear !== selectedDate.getFullYear();
        self2.currentYear = selectedDate.getFullYear();
        self2.currentMonth = selectedDate.getMonth();
        if (isNewYear) {
          triggerEvent("onYearChange");
          buildMonthSwitch();
        }
        triggerEvent("onMonthChange");
      }
      updateNavigationCurrentMonth();
      buildDays();
      updateValue();
      if (!shouldChangeMonth && self2.config.mode !== "range" && self2.config.showMonths === 1)
        focusOnDayElem(target);
      else if (self2.selectedDateElem !== void 0 && self2.hourElement === void 0) {
        self2.selectedDateElem && self2.selectedDateElem.focus();
      }
      if (self2.hourElement !== void 0)
        self2.hourElement !== void 0 && self2.hourElement.focus();
      if (self2.config.closeOnSelect) {
        var single = self2.config.mode === "single" && !self2.config.enableTime;
        var range = self2.config.mode === "range" && self2.selectedDates.length === 2 && !self2.config.enableTime;
        if (single || range) {
          focusAndClose();
        }
      }
      triggerChange();
    }
    __name(selectDate, "selectDate");
    var CALLBACKS = {
      locale: [setupLocale, updateWeekdays],
      showMonths: [buildMonths, setCalendarWidth, buildWeekdays],
      minDate: [jumpToDate],
      maxDate: [jumpToDate],
      positionElement: [updatePositionElement],
      clickOpens: [
        function() {
          if (self2.config.clickOpens === true) {
            bind(self2._input, "focus", self2.open);
            bind(self2._input, "click", self2.open);
          } else {
            self2._input.removeEventListener("focus", self2.open);
            self2._input.removeEventListener("click", self2.open);
          }
        }
      ]
    };
    function set(option2, value) {
      if (option2 !== null && typeof option2 === "object") {
        Object.assign(self2.config, option2);
        for (var key in option2) {
          if (CALLBACKS[key] !== void 0)
            CALLBACKS[key].forEach(function(x3) {
              return x3();
            });
        }
      } else {
        self2.config[option2] = value;
        if (CALLBACKS[option2] !== void 0)
          CALLBACKS[option2].forEach(function(x3) {
            return x3();
          });
        else if (HOOKS.indexOf(option2) > -1)
          self2.config[option2] = arrayify(value);
      }
      self2.redraw();
      updateValue(true);
    }
    __name(set, "set");
    function setSelectedDate(inputDate, format) {
      var dates = [];
      if (inputDate instanceof Array)
        dates = inputDate.map(function(d3) {
          return self2.parseDate(d3, format);
        });
      else if (inputDate instanceof Date || typeof inputDate === "number")
        dates = [self2.parseDate(inputDate, format)];
      else if (typeof inputDate === "string") {
        switch (self2.config.mode) {
          case "single":
          case "time":
            dates = [self2.parseDate(inputDate, format)];
            break;
          case "multiple":
            dates = inputDate.split(self2.config.conjunction).map(function(date) {
              return self2.parseDate(date, format);
            });
            break;
          case "range":
            dates = inputDate.split(self2.l10n.rangeSeparator).map(function(date) {
              return self2.parseDate(date, format);
            });
            break;
          default:
            break;
        }
      } else
        self2.config.errorHandler(new Error("Invalid date supplied: " + JSON.stringify(inputDate)));
      self2.selectedDates = self2.config.allowInvalidPreload ? dates : dates.filter(function(d3) {
        return d3 instanceof Date && isEnabled(d3, false);
      });
      if (self2.config.mode === "range")
        self2.selectedDates.sort(function(a3, b3) {
          return a3.getTime() - b3.getTime();
        });
    }
    __name(setSelectedDate, "setSelectedDate");
    function setDate(date, triggerChange2, format) {
      if (triggerChange2 === void 0) {
        triggerChange2 = false;
      }
      if (format === void 0) {
        format = self2.config.dateFormat;
      }
      if (date !== 0 && !date || date instanceof Array && date.length === 0)
        return self2.clear(triggerChange2);
      setSelectedDate(date, format);
      self2.latestSelectedDateObj = self2.selectedDates[self2.selectedDates.length - 1];
      self2.redraw();
      jumpToDate(void 0, triggerChange2);
      setHoursFromDate();
      if (self2.selectedDates.length === 0) {
        self2.clear(false);
      }
      updateValue(triggerChange2);
      if (triggerChange2)
        triggerEvent("onChange");
    }
    __name(setDate, "setDate");
    function parseDateRules(arr) {
      return arr.slice().map(function(rule) {
        if (typeof rule === "string" || typeof rule === "number" || rule instanceof Date) {
          return self2.parseDate(rule, void 0, true);
        } else if (rule && typeof rule === "object" && rule.from && rule.to)
          return {
            from: self2.parseDate(rule.from, void 0),
            to: self2.parseDate(rule.to, void 0)
          };
        return rule;
      }).filter(function(x3) {
        return x3;
      });
    }
    __name(parseDateRules, "parseDateRules");
    function setupDates() {
      self2.selectedDates = [];
      self2.now = self2.parseDate(self2.config.now) || /* @__PURE__ */ new Date();
      var preloadedDate = self2.config.defaultDate || ((self2.input.nodeName === "INPUT" || self2.input.nodeName === "TEXTAREA") && self2.input.placeholder && self2.input.value === self2.input.placeholder ? null : self2.input.value);
      if (preloadedDate)
        setSelectedDate(preloadedDate, self2.config.dateFormat);
      self2._initialDate = self2.selectedDates.length > 0 ? self2.selectedDates[0] : self2.config.minDate && self2.config.minDate.getTime() > self2.now.getTime() ? self2.config.minDate : self2.config.maxDate && self2.config.maxDate.getTime() < self2.now.getTime() ? self2.config.maxDate : self2.now;
      self2.currentYear = self2._initialDate.getFullYear();
      self2.currentMonth = self2._initialDate.getMonth();
      if (self2.selectedDates.length > 0)
        self2.latestSelectedDateObj = self2.selectedDates[0];
      if (self2.config.minTime !== void 0)
        self2.config.minTime = self2.parseDate(self2.config.minTime, "H:i");
      if (self2.config.maxTime !== void 0)
        self2.config.maxTime = self2.parseDate(self2.config.maxTime, "H:i");
      self2.minDateHasTime = !!self2.config.minDate && (self2.config.minDate.getHours() > 0 || self2.config.minDate.getMinutes() > 0 || self2.config.minDate.getSeconds() > 0);
      self2.maxDateHasTime = !!self2.config.maxDate && (self2.config.maxDate.getHours() > 0 || self2.config.maxDate.getMinutes() > 0 || self2.config.maxDate.getSeconds() > 0);
    }
    __name(setupDates, "setupDates");
    function setupInputs() {
      self2.input = getInputElem();
      if (!self2.input) {
        self2.config.errorHandler(new Error("Invalid input element specified"));
        return;
      }
      self2.input._type = self2.input.type;
      self2.input.type = "text";
      self2.input.classList.add("flatpickr-input");
      self2._input = self2.input;
      if (self2.config.altInput) {
        self2.altInput = createElement(self2.input.nodeName, self2.config.altInputClass);
        self2._input = self2.altInput;
        self2.altInput.placeholder = self2.input.placeholder;
        self2.altInput.disabled = self2.input.disabled;
        self2.altInput.required = self2.input.required;
        self2.altInput.tabIndex = self2.input.tabIndex;
        self2.altInput.type = "text";
        self2.input.setAttribute("type", "hidden");
        if (!self2.config.static && self2.input.parentNode)
          self2.input.parentNode.insertBefore(self2.altInput, self2.input.nextSibling);
      }
      if (!self2.config.allowInput)
        self2._input.setAttribute("readonly", "readonly");
      updatePositionElement();
    }
    __name(setupInputs, "setupInputs");
    function updatePositionElement() {
      self2._positionElement = self2.config.positionElement || self2._input;
    }
    __name(updatePositionElement, "updatePositionElement");
    function setupMobile() {
      var inputType = self2.config.enableTime ? self2.config.noCalendar ? "time" : "datetime-local" : "date";
      self2.mobileInput = createElement("input", self2.input.className + " flatpickr-mobile");
      self2.mobileInput.tabIndex = 1;
      self2.mobileInput.type = inputType;
      self2.mobileInput.disabled = self2.input.disabled;
      self2.mobileInput.required = self2.input.required;
      self2.mobileInput.placeholder = self2.input.placeholder;
      self2.mobileFormatStr = inputType === "datetime-local" ? "Y-m-d\\TH:i:S" : inputType === "date" ? "Y-m-d" : "H:i:S";
      if (self2.selectedDates.length > 0) {
        self2.mobileInput.defaultValue = self2.mobileInput.value = self2.formatDate(self2.selectedDates[0], self2.mobileFormatStr);
      }
      if (self2.config.minDate)
        self2.mobileInput.min = self2.formatDate(self2.config.minDate, "Y-m-d");
      if (self2.config.maxDate)
        self2.mobileInput.max = self2.formatDate(self2.config.maxDate, "Y-m-d");
      if (self2.input.getAttribute("step"))
        self2.mobileInput.step = String(self2.input.getAttribute("step"));
      self2.input.type = "hidden";
      if (self2.altInput !== void 0)
        self2.altInput.type = "hidden";
      try {
        if (self2.input.parentNode)
          self2.input.parentNode.insertBefore(self2.mobileInput, self2.input.nextSibling);
      } catch (_a) {
      }
      bind(self2.mobileInput, "change", function(e3) {
        self2.setDate(getEventTarget(e3).value, false, self2.mobileFormatStr);
        triggerEvent("onChange");
        triggerEvent("onClose");
      });
    }
    __name(setupMobile, "setupMobile");
    function toggle(e3) {
      if (self2.isOpen === true)
        return self2.close();
      self2.open(e3);
    }
    __name(toggle, "toggle");
    function triggerEvent(event, data) {
      if (self2.config === void 0)
        return;
      var hooks = self2.config[event];
      if (hooks !== void 0 && hooks.length > 0) {
        for (var i3 = 0; hooks[i3] && i3 < hooks.length; i3++)
          hooks[i3](self2.selectedDates, self2.input.value, self2, data);
      }
      if (event === "onChange") {
        self2.input.dispatchEvent(createEvent("change"));
        self2.input.dispatchEvent(createEvent("input"));
      }
    }
    __name(triggerEvent, "triggerEvent");
    function createEvent(name) {
      var e3 = document.createEvent("Event");
      e3.initEvent(name, true, true);
      return e3;
    }
    __name(createEvent, "createEvent");
    function isDateSelected(date) {
      for (var i3 = 0; i3 < self2.selectedDates.length; i3++) {
        var selectedDate = self2.selectedDates[i3];
        if (selectedDate instanceof Date && compareDates(selectedDate, date) === 0)
          return "" + i3;
      }
      return false;
    }
    __name(isDateSelected, "isDateSelected");
    function isDateInRange(date) {
      if (self2.config.mode !== "range" || self2.selectedDates.length < 2)
        return false;
      return compareDates(date, self2.selectedDates[0]) >= 0 && compareDates(date, self2.selectedDates[1]) <= 0;
    }
    __name(isDateInRange, "isDateInRange");
    function updateNavigationCurrentMonth() {
      if (self2.config.noCalendar || self2.isMobile || !self2.monthNav)
        return;
      self2.yearElements.forEach(function(yearElement, i3) {
        var d3 = new Date(self2.currentYear, self2.currentMonth, 1);
        d3.setMonth(self2.currentMonth + i3);
        if (self2.config.showMonths > 1 || self2.config.monthSelectorType === "static") {
          self2.monthElements[i3].textContent = monthToStr(d3.getMonth(), self2.config.shorthandCurrentMonth, self2.l10n) + " ";
        } else {
          self2.monthsDropdownContainer.value = d3.getMonth().toString();
        }
        yearElement.value = d3.getFullYear().toString();
      });
      self2._hidePrevMonthArrow = self2.config.minDate !== void 0 && (self2.currentYear === self2.config.minDate.getFullYear() ? self2.currentMonth <= self2.config.minDate.getMonth() : self2.currentYear < self2.config.minDate.getFullYear());
      self2._hideNextMonthArrow = self2.config.maxDate !== void 0 && (self2.currentYear === self2.config.maxDate.getFullYear() ? self2.currentMonth + 1 > self2.config.maxDate.getMonth() : self2.currentYear > self2.config.maxDate.getFullYear());
    }
    __name(updateNavigationCurrentMonth, "updateNavigationCurrentMonth");
    function getDateStr(specificFormat) {
      var format = specificFormat || (self2.config.altInput ? self2.config.altFormat : self2.config.dateFormat);
      return self2.selectedDates.map(function(dObj) {
        return self2.formatDate(dObj, format);
      }).filter(function(d3, i3, arr) {
        return self2.config.mode !== "range" || self2.config.enableTime || arr.indexOf(d3) === i3;
      }).join(self2.config.mode !== "range" ? self2.config.conjunction : self2.l10n.rangeSeparator);
    }
    __name(getDateStr, "getDateStr");
    function updateValue(triggerChange2) {
      if (triggerChange2 === void 0) {
        triggerChange2 = true;
      }
      if (self2.mobileInput !== void 0 && self2.mobileFormatStr) {
        self2.mobileInput.value = self2.latestSelectedDateObj !== void 0 ? self2.formatDate(self2.latestSelectedDateObj, self2.mobileFormatStr) : "";
      }
      self2.input.value = getDateStr(self2.config.dateFormat);
      if (self2.altInput !== void 0) {
        self2.altInput.value = getDateStr(self2.config.altFormat);
      }
      if (triggerChange2 !== false)
        triggerEvent("onValueUpdate");
    }
    __name(updateValue, "updateValue");
    function onMonthNavClick(e3) {
      var eventTarget = getEventTarget(e3);
      var isPrevMonth = self2.prevMonthNav.contains(eventTarget);
      var isNextMonth = self2.nextMonthNav.contains(eventTarget);
      if (isPrevMonth || isNextMonth) {
        changeMonth(isPrevMonth ? -1 : 1);
      } else if (self2.yearElements.indexOf(eventTarget) >= 0) {
        eventTarget.select();
      } else if (eventTarget.classList.contains("arrowUp")) {
        self2.changeYear(self2.currentYear + 1);
      } else if (eventTarget.classList.contains("arrowDown")) {
        self2.changeYear(self2.currentYear - 1);
      }
    }
    __name(onMonthNavClick, "onMonthNavClick");
    function timeWrapper(e3) {
      e3.preventDefault();
      var isKeyDown = e3.type === "keydown", eventTarget = getEventTarget(e3), input = eventTarget;
      if (self2.amPM !== void 0 && eventTarget === self2.amPM) {
        self2.amPM.textContent = self2.l10n.amPM[int(self2.amPM.textContent === self2.l10n.amPM[0])];
      }
      var min = parseFloat(input.getAttribute("min")), max = parseFloat(input.getAttribute("max")), step = parseFloat(input.getAttribute("step")), curValue = parseInt(input.value, 10), delta = e3.delta || (isKeyDown ? e3.which === 38 ? 1 : -1 : 0);
      var newValue = curValue + step * delta;
      if (typeof input.value !== "undefined" && input.value.length === 2) {
        var isHourElem = input === self2.hourElement, isMinuteElem = input === self2.minuteElement;
        if (newValue < min) {
          newValue = max + newValue + int(!isHourElem) + (int(isHourElem) && int(!self2.amPM));
          if (isMinuteElem)
            incrementNumInput(void 0, -1, self2.hourElement);
        } else if (newValue > max) {
          newValue = input === self2.hourElement ? newValue - max - int(!self2.amPM) : min;
          if (isMinuteElem)
            incrementNumInput(void 0, 1, self2.hourElement);
        }
        if (self2.amPM && isHourElem && (step === 1 ? newValue + curValue === 23 : Math.abs(newValue - curValue) > step)) {
          self2.amPM.textContent = self2.l10n.amPM[int(self2.amPM.textContent === self2.l10n.amPM[0])];
        }
        input.value = pad(newValue);
      }
    }
    __name(timeWrapper, "timeWrapper");
    init2();
    return self2;
  }
  __name(FlatpickrInstance, "FlatpickrInstance");
  function _flatpickr(nodeList, config4) {
    var nodes = Array.prototype.slice.call(nodeList).filter(function(x3) {
      return x3 instanceof HTMLElement;
    });
    var instances = [];
    for (var i3 = 0; i3 < nodes.length; i3++) {
      var node = nodes[i3];
      try {
        if (node.getAttribute("data-fp-omit") !== null)
          continue;
        if (node._flatpickr !== void 0) {
          node._flatpickr.destroy();
          node._flatpickr = void 0;
        }
        node._flatpickr = FlatpickrInstance(node, config4 || {});
        instances.push(node._flatpickr);
      } catch (e3) {
        console.error(e3);
      }
    }
    return instances.length === 1 ? instances[0] : instances;
  }
  __name(_flatpickr, "_flatpickr");
  if (typeof HTMLElement !== "undefined" && typeof HTMLCollection !== "undefined" && typeof NodeList !== "undefined") {
    HTMLCollection.prototype.flatpickr = NodeList.prototype.flatpickr = function(config4) {
      return _flatpickr(this, config4);
    };
    HTMLElement.prototype.flatpickr = function(config4) {
      return _flatpickr([this], config4);
    };
  }
  var flatpickr = /* @__PURE__ */ __name(function(selector, config4) {
    if (typeof selector === "string") {
      return _flatpickr(window.document.querySelectorAll(selector), config4);
    } else if (selector instanceof Node) {
      return _flatpickr([selector], config4);
    } else {
      return _flatpickr(selector, config4);
    }
  }, "flatpickr");
  flatpickr.defaultConfig = {};
  flatpickr.l10ns = {
    en: __assign({}, default_default),
    default: __assign({}, default_default)
  };
  flatpickr.localize = function(l10n) {
    flatpickr.l10ns.default = __assign(__assign({}, flatpickr.l10ns.default), l10n);
  };
  flatpickr.setDefaults = function(config4) {
    flatpickr.defaultConfig = __assign(__assign({}, flatpickr.defaultConfig), config4);
  };
  flatpickr.parseDate = createDateParser({});
  flatpickr.formatDate = createDateFormatter({});
  flatpickr.compareDates = compareDates;
  if (typeof jQuery !== "undefined" && typeof jQuery.fn !== "undefined") {
    jQuery.fn.flatpickr = function(config4) {
      return _flatpickr(this, config4);
    };
  }
  Date.prototype.fp_incr = function(days) {
    return new Date(this.getFullYear(), this.getMonth(), this.getDate() + (typeof days === "string" ? parseInt(days, 10) : days));
  };
  if (typeof window !== "undefined") {
    window.flatpickr = flatpickr;
  }
  var esm_default = flatpickr;

  // app/javascript/controllers/date_select_controller.js
  var DateSelectController = class extends Controller {
    static {
      __name(this, "DateSelectController");
    }
    connect() {
      this.picker = esm_default(this.querySelector("input"), { dateFormat: "Y-m-d" });
    }
  };

  // app/javascript/controllers/datetime_select_controller.js
  var DatetimeSelectController = class extends Controller {
    static {
      __name(this, "DatetimeSelectController");
    }
    connect() {
      const defaults4 = { enableTime: true, time_24hr: true, defaultMinute: 0 };
      const tmp = esm_default(this.querySelector("input"), Object.assign(defaults4, this.appendage()));
    }
    appendage() {
      return this.dataset["inline"] ? { inline: true } : {};
    }
  };

  // ../highway/node_modules/sortablejs/modular/sortable.core.esm.js
  function ownKeys(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly) {
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      }
      keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  __name(ownKeys, "ownKeys");
  function _objectSpread2(target) {
    for (var i3 = 1; i3 < arguments.length; i3++) {
      var source = arguments[i3] != null ? arguments[i3] : {};
      if (i3 % 2) {
        ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }
  __name(_objectSpread2, "_objectSpread2");
  function _typeof(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = /* @__PURE__ */ __name(function(obj2) {
        return typeof obj2;
      }, "_typeof");
    } else {
      _typeof = /* @__PURE__ */ __name(function(obj2) {
        return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, "_typeof");
    }
    return _typeof(obj);
  }
  __name(_typeof, "_typeof");
  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  __name(_defineProperty, "_defineProperty");
  function _extends() {
    _extends = Object.assign || function(target) {
      for (var i3 = 1; i3 < arguments.length; i3++) {
        var source = arguments[i3];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends.apply(this, arguments);
  }
  __name(_extends, "_extends");
  function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i3;
    for (i3 = 0; i3 < sourceKeys.length; i3++) {
      key = sourceKeys[i3];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  __name(_objectWithoutPropertiesLoose, "_objectWithoutPropertiesLoose");
  function _objectWithoutProperties(source, excluded) {
    if (source == null)
      return {};
    var target = _objectWithoutPropertiesLoose(source, excluded);
    var key, i3;
    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
      for (i3 = 0; i3 < sourceSymbolKeys.length; i3++) {
        key = sourceSymbolKeys[i3];
        if (excluded.indexOf(key) >= 0)
          continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key))
          continue;
        target[key] = source[key];
      }
    }
    return target;
  }
  __name(_objectWithoutProperties, "_objectWithoutProperties");
  var version = "1.15.6";
  function userAgent(pattern) {
    if (typeof window !== "undefined" && window.navigator) {
      return !!/* @__PURE__ */ navigator.userAgent.match(pattern);
    }
  }
  __name(userAgent, "userAgent");
  var IE11OrLess = userAgent(/(?:Trident.*rv[ :]?11\.|msie|iemobile|Windows Phone)/i);
  var Edge = userAgent(/Edge/i);
  var FireFox = userAgent(/firefox/i);
  var Safari = userAgent(/safari/i) && !userAgent(/chrome/i) && !userAgent(/android/i);
  var IOS = userAgent(/iP(ad|od|hone)/i);
  var ChromeForAndroid = userAgent(/chrome/i) && userAgent(/android/i);
  var captureMode = {
    capture: false,
    passive: false
  };
  function on(el, event, fn) {
    el.addEventListener(event, fn, !IE11OrLess && captureMode);
  }
  __name(on, "on");
  function off(el, event, fn) {
    el.removeEventListener(event, fn, !IE11OrLess && captureMode);
  }
  __name(off, "off");
  function matches(el, selector) {
    if (!selector)
      return;
    selector[0] === ">" && (selector = selector.substring(1));
    if (el) {
      try {
        if (el.matches) {
          return el.matches(selector);
        } else if (el.msMatchesSelector) {
          return el.msMatchesSelector(selector);
        } else if (el.webkitMatchesSelector) {
          return el.webkitMatchesSelector(selector);
        }
      } catch (_2) {
        return false;
      }
    }
    return false;
  }
  __name(matches, "matches");
  function getParentOrHost(el) {
    return el.host && el !== document && el.host.nodeType ? el.host : el.parentNode;
  }
  __name(getParentOrHost, "getParentOrHost");
  function closest(el, selector, ctx, includeCTX) {
    if (el) {
      ctx = ctx || document;
      do {
        if (selector != null && (selector[0] === ">" ? el.parentNode === ctx && matches(el, selector) : matches(el, selector)) || includeCTX && el === ctx) {
          return el;
        }
        if (el === ctx)
          break;
      } while (el = getParentOrHost(el));
    }
    return null;
  }
  __name(closest, "closest");
  var R_SPACE = /\s+/g;
  function toggleClass2(el, name, state) {
    if (el && name) {
      if (el.classList) {
        el.classList[state ? "add" : "remove"](name);
      } else {
        var className = (" " + el.className + " ").replace(R_SPACE, " ").replace(" " + name + " ", " ");
        el.className = (className + (state ? " " + name : "")).replace(R_SPACE, " ");
      }
    }
  }
  __name(toggleClass2, "toggleClass");
  function css(el, prop, val2) {
    var style = el && el.style;
    if (style) {
      if (val2 === void 0) {
        if (document.defaultView && document.defaultView.getComputedStyle) {
          val2 = document.defaultView.getComputedStyle(el, "");
        } else if (el.currentStyle) {
          val2 = el.currentStyle;
        }
        return prop === void 0 ? val2 : val2[prop];
      } else {
        if (!(prop in style) && prop.indexOf("webkit") === -1) {
          prop = "-webkit-" + prop;
        }
        style[prop] = val2 + (typeof val2 === "string" ? "" : "px");
      }
    }
  }
  __name(css, "css");
  function matrix(el, selfOnly) {
    var appliedTransforms = "";
    if (typeof el === "string") {
      appliedTransforms = el;
    } else {
      do {
        var transform = css(el, "transform");
        if (transform && transform !== "none") {
          appliedTransforms = transform + " " + appliedTransforms;
        }
      } while (!selfOnly && (el = el.parentNode));
    }
    var matrixFn = window.DOMMatrix || window.WebKitCSSMatrix || window.CSSMatrix || window.MSCSSMatrix;
    return matrixFn && new matrixFn(appliedTransforms);
  }
  __name(matrix, "matrix");
  function find(ctx, tagName, iterator) {
    if (ctx) {
      var list = ctx.getElementsByTagName(tagName), i3 = 0, n3 = list.length;
      if (iterator) {
        for (; i3 < n3; i3++) {
          iterator(list[i3], i3);
        }
      }
      return list;
    }
    return [];
  }
  __name(find, "find");
  function getWindowScrollingElement() {
    var scrollingElement = document.scrollingElement;
    if (scrollingElement) {
      return scrollingElement;
    } else {
      return document.documentElement;
    }
  }
  __name(getWindowScrollingElement, "getWindowScrollingElement");
  function getRect(el, relativeToContainingBlock, relativeToNonStaticParent, undoScale, container) {
    if (!el.getBoundingClientRect && el !== window)
      return;
    var elRect, top, left, bottom, right, height, width;
    if (el !== window && el.parentNode && el !== getWindowScrollingElement()) {
      elRect = el.getBoundingClientRect();
      top = elRect.top;
      left = elRect.left;
      bottom = elRect.bottom;
      right = elRect.right;
      height = elRect.height;
      width = elRect.width;
    } else {
      top = 0;
      left = 0;
      bottom = window.innerHeight;
      right = window.innerWidth;
      height = window.innerHeight;
      width = window.innerWidth;
    }
    if ((relativeToContainingBlock || relativeToNonStaticParent) && el !== window) {
      container = container || el.parentNode;
      if (!IE11OrLess) {
        do {
          if (container && container.getBoundingClientRect && (css(container, "transform") !== "none" || relativeToNonStaticParent && css(container, "position") !== "static")) {
            var containerRect = container.getBoundingClientRect();
            top -= containerRect.top + parseInt(css(container, "border-top-width"));
            left -= containerRect.left + parseInt(css(container, "border-left-width"));
            bottom = top + elRect.height;
            right = left + elRect.width;
            break;
          }
        } while (container = container.parentNode);
      }
    }
    if (undoScale && el !== window) {
      var elMatrix = matrix(container || el), scaleX = elMatrix && elMatrix.a, scaleY = elMatrix && elMatrix.d;
      if (elMatrix) {
        top /= scaleY;
        left /= scaleX;
        width /= scaleX;
        height /= scaleY;
        bottom = top + height;
        right = left + width;
      }
    }
    return {
      top,
      left,
      bottom,
      right,
      width,
      height
    };
  }
  __name(getRect, "getRect");
  function isScrolledPast(el, elSide, parentSide) {
    var parent = getParentAutoScrollElement(el, true), elSideVal = getRect(el)[elSide];
    while (parent) {
      var parentSideVal = getRect(parent)[parentSide], visible = void 0;
      if (parentSide === "top" || parentSide === "left") {
        visible = elSideVal >= parentSideVal;
      } else {
        visible = elSideVal <= parentSideVal;
      }
      if (!visible)
        return parent;
      if (parent === getWindowScrollingElement())
        break;
      parent = getParentAutoScrollElement(parent, false);
    }
    return false;
  }
  __name(isScrolledPast, "isScrolledPast");
  function getChild(el, childNum, options, includeDragEl) {
    var currentChild = 0, i3 = 0, children = el.children;
    while (i3 < children.length) {
      if (children[i3].style.display !== "none" && children[i3] !== Sortable.ghost && (includeDragEl || children[i3] !== Sortable.dragged) && closest(children[i3], options.draggable, el, false)) {
        if (currentChild === childNum) {
          return children[i3];
        }
        currentChild++;
      }
      i3++;
    }
    return null;
  }
  __name(getChild, "getChild");
  function lastChild(el, selector) {
    var last = el.lastElementChild;
    while (last && (last === Sortable.ghost || css(last, "display") === "none" || selector && !matches(last, selector))) {
      last = last.previousElementSibling;
    }
    return last || null;
  }
  __name(lastChild, "lastChild");
  function index(el, selector) {
    var index2 = 0;
    if (!el || !el.parentNode) {
      return -1;
    }
    while (el = el.previousElementSibling) {
      if (el.nodeName.toUpperCase() !== "TEMPLATE" && el !== Sortable.clone && (!selector || matches(el, selector))) {
        index2++;
      }
    }
    return index2;
  }
  __name(index, "index");
  function getRelativeScrollOffset(el) {
    var offsetLeft = 0, offsetTop = 0, winScroller = getWindowScrollingElement();
    if (el) {
      do {
        var elMatrix = matrix(el), scaleX = elMatrix.a, scaleY = elMatrix.d;
        offsetLeft += el.scrollLeft * scaleX;
        offsetTop += el.scrollTop * scaleY;
      } while (el !== winScroller && (el = el.parentNode));
    }
    return [offsetLeft, offsetTop];
  }
  __name(getRelativeScrollOffset, "getRelativeScrollOffset");
  function indexOfObject(arr, obj) {
    for (var i3 in arr) {
      if (!arr.hasOwnProperty(i3))
        continue;
      for (var key in obj) {
        if (obj.hasOwnProperty(key) && obj[key] === arr[i3][key])
          return Number(i3);
      }
    }
    return -1;
  }
  __name(indexOfObject, "indexOfObject");
  function getParentAutoScrollElement(el, includeSelf) {
    if (!el || !el.getBoundingClientRect)
      return getWindowScrollingElement();
    var elem = el;
    var gotSelf = false;
    do {
      if (elem.clientWidth < elem.scrollWidth || elem.clientHeight < elem.scrollHeight) {
        var elemCSS = css(elem);
        if (elem.clientWidth < elem.scrollWidth && (elemCSS.overflowX == "auto" || elemCSS.overflowX == "scroll") || elem.clientHeight < elem.scrollHeight && (elemCSS.overflowY == "auto" || elemCSS.overflowY == "scroll")) {
          if (!elem.getBoundingClientRect || elem === document.body)
            return getWindowScrollingElement();
          if (gotSelf || includeSelf)
            return elem;
          gotSelf = true;
        }
      }
    } while (elem = elem.parentNode);
    return getWindowScrollingElement();
  }
  __name(getParentAutoScrollElement, "getParentAutoScrollElement");
  function extend2(dst, src) {
    if (dst && src) {
      for (var key in src) {
        if (src.hasOwnProperty(key)) {
          dst[key] = src[key];
        }
      }
    }
    return dst;
  }
  __name(extend2, "extend");
  function isRectEqual(rect1, rect2) {
    return Math.round(rect1.top) === Math.round(rect2.top) && Math.round(rect1.left) === Math.round(rect2.left) && Math.round(rect1.height) === Math.round(rect2.height) && Math.round(rect1.width) === Math.round(rect2.width);
  }
  __name(isRectEqual, "isRectEqual");
  var _throttleTimeout;
  function throttle(callback, ms) {
    return function() {
      if (!_throttleTimeout) {
        var args = arguments, _this = this;
        if (args.length === 1) {
          callback.call(_this, args[0]);
        } else {
          callback.apply(_this, args);
        }
        _throttleTimeout = setTimeout(function() {
          _throttleTimeout = void 0;
        }, ms);
      }
    };
  }
  __name(throttle, "throttle");
  function scrollBy(el, x3, y3) {
    el.scrollLeft += x3;
    el.scrollTop += y3;
  }
  __name(scrollBy, "scrollBy");
  function clone(el) {
    var Polymer = window.Polymer;
    var $2 = window.jQuery || window.Zepto;
    if (Polymer && Polymer.dom) {
      return Polymer.dom(el).cloneNode(true);
    } else if ($2) {
      return $2(el).clone(true)[0];
    } else {
      return el.cloneNode(true);
    }
  }
  __name(clone, "clone");
  function getChildContainingRectFromElement(container, options, ghostEl2) {
    var rect = {};
    Array.from(container.children).forEach(function(child) {
      var _rect$left, _rect$top, _rect$right, _rect$bottom;
      if (!closest(child, options.draggable, container, false) || child.animated || child === ghostEl2)
        return;
      var childRect = getRect(child);
      rect.left = Math.min((_rect$left = rect.left) !== null && _rect$left !== void 0 ? _rect$left : Infinity, childRect.left);
      rect.top = Math.min((_rect$top = rect.top) !== null && _rect$top !== void 0 ? _rect$top : Infinity, childRect.top);
      rect.right = Math.max((_rect$right = rect.right) !== null && _rect$right !== void 0 ? _rect$right : -Infinity, childRect.right);
      rect.bottom = Math.max((_rect$bottom = rect.bottom) !== null && _rect$bottom !== void 0 ? _rect$bottom : -Infinity, childRect.bottom);
    });
    rect.width = rect.right - rect.left;
    rect.height = rect.bottom - rect.top;
    rect.x = rect.left;
    rect.y = rect.top;
    return rect;
  }
  __name(getChildContainingRectFromElement, "getChildContainingRectFromElement");
  var expando = "Sortable" + (/* @__PURE__ */ new Date()).getTime();
  function AnimationStateManager() {
    var animationStates = [], animationCallbackId;
    return {
      captureAnimationState: /* @__PURE__ */ __name(function captureAnimationState() {
        animationStates = [];
        if (!this.options.animation)
          return;
        var children = [].slice.call(this.el.children);
        children.forEach(function(child) {
          if (css(child, "display") === "none" || child === Sortable.ghost)
            return;
          animationStates.push({
            target: child,
            rect: getRect(child)
          });
          var fromRect = _objectSpread2({}, animationStates[animationStates.length - 1].rect);
          if (child.thisAnimationDuration) {
            var childMatrix = matrix(child, true);
            if (childMatrix) {
              fromRect.top -= childMatrix.f;
              fromRect.left -= childMatrix.e;
            }
          }
          child.fromRect = fromRect;
        });
      }, "captureAnimationState"),
      addAnimationState: /* @__PURE__ */ __name(function addAnimationState(state) {
        animationStates.push(state);
      }, "addAnimationState"),
      removeAnimationState: /* @__PURE__ */ __name(function removeAnimationState(target) {
        animationStates.splice(indexOfObject(animationStates, {
          target
        }), 1);
      }, "removeAnimationState"),
      animateAll: /* @__PURE__ */ __name(function animateAll(callback) {
        var _this = this;
        if (!this.options.animation) {
          clearTimeout(animationCallbackId);
          if (typeof callback === "function")
            callback();
          return;
        }
        var animating = false, animationTime = 0;
        animationStates.forEach(function(state) {
          var time = 0, target = state.target, fromRect = target.fromRect, toRect = getRect(target), prevFromRect = target.prevFromRect, prevToRect = target.prevToRect, animatingRect = state.rect, targetMatrix = matrix(target, true);
          if (targetMatrix) {
            toRect.top -= targetMatrix.f;
            toRect.left -= targetMatrix.e;
          }
          target.toRect = toRect;
          if (target.thisAnimationDuration) {
            if (isRectEqual(prevFromRect, toRect) && !isRectEqual(fromRect, toRect) && // Make sure animatingRect is on line between toRect & fromRect
            (animatingRect.top - toRect.top) / (animatingRect.left - toRect.left) === (fromRect.top - toRect.top) / (fromRect.left - toRect.left)) {
              time = calculateRealTime(animatingRect, prevFromRect, prevToRect, _this.options);
            }
          }
          if (!isRectEqual(toRect, fromRect)) {
            target.prevFromRect = fromRect;
            target.prevToRect = toRect;
            if (!time) {
              time = _this.options.animation;
            }
            _this.animate(target, animatingRect, toRect, time);
          }
          if (time) {
            animating = true;
            animationTime = Math.max(animationTime, time);
            clearTimeout(target.animationResetTimer);
            target.animationResetTimer = setTimeout(function() {
              target.animationTime = 0;
              target.prevFromRect = null;
              target.fromRect = null;
              target.prevToRect = null;
              target.thisAnimationDuration = null;
            }, time);
            target.thisAnimationDuration = time;
          }
        });
        clearTimeout(animationCallbackId);
        if (!animating) {
          if (typeof callback === "function")
            callback();
        } else {
          animationCallbackId = setTimeout(function() {
            if (typeof callback === "function")
              callback();
          }, animationTime);
        }
        animationStates = [];
      }, "animateAll"),
      animate: /* @__PURE__ */ __name(function animate(target, currentRect, toRect, duration3) {
        if (duration3) {
          css(target, "transition", "");
          css(target, "transform", "");
          var elMatrix = matrix(this.el), scaleX = elMatrix && elMatrix.a, scaleY = elMatrix && elMatrix.d, translateX = (currentRect.left - toRect.left) / (scaleX || 1), translateY = (currentRect.top - toRect.top) / (scaleY || 1);
          target.animatingX = !!translateX;
          target.animatingY = !!translateY;
          css(target, "transform", "translate3d(" + translateX + "px," + translateY + "px,0)");
          this.forRepaintDummy = repaint(target);
          css(target, "transition", "transform " + duration3 + "ms" + (this.options.easing ? " " + this.options.easing : ""));
          css(target, "transform", "translate3d(0,0,0)");
          typeof target.animated === "number" && clearTimeout(target.animated);
          target.animated = setTimeout(function() {
            css(target, "transition", "");
            css(target, "transform", "");
            target.animated = false;
            target.animatingX = false;
            target.animatingY = false;
          }, duration3);
        }
      }, "animate")
    };
  }
  __name(AnimationStateManager, "AnimationStateManager");
  function repaint(target) {
    return target.offsetWidth;
  }
  __name(repaint, "repaint");
  function calculateRealTime(animatingRect, fromRect, toRect, options) {
    return Math.sqrt(Math.pow(fromRect.top - animatingRect.top, 2) + Math.pow(fromRect.left - animatingRect.left, 2)) / Math.sqrt(Math.pow(fromRect.top - toRect.top, 2) + Math.pow(fromRect.left - toRect.left, 2)) * options.animation;
  }
  __name(calculateRealTime, "calculateRealTime");
  var plugins = [];
  var defaults2 = {
    initializeByDefault: true
  };
  var PluginManager = {
    mount: /* @__PURE__ */ __name(function mount(plugin) {
      for (var option2 in defaults2) {
        if (defaults2.hasOwnProperty(option2) && !(option2 in plugin)) {
          plugin[option2] = defaults2[option2];
        }
      }
      plugins.forEach(function(p3) {
        if (p3.pluginName === plugin.pluginName) {
          throw "Sortable: Cannot mount plugin ".concat(plugin.pluginName, " more than once");
        }
      });
      plugins.push(plugin);
    }, "mount"),
    pluginEvent: /* @__PURE__ */ __name(function pluginEvent(eventName, sortable, evt) {
      var _this = this;
      this.eventCanceled = false;
      evt.cancel = function() {
        _this.eventCanceled = true;
      };
      var eventNameGlobal = eventName + "Global";
      plugins.forEach(function(plugin) {
        if (!sortable[plugin.pluginName])
          return;
        if (sortable[plugin.pluginName][eventNameGlobal]) {
          sortable[plugin.pluginName][eventNameGlobal](_objectSpread2({
            sortable
          }, evt));
        }
        if (sortable.options[plugin.pluginName] && sortable[plugin.pluginName][eventName]) {
          sortable[plugin.pluginName][eventName](_objectSpread2({
            sortable
          }, evt));
        }
      });
    }, "pluginEvent"),
    initializePlugins: /* @__PURE__ */ __name(function initializePlugins(sortable, el, defaults4, options) {
      plugins.forEach(function(plugin) {
        var pluginName = plugin.pluginName;
        if (!sortable.options[pluginName] && !plugin.initializeByDefault)
          return;
        var initialized = new plugin(sortable, el, sortable.options);
        initialized.sortable = sortable;
        initialized.options = sortable.options;
        sortable[pluginName] = initialized;
        _extends(defaults4, initialized.defaults);
      });
      for (var option2 in sortable.options) {
        if (!sortable.options.hasOwnProperty(option2))
          continue;
        var modified = this.modifyOption(sortable, option2, sortable.options[option2]);
        if (typeof modified !== "undefined") {
          sortable.options[option2] = modified;
        }
      }
    }, "initializePlugins"),
    getEventProperties: /* @__PURE__ */ __name(function getEventProperties(name, sortable) {
      var eventProperties = {};
      plugins.forEach(function(plugin) {
        if (typeof plugin.eventProperties !== "function")
          return;
        _extends(eventProperties, plugin.eventProperties.call(sortable[plugin.pluginName], name));
      });
      return eventProperties;
    }, "getEventProperties"),
    modifyOption: /* @__PURE__ */ __name(function modifyOption(sortable, name, value) {
      var modifiedValue;
      plugins.forEach(function(plugin) {
        if (!sortable[plugin.pluginName])
          return;
        if (plugin.optionListeners && typeof plugin.optionListeners[name] === "function") {
          modifiedValue = plugin.optionListeners[name].call(sortable[plugin.pluginName], value);
        }
      });
      return modifiedValue;
    }, "modifyOption")
  };
  function dispatchEvent2(_ref) {
    var sortable = _ref.sortable, rootEl2 = _ref.rootEl, name = _ref.name, targetEl = _ref.targetEl, cloneEl2 = _ref.cloneEl, toEl = _ref.toEl, fromEl = _ref.fromEl, oldIndex2 = _ref.oldIndex, newIndex2 = _ref.newIndex, oldDraggableIndex2 = _ref.oldDraggableIndex, newDraggableIndex2 = _ref.newDraggableIndex, originalEvent = _ref.originalEvent, putSortable2 = _ref.putSortable, extraEventProperties = _ref.extraEventProperties;
    sortable = sortable || rootEl2 && rootEl2[expando];
    if (!sortable)
      return;
    var evt, options = sortable.options, onName = "on" + name.charAt(0).toUpperCase() + name.substr(1);
    if (window.CustomEvent && !IE11OrLess && !Edge) {
      evt = new CustomEvent(name, {
        bubbles: true,
        cancelable: true
      });
    } else {
      evt = document.createEvent("Event");
      evt.initEvent(name, true, true);
    }
    evt.to = toEl || rootEl2;
    evt.from = fromEl || rootEl2;
    evt.item = targetEl || rootEl2;
    evt.clone = cloneEl2;
    evt.oldIndex = oldIndex2;
    evt.newIndex = newIndex2;
    evt.oldDraggableIndex = oldDraggableIndex2;
    evt.newDraggableIndex = newDraggableIndex2;
    evt.originalEvent = originalEvent;
    evt.pullMode = putSortable2 ? putSortable2.lastPutMode : void 0;
    var allEventProperties = _objectSpread2(_objectSpread2({}, extraEventProperties), PluginManager.getEventProperties(name, sortable));
    for (var option2 in allEventProperties) {
      evt[option2] = allEventProperties[option2];
    }
    if (rootEl2) {
      rootEl2.dispatchEvent(evt);
    }
    if (options[onName]) {
      options[onName].call(sortable, evt);
    }
  }
  __name(dispatchEvent2, "dispatchEvent");
  var _excluded = ["evt"];
  var pluginEvent2 = /* @__PURE__ */ __name(function pluginEvent3(eventName, sortable) {
    var _ref = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, originalEvent = _ref.evt, data = _objectWithoutProperties(_ref, _excluded);
    PluginManager.pluginEvent.bind(Sortable)(eventName, sortable, _objectSpread2({
      dragEl,
      parentEl,
      ghostEl,
      rootEl,
      nextEl,
      lastDownEl,
      cloneEl,
      cloneHidden,
      dragStarted: moved,
      putSortable,
      activeSortable: Sortable.active,
      originalEvent,
      oldIndex,
      oldDraggableIndex,
      newIndex,
      newDraggableIndex,
      hideGhostForTarget: _hideGhostForTarget,
      unhideGhostForTarget: _unhideGhostForTarget,
      cloneNowHidden: /* @__PURE__ */ __name(function cloneNowHidden() {
        cloneHidden = true;
      }, "cloneNowHidden"),
      cloneNowShown: /* @__PURE__ */ __name(function cloneNowShown() {
        cloneHidden = false;
      }, "cloneNowShown"),
      dispatchSortableEvent: /* @__PURE__ */ __name(function dispatchSortableEvent(name) {
        _dispatchEvent({
          sortable,
          name,
          originalEvent
        });
      }, "dispatchSortableEvent")
    }, data));
  }, "pluginEvent");
  function _dispatchEvent(info) {
    dispatchEvent2(_objectSpread2({
      putSortable,
      cloneEl,
      targetEl: dragEl,
      rootEl,
      oldIndex,
      oldDraggableIndex,
      newIndex,
      newDraggableIndex
    }, info));
  }
  __name(_dispatchEvent, "_dispatchEvent");
  var dragEl;
  var parentEl;
  var ghostEl;
  var rootEl;
  var nextEl;
  var lastDownEl;
  var cloneEl;
  var cloneHidden;
  var oldIndex;
  var newIndex;
  var oldDraggableIndex;
  var newDraggableIndex;
  var activeGroup;
  var putSortable;
  var awaitingDragStarted = false;
  var ignoreNextClick = false;
  var sortables = [];
  var tapEvt;
  var touchEvt;
  var lastDx;
  var lastDy;
  var tapDistanceLeft;
  var tapDistanceTop;
  var moved;
  var lastTarget;
  var lastDirection;
  var pastFirstInvertThresh = false;
  var isCircumstantialInvert = false;
  var targetMoveDistance;
  var ghostRelativeParent;
  var ghostRelativeParentInitialScroll = [];
  var _silent = false;
  var savedInputChecked = [];
  var documentExists = typeof document !== "undefined";
  var PositionGhostAbsolutely = IOS;
  var CSSFloatProperty = Edge || IE11OrLess ? "cssFloat" : "float";
  var supportDraggable = documentExists && !ChromeForAndroid && !IOS && "draggable" in document.createElement("div");
  var supportCssPointerEvents = function() {
    if (!documentExists)
      return;
    if (IE11OrLess) {
      return false;
    }
    var el = document.createElement("x");
    el.style.cssText = "pointer-events:auto";
    return el.style.pointerEvents === "auto";
  }();
  var _detectDirection = /* @__PURE__ */ __name(function _detectDirection2(el, options) {
    var elCSS = css(el), elWidth = parseInt(elCSS.width) - parseInt(elCSS.paddingLeft) - parseInt(elCSS.paddingRight) - parseInt(elCSS.borderLeftWidth) - parseInt(elCSS.borderRightWidth), child1 = getChild(el, 0, options), child2 = getChild(el, 1, options), firstChildCSS = child1 && css(child1), secondChildCSS = child2 && css(child2), firstChildWidth = firstChildCSS && parseInt(firstChildCSS.marginLeft) + parseInt(firstChildCSS.marginRight) + getRect(child1).width, secondChildWidth = secondChildCSS && parseInt(secondChildCSS.marginLeft) + parseInt(secondChildCSS.marginRight) + getRect(child2).width;
    if (elCSS.display === "flex") {
      return elCSS.flexDirection === "column" || elCSS.flexDirection === "column-reverse" ? "vertical" : "horizontal";
    }
    if (elCSS.display === "grid") {
      return elCSS.gridTemplateColumns.split(" ").length <= 1 ? "vertical" : "horizontal";
    }
    if (child1 && firstChildCSS["float"] && firstChildCSS["float"] !== "none") {
      var touchingSideChild2 = firstChildCSS["float"] === "left" ? "left" : "right";
      return child2 && (secondChildCSS.clear === "both" || secondChildCSS.clear === touchingSideChild2) ? "vertical" : "horizontal";
    }
    return child1 && (firstChildCSS.display === "block" || firstChildCSS.display === "flex" || firstChildCSS.display === "table" || firstChildCSS.display === "grid" || firstChildWidth >= elWidth && elCSS[CSSFloatProperty] === "none" || child2 && elCSS[CSSFloatProperty] === "none" && firstChildWidth + secondChildWidth > elWidth) ? "vertical" : "horizontal";
  }, "_detectDirection");
  var _dragElInRowColumn = /* @__PURE__ */ __name(function _dragElInRowColumn2(dragRect, targetRect, vertical) {
    var dragElS1Opp = vertical ? dragRect.left : dragRect.top, dragElS2Opp = vertical ? dragRect.right : dragRect.bottom, dragElOppLength = vertical ? dragRect.width : dragRect.height, targetS1Opp = vertical ? targetRect.left : targetRect.top, targetS2Opp = vertical ? targetRect.right : targetRect.bottom, targetOppLength = vertical ? targetRect.width : targetRect.height;
    return dragElS1Opp === targetS1Opp || dragElS2Opp === targetS2Opp || dragElS1Opp + dragElOppLength / 2 === targetS1Opp + targetOppLength / 2;
  }, "_dragElInRowColumn");
  var _detectNearestEmptySortable = /* @__PURE__ */ __name(function _detectNearestEmptySortable2(x3, y3) {
    var ret;
    sortables.some(function(sortable) {
      var threshold = sortable[expando].options.emptyInsertThreshold;
      if (!threshold || lastChild(sortable))
        return;
      var rect = getRect(sortable), insideHorizontally = x3 >= rect.left - threshold && x3 <= rect.right + threshold, insideVertically = y3 >= rect.top - threshold && y3 <= rect.bottom + threshold;
      if (insideHorizontally && insideVertically) {
        return ret = sortable;
      }
    });
    return ret;
  }, "_detectNearestEmptySortable");
  var _prepareGroup = /* @__PURE__ */ __name(function _prepareGroup2(options) {
    function toFn(value, pull) {
      return function(to, from, dragEl2, evt) {
        var sameGroup = to.options.group.name && from.options.group.name && to.options.group.name === from.options.group.name;
        if (value == null && (pull || sameGroup)) {
          return true;
        } else if (value == null || value === false) {
          return false;
        } else if (pull && value === "clone") {
          return value;
        } else if (typeof value === "function") {
          return toFn(value(to, from, dragEl2, evt), pull)(to, from, dragEl2, evt);
        } else {
          var otherGroup = (pull ? to : from).options.group.name;
          return value === true || typeof value === "string" && value === otherGroup || value.join && value.indexOf(otherGroup) > -1;
        }
      };
    }
    __name(toFn, "toFn");
    var group = {};
    var originalGroup = options.group;
    if (!originalGroup || _typeof(originalGroup) != "object") {
      originalGroup = {
        name: originalGroup
      };
    }
    group.name = originalGroup.name;
    group.checkPull = toFn(originalGroup.pull, true);
    group.checkPut = toFn(originalGroup.put);
    group.revertClone = originalGroup.revertClone;
    options.group = group;
  }, "_prepareGroup");
  var _hideGhostForTarget = /* @__PURE__ */ __name(function _hideGhostForTarget2() {
    if (!supportCssPointerEvents && ghostEl) {
      css(ghostEl, "display", "none");
    }
  }, "_hideGhostForTarget");
  var _unhideGhostForTarget = /* @__PURE__ */ __name(function _unhideGhostForTarget2() {
    if (!supportCssPointerEvents && ghostEl) {
      css(ghostEl, "display", "");
    }
  }, "_unhideGhostForTarget");
  if (documentExists && !ChromeForAndroid) {
    document.addEventListener("click", function(evt) {
      if (ignoreNextClick) {
        evt.preventDefault();
        evt.stopPropagation && evt.stopPropagation();
        evt.stopImmediatePropagation && evt.stopImmediatePropagation();
        ignoreNextClick = false;
        return false;
      }
    }, true);
  }
  var nearestEmptyInsertDetectEvent = /* @__PURE__ */ __name(function nearestEmptyInsertDetectEvent2(evt) {
    if (dragEl) {
      evt = evt.touches ? evt.touches[0] : evt;
      var nearest = _detectNearestEmptySortable(evt.clientX, evt.clientY);
      if (nearest) {
        var event = {};
        for (var i3 in evt) {
          if (evt.hasOwnProperty(i3)) {
            event[i3] = evt[i3];
          }
        }
        event.target = event.rootEl = nearest;
        event.preventDefault = void 0;
        event.stopPropagation = void 0;
        nearest[expando]._onDragOver(event);
      }
    }
  }, "nearestEmptyInsertDetectEvent");
  var _checkOutsideTargetEl = /* @__PURE__ */ __name(function _checkOutsideTargetEl2(evt) {
    if (dragEl) {
      dragEl.parentNode[expando]._isOutsideThisEl(evt.target);
    }
  }, "_checkOutsideTargetEl");
  function Sortable(el, options) {
    if (!(el && el.nodeType && el.nodeType === 1)) {
      throw "Sortable: `el` must be an HTMLElement, not ".concat({}.toString.call(el));
    }
    this.el = el;
    this.options = options = _extends({}, options);
    el[expando] = this;
    var defaults4 = {
      group: null,
      sort: true,
      disabled: false,
      store: null,
      handle: null,
      draggable: /^[uo]l$/i.test(el.nodeName) ? ">li" : ">*",
      swapThreshold: 1,
      // percentage; 0 <= x <= 1
      invertSwap: false,
      // invert always
      invertedSwapThreshold: null,
      // will be set to same as swapThreshold if default
      removeCloneOnHide: true,
      direction: /* @__PURE__ */ __name(function direction() {
        return _detectDirection(el, this.options);
      }, "direction"),
      ghostClass: "sortable-ghost",
      chosenClass: "sortable-chosen",
      dragClass: "sortable-drag",
      ignore: "a, img",
      filter: null,
      preventOnFilter: true,
      animation: 0,
      easing: null,
      setData: /* @__PURE__ */ __name(function setData(dataTransfer, dragEl2) {
        dataTransfer.setData("Text", dragEl2.textContent);
      }, "setData"),
      dropBubble: false,
      dragoverBubble: false,
      dataIdAttr: "data-id",
      delay: 0,
      delayOnTouchOnly: false,
      touchStartThreshold: (Number.parseInt ? Number : window).parseInt(window.devicePixelRatio, 10) || 1,
      forceFallback: false,
      fallbackClass: "sortable-fallback",
      fallbackOnBody: false,
      fallbackTolerance: 0,
      fallbackOffset: {
        x: 0,
        y: 0
      },
      // Disabled on Safari: #1571; Enabled on Safari IOS: #2244
      supportPointer: Sortable.supportPointer !== false && "PointerEvent" in window && (!Safari || IOS),
      emptyInsertThreshold: 5
    };
    PluginManager.initializePlugins(this, el, defaults4);
    for (var name in defaults4) {
      !(name in options) && (options[name] = defaults4[name]);
    }
    _prepareGroup(options);
    for (var fn in this) {
      if (fn.charAt(0) === "_" && typeof this[fn] === "function") {
        this[fn] = this[fn].bind(this);
      }
    }
    this.nativeDraggable = options.forceFallback ? false : supportDraggable;
    if (this.nativeDraggable) {
      this.options.touchStartThreshold = 1;
    }
    if (options.supportPointer) {
      on(el, "pointerdown", this._onTapStart);
    } else {
      on(el, "mousedown", this._onTapStart);
      on(el, "touchstart", this._onTapStart);
    }
    if (this.nativeDraggable) {
      on(el, "dragover", this);
      on(el, "dragenter", this);
    }
    sortables.push(this.el);
    options.store && options.store.get && this.sort(options.store.get(this) || []);
    _extends(this, AnimationStateManager());
  }
  __name(Sortable, "Sortable");
  Sortable.prototype = /** @lends Sortable.prototype */
  {
    constructor: Sortable,
    _isOutsideThisEl: /* @__PURE__ */ __name(function _isOutsideThisEl(target) {
      if (!this.el.contains(target) && target !== this.el) {
        lastTarget = null;
      }
    }, "_isOutsideThisEl"),
    _getDirection: /* @__PURE__ */ __name(function _getDirection(evt, target) {
      return typeof this.options.direction === "function" ? this.options.direction.call(this, evt, target, dragEl) : this.options.direction;
    }, "_getDirection"),
    _onTapStart: /* @__PURE__ */ __name(function _onTapStart(evt) {
      if (!evt.cancelable)
        return;
      var _this = this, el = this.el, options = this.options, preventOnFilter = options.preventOnFilter, type = evt.type, touch = evt.touches && evt.touches[0] || evt.pointerType && evt.pointerType === "touch" && evt, target = (touch || evt).target, originalTarget = evt.target.shadowRoot && (evt.path && evt.path[0] || evt.composedPath && evt.composedPath()[0]) || target, filter = options.filter;
      _saveInputCheckedState(el);
      if (dragEl) {
        return;
      }
      if (/mousedown|pointerdown/.test(type) && evt.button !== 0 || options.disabled) {
        return;
      }
      if (originalTarget.isContentEditable) {
        return;
      }
      if (!this.nativeDraggable && Safari && target && target.tagName.toUpperCase() === "SELECT") {
        return;
      }
      target = closest(target, options.draggable, el, false);
      if (target && target.animated) {
        return;
      }
      if (lastDownEl === target) {
        return;
      }
      oldIndex = index(target);
      oldDraggableIndex = index(target, options.draggable);
      if (typeof filter === "function") {
        if (filter.call(this, evt, target, this)) {
          _dispatchEvent({
            sortable: _this,
            rootEl: originalTarget,
            name: "filter",
            targetEl: target,
            toEl: el,
            fromEl: el
          });
          pluginEvent2("filter", _this, {
            evt
          });
          preventOnFilter && evt.preventDefault();
          return;
        }
      } else if (filter) {
        filter = filter.split(",").some(function(criteria) {
          criteria = closest(originalTarget, criteria.trim(), el, false);
          if (criteria) {
            _dispatchEvent({
              sortable: _this,
              rootEl: criteria,
              name: "filter",
              targetEl: target,
              fromEl: el,
              toEl: el
            });
            pluginEvent2("filter", _this, {
              evt
            });
            return true;
          }
        });
        if (filter) {
          preventOnFilter && evt.preventDefault();
          return;
        }
      }
      if (options.handle && !closest(originalTarget, options.handle, el, false)) {
        return;
      }
      this._prepareDragStart(evt, touch, target);
    }, "_onTapStart"),
    _prepareDragStart: /* @__PURE__ */ __name(function _prepareDragStart(evt, touch, target) {
      var _this = this, el = _this.el, options = _this.options, ownerDocument = el.ownerDocument, dragStartFn;
      if (target && !dragEl && target.parentNode === el) {
        var dragRect = getRect(target);
        rootEl = el;
        dragEl = target;
        parentEl = dragEl.parentNode;
        nextEl = dragEl.nextSibling;
        lastDownEl = target;
        activeGroup = options.group;
        Sortable.dragged = dragEl;
        tapEvt = {
          target: dragEl,
          clientX: (touch || evt).clientX,
          clientY: (touch || evt).clientY
        };
        tapDistanceLeft = tapEvt.clientX - dragRect.left;
        tapDistanceTop = tapEvt.clientY - dragRect.top;
        this._lastX = (touch || evt).clientX;
        this._lastY = (touch || evt).clientY;
        dragEl.style["will-change"] = "all";
        dragStartFn = /* @__PURE__ */ __name(function dragStartFn2() {
          pluginEvent2("delayEnded", _this, {
            evt
          });
          if (Sortable.eventCanceled) {
            _this._onDrop();
            return;
          }
          _this._disableDelayedDragEvents();
          if (!FireFox && _this.nativeDraggable) {
            dragEl.draggable = true;
          }
          _this._triggerDragStart(evt, touch);
          _dispatchEvent({
            sortable: _this,
            name: "choose",
            originalEvent: evt
          });
          toggleClass2(dragEl, options.chosenClass, true);
        }, "dragStartFn");
        options.ignore.split(",").forEach(function(criteria) {
          find(dragEl, criteria.trim(), _disableDraggable);
        });
        on(ownerDocument, "dragover", nearestEmptyInsertDetectEvent);
        on(ownerDocument, "mousemove", nearestEmptyInsertDetectEvent);
        on(ownerDocument, "touchmove", nearestEmptyInsertDetectEvent);
        if (options.supportPointer) {
          on(ownerDocument, "pointerup", _this._onDrop);
          !this.nativeDraggable && on(ownerDocument, "pointercancel", _this._onDrop);
        } else {
          on(ownerDocument, "mouseup", _this._onDrop);
          on(ownerDocument, "touchend", _this._onDrop);
          on(ownerDocument, "touchcancel", _this._onDrop);
        }
        if (FireFox && this.nativeDraggable) {
          this.options.touchStartThreshold = 4;
          dragEl.draggable = true;
        }
        pluginEvent2("delayStart", this, {
          evt
        });
        if (options.delay && (!options.delayOnTouchOnly || touch) && (!this.nativeDraggable || !(Edge || IE11OrLess))) {
          if (Sortable.eventCanceled) {
            this._onDrop();
            return;
          }
          if (options.supportPointer) {
            on(ownerDocument, "pointerup", _this._disableDelayedDrag);
            on(ownerDocument, "pointercancel", _this._disableDelayedDrag);
          } else {
            on(ownerDocument, "mouseup", _this._disableDelayedDrag);
            on(ownerDocument, "touchend", _this._disableDelayedDrag);
            on(ownerDocument, "touchcancel", _this._disableDelayedDrag);
          }
          on(ownerDocument, "mousemove", _this._delayedDragTouchMoveHandler);
          on(ownerDocument, "touchmove", _this._delayedDragTouchMoveHandler);
          options.supportPointer && on(ownerDocument, "pointermove", _this._delayedDragTouchMoveHandler);
          _this._dragStartTimer = setTimeout(dragStartFn, options.delay);
        } else {
          dragStartFn();
        }
      }
    }, "_prepareDragStart"),
    _delayedDragTouchMoveHandler: /* @__PURE__ */ __name(function _delayedDragTouchMoveHandler(e3) {
      var touch = e3.touches ? e3.touches[0] : e3;
      if (Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) >= Math.floor(this.options.touchStartThreshold / (this.nativeDraggable && window.devicePixelRatio || 1))) {
        this._disableDelayedDrag();
      }
    }, "_delayedDragTouchMoveHandler"),
    _disableDelayedDrag: /* @__PURE__ */ __name(function _disableDelayedDrag() {
      dragEl && _disableDraggable(dragEl);
      clearTimeout(this._dragStartTimer);
      this._disableDelayedDragEvents();
    }, "_disableDelayedDrag"),
    _disableDelayedDragEvents: /* @__PURE__ */ __name(function _disableDelayedDragEvents() {
      var ownerDocument = this.el.ownerDocument;
      off(ownerDocument, "mouseup", this._disableDelayedDrag);
      off(ownerDocument, "touchend", this._disableDelayedDrag);
      off(ownerDocument, "touchcancel", this._disableDelayedDrag);
      off(ownerDocument, "pointerup", this._disableDelayedDrag);
      off(ownerDocument, "pointercancel", this._disableDelayedDrag);
      off(ownerDocument, "mousemove", this._delayedDragTouchMoveHandler);
      off(ownerDocument, "touchmove", this._delayedDragTouchMoveHandler);
      off(ownerDocument, "pointermove", this._delayedDragTouchMoveHandler);
    }, "_disableDelayedDragEvents"),
    _triggerDragStart: /* @__PURE__ */ __name(function _triggerDragStart(evt, touch) {
      touch = touch || evt.pointerType == "touch" && evt;
      if (!this.nativeDraggable || touch) {
        if (this.options.supportPointer) {
          on(document, "pointermove", this._onTouchMove);
        } else if (touch) {
          on(document, "touchmove", this._onTouchMove);
        } else {
          on(document, "mousemove", this._onTouchMove);
        }
      } else {
        on(dragEl, "dragend", this);
        on(rootEl, "dragstart", this._onDragStart);
      }
      try {
        if (document.selection) {
          _nextTick(function() {
            document.selection.empty();
          });
        } else {
          window.getSelection().removeAllRanges();
        }
      } catch (err) {
      }
    }, "_triggerDragStart"),
    _dragStarted: /* @__PURE__ */ __name(function _dragStarted(fallback, evt) {
      awaitingDragStarted = false;
      if (rootEl && dragEl) {
        pluginEvent2("dragStarted", this, {
          evt
        });
        if (this.nativeDraggable) {
          on(document, "dragover", _checkOutsideTargetEl);
        }
        var options = this.options;
        !fallback && toggleClass2(dragEl, options.dragClass, false);
        toggleClass2(dragEl, options.ghostClass, true);
        Sortable.active = this;
        fallback && this._appendGhost();
        _dispatchEvent({
          sortable: this,
          name: "start",
          originalEvent: evt
        });
      } else {
        this._nulling();
      }
    }, "_dragStarted"),
    _emulateDragOver: /* @__PURE__ */ __name(function _emulateDragOver() {
      if (touchEvt) {
        this._lastX = touchEvt.clientX;
        this._lastY = touchEvt.clientY;
        _hideGhostForTarget();
        var target = document.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
        var parent = target;
        while (target && target.shadowRoot) {
          target = target.shadowRoot.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
          if (target === parent)
            break;
          parent = target;
        }
        dragEl.parentNode[expando]._isOutsideThisEl(target);
        if (parent) {
          do {
            if (parent[expando]) {
              var inserted = void 0;
              inserted = parent[expando]._onDragOver({
                clientX: touchEvt.clientX,
                clientY: touchEvt.clientY,
                target,
                rootEl: parent
              });
              if (inserted && !this.options.dragoverBubble) {
                break;
              }
            }
            target = parent;
          } while (parent = getParentOrHost(parent));
        }
        _unhideGhostForTarget();
      }
    }, "_emulateDragOver"),
    _onTouchMove: /* @__PURE__ */ __name(function _onTouchMove(evt) {
      if (tapEvt) {
        var options = this.options, fallbackTolerance = options.fallbackTolerance, fallbackOffset = options.fallbackOffset, touch = evt.touches ? evt.touches[0] : evt, ghostMatrix = ghostEl && matrix(ghostEl, true), scaleX = ghostEl && ghostMatrix && ghostMatrix.a, scaleY = ghostEl && ghostMatrix && ghostMatrix.d, relativeScrollOffset = PositionGhostAbsolutely && ghostRelativeParent && getRelativeScrollOffset(ghostRelativeParent), dx = (touch.clientX - tapEvt.clientX + fallbackOffset.x) / (scaleX || 1) + (relativeScrollOffset ? relativeScrollOffset[0] - ghostRelativeParentInitialScroll[0] : 0) / (scaleX || 1), dy = (touch.clientY - tapEvt.clientY + fallbackOffset.y) / (scaleY || 1) + (relativeScrollOffset ? relativeScrollOffset[1] - ghostRelativeParentInitialScroll[1] : 0) / (scaleY || 1);
        if (!Sortable.active && !awaitingDragStarted) {
          if (fallbackTolerance && Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) < fallbackTolerance) {
            return;
          }
          this._onDragStart(evt, true);
        }
        if (ghostEl) {
          if (ghostMatrix) {
            ghostMatrix.e += dx - (lastDx || 0);
            ghostMatrix.f += dy - (lastDy || 0);
          } else {
            ghostMatrix = {
              a: 1,
              b: 0,
              c: 0,
              d: 1,
              e: dx,
              f: dy
            };
          }
          var cssMatrix = "matrix(".concat(ghostMatrix.a, ",").concat(ghostMatrix.b, ",").concat(ghostMatrix.c, ",").concat(ghostMatrix.d, ",").concat(ghostMatrix.e, ",").concat(ghostMatrix.f, ")");
          css(ghostEl, "webkitTransform", cssMatrix);
          css(ghostEl, "mozTransform", cssMatrix);
          css(ghostEl, "msTransform", cssMatrix);
          css(ghostEl, "transform", cssMatrix);
          lastDx = dx;
          lastDy = dy;
          touchEvt = touch;
        }
        evt.cancelable && evt.preventDefault();
      }
    }, "_onTouchMove"),
    _appendGhost: /* @__PURE__ */ __name(function _appendGhost() {
      if (!ghostEl) {
        var container = this.options.fallbackOnBody ? document.body : rootEl, rect = getRect(dragEl, true, PositionGhostAbsolutely, true, container), options = this.options;
        if (PositionGhostAbsolutely) {
          ghostRelativeParent = container;
          while (css(ghostRelativeParent, "position") === "static" && css(ghostRelativeParent, "transform") === "none" && ghostRelativeParent !== document) {
            ghostRelativeParent = ghostRelativeParent.parentNode;
          }
          if (ghostRelativeParent !== document.body && ghostRelativeParent !== document.documentElement) {
            if (ghostRelativeParent === document)
              ghostRelativeParent = getWindowScrollingElement();
            rect.top += ghostRelativeParent.scrollTop;
            rect.left += ghostRelativeParent.scrollLeft;
          } else {
            ghostRelativeParent = getWindowScrollingElement();
          }
          ghostRelativeParentInitialScroll = getRelativeScrollOffset(ghostRelativeParent);
        }
        ghostEl = dragEl.cloneNode(true);
        toggleClass2(ghostEl, options.ghostClass, false);
        toggleClass2(ghostEl, options.fallbackClass, true);
        toggleClass2(ghostEl, options.dragClass, true);
        css(ghostEl, "transition", "");
        css(ghostEl, "transform", "");
        css(ghostEl, "box-sizing", "border-box");
        css(ghostEl, "margin", 0);
        css(ghostEl, "top", rect.top);
        css(ghostEl, "left", rect.left);
        css(ghostEl, "width", rect.width);
        css(ghostEl, "height", rect.height);
        css(ghostEl, "opacity", "0.8");
        css(ghostEl, "position", PositionGhostAbsolutely ? "absolute" : "fixed");
        css(ghostEl, "zIndex", "100000");
        css(ghostEl, "pointerEvents", "none");
        Sortable.ghost = ghostEl;
        container.appendChild(ghostEl);
        css(ghostEl, "transform-origin", tapDistanceLeft / parseInt(ghostEl.style.width) * 100 + "% " + tapDistanceTop / parseInt(ghostEl.style.height) * 100 + "%");
      }
    }, "_appendGhost"),
    _onDragStart: /* @__PURE__ */ __name(function _onDragStart(evt, fallback) {
      var _this = this;
      var dataTransfer = evt.dataTransfer;
      var options = _this.options;
      pluginEvent2("dragStart", this, {
        evt
      });
      if (Sortable.eventCanceled) {
        this._onDrop();
        return;
      }
      pluginEvent2("setupClone", this);
      if (!Sortable.eventCanceled) {
        cloneEl = clone(dragEl);
        cloneEl.removeAttribute("id");
        cloneEl.draggable = false;
        cloneEl.style["will-change"] = "";
        this._hideClone();
        toggleClass2(cloneEl, this.options.chosenClass, false);
        Sortable.clone = cloneEl;
      }
      _this.cloneId = _nextTick(function() {
        pluginEvent2("clone", _this);
        if (Sortable.eventCanceled)
          return;
        if (!_this.options.removeCloneOnHide) {
          rootEl.insertBefore(cloneEl, dragEl);
        }
        _this._hideClone();
        _dispatchEvent({
          sortable: _this,
          name: "clone"
        });
      });
      !fallback && toggleClass2(dragEl, options.dragClass, true);
      if (fallback) {
        ignoreNextClick = true;
        _this._loopId = setInterval(_this._emulateDragOver, 50);
      } else {
        off(document, "mouseup", _this._onDrop);
        off(document, "touchend", _this._onDrop);
        off(document, "touchcancel", _this._onDrop);
        if (dataTransfer) {
          dataTransfer.effectAllowed = "move";
          options.setData && options.setData.call(_this, dataTransfer, dragEl);
        }
        on(document, "drop", _this);
        css(dragEl, "transform", "translateZ(0)");
      }
      awaitingDragStarted = true;
      _this._dragStartId = _nextTick(_this._dragStarted.bind(_this, fallback, evt));
      on(document, "selectstart", _this);
      moved = true;
      window.getSelection().removeAllRanges();
      if (Safari) {
        css(document.body, "user-select", "none");
      }
    }, "_onDragStart"),
    // Returns true - if no further action is needed (either inserted or another condition)
    _onDragOver: /* @__PURE__ */ __name(function _onDragOver(evt) {
      var el = this.el, target = evt.target, dragRect, targetRect, revert, options = this.options, group = options.group, activeSortable = Sortable.active, isOwner = activeGroup === group, canSort = options.sort, fromSortable = putSortable || activeSortable, vertical, _this = this, completedFired = false;
      if (_silent)
        return;
      function dragOverEvent(name, extra) {
        pluginEvent2(name, _this, _objectSpread2({
          evt,
          isOwner,
          axis: vertical ? "vertical" : "horizontal",
          revert,
          dragRect,
          targetRect,
          canSort,
          fromSortable,
          target,
          completed,
          onMove: /* @__PURE__ */ __name(function onMove(target2, after2) {
            return _onMove(rootEl, el, dragEl, dragRect, target2, getRect(target2), evt, after2);
          }, "onMove"),
          changed
        }, extra));
      }
      __name(dragOverEvent, "dragOverEvent");
      function capture() {
        dragOverEvent("dragOverAnimationCapture");
        _this.captureAnimationState();
        if (_this !== fromSortable) {
          fromSortable.captureAnimationState();
        }
      }
      __name(capture, "capture");
      function completed(insertion) {
        dragOverEvent("dragOverCompleted", {
          insertion
        });
        if (insertion) {
          if (isOwner) {
            activeSortable._hideClone();
          } else {
            activeSortable._showClone(_this);
          }
          if (_this !== fromSortable) {
            toggleClass2(dragEl, putSortable ? putSortable.options.ghostClass : activeSortable.options.ghostClass, false);
            toggleClass2(dragEl, options.ghostClass, true);
          }
          if (putSortable !== _this && _this !== Sortable.active) {
            putSortable = _this;
          } else if (_this === Sortable.active && putSortable) {
            putSortable = null;
          }
          if (fromSortable === _this) {
            _this._ignoreWhileAnimating = target;
          }
          _this.animateAll(function() {
            dragOverEvent("dragOverAnimationComplete");
            _this._ignoreWhileAnimating = null;
          });
          if (_this !== fromSortable) {
            fromSortable.animateAll();
            fromSortable._ignoreWhileAnimating = null;
          }
        }
        if (target === dragEl && !dragEl.animated || target === el && !target.animated) {
          lastTarget = null;
        }
        if (!options.dragoverBubble && !evt.rootEl && target !== document) {
          dragEl.parentNode[expando]._isOutsideThisEl(evt.target);
          !insertion && nearestEmptyInsertDetectEvent(evt);
        }
        !options.dragoverBubble && evt.stopPropagation && evt.stopPropagation();
        return completedFired = true;
      }
      __name(completed, "completed");
      function changed() {
        newIndex = index(dragEl);
        newDraggableIndex = index(dragEl, options.draggable);
        _dispatchEvent({
          sortable: _this,
          name: "change",
          toEl: el,
          newIndex,
          newDraggableIndex,
          originalEvent: evt
        });
      }
      __name(changed, "changed");
      if (evt.preventDefault !== void 0) {
        evt.cancelable && evt.preventDefault();
      }
      target = closest(target, options.draggable, el, true);
      dragOverEvent("dragOver");
      if (Sortable.eventCanceled)
        return completedFired;
      if (dragEl.contains(evt.target) || target.animated && target.animatingX && target.animatingY || _this._ignoreWhileAnimating === target) {
        return completed(false);
      }
      ignoreNextClick = false;
      if (activeSortable && !options.disabled && (isOwner ? canSort || (revert = parentEl !== rootEl) : putSortable === this || (this.lastPutMode = activeGroup.checkPull(this, activeSortable, dragEl, evt)) && group.checkPut(this, activeSortable, dragEl, evt))) {
        vertical = this._getDirection(evt, target) === "vertical";
        dragRect = getRect(dragEl);
        dragOverEvent("dragOverValid");
        if (Sortable.eventCanceled)
          return completedFired;
        if (revert) {
          parentEl = rootEl;
          capture();
          this._hideClone();
          dragOverEvent("revert");
          if (!Sortable.eventCanceled) {
            if (nextEl) {
              rootEl.insertBefore(dragEl, nextEl);
            } else {
              rootEl.appendChild(dragEl);
            }
          }
          return completed(true);
        }
        var elLastChild = lastChild(el, options.draggable);
        if (!elLastChild || _ghostIsLast(evt, vertical, this) && !elLastChild.animated) {
          if (elLastChild === dragEl) {
            return completed(false);
          }
          if (elLastChild && el === evt.target) {
            target = elLastChild;
          }
          if (target) {
            targetRect = getRect(target);
          }
          if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, !!target) !== false) {
            capture();
            if (elLastChild && elLastChild.nextSibling) {
              el.insertBefore(dragEl, elLastChild.nextSibling);
            } else {
              el.appendChild(dragEl);
            }
            parentEl = el;
            changed();
            return completed(true);
          }
        } else if (elLastChild && _ghostIsFirst(evt, vertical, this)) {
          var firstChild = getChild(el, 0, options, true);
          if (firstChild === dragEl) {
            return completed(false);
          }
          target = firstChild;
          targetRect = getRect(target);
          if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, false) !== false) {
            capture();
            el.insertBefore(dragEl, firstChild);
            parentEl = el;
            changed();
            return completed(true);
          }
        } else if (target.parentNode === el) {
          targetRect = getRect(target);
          var direction = 0, targetBeforeFirstSwap, differentLevel = dragEl.parentNode !== el, differentRowCol = !_dragElInRowColumn(dragEl.animated && dragEl.toRect || dragRect, target.animated && target.toRect || targetRect, vertical), side1 = vertical ? "top" : "left", scrolledPastTop = isScrolledPast(target, "top", "top") || isScrolledPast(dragEl, "top", "top"), scrollBefore = scrolledPastTop ? scrolledPastTop.scrollTop : void 0;
          if (lastTarget !== target) {
            targetBeforeFirstSwap = targetRect[side1];
            pastFirstInvertThresh = false;
            isCircumstantialInvert = !differentRowCol && options.invertSwap || differentLevel;
          }
          direction = _getSwapDirection(evt, target, targetRect, vertical, differentRowCol ? 1 : options.swapThreshold, options.invertedSwapThreshold == null ? options.swapThreshold : options.invertedSwapThreshold, isCircumstantialInvert, lastTarget === target);
          var sibling;
          if (direction !== 0) {
            var dragIndex = index(dragEl);
            do {
              dragIndex -= direction;
              sibling = parentEl.children[dragIndex];
            } while (sibling && (css(sibling, "display") === "none" || sibling === ghostEl));
          }
          if (direction === 0 || sibling === target) {
            return completed(false);
          }
          lastTarget = target;
          lastDirection = direction;
          var nextSibling = target.nextElementSibling, after = false;
          after = direction === 1;
          var moveVector = _onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, after);
          if (moveVector !== false) {
            if (moveVector === 1 || moveVector === -1) {
              after = moveVector === 1;
            }
            _silent = true;
            setTimeout(_unsilent, 30);
            capture();
            if (after && !nextSibling) {
              el.appendChild(dragEl);
            } else {
              target.parentNode.insertBefore(dragEl, after ? nextSibling : target);
            }
            if (scrolledPastTop) {
              scrollBy(scrolledPastTop, 0, scrollBefore - scrolledPastTop.scrollTop);
            }
            parentEl = dragEl.parentNode;
            if (targetBeforeFirstSwap !== void 0 && !isCircumstantialInvert) {
              targetMoveDistance = Math.abs(targetBeforeFirstSwap - getRect(target)[side1]);
            }
            changed();
            return completed(true);
          }
        }
        if (el.contains(dragEl)) {
          return completed(false);
        }
      }
      return false;
    }, "_onDragOver"),
    _ignoreWhileAnimating: null,
    _offMoveEvents: /* @__PURE__ */ __name(function _offMoveEvents() {
      off(document, "mousemove", this._onTouchMove);
      off(document, "touchmove", this._onTouchMove);
      off(document, "pointermove", this._onTouchMove);
      off(document, "dragover", nearestEmptyInsertDetectEvent);
      off(document, "mousemove", nearestEmptyInsertDetectEvent);
      off(document, "touchmove", nearestEmptyInsertDetectEvent);
    }, "_offMoveEvents"),
    _offUpEvents: /* @__PURE__ */ __name(function _offUpEvents() {
      var ownerDocument = this.el.ownerDocument;
      off(ownerDocument, "mouseup", this._onDrop);
      off(ownerDocument, "touchend", this._onDrop);
      off(ownerDocument, "pointerup", this._onDrop);
      off(ownerDocument, "pointercancel", this._onDrop);
      off(ownerDocument, "touchcancel", this._onDrop);
      off(document, "selectstart", this);
    }, "_offUpEvents"),
    _onDrop: /* @__PURE__ */ __name(function _onDrop(evt) {
      var el = this.el, options = this.options;
      newIndex = index(dragEl);
      newDraggableIndex = index(dragEl, options.draggable);
      pluginEvent2("drop", this, {
        evt
      });
      parentEl = dragEl && dragEl.parentNode;
      newIndex = index(dragEl);
      newDraggableIndex = index(dragEl, options.draggable);
      if (Sortable.eventCanceled) {
        this._nulling();
        return;
      }
      awaitingDragStarted = false;
      isCircumstantialInvert = false;
      pastFirstInvertThresh = false;
      clearInterval(this._loopId);
      clearTimeout(this._dragStartTimer);
      _cancelNextTick(this.cloneId);
      _cancelNextTick(this._dragStartId);
      if (this.nativeDraggable) {
        off(document, "drop", this);
        off(el, "dragstart", this._onDragStart);
      }
      this._offMoveEvents();
      this._offUpEvents();
      if (Safari) {
        css(document.body, "user-select", "");
      }
      css(dragEl, "transform", "");
      if (evt) {
        if (moved) {
          evt.cancelable && evt.preventDefault();
          !options.dropBubble && evt.stopPropagation();
        }
        ghostEl && ghostEl.parentNode && ghostEl.parentNode.removeChild(ghostEl);
        if (rootEl === parentEl || putSortable && putSortable.lastPutMode !== "clone") {
          cloneEl && cloneEl.parentNode && cloneEl.parentNode.removeChild(cloneEl);
        }
        if (dragEl) {
          if (this.nativeDraggable) {
            off(dragEl, "dragend", this);
          }
          _disableDraggable(dragEl);
          dragEl.style["will-change"] = "";
          if (moved && !awaitingDragStarted) {
            toggleClass2(dragEl, putSortable ? putSortable.options.ghostClass : this.options.ghostClass, false);
          }
          toggleClass2(dragEl, this.options.chosenClass, false);
          _dispatchEvent({
            sortable: this,
            name: "unchoose",
            toEl: parentEl,
            newIndex: null,
            newDraggableIndex: null,
            originalEvent: evt
          });
          if (rootEl !== parentEl) {
            if (newIndex >= 0) {
              _dispatchEvent({
                rootEl: parentEl,
                name: "add",
                toEl: parentEl,
                fromEl: rootEl,
                originalEvent: evt
              });
              _dispatchEvent({
                sortable: this,
                name: "remove",
                toEl: parentEl,
                originalEvent: evt
              });
              _dispatchEvent({
                rootEl: parentEl,
                name: "sort",
                toEl: parentEl,
                fromEl: rootEl,
                originalEvent: evt
              });
              _dispatchEvent({
                sortable: this,
                name: "sort",
                toEl: parentEl,
                originalEvent: evt
              });
            }
            putSortable && putSortable.save();
          } else {
            if (newIndex !== oldIndex) {
              if (newIndex >= 0) {
                _dispatchEvent({
                  sortable: this,
                  name: "update",
                  toEl: parentEl,
                  originalEvent: evt
                });
                _dispatchEvent({
                  sortable: this,
                  name: "sort",
                  toEl: parentEl,
                  originalEvent: evt
                });
              }
            }
          }
          if (Sortable.active) {
            if (newIndex == null || newIndex === -1) {
              newIndex = oldIndex;
              newDraggableIndex = oldDraggableIndex;
            }
            _dispatchEvent({
              sortable: this,
              name: "end",
              toEl: parentEl,
              originalEvent: evt
            });
            this.save();
          }
        }
      }
      this._nulling();
    }, "_onDrop"),
    _nulling: /* @__PURE__ */ __name(function _nulling() {
      pluginEvent2("nulling", this);
      rootEl = dragEl = parentEl = ghostEl = nextEl = cloneEl = lastDownEl = cloneHidden = tapEvt = touchEvt = moved = newIndex = newDraggableIndex = oldIndex = oldDraggableIndex = lastTarget = lastDirection = putSortable = activeGroup = Sortable.dragged = Sortable.ghost = Sortable.clone = Sortable.active = null;
      savedInputChecked.forEach(function(el) {
        el.checked = true;
      });
      savedInputChecked.length = lastDx = lastDy = 0;
    }, "_nulling"),
    handleEvent: /* @__PURE__ */ __name(function handleEvent(evt) {
      switch (evt.type) {
        case "drop":
        case "dragend":
          this._onDrop(evt);
          break;
        case "dragenter":
        case "dragover":
          if (dragEl) {
            this._onDragOver(evt);
            _globalDragOver(evt);
          }
          break;
        case "selectstart":
          evt.preventDefault();
          break;
      }
    }, "handleEvent"),
    /**
     * Serializes the item into an array of string.
     * @returns {String[]}
     */
    toArray: /* @__PURE__ */ __name(function toArray() {
      var order = [], el, children = this.el.children, i3 = 0, n3 = children.length, options = this.options;
      for (; i3 < n3; i3++) {
        el = children[i3];
        if (closest(el, options.draggable, this.el, false)) {
          order.push(el.getAttribute(options.dataIdAttr) || _generateId(el));
        }
      }
      return order;
    }, "toArray"),
    /**
     * Sorts the elements according to the array.
     * @param  {String[]}  order  order of the items
     */
    sort: /* @__PURE__ */ __name(function sort(order, useAnimation) {
      var items = {}, rootEl2 = this.el;
      this.toArray().forEach(function(id, i3) {
        var el = rootEl2.children[i3];
        if (closest(el, this.options.draggable, rootEl2, false)) {
          items[id] = el;
        }
      }, this);
      useAnimation && this.captureAnimationState();
      order.forEach(function(id) {
        if (items[id]) {
          rootEl2.removeChild(items[id]);
          rootEl2.appendChild(items[id]);
        }
      });
      useAnimation && this.animateAll();
    }, "sort"),
    /**
     * Save the current sorting
     */
    save: /* @__PURE__ */ __name(function save() {
      var store = this.options.store;
      store && store.set && store.set(this);
    }, "save"),
    /**
     * For each element in the set, get the first element that matches the selector by testing the element itself and traversing up through its ancestors in the DOM tree.
     * @param   {HTMLElement}  el
     * @param   {String}       [selector]  default: `options.draggable`
     * @returns {HTMLElement|null}
     */
    closest: /* @__PURE__ */ __name(function closest$1(el, selector) {
      return closest(el, selector || this.options.draggable, this.el, false);
    }, "closest$1"),
    /**
     * Set/get option
     * @param   {string} name
     * @param   {*}      [value]
     * @returns {*}
     */
    option: /* @__PURE__ */ __name(function option(name, value) {
      var options = this.options;
      if (value === void 0) {
        return options[name];
      } else {
        var modifiedValue = PluginManager.modifyOption(this, name, value);
        if (typeof modifiedValue !== "undefined") {
          options[name] = modifiedValue;
        } else {
          options[name] = value;
        }
        if (name === "group") {
          _prepareGroup(options);
        }
      }
    }, "option"),
    /**
     * Destroy
     */
    destroy: /* @__PURE__ */ __name(function destroy() {
      pluginEvent2("destroy", this);
      var el = this.el;
      el[expando] = null;
      off(el, "mousedown", this._onTapStart);
      off(el, "touchstart", this._onTapStart);
      off(el, "pointerdown", this._onTapStart);
      if (this.nativeDraggable) {
        off(el, "dragover", this);
        off(el, "dragenter", this);
      }
      Array.prototype.forEach.call(el.querySelectorAll("[draggable]"), function(el2) {
        el2.removeAttribute("draggable");
      });
      this._onDrop();
      this._disableDelayedDragEvents();
      sortables.splice(sortables.indexOf(this.el), 1);
      this.el = el = null;
    }, "destroy"),
    _hideClone: /* @__PURE__ */ __name(function _hideClone() {
      if (!cloneHidden) {
        pluginEvent2("hideClone", this);
        if (Sortable.eventCanceled)
          return;
        css(cloneEl, "display", "none");
        if (this.options.removeCloneOnHide && cloneEl.parentNode) {
          cloneEl.parentNode.removeChild(cloneEl);
        }
        cloneHidden = true;
      }
    }, "_hideClone"),
    _showClone: /* @__PURE__ */ __name(function _showClone(putSortable2) {
      if (putSortable2.lastPutMode !== "clone") {
        this._hideClone();
        return;
      }
      if (cloneHidden) {
        pluginEvent2("showClone", this);
        if (Sortable.eventCanceled)
          return;
        if (dragEl.parentNode == rootEl && !this.options.group.revertClone) {
          rootEl.insertBefore(cloneEl, dragEl);
        } else if (nextEl) {
          rootEl.insertBefore(cloneEl, nextEl);
        } else {
          rootEl.appendChild(cloneEl);
        }
        if (this.options.group.revertClone) {
          this.animate(dragEl, cloneEl);
        }
        css(cloneEl, "display", "");
        cloneHidden = false;
      }
    }, "_showClone")
  };
  function _globalDragOver(evt) {
    if (evt.dataTransfer) {
      evt.dataTransfer.dropEffect = "move";
    }
    evt.cancelable && evt.preventDefault();
  }
  __name(_globalDragOver, "_globalDragOver");
  function _onMove(fromEl, toEl, dragEl2, dragRect, targetEl, targetRect, originalEvent, willInsertAfter) {
    var evt, sortable = fromEl[expando], onMoveFn = sortable.options.onMove, retVal;
    if (window.CustomEvent && !IE11OrLess && !Edge) {
      evt = new CustomEvent("move", {
        bubbles: true,
        cancelable: true
      });
    } else {
      evt = document.createEvent("Event");
      evt.initEvent("move", true, true);
    }
    evt.to = toEl;
    evt.from = fromEl;
    evt.dragged = dragEl2;
    evt.draggedRect = dragRect;
    evt.related = targetEl || toEl;
    evt.relatedRect = targetRect || getRect(toEl);
    evt.willInsertAfter = willInsertAfter;
    evt.originalEvent = originalEvent;
    fromEl.dispatchEvent(evt);
    if (onMoveFn) {
      retVal = onMoveFn.call(sortable, evt, originalEvent);
    }
    return retVal;
  }
  __name(_onMove, "_onMove");
  function _disableDraggable(el) {
    el.draggable = false;
  }
  __name(_disableDraggable, "_disableDraggable");
  function _unsilent() {
    _silent = false;
  }
  __name(_unsilent, "_unsilent");
  function _ghostIsFirst(evt, vertical, sortable) {
    var firstElRect = getRect(getChild(sortable.el, 0, sortable.options, true));
    var childContainingRect = getChildContainingRectFromElement(sortable.el, sortable.options, ghostEl);
    var spacer = 10;
    return vertical ? evt.clientX < childContainingRect.left - spacer || evt.clientY < firstElRect.top && evt.clientX < firstElRect.right : evt.clientY < childContainingRect.top - spacer || evt.clientY < firstElRect.bottom && evt.clientX < firstElRect.left;
  }
  __name(_ghostIsFirst, "_ghostIsFirst");
  function _ghostIsLast(evt, vertical, sortable) {
    var lastElRect = getRect(lastChild(sortable.el, sortable.options.draggable));
    var childContainingRect = getChildContainingRectFromElement(sortable.el, sortable.options, ghostEl);
    var spacer = 10;
    return vertical ? evt.clientX > childContainingRect.right + spacer || evt.clientY > lastElRect.bottom && evt.clientX > lastElRect.left : evt.clientY > childContainingRect.bottom + spacer || evt.clientX > lastElRect.right && evt.clientY > lastElRect.top;
  }
  __name(_ghostIsLast, "_ghostIsLast");
  function _getSwapDirection(evt, target, targetRect, vertical, swapThreshold, invertedSwapThreshold, invertSwap, isLastTarget) {
    var mouseOnAxis = vertical ? evt.clientY : evt.clientX, targetLength = vertical ? targetRect.height : targetRect.width, targetS1 = vertical ? targetRect.top : targetRect.left, targetS2 = vertical ? targetRect.bottom : targetRect.right, invert = false;
    if (!invertSwap) {
      if (isLastTarget && targetMoveDistance < targetLength * swapThreshold) {
        if (!pastFirstInvertThresh && (lastDirection === 1 ? mouseOnAxis > targetS1 + targetLength * invertedSwapThreshold / 2 : mouseOnAxis < targetS2 - targetLength * invertedSwapThreshold / 2)) {
          pastFirstInvertThresh = true;
        }
        if (!pastFirstInvertThresh) {
          if (lastDirection === 1 ? mouseOnAxis < targetS1 + targetMoveDistance : mouseOnAxis > targetS2 - targetMoveDistance) {
            return -lastDirection;
          }
        } else {
          invert = true;
        }
      } else {
        if (mouseOnAxis > targetS1 + targetLength * (1 - swapThreshold) / 2 && mouseOnAxis < targetS2 - targetLength * (1 - swapThreshold) / 2) {
          return _getInsertDirection(target);
        }
      }
    }
    invert = invert || invertSwap;
    if (invert) {
      if (mouseOnAxis < targetS1 + targetLength * invertedSwapThreshold / 2 || mouseOnAxis > targetS2 - targetLength * invertedSwapThreshold / 2) {
        return mouseOnAxis > targetS1 + targetLength / 2 ? 1 : -1;
      }
    }
    return 0;
  }
  __name(_getSwapDirection, "_getSwapDirection");
  function _getInsertDirection(target) {
    if (index(dragEl) < index(target)) {
      return 1;
    } else {
      return -1;
    }
  }
  __name(_getInsertDirection, "_getInsertDirection");
  function _generateId(el) {
    var str = el.tagName + el.className + el.src + el.href + el.textContent, i3 = str.length, sum = 0;
    while (i3--) {
      sum += str.charCodeAt(i3);
    }
    return sum.toString(36);
  }
  __name(_generateId, "_generateId");
  function _saveInputCheckedState(root2) {
    savedInputChecked.length = 0;
    var inputs = root2.getElementsByTagName("input");
    var idx = inputs.length;
    while (idx--) {
      var el = inputs[idx];
      el.checked && savedInputChecked.push(el);
    }
  }
  __name(_saveInputCheckedState, "_saveInputCheckedState");
  function _nextTick(fn) {
    return setTimeout(fn, 0);
  }
  __name(_nextTick, "_nextTick");
  function _cancelNextTick(id) {
    return clearTimeout(id);
  }
  __name(_cancelNextTick, "_cancelNextTick");
  if (documentExists) {
    on(document, "touchmove", function(evt) {
      if ((Sortable.active || awaitingDragStarted) && evt.cancelable) {
        evt.preventDefault();
      }
    });
  }
  Sortable.utils = {
    on,
    off,
    css,
    find,
    is: /* @__PURE__ */ __name(function is(el, selector) {
      return !!closest(el, selector, el, false);
    }, "is"),
    extend: extend2,
    throttle,
    closest,
    toggleClass: toggleClass2,
    clone,
    index,
    nextTick: _nextTick,
    cancelNextTick: _cancelNextTick,
    detectDirection: _detectDirection,
    getChild,
    expando
  };
  Sortable.get = function(element) {
    return element[expando];
  };
  Sortable.mount = function() {
    for (var _len = arguments.length, plugins2 = new Array(_len), _key = 0; _key < _len; _key++) {
      plugins2[_key] = arguments[_key];
    }
    if (plugins2[0].constructor === Array)
      plugins2 = plugins2[0];
    plugins2.forEach(function(plugin) {
      if (!plugin.prototype || !plugin.prototype.constructor) {
        throw "Sortable: Mounted plugin must be a constructor function, not ".concat({}.toString.call(plugin));
      }
      if (plugin.utils)
        Sortable.utils = _objectSpread2(_objectSpread2({}, Sortable.utils), plugin.utils);
      PluginManager.mount(plugin);
    });
  };
  Sortable.create = function(el, options) {
    return new Sortable(el, options);
  };
  Sortable.version = version;
  var autoScrolls = [];
  var scrollEl;
  var scrollRootEl;
  var scrolling = false;
  var touchEvt$1;
  function clearAutoScrolls() {
    autoScrolls.forEach(function(autoScroll2) {
      clearInterval(autoScroll2.pid);
    });
    autoScrolls = [];
  }
  __name(clearAutoScrolls, "clearAutoScrolls");
  var autoScroll = throttle(function(evt, options, rootEl2, isFallback) {
    if (!options.scroll)
      return;
    var x3 = (evt.touches ? evt.touches[0] : evt).clientX, y3 = (evt.touches ? evt.touches[0] : evt).clientY, sens = options.scrollSensitivity, speed = options.scrollSpeed, winScroller = getWindowScrollingElement();
    var scrollThisInstance = false, scrollCustomFn;
    if (scrollRootEl !== rootEl2) {
      scrollRootEl = rootEl2;
      clearAutoScrolls();
      scrollEl = options.scroll;
      scrollCustomFn = options.scrollFn;
      if (scrollEl === true) {
        scrollEl = getParentAutoScrollElement(rootEl2, true);
      }
    }
    var layersOut = 0;
    var currentParent = scrollEl;
    do {
      var el = currentParent, rect = getRect(el), top = rect.top, bottom = rect.bottom, left = rect.left, right = rect.right, width = rect.width, height = rect.height, canScrollX = void 0, canScrollY = void 0, scrollWidth = el.scrollWidth, scrollHeight = el.scrollHeight, elCSS = css(el), scrollPosX = el.scrollLeft, scrollPosY = el.scrollTop;
      if (el === winScroller) {
        canScrollX = width < scrollWidth && (elCSS.overflowX === "auto" || elCSS.overflowX === "scroll" || elCSS.overflowX === "visible");
        canScrollY = height < scrollHeight && (elCSS.overflowY === "auto" || elCSS.overflowY === "scroll" || elCSS.overflowY === "visible");
      } else {
        canScrollX = width < scrollWidth && (elCSS.overflowX === "auto" || elCSS.overflowX === "scroll");
        canScrollY = height < scrollHeight && (elCSS.overflowY === "auto" || elCSS.overflowY === "scroll");
      }
      var vx = canScrollX && (Math.abs(right - x3) <= sens && scrollPosX + width < scrollWidth) - (Math.abs(left - x3) <= sens && !!scrollPosX);
      var vy = canScrollY && (Math.abs(bottom - y3) <= sens && scrollPosY + height < scrollHeight) - (Math.abs(top - y3) <= sens && !!scrollPosY);
      if (!autoScrolls[layersOut]) {
        for (var i3 = 0; i3 <= layersOut; i3++) {
          if (!autoScrolls[i3]) {
            autoScrolls[i3] = {};
          }
        }
      }
      if (autoScrolls[layersOut].vx != vx || autoScrolls[layersOut].vy != vy || autoScrolls[layersOut].el !== el) {
        autoScrolls[layersOut].el = el;
        autoScrolls[layersOut].vx = vx;
        autoScrolls[layersOut].vy = vy;
        clearInterval(autoScrolls[layersOut].pid);
        if (vx != 0 || vy != 0) {
          scrollThisInstance = true;
          autoScrolls[layersOut].pid = setInterval(function() {
            if (isFallback && this.layer === 0) {
              Sortable.active._onTouchMove(touchEvt$1);
            }
            var scrollOffsetY = autoScrolls[this.layer].vy ? autoScrolls[this.layer].vy * speed : 0;
            var scrollOffsetX = autoScrolls[this.layer].vx ? autoScrolls[this.layer].vx * speed : 0;
            if (typeof scrollCustomFn === "function") {
              if (scrollCustomFn.call(Sortable.dragged.parentNode[expando], scrollOffsetX, scrollOffsetY, evt, touchEvt$1, autoScrolls[this.layer].el) !== "continue") {
                return;
              }
            }
            scrollBy(autoScrolls[this.layer].el, scrollOffsetX, scrollOffsetY);
          }.bind({
            layer: layersOut
          }), 24);
        }
      }
      layersOut++;
    } while (options.bubbleScroll && currentParent !== winScroller && (currentParent = getParentAutoScrollElement(currentParent, false)));
    scrolling = scrollThisInstance;
  }, 30);
  var drop = /* @__PURE__ */ __name(function drop2(_ref) {
    var originalEvent = _ref.originalEvent, putSortable2 = _ref.putSortable, dragEl2 = _ref.dragEl, activeSortable = _ref.activeSortable, dispatchSortableEvent = _ref.dispatchSortableEvent, hideGhostForTarget = _ref.hideGhostForTarget, unhideGhostForTarget = _ref.unhideGhostForTarget;
    if (!originalEvent)
      return;
    var toSortable = putSortable2 || activeSortable;
    hideGhostForTarget();
    var touch = originalEvent.changedTouches && originalEvent.changedTouches.length ? originalEvent.changedTouches[0] : originalEvent;
    var target = document.elementFromPoint(touch.clientX, touch.clientY);
    unhideGhostForTarget();
    if (toSortable && !toSortable.el.contains(target)) {
      dispatchSortableEvent("spill");
      this.onSpill({
        dragEl: dragEl2,
        putSortable: putSortable2
      });
    }
  }, "drop");
  function Revert() {
  }
  __name(Revert, "Revert");
  Revert.prototype = {
    startIndex: null,
    dragStart: /* @__PURE__ */ __name(function dragStart(_ref2) {
      var oldDraggableIndex2 = _ref2.oldDraggableIndex;
      this.startIndex = oldDraggableIndex2;
    }, "dragStart"),
    onSpill: /* @__PURE__ */ __name(function onSpill(_ref3) {
      var dragEl2 = _ref3.dragEl, putSortable2 = _ref3.putSortable;
      this.sortable.captureAnimationState();
      if (putSortable2) {
        putSortable2.captureAnimationState();
      }
      var nextSibling = getChild(this.sortable.el, this.startIndex, this.options);
      if (nextSibling) {
        this.sortable.el.insertBefore(dragEl2, nextSibling);
      } else {
        this.sortable.el.appendChild(dragEl2);
      }
      this.sortable.animateAll();
      if (putSortable2) {
        putSortable2.animateAll();
      }
    }, "onSpill"),
    drop
  };
  _extends(Revert, {
    pluginName: "revertOnSpill"
  });
  function Remove() {
  }
  __name(Remove, "Remove");
  Remove.prototype = {
    onSpill: /* @__PURE__ */ __name(function onSpill2(_ref4) {
      var dragEl2 = _ref4.dragEl, putSortable2 = _ref4.putSortable;
      var parentSortable = putSortable2 || this.sortable;
      parentSortable.captureAnimationState();
      dragEl2.parentNode && dragEl2.parentNode.removeChild(dragEl2);
      parentSortable.animateAll();
    }, "onSpill"),
    drop
  };
  _extends(Remove, {
    pluginName: "removeOnSpill"
  });
  var sortable_core_esm_default = Sortable;

  // ../highway/app/javascript/admin/draggable_controller.js
  var DraggableController = class extends Controller2 {
    static {
      __name(this, "DraggableController");
    }
    connect() {
      this.sortable = sortable_core_esm_default.create(this, {
        animation: 150,
        draggable: ".js-draggable-item",
        handle: ".js-handle",
        onEnd: this.onReorder.bind(this)
      });
    }
    onReorder(e3) {
      document.querySelectorAll(".js-draggable-item").forEach(function(el, i3) {
        const input = el.querySelector(".js-position");
        input.value = i3 + 1;
      });
    }
  };

  // app/javascript/controllers/geo_search_controller.js
  var import_debounce = __toESM(require_debounce());
  var GeoSearchController = class extends Controller {
    static {
      __name(this, "GeoSearchController");
    }
    static targets = ["lat", "lng", "visibleField", "results"];
    static values = { model: String };
    connect() {
      this.debouncedFetchData = (0, import_debounce.default)(this.fetchData.bind(this), 500);
    }
    change(e3) {
      this.debouncedFetchData(e3.target.value);
    }
    fetchData(text, update) {
      fetch("https://nominatim.openstreetmap.org/search?" + new URLSearchParams({ q: text, format: "jsonv2" })).then((response) => response.json()).then((response) => this.display(response));
    }
    buildMarkup(response) {
      return response.map(function(location2) {
        return `
        <div>
          <span
            class="block p-2 cursor-pointer hover:bg-neutral-100"
            data-info='${JSON.stringify(location2)}'
            data-action="click->geo-search#select"
          >${location2.display_name}</span>
        </div>`;
      }).join("");
    }
    display(response) {
      this.resultsTarget.innerHTML = this.buildMarkup(response);
      this.bindNewActions(this.resultsTarget);
    }
    bindNewActions(el) {
      const actionElements = Array.from(el.querySelectorAll("[data-action]"));
      const actions = actionElements.flatMap(this.parseAction.bind(this));
      actions.forEach(this.bindAction.bind(this));
    }
    select(e3) {
      const item = JSON.parse(e3.currentTarget.dataset["info"]);
      this.visibleFieldTarget.value = item.name || item.display_name;
      this.latTarget.value = item.lat;
      this.lngTarget.value = item.lon;
      this.resultsTarget.innerHTML = "";
    }
  };

  // ../highway/app/javascript/admin/global_search_controller.js
  var import_debounce2 = __toESM(require_debounce2());
  var GlobalSearchController = class extends Controller2 {
    static {
      __name(this, "GlobalSearchController");
    }
    connect() {
      this.selectedResult = -1;
      this.debouncedSubmit = (0, import_debounce2.default)(this.submit, 500);
      this.form = this.querySelector("form");
    }
    resultsTarget() {
      return this.querySelector("#global-results");
    }
    items() {
      return this.resultsTarget().querySelectorAll("a");
    }
    closeList() {
      this.selectedResult = -1;
      this.resultsTarget().innerHTML = "";
    }
    prevItem() {
      this.selectedResult = Math.max(this.selectedResult - 1, 0);
    }
    nextItem() {
      this.selectedResult = Math.min(this.selectedResult + 1, this.items().length - 1);
    }
    markSelectedResult() {
      if (this.resultsTarget().innerHTML == "") {
        return;
      }
      this.items().forEach(this.markAsSelected.bind(this));
    }
    markAsSelected(item, index2) {
      if (index2 == this.selectedResult) {
        item.classList.add("bg-neutral-100");
        item.scrollIntoView({ block: "end" });
      } else {
        item.classList.remove("bg-neutral-100");
      }
    }
    submit() {
      this.form.requestSubmit();
    }
    selectedLink() {
      return this.items()[this.selectedResult].href;
    }
    keydown(e3) {
      switch (e3.keyCode) {
        case 13:
          location.href = this.selectedLink();
          break;
        case 38:
          e3.preventDefault();
          this.prevItem();
          this.markSelectedResult();
          break;
        case 40:
          e3.preventDefault();
          this.nextItem();
          this.markSelectedResult();
          break;
        case 27:
          e3.preventDefault();
          this.closeList();
          break;
        default:
          if (String.fromCharCode(e3.keyCode).match(/(\w|\s)/g)) {
            this.debouncedSubmit();
          }
      }
    }
  };

  // app/javascript/controllers/hamburger_menu_controller.js
  var HamburgerMenuController = class extends Controller {
    static {
      __name(this, "HamburgerMenuController");
    }
    connect() {
      this.classList.add("cursor-pointer");
    }
    toggle(e3) {
      document.getElementById("left-menu").classList.toggle("-translate-x-full");
      document.getElementById("main").classList.toggle("blur-sm");
    }
  };

  // app/javascript/controllers/image_preview_controller.js
  var ImagePreviewController = class extends Controller {
    static {
      __name(this, "ImagePreviewController");
    }
    static targets = ["container"];
    preview(e3) {
      const file = e3.currentTarget.files[0];
      if (!file.type.startsWith("image/")) {
        return;
      }
      const img = this.imageElement(file);
      this.containerTarget.innerHTML = "";
      this.containerTarget.appendChild(img);
      this.generatePreview(file, img);
    }
    generatePreview(file, img) {
      const reader = new FileReader();
      reader.onload = /* @__PURE__ */ function(aImg) {
        return function(e3) {
          aImg.src = e3.target.result;
        };
      }(img);
      reader.readAsDataURL(file);
    }
    imageElement(file) {
      const img = document.createElement("img");
      img.file = file;
      return img;
    }
  };

  // ../highway/node_modules/flatpickr/dist/esm/types/options.js
  var HOOKS2 = [
    "onChange",
    "onClose",
    "onDayCreate",
    "onDestroy",
    "onKeyDown",
    "onMonthChange",
    "onOpen",
    "onParseConfig",
    "onReady",
    "onValueUpdate",
    "onYearChange",
    "onPreCalendarPosition"
  ];
  var defaults3 = {
    _disable: [],
    allowInput: false,
    allowInvalidPreload: false,
    altFormat: "F j, Y",
    altInput: false,
    altInputClass: "form-control input",
    animate: typeof window === "object" && window.navigator.userAgent.indexOf("MSIE") === -1,
    ariaDateFormat: "F j, Y",
    autoFillDefaultTime: true,
    clickOpens: true,
    closeOnSelect: true,
    conjunction: ", ",
    dateFormat: "Y-m-d",
    defaultHour: 12,
    defaultMinute: 0,
    defaultSeconds: 0,
    disable: [],
    disableMobile: false,
    enableSeconds: false,
    enableTime: false,
    errorHandler: function(err) {
      return typeof console !== "undefined" && console.warn(err);
    },
    getWeek: function(givenDate) {
      var date = new Date(givenDate.getTime());
      date.setHours(0, 0, 0, 0);
      date.setDate(date.getDate() + 3 - (date.getDay() + 6) % 7);
      var week1 = new Date(date.getFullYear(), 0, 4);
      return 1 + Math.round(((date.getTime() - week1.getTime()) / 864e5 - 3 + (week1.getDay() + 6) % 7) / 7);
    },
    hourIncrement: 1,
    ignoredFocusElements: [],
    inline: false,
    locale: "default",
    minuteIncrement: 5,
    mode: "single",
    monthSelectorType: "dropdown",
    nextArrow: "<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 17 17'><g></g><path d='M13.207 8.472l-7.854 7.854-0.707-0.707 7.146-7.146-7.146-7.148 0.707-0.707 7.854 7.854z' /></svg>",
    noCalendar: false,
    now: /* @__PURE__ */ new Date(),
    onChange: [],
    onClose: [],
    onDayCreate: [],
    onDestroy: [],
    onKeyDown: [],
    onMonthChange: [],
    onOpen: [],
    onParseConfig: [],
    onReady: [],
    onValueUpdate: [],
    onYearChange: [],
    onPreCalendarPosition: [],
    plugins: [],
    position: "auto",
    positionElement: void 0,
    prevArrow: "<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 17 17'><g></g><path d='M5.207 8.471l7.146 7.147-0.707 0.707-7.853-7.854 7.854-7.853 0.707 0.707-7.147 7.146z' /></svg>",
    shorthandCurrentMonth: false,
    showMonths: 1,
    static: false,
    time_24hr: false,
    weekNumbers: false,
    wrap: false
  };

  // ../highway/node_modules/flatpickr/dist/esm/l10n/default.js
  var english2 = {
    weekdays: {
      shorthand: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
      longhand: [
        "Sunday",
        "Monday",
        "Tuesday",
        "Wednesday",
        "Thursday",
        "Friday",
        "Saturday"
      ]
    },
    months: {
      shorthand: [
        "Jan",
        "Feb",
        "Mar",
        "Apr",
        "May",
        "Jun",
        "Jul",
        "Aug",
        "Sep",
        "Oct",
        "Nov",
        "Dec"
      ],
      longhand: [
        "January",
        "February",
        "March",
        "April",
        "May",
        "June",
        "July",
        "August",
        "September",
        "October",
        "November",
        "December"
      ]
    },
    daysInMonth: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
    firstDayOfWeek: 0,
    ordinal: function(nth) {
      var s3 = nth % 100;
      if (s3 > 3 && s3 < 21)
        return "th";
      switch (s3 % 10) {
        case 1:
          return "st";
        case 2:
          return "nd";
        case 3:
          return "rd";
        default:
          return "th";
      }
    },
    rangeSeparator: " to ",
    weekAbbreviation: "Wk",
    scrollTitle: "Scroll to increment",
    toggleTitle: "Click to toggle",
    amPM: ["AM", "PM"],
    yearAriaLabel: "Year",
    monthAriaLabel: "Month",
    hourAriaLabel: "Hour",
    minuteAriaLabel: "Minute",
    time_24hr: false
  };
  var default_default2 = english2;

  // ../highway/node_modules/flatpickr/dist/esm/utils/index.js
  var pad2 = /* @__PURE__ */ __name(function(number, length) {
    if (length === void 0) {
      length = 2;
    }
    return ("000" + number).slice(length * -1);
  }, "pad");
  var int2 = /* @__PURE__ */ __name(function(bool) {
    return bool === true ? 1 : 0;
  }, "int");
  function debounce5(fn, wait) {
    var t3;
    return function() {
      var _this = this;
      var args = arguments;
      clearTimeout(t3);
      t3 = setTimeout(function() {
        return fn.apply(_this, args);
      }, wait);
    };
  }
  __name(debounce5, "debounce");
  var arrayify2 = /* @__PURE__ */ __name(function(obj) {
    return obj instanceof Array ? obj : [obj];
  }, "arrayify");

  // ../highway/node_modules/flatpickr/dist/esm/utils/dom.js
  function toggleClass3(elem, className, bool) {
    if (bool === true)
      return elem.classList.add(className);
    elem.classList.remove(className);
  }
  __name(toggleClass3, "toggleClass");
  function createElement2(tag, className, content) {
    var e3 = window.document.createElement(tag);
    className = className || "";
    content = content || "";
    e3.className = className;
    if (content !== void 0)
      e3.textContent = content;
    return e3;
  }
  __name(createElement2, "createElement");
  function clearNode2(node) {
    while (node.firstChild)
      node.removeChild(node.firstChild);
  }
  __name(clearNode2, "clearNode");
  function findParent2(node, condition) {
    if (condition(node))
      return node;
    else if (node.parentNode)
      return findParent2(node.parentNode, condition);
    return void 0;
  }
  __name(findParent2, "findParent");
  function createNumberInput2(inputClassName, opts) {
    var wrapper = createElement2("div", "numInputWrapper"), numInput = createElement2("input", "numInput " + inputClassName), arrowUp = createElement2("span", "arrowUp"), arrowDown = createElement2("span", "arrowDown");
    if (navigator.userAgent.indexOf("MSIE 9.0") === -1) {
      numInput.type = "number";
    } else {
      numInput.type = "text";
      numInput.pattern = "\\d*";
    }
    if (opts !== void 0)
      for (var key in opts)
        numInput.setAttribute(key, opts[key]);
    wrapper.appendChild(numInput);
    wrapper.appendChild(arrowUp);
    wrapper.appendChild(arrowDown);
    return wrapper;
  }
  __name(createNumberInput2, "createNumberInput");
  function getEventTarget2(event) {
    try {
      if (typeof event.composedPath === "function") {
        var path = event.composedPath();
        return path[0];
      }
      return event.target;
    } catch (error) {
      return event.target;
    }
  }
  __name(getEventTarget2, "getEventTarget");

  // ../highway/node_modules/flatpickr/dist/esm/utils/formatting.js
  var doNothing2 = /* @__PURE__ */ __name(function() {
    return void 0;
  }, "doNothing");
  var monthToStr2 = /* @__PURE__ */ __name(function(monthNumber, shorthand, locale) {
    return locale.months[shorthand ? "shorthand" : "longhand"][monthNumber];
  }, "monthToStr");
  var revFormat2 = {
    D: doNothing2,
    F: function(dateObj, monthName, locale) {
      dateObj.setMonth(locale.months.longhand.indexOf(monthName));
    },
    G: function(dateObj, hour) {
      dateObj.setHours((dateObj.getHours() >= 12 ? 12 : 0) + parseFloat(hour));
    },
    H: function(dateObj, hour) {
      dateObj.setHours(parseFloat(hour));
    },
    J: function(dateObj, day) {
      dateObj.setDate(parseFloat(day));
    },
    K: function(dateObj, amPM, locale) {
      dateObj.setHours(dateObj.getHours() % 12 + 12 * int2(new RegExp(locale.amPM[1], "i").test(amPM)));
    },
    M: function(dateObj, shortMonth, locale) {
      dateObj.setMonth(locale.months.shorthand.indexOf(shortMonth));
    },
    S: function(dateObj, seconds) {
      dateObj.setSeconds(parseFloat(seconds));
    },
    U: function(_2, unixSeconds) {
      return new Date(parseFloat(unixSeconds) * 1e3);
    },
    W: function(dateObj, weekNum, locale) {
      var weekNumber = parseInt(weekNum);
      var date = new Date(dateObj.getFullYear(), 0, 2 + (weekNumber - 1) * 7, 0, 0, 0, 0);
      date.setDate(date.getDate() - date.getDay() + locale.firstDayOfWeek);
      return date;
    },
    Y: function(dateObj, year) {
      dateObj.setFullYear(parseFloat(year));
    },
    Z: function(_2, ISODate) {
      return new Date(ISODate);
    },
    d: function(dateObj, day) {
      dateObj.setDate(parseFloat(day));
    },
    h: function(dateObj, hour) {
      dateObj.setHours((dateObj.getHours() >= 12 ? 12 : 0) + parseFloat(hour));
    },
    i: function(dateObj, minutes) {
      dateObj.setMinutes(parseFloat(minutes));
    },
    j: function(dateObj, day) {
      dateObj.setDate(parseFloat(day));
    },
    l: doNothing2,
    m: function(dateObj, month) {
      dateObj.setMonth(parseFloat(month) - 1);
    },
    n: function(dateObj, month) {
      dateObj.setMonth(parseFloat(month) - 1);
    },
    s: function(dateObj, seconds) {
      dateObj.setSeconds(parseFloat(seconds));
    },
    u: function(_2, unixMillSeconds) {
      return new Date(parseFloat(unixMillSeconds));
    },
    w: doNothing2,
    y: function(dateObj, year) {
      dateObj.setFullYear(2e3 + parseFloat(year));
    }
  };
  var tokenRegex2 = {
    D: "",
    F: "",
    G: "(\\d\\d|\\d)",
    H: "(\\d\\d|\\d)",
    J: "(\\d\\d|\\d)\\w+",
    K: "",
    M: "",
    S: "(\\d\\d|\\d)",
    U: "(.+)",
    W: "(\\d\\d|\\d)",
    Y: "(\\d{4})",
    Z: "(.+)",
    d: "(\\d\\d|\\d)",
    h: "(\\d\\d|\\d)",
    i: "(\\d\\d|\\d)",
    j: "(\\d\\d|\\d)",
    l: "",
    m: "(\\d\\d|\\d)",
    n: "(\\d\\d|\\d)",
    s: "(\\d\\d|\\d)",
    u: "(.+)",
    w: "(\\d\\d|\\d)",
    y: "(\\d{2})"
  };
  var formats2 = {
    Z: function(date) {
      return date.toISOString();
    },
    D: function(date, locale, options) {
      return locale.weekdays.shorthand[formats2.w(date, locale, options)];
    },
    F: function(date, locale, options) {
      return monthToStr2(formats2.n(date, locale, options) - 1, false, locale);
    },
    G: function(date, locale, options) {
      return pad2(formats2.h(date, locale, options));
    },
    H: function(date) {
      return pad2(date.getHours());
    },
    J: function(date, locale) {
      return locale.ordinal !== void 0 ? date.getDate() + locale.ordinal(date.getDate()) : date.getDate();
    },
    K: function(date, locale) {
      return locale.amPM[int2(date.getHours() > 11)];
    },
    M: function(date, locale) {
      return monthToStr2(date.getMonth(), true, locale);
    },
    S: function(date) {
      return pad2(date.getSeconds());
    },
    U: function(date) {
      return date.getTime() / 1e3;
    },
    W: function(date, _2, options) {
      return options.getWeek(date);
    },
    Y: function(date) {
      return pad2(date.getFullYear(), 4);
    },
    d: function(date) {
      return pad2(date.getDate());
    },
    h: function(date) {
      return date.getHours() % 12 ? date.getHours() % 12 : 12;
    },
    i: function(date) {
      return pad2(date.getMinutes());
    },
    j: function(date) {
      return date.getDate();
    },
    l: function(date, locale) {
      return locale.weekdays.longhand[date.getDay()];
    },
    m: function(date) {
      return pad2(date.getMonth() + 1);
    },
    n: function(date) {
      return date.getMonth() + 1;
    },
    s: function(date) {
      return date.getSeconds();
    },
    u: function(date) {
      return date.getTime();
    },
    w: function(date) {
      return date.getDay();
    },
    y: function(date) {
      return String(date.getFullYear()).substring(2);
    }
  };

  // ../highway/node_modules/flatpickr/dist/esm/utils/dates.js
  var createDateFormatter2 = /* @__PURE__ */ __name(function(_a) {
    var _b = _a.config, config4 = _b === void 0 ? defaults3 : _b, _c = _a.l10n, l10n = _c === void 0 ? english2 : _c, _d = _a.isMobile, isMobile = _d === void 0 ? false : _d;
    return function(dateObj, frmt, overrideLocale) {
      var locale = overrideLocale || l10n;
      if (config4.formatDate !== void 0 && !isMobile) {
        return config4.formatDate(dateObj, frmt, locale);
      }
      return frmt.split("").map(function(c3, i3, arr) {
        return formats2[c3] && arr[i3 - 1] !== "\\" ? formats2[c3](dateObj, locale, config4) : c3 !== "\\" ? c3 : "";
      }).join("");
    };
  }, "createDateFormatter");
  var createDateParser2 = /* @__PURE__ */ __name(function(_a) {
    var _b = _a.config, config4 = _b === void 0 ? defaults3 : _b, _c = _a.l10n, l10n = _c === void 0 ? english2 : _c;
    return function(date, givenFormat, timeless, customLocale) {
      if (date !== 0 && !date)
        return void 0;
      var locale = customLocale || l10n;
      var parsedDate;
      var dateOrig = date;
      if (date instanceof Date)
        parsedDate = new Date(date.getTime());
      else if (typeof date !== "string" && date.toFixed !== void 0)
        parsedDate = new Date(date);
      else if (typeof date === "string") {
        var format = givenFormat || (config4 || defaults3).dateFormat;
        var datestr = String(date).trim();
        if (datestr === "today") {
          parsedDate = /* @__PURE__ */ new Date();
          timeless = true;
        } else if (config4 && config4.parseDate) {
          parsedDate = config4.parseDate(date, format);
        } else if (/Z$/.test(datestr) || /GMT$/.test(datestr)) {
          parsedDate = new Date(date);
        } else {
          var matched = void 0, ops = [];
          for (var i3 = 0, matchIndex = 0, regexStr = ""; i3 < format.length; i3++) {
            var token = format[i3];
            var isBackSlash = token === "\\";
            var escaped = format[i3 - 1] === "\\" || isBackSlash;
            if (tokenRegex2[token] && !escaped) {
              regexStr += tokenRegex2[token];
              var match2 = new RegExp(regexStr).exec(date);
              if (match2 && (matched = true)) {
                ops[token !== "Y" ? "push" : "unshift"]({
                  fn: revFormat2[token],
                  val: match2[++matchIndex]
                });
              }
            } else if (!isBackSlash)
              regexStr += ".";
          }
          parsedDate = !config4 || !config4.noCalendar ? new Date((/* @__PURE__ */ new Date()).getFullYear(), 0, 1, 0, 0, 0, 0) : new Date((/* @__PURE__ */ new Date()).setHours(0, 0, 0, 0));
          ops.forEach(function(_a2) {
            var fn = _a2.fn, val2 = _a2.val;
            return parsedDate = fn(parsedDate, val2, locale) || parsedDate;
          });
          parsedDate = matched ? parsedDate : void 0;
        }
      }
      if (!(parsedDate instanceof Date && !isNaN(parsedDate.getTime()))) {
        config4.errorHandler(new Error("Invalid date provided: " + dateOrig));
        return void 0;
      }
      if (timeless === true)
        parsedDate.setHours(0, 0, 0, 0);
      return parsedDate;
    };
  }, "createDateParser");
  function compareDates2(date1, date2, timeless) {
    if (timeless === void 0) {
      timeless = true;
    }
    if (timeless !== false) {
      return new Date(date1.getTime()).setHours(0, 0, 0, 0) - new Date(date2.getTime()).setHours(0, 0, 0, 0);
    }
    return date1.getTime() - date2.getTime();
  }
  __name(compareDates2, "compareDates");
  var isBetween2 = /* @__PURE__ */ __name(function(ts, ts1, ts2) {
    return ts > Math.min(ts1, ts2) && ts < Math.max(ts1, ts2);
  }, "isBetween");
  var calculateSecondsSinceMidnight2 = /* @__PURE__ */ __name(function(hours, minutes, seconds) {
    return hours * 3600 + minutes * 60 + seconds;
  }, "calculateSecondsSinceMidnight");
  var parseSeconds2 = /* @__PURE__ */ __name(function(secondsSinceMidnight) {
    var hours = Math.floor(secondsSinceMidnight / 3600), minutes = (secondsSinceMidnight - hours * 3600) / 60;
    return [hours, minutes, secondsSinceMidnight - hours * 3600 - minutes * 60];
  }, "parseSeconds");
  var duration2 = {
    DAY: 864e5
  };
  function getDefaultHours2(config4) {
    var hours = config4.defaultHour;
    var minutes = config4.defaultMinute;
    var seconds = config4.defaultSeconds;
    if (config4.minDate !== void 0) {
      var minHour = config4.minDate.getHours();
      var minMinutes = config4.minDate.getMinutes();
      var minSeconds = config4.minDate.getSeconds();
      if (hours < minHour) {
        hours = minHour;
      }
      if (hours === minHour && minutes < minMinutes) {
        minutes = minMinutes;
      }
      if (hours === minHour && minutes === minMinutes && seconds < minSeconds)
        seconds = config4.minDate.getSeconds();
    }
    if (config4.maxDate !== void 0) {
      var maxHr = config4.maxDate.getHours();
      var maxMinutes = config4.maxDate.getMinutes();
      hours = Math.min(hours, maxHr);
      if (hours === maxHr)
        minutes = Math.min(maxMinutes, minutes);
      if (hours === maxHr && minutes === maxMinutes)
        seconds = config4.maxDate.getSeconds();
    }
    return { hours, minutes, seconds };
  }
  __name(getDefaultHours2, "getDefaultHours");

  // ../highway/node_modules/flatpickr/dist/esm/utils/polyfills.js
  if (typeof Object.assign !== "function") {
    Object.assign = function(target) {
      var args = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
      }
      if (!target) {
        throw TypeError("Cannot convert undefined or null to object");
      }
      var _loop_1 = /* @__PURE__ */ __name(function(source2) {
        if (source2) {
          Object.keys(source2).forEach(function(key) {
            return target[key] = source2[key];
          });
        }
      }, "_loop_1");
      for (var _a = 0, args_1 = args; _a < args_1.length; _a++) {
        var source = args_1[_a];
        _loop_1(source);
      }
      return target;
    };
  }

  // ../highway/node_modules/flatpickr/dist/esm/index.js
  var __assign2 = function() {
    __assign2 = Object.assign || function(t3) {
      for (var s3, i3 = 1, n3 = arguments.length; i3 < n3; i3++) {
        s3 = arguments[i3];
        for (var p3 in s3)
          if (Object.prototype.hasOwnProperty.call(s3, p3))
            t3[p3] = s3[p3];
      }
      return t3;
    };
    return __assign2.apply(this, arguments);
  };
  var __spreadArrays2 = function() {
    for (var s3 = 0, i3 = 0, il = arguments.length; i3 < il; i3++)
      s3 += arguments[i3].length;
    for (var r3 = Array(s3), k3 = 0, i3 = 0; i3 < il; i3++)
      for (var a3 = arguments[i3], j3 = 0, jl = a3.length; j3 < jl; j3++, k3++)
        r3[k3] = a3[j3];
    return r3;
  };
  var DEBOUNCED_CHANGE_MS2 = 300;
  function FlatpickrInstance2(element, instanceConfig) {
    var self2 = {
      config: __assign2(__assign2({}, defaults3), flatpickr2.defaultConfig),
      l10n: default_default2
    };
    self2.parseDate = createDateParser2({ config: self2.config, l10n: self2.l10n });
    self2._handlers = [];
    self2.pluginElements = [];
    self2.loadedPlugins = [];
    self2._bind = bind;
    self2._setHoursFromDate = setHoursFromDate;
    self2._positionCalendar = positionCalendar;
    self2.changeMonth = changeMonth;
    self2.changeYear = changeYear;
    self2.clear = clear;
    self2.close = close;
    self2.onMouseOver = onMouseOver;
    self2._createElement = createElement2;
    self2.createDay = createDay;
    self2.destroy = destroy2;
    self2.isEnabled = isEnabled;
    self2.jumpToDate = jumpToDate;
    self2.updateValue = updateValue;
    self2.open = open;
    self2.redraw = redraw;
    self2.set = set;
    self2.setDate = setDate;
    self2.toggle = toggle;
    function setupHelperFunctions() {
      self2.utils = {
        getDaysInMonth: function(month, yr) {
          if (month === void 0) {
            month = self2.currentMonth;
          }
          if (yr === void 0) {
            yr = self2.currentYear;
          }
          if (month === 1 && (yr % 4 === 0 && yr % 100 !== 0 || yr % 400 === 0))
            return 29;
          return self2.l10n.daysInMonth[month];
        }
      };
    }
    __name(setupHelperFunctions, "setupHelperFunctions");
    function init2() {
      self2.element = self2.input = element;
      self2.isOpen = false;
      parseConfig();
      setupLocale();
      setupInputs();
      setupDates();
      setupHelperFunctions();
      if (!self2.isMobile)
        build();
      bindEvents();
      if (self2.selectedDates.length || self2.config.noCalendar) {
        if (self2.config.enableTime) {
          setHoursFromDate(self2.config.noCalendar ? self2.latestSelectedDateObj : void 0);
        }
        updateValue(false);
      }
      setCalendarWidth();
      var isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
      if (!self2.isMobile && isSafari) {
        positionCalendar();
      }
      triggerEvent("onReady");
    }
    __name(init2, "init");
    function getClosestActiveElement() {
      var _a;
      return ((_a = self2.calendarContainer) === null || _a === void 0 ? void 0 : _a.getRootNode()).activeElement || document.activeElement;
    }
    __name(getClosestActiveElement, "getClosestActiveElement");
    function bindToInstance(fn) {
      return fn.bind(self2);
    }
    __name(bindToInstance, "bindToInstance");
    function setCalendarWidth() {
      var config4 = self2.config;
      if (config4.weekNumbers === false && config4.showMonths === 1) {
        return;
      } else if (config4.noCalendar !== true) {
        window.requestAnimationFrame(function() {
          if (self2.calendarContainer !== void 0) {
            self2.calendarContainer.style.visibility = "hidden";
            self2.calendarContainer.style.display = "block";
          }
          if (self2.daysContainer !== void 0) {
            var daysWidth = (self2.days.offsetWidth + 1) * config4.showMonths;
            self2.daysContainer.style.width = daysWidth + "px";
            self2.calendarContainer.style.width = daysWidth + (self2.weekWrapper !== void 0 ? self2.weekWrapper.offsetWidth : 0) + "px";
            self2.calendarContainer.style.removeProperty("visibility");
            self2.calendarContainer.style.removeProperty("display");
          }
        });
      }
    }
    __name(setCalendarWidth, "setCalendarWidth");
    function updateTime(e3) {
      if (self2.selectedDates.length === 0) {
        var defaultDate = self2.config.minDate === void 0 || compareDates2(/* @__PURE__ */ new Date(), self2.config.minDate) >= 0 ? /* @__PURE__ */ new Date() : new Date(self2.config.minDate.getTime());
        var defaults4 = getDefaultHours2(self2.config);
        defaultDate.setHours(defaults4.hours, defaults4.minutes, defaults4.seconds, defaultDate.getMilliseconds());
        self2.selectedDates = [defaultDate];
        self2.latestSelectedDateObj = defaultDate;
      }
      if (e3 !== void 0 && e3.type !== "blur") {
        timeWrapper(e3);
      }
      var prevValue = self2._input.value;
      setHoursFromInputs();
      updateValue();
      if (self2._input.value !== prevValue) {
        self2._debouncedChange();
      }
    }
    __name(updateTime, "updateTime");
    function ampm2military(hour, amPM) {
      return hour % 12 + 12 * int2(amPM === self2.l10n.amPM[1]);
    }
    __name(ampm2military, "ampm2military");
    function military2ampm(hour) {
      switch (hour % 24) {
        case 0:
        case 12:
          return 12;
        default:
          return hour % 12;
      }
    }
    __name(military2ampm, "military2ampm");
    function setHoursFromInputs() {
      if (self2.hourElement === void 0 || self2.minuteElement === void 0)
        return;
      var hours = (parseInt(self2.hourElement.value.slice(-2), 10) || 0) % 24, minutes = (parseInt(self2.minuteElement.value, 10) || 0) % 60, seconds = self2.secondElement !== void 0 ? (parseInt(self2.secondElement.value, 10) || 0) % 60 : 0;
      if (self2.amPM !== void 0) {
        hours = ampm2military(hours, self2.amPM.textContent);
      }
      var limitMinHours = self2.config.minTime !== void 0 || self2.config.minDate && self2.minDateHasTime && self2.latestSelectedDateObj && compareDates2(self2.latestSelectedDateObj, self2.config.minDate, true) === 0;
      var limitMaxHours = self2.config.maxTime !== void 0 || self2.config.maxDate && self2.maxDateHasTime && self2.latestSelectedDateObj && compareDates2(self2.latestSelectedDateObj, self2.config.maxDate, true) === 0;
      if (self2.config.maxTime !== void 0 && self2.config.minTime !== void 0 && self2.config.minTime > self2.config.maxTime) {
        var minBound = calculateSecondsSinceMidnight2(self2.config.minTime.getHours(), self2.config.minTime.getMinutes(), self2.config.minTime.getSeconds());
        var maxBound = calculateSecondsSinceMidnight2(self2.config.maxTime.getHours(), self2.config.maxTime.getMinutes(), self2.config.maxTime.getSeconds());
        var currentTime = calculateSecondsSinceMidnight2(hours, minutes, seconds);
        if (currentTime > maxBound && currentTime < minBound) {
          var result = parseSeconds2(minBound);
          hours = result[0];
          minutes = result[1];
          seconds = result[2];
        }
      } else {
        if (limitMaxHours) {
          var maxTime = self2.config.maxTime !== void 0 ? self2.config.maxTime : self2.config.maxDate;
          hours = Math.min(hours, maxTime.getHours());
          if (hours === maxTime.getHours())
            minutes = Math.min(minutes, maxTime.getMinutes());
          if (minutes === maxTime.getMinutes())
            seconds = Math.min(seconds, maxTime.getSeconds());
        }
        if (limitMinHours) {
          var minTime = self2.config.minTime !== void 0 ? self2.config.minTime : self2.config.minDate;
          hours = Math.max(hours, minTime.getHours());
          if (hours === minTime.getHours() && minutes < minTime.getMinutes())
            minutes = minTime.getMinutes();
          if (minutes === minTime.getMinutes())
            seconds = Math.max(seconds, minTime.getSeconds());
        }
      }
      setHours(hours, minutes, seconds);
    }
    __name(setHoursFromInputs, "setHoursFromInputs");
    function setHoursFromDate(dateObj) {
      var date = dateObj || self2.latestSelectedDateObj;
      if (date && date instanceof Date) {
        setHours(date.getHours(), date.getMinutes(), date.getSeconds());
      }
    }
    __name(setHoursFromDate, "setHoursFromDate");
    function setHours(hours, minutes, seconds) {
      if (self2.latestSelectedDateObj !== void 0) {
        self2.latestSelectedDateObj.setHours(hours % 24, minutes, seconds || 0, 0);
      }
      if (!self2.hourElement || !self2.minuteElement || self2.isMobile)
        return;
      self2.hourElement.value = pad2(!self2.config.time_24hr ? (12 + hours) % 12 + 12 * int2(hours % 12 === 0) : hours);
      self2.minuteElement.value = pad2(minutes);
      if (self2.amPM !== void 0)
        self2.amPM.textContent = self2.l10n.amPM[int2(hours >= 12)];
      if (self2.secondElement !== void 0)
        self2.secondElement.value = pad2(seconds);
    }
    __name(setHours, "setHours");
    function onYearInput(event) {
      var eventTarget = getEventTarget2(event);
      var year = parseInt(eventTarget.value) + (event.delta || 0);
      if (year / 1e3 > 1 || event.key === "Enter" && !/[^\d]/.test(year.toString())) {
        changeYear(year);
      }
    }
    __name(onYearInput, "onYearInput");
    function bind(element2, event, handler, options) {
      if (event instanceof Array)
        return event.forEach(function(ev) {
          return bind(element2, ev, handler, options);
        });
      if (element2 instanceof Array)
        return element2.forEach(function(el) {
          return bind(el, event, handler, options);
        });
      element2.addEventListener(event, handler, options);
      self2._handlers.push({
        remove: function() {
          return element2.removeEventListener(event, handler, options);
        }
      });
    }
    __name(bind, "bind");
    function triggerChange() {
      triggerEvent("onChange");
    }
    __name(triggerChange, "triggerChange");
    function bindEvents() {
      if (self2.config.wrap) {
        ["open", "close", "toggle", "clear"].forEach(function(evt) {
          Array.prototype.forEach.call(self2.element.querySelectorAll("[data-" + evt + "]"), function(el) {
            return bind(el, "click", self2[evt]);
          });
        });
      }
      if (self2.isMobile) {
        setupMobile();
        return;
      }
      var debouncedResize = debounce5(onResize, 50);
      self2._debouncedChange = debounce5(triggerChange, DEBOUNCED_CHANGE_MS2);
      if (self2.daysContainer && !/iPhone|iPad|iPod/i.test(navigator.userAgent))
        bind(self2.daysContainer, "mouseover", function(e3) {
          if (self2.config.mode === "range")
            onMouseOver(getEventTarget2(e3));
        });
      bind(self2._input, "keydown", onKeyDown);
      if (self2.calendarContainer !== void 0) {
        bind(self2.calendarContainer, "keydown", onKeyDown);
      }
      if (!self2.config.inline && !self2.config.static)
        bind(window, "resize", debouncedResize);
      if (window.ontouchstart !== void 0)
        bind(window.document, "touchstart", documentClick);
      else
        bind(window.document, "mousedown", documentClick);
      bind(window.document, "focus", documentClick, { capture: true });
      if (self2.config.clickOpens === true) {
        bind(self2._input, "focus", self2.open);
        bind(self2._input, "click", self2.open);
      }
      if (self2.daysContainer !== void 0) {
        bind(self2.monthNav, "click", onMonthNavClick);
        bind(self2.monthNav, ["keyup", "increment"], onYearInput);
        bind(self2.daysContainer, "click", selectDate);
      }
      if (self2.timeContainer !== void 0 && self2.minuteElement !== void 0 && self2.hourElement !== void 0) {
        var selText = /* @__PURE__ */ __name(function(e3) {
          return getEventTarget2(e3).select();
        }, "selText");
        bind(self2.timeContainer, ["increment"], updateTime);
        bind(self2.timeContainer, "blur", updateTime, { capture: true });
        bind(self2.timeContainer, "click", timeIncrement);
        bind([self2.hourElement, self2.minuteElement], ["focus", "click"], selText);
        if (self2.secondElement !== void 0)
          bind(self2.secondElement, "focus", function() {
            return self2.secondElement && self2.secondElement.select();
          });
        if (self2.amPM !== void 0) {
          bind(self2.amPM, "click", function(e3) {
            updateTime(e3);
          });
        }
      }
      if (self2.config.allowInput) {
        bind(self2._input, "blur", onBlur);
      }
    }
    __name(bindEvents, "bindEvents");
    function jumpToDate(jumpDate, triggerChange2) {
      var jumpTo = jumpDate !== void 0 ? self2.parseDate(jumpDate) : self2.latestSelectedDateObj || (self2.config.minDate && self2.config.minDate > self2.now ? self2.config.minDate : self2.config.maxDate && self2.config.maxDate < self2.now ? self2.config.maxDate : self2.now);
      var oldYear = self2.currentYear;
      var oldMonth = self2.currentMonth;
      try {
        if (jumpTo !== void 0) {
          self2.currentYear = jumpTo.getFullYear();
          self2.currentMonth = jumpTo.getMonth();
        }
      } catch (e3) {
        e3.message = "Invalid date supplied: " + jumpTo;
        self2.config.errorHandler(e3);
      }
      if (triggerChange2 && self2.currentYear !== oldYear) {
        triggerEvent("onYearChange");
        buildMonthSwitch();
      }
      if (triggerChange2 && (self2.currentYear !== oldYear || self2.currentMonth !== oldMonth)) {
        triggerEvent("onMonthChange");
      }
      self2.redraw();
    }
    __name(jumpToDate, "jumpToDate");
    function timeIncrement(e3) {
      var eventTarget = getEventTarget2(e3);
      if (~eventTarget.className.indexOf("arrow"))
        incrementNumInput(e3, eventTarget.classList.contains("arrowUp") ? 1 : -1);
    }
    __name(timeIncrement, "timeIncrement");
    function incrementNumInput(e3, delta, inputElem) {
      var target = e3 && getEventTarget2(e3);
      var input = inputElem || target && target.parentNode && target.parentNode.firstChild;
      var event = createEvent("increment");
      event.delta = delta;
      input && input.dispatchEvent(event);
    }
    __name(incrementNumInput, "incrementNumInput");
    function build() {
      var fragment = window.document.createDocumentFragment();
      self2.calendarContainer = createElement2("div", "flatpickr-calendar");
      self2.calendarContainer.tabIndex = -1;
      if (!self2.config.noCalendar) {
        fragment.appendChild(buildMonthNav());
        self2.innerContainer = createElement2("div", "flatpickr-innerContainer");
        if (self2.config.weekNumbers) {
          var _a = buildWeeks(), weekWrapper = _a.weekWrapper, weekNumbers = _a.weekNumbers;
          self2.innerContainer.appendChild(weekWrapper);
          self2.weekNumbers = weekNumbers;
          self2.weekWrapper = weekWrapper;
        }
        self2.rContainer = createElement2("div", "flatpickr-rContainer");
        self2.rContainer.appendChild(buildWeekdays());
        if (!self2.daysContainer) {
          self2.daysContainer = createElement2("div", "flatpickr-days");
          self2.daysContainer.tabIndex = -1;
        }
        buildDays();
        self2.rContainer.appendChild(self2.daysContainer);
        self2.innerContainer.appendChild(self2.rContainer);
        fragment.appendChild(self2.innerContainer);
      }
      if (self2.config.enableTime) {
        fragment.appendChild(buildTime());
      }
      toggleClass3(self2.calendarContainer, "rangeMode", self2.config.mode === "range");
      toggleClass3(self2.calendarContainer, "animate", self2.config.animate === true);
      toggleClass3(self2.calendarContainer, "multiMonth", self2.config.showMonths > 1);
      self2.calendarContainer.appendChild(fragment);
      var customAppend = self2.config.appendTo !== void 0 && self2.config.appendTo.nodeType !== void 0;
      if (self2.config.inline || self2.config.static) {
        self2.calendarContainer.classList.add(self2.config.inline ? "inline" : "static");
        if (self2.config.inline) {
          if (!customAppend && self2.element.parentNode)
            self2.element.parentNode.insertBefore(self2.calendarContainer, self2._input.nextSibling);
          else if (self2.config.appendTo !== void 0)
            self2.config.appendTo.appendChild(self2.calendarContainer);
        }
        if (self2.config.static) {
          var wrapper = createElement2("div", "flatpickr-wrapper");
          if (self2.element.parentNode)
            self2.element.parentNode.insertBefore(wrapper, self2.element);
          wrapper.appendChild(self2.element);
          if (self2.altInput)
            wrapper.appendChild(self2.altInput);
          wrapper.appendChild(self2.calendarContainer);
        }
      }
      if (!self2.config.static && !self2.config.inline)
        (self2.config.appendTo !== void 0 ? self2.config.appendTo : window.document.body).appendChild(self2.calendarContainer);
    }
    __name(build, "build");
    function createDay(className, date, _dayNumber, i3) {
      var dateIsEnabled = isEnabled(date, true), dayElement = createElement2("span", className, date.getDate().toString());
      dayElement.dateObj = date;
      dayElement.$i = i3;
      dayElement.setAttribute("aria-label", self2.formatDate(date, self2.config.ariaDateFormat));
      if (className.indexOf("hidden") === -1 && compareDates2(date, self2.now) === 0) {
        self2.todayDateElem = dayElement;
        dayElement.classList.add("today");
        dayElement.setAttribute("aria-current", "date");
      }
      if (dateIsEnabled) {
        dayElement.tabIndex = -1;
        if (isDateSelected(date)) {
          dayElement.classList.add("selected");
          self2.selectedDateElem = dayElement;
          if (self2.config.mode === "range") {
            toggleClass3(dayElement, "startRange", self2.selectedDates[0] && compareDates2(date, self2.selectedDates[0], true) === 0);
            toggleClass3(dayElement, "endRange", self2.selectedDates[1] && compareDates2(date, self2.selectedDates[1], true) === 0);
            if (className === "nextMonthDay")
              dayElement.classList.add("inRange");
          }
        }
      } else {
        dayElement.classList.add("flatpickr-disabled");
      }
      if (self2.config.mode === "range") {
        if (isDateInRange(date) && !isDateSelected(date))
          dayElement.classList.add("inRange");
      }
      if (self2.weekNumbers && self2.config.showMonths === 1 && className !== "prevMonthDay" && i3 % 7 === 6) {
        self2.weekNumbers.insertAdjacentHTML("beforeend", "<span class='flatpickr-day'>" + self2.config.getWeek(date) + "</span>");
      }
      triggerEvent("onDayCreate", dayElement);
      return dayElement;
    }
    __name(createDay, "createDay");
    function focusOnDayElem(targetNode) {
      targetNode.focus();
      if (self2.config.mode === "range")
        onMouseOver(targetNode);
    }
    __name(focusOnDayElem, "focusOnDayElem");
    function getFirstAvailableDay(delta) {
      var startMonth = delta > 0 ? 0 : self2.config.showMonths - 1;
      var endMonth = delta > 0 ? self2.config.showMonths : -1;
      for (var m3 = startMonth; m3 != endMonth; m3 += delta) {
        var month = self2.daysContainer.children[m3];
        var startIndex = delta > 0 ? 0 : month.children.length - 1;
        var endIndex = delta > 0 ? month.children.length : -1;
        for (var i3 = startIndex; i3 != endIndex; i3 += delta) {
          var c3 = month.children[i3];
          if (c3.className.indexOf("hidden") === -1 && isEnabled(c3.dateObj))
            return c3;
        }
      }
      return void 0;
    }
    __name(getFirstAvailableDay, "getFirstAvailableDay");
    function getNextAvailableDay(current, delta) {
      var givenMonth = current.className.indexOf("Month") === -1 ? current.dateObj.getMonth() : self2.currentMonth;
      var endMonth = delta > 0 ? self2.config.showMonths : -1;
      var loopDelta = delta > 0 ? 1 : -1;
      for (var m3 = givenMonth - self2.currentMonth; m3 != endMonth; m3 += loopDelta) {
        var month = self2.daysContainer.children[m3];
        var startIndex = givenMonth - self2.currentMonth === m3 ? current.$i + delta : delta < 0 ? month.children.length - 1 : 0;
        var numMonthDays = month.children.length;
        for (var i3 = startIndex; i3 >= 0 && i3 < numMonthDays && i3 != (delta > 0 ? numMonthDays : -1); i3 += loopDelta) {
          var c3 = month.children[i3];
          if (c3.className.indexOf("hidden") === -1 && isEnabled(c3.dateObj) && Math.abs(current.$i - i3) >= Math.abs(delta))
            return focusOnDayElem(c3);
        }
      }
      self2.changeMonth(loopDelta);
      focusOnDay(getFirstAvailableDay(loopDelta), 0);
      return void 0;
    }
    __name(getNextAvailableDay, "getNextAvailableDay");
    function focusOnDay(current, offset) {
      var activeElement = getClosestActiveElement();
      var dayFocused = isInView(activeElement || document.body);
      var startElem = current !== void 0 ? current : dayFocused ? activeElement : self2.selectedDateElem !== void 0 && isInView(self2.selectedDateElem) ? self2.selectedDateElem : self2.todayDateElem !== void 0 && isInView(self2.todayDateElem) ? self2.todayDateElem : getFirstAvailableDay(offset > 0 ? 1 : -1);
      if (startElem === void 0) {
        self2._input.focus();
      } else if (!dayFocused) {
        focusOnDayElem(startElem);
      } else {
        getNextAvailableDay(startElem, offset);
      }
    }
    __name(focusOnDay, "focusOnDay");
    function buildMonthDays(year, month) {
      var firstOfMonth = (new Date(year, month, 1).getDay() - self2.l10n.firstDayOfWeek + 7) % 7;
      var prevMonthDays = self2.utils.getDaysInMonth((month - 1 + 12) % 12, year);
      var daysInMonth = self2.utils.getDaysInMonth(month, year), days = window.document.createDocumentFragment(), isMultiMonth = self2.config.showMonths > 1, prevMonthDayClass = isMultiMonth ? "prevMonthDay hidden" : "prevMonthDay", nextMonthDayClass = isMultiMonth ? "nextMonthDay hidden" : "nextMonthDay";
      var dayNumber = prevMonthDays + 1 - firstOfMonth, dayIndex = 0;
      for (; dayNumber <= prevMonthDays; dayNumber++, dayIndex++) {
        days.appendChild(createDay("flatpickr-day " + prevMonthDayClass, new Date(year, month - 1, dayNumber), dayNumber, dayIndex));
      }
      for (dayNumber = 1; dayNumber <= daysInMonth; dayNumber++, dayIndex++) {
        days.appendChild(createDay("flatpickr-day", new Date(year, month, dayNumber), dayNumber, dayIndex));
      }
      for (var dayNum = daysInMonth + 1; dayNum <= 42 - firstOfMonth && (self2.config.showMonths === 1 || dayIndex % 7 !== 0); dayNum++, dayIndex++) {
        days.appendChild(createDay("flatpickr-day " + nextMonthDayClass, new Date(year, month + 1, dayNum % daysInMonth), dayNum, dayIndex));
      }
      var dayContainer = createElement2("div", "dayContainer");
      dayContainer.appendChild(days);
      return dayContainer;
    }
    __name(buildMonthDays, "buildMonthDays");
    function buildDays() {
      if (self2.daysContainer === void 0) {
        return;
      }
      clearNode2(self2.daysContainer);
      if (self2.weekNumbers)
        clearNode2(self2.weekNumbers);
      var frag = document.createDocumentFragment();
      for (var i3 = 0; i3 < self2.config.showMonths; i3++) {
        var d3 = new Date(self2.currentYear, self2.currentMonth, 1);
        d3.setMonth(self2.currentMonth + i3);
        frag.appendChild(buildMonthDays(d3.getFullYear(), d3.getMonth()));
      }
      self2.daysContainer.appendChild(frag);
      self2.days = self2.daysContainer.firstChild;
      if (self2.config.mode === "range" && self2.selectedDates.length === 1) {
        onMouseOver();
      }
    }
    __name(buildDays, "buildDays");
    function buildMonthSwitch() {
      if (self2.config.showMonths > 1 || self2.config.monthSelectorType !== "dropdown")
        return;
      var shouldBuildMonth = /* @__PURE__ */ __name(function(month2) {
        if (self2.config.minDate !== void 0 && self2.currentYear === self2.config.minDate.getFullYear() && month2 < self2.config.minDate.getMonth()) {
          return false;
        }
        return !(self2.config.maxDate !== void 0 && self2.currentYear === self2.config.maxDate.getFullYear() && month2 > self2.config.maxDate.getMonth());
      }, "shouldBuildMonth");
      self2.monthsDropdownContainer.tabIndex = -1;
      self2.monthsDropdownContainer.innerHTML = "";
      for (var i3 = 0; i3 < 12; i3++) {
        if (!shouldBuildMonth(i3))
          continue;
        var month = createElement2("option", "flatpickr-monthDropdown-month");
        month.value = new Date(self2.currentYear, i3).getMonth().toString();
        month.textContent = monthToStr2(i3, self2.config.shorthandCurrentMonth, self2.l10n);
        month.tabIndex = -1;
        if (self2.currentMonth === i3) {
          month.selected = true;
        }
        self2.monthsDropdownContainer.appendChild(month);
      }
    }
    __name(buildMonthSwitch, "buildMonthSwitch");
    function buildMonth() {
      var container = createElement2("div", "flatpickr-month");
      var monthNavFragment = window.document.createDocumentFragment();
      var monthElement;
      if (self2.config.showMonths > 1 || self2.config.monthSelectorType === "static") {
        monthElement = createElement2("span", "cur-month");
      } else {
        self2.monthsDropdownContainer = createElement2("select", "flatpickr-monthDropdown-months");
        self2.monthsDropdownContainer.setAttribute("aria-label", self2.l10n.monthAriaLabel);
        bind(self2.monthsDropdownContainer, "change", function(e3) {
          var target = getEventTarget2(e3);
          var selectedMonth = parseInt(target.value, 10);
          self2.changeMonth(selectedMonth - self2.currentMonth);
          triggerEvent("onMonthChange");
        });
        buildMonthSwitch();
        monthElement = self2.monthsDropdownContainer;
      }
      var yearInput = createNumberInput2("cur-year", { tabindex: "-1" });
      var yearElement = yearInput.getElementsByTagName("input")[0];
      yearElement.setAttribute("aria-label", self2.l10n.yearAriaLabel);
      if (self2.config.minDate) {
        yearElement.setAttribute("min", self2.config.minDate.getFullYear().toString());
      }
      if (self2.config.maxDate) {
        yearElement.setAttribute("max", self2.config.maxDate.getFullYear().toString());
        yearElement.disabled = !!self2.config.minDate && self2.config.minDate.getFullYear() === self2.config.maxDate.getFullYear();
      }
      var currentMonth = createElement2("div", "flatpickr-current-month");
      currentMonth.appendChild(monthElement);
      currentMonth.appendChild(yearInput);
      monthNavFragment.appendChild(currentMonth);
      container.appendChild(monthNavFragment);
      return {
        container,
        yearElement,
        monthElement
      };
    }
    __name(buildMonth, "buildMonth");
    function buildMonths() {
      clearNode2(self2.monthNav);
      self2.monthNav.appendChild(self2.prevMonthNav);
      if (self2.config.showMonths) {
        self2.yearElements = [];
        self2.monthElements = [];
      }
      for (var m3 = self2.config.showMonths; m3--; ) {
        var month = buildMonth();
        self2.yearElements.push(month.yearElement);
        self2.monthElements.push(month.monthElement);
        self2.monthNav.appendChild(month.container);
      }
      self2.monthNav.appendChild(self2.nextMonthNav);
    }
    __name(buildMonths, "buildMonths");
    function buildMonthNav() {
      self2.monthNav = createElement2("div", "flatpickr-months");
      self2.yearElements = [];
      self2.monthElements = [];
      self2.prevMonthNav = createElement2("span", "flatpickr-prev-month");
      self2.prevMonthNav.innerHTML = self2.config.prevArrow;
      self2.nextMonthNav = createElement2("span", "flatpickr-next-month");
      self2.nextMonthNav.innerHTML = self2.config.nextArrow;
      buildMonths();
      Object.defineProperty(self2, "_hidePrevMonthArrow", {
        get: function() {
          return self2.__hidePrevMonthArrow;
        },
        set: function(bool) {
          if (self2.__hidePrevMonthArrow !== bool) {
            toggleClass3(self2.prevMonthNav, "flatpickr-disabled", bool);
            self2.__hidePrevMonthArrow = bool;
          }
        }
      });
      Object.defineProperty(self2, "_hideNextMonthArrow", {
        get: function() {
          return self2.__hideNextMonthArrow;
        },
        set: function(bool) {
          if (self2.__hideNextMonthArrow !== bool) {
            toggleClass3(self2.nextMonthNav, "flatpickr-disabled", bool);
            self2.__hideNextMonthArrow = bool;
          }
        }
      });
      self2.currentYearElement = self2.yearElements[0];
      updateNavigationCurrentMonth();
      return self2.monthNav;
    }
    __name(buildMonthNav, "buildMonthNav");
    function buildTime() {
      self2.calendarContainer.classList.add("hasTime");
      if (self2.config.noCalendar)
        self2.calendarContainer.classList.add("noCalendar");
      var defaults4 = getDefaultHours2(self2.config);
      self2.timeContainer = createElement2("div", "flatpickr-time");
      self2.timeContainer.tabIndex = -1;
      var separator = createElement2("span", "flatpickr-time-separator", ":");
      var hourInput = createNumberInput2("flatpickr-hour", {
        "aria-label": self2.l10n.hourAriaLabel
      });
      self2.hourElement = hourInput.getElementsByTagName("input")[0];
      var minuteInput = createNumberInput2("flatpickr-minute", {
        "aria-label": self2.l10n.minuteAriaLabel
      });
      self2.minuteElement = minuteInput.getElementsByTagName("input")[0];
      self2.hourElement.tabIndex = self2.minuteElement.tabIndex = -1;
      self2.hourElement.value = pad2(self2.latestSelectedDateObj ? self2.latestSelectedDateObj.getHours() : self2.config.time_24hr ? defaults4.hours : military2ampm(defaults4.hours));
      self2.minuteElement.value = pad2(self2.latestSelectedDateObj ? self2.latestSelectedDateObj.getMinutes() : defaults4.minutes);
      self2.hourElement.setAttribute("step", self2.config.hourIncrement.toString());
      self2.minuteElement.setAttribute("step", self2.config.minuteIncrement.toString());
      self2.hourElement.setAttribute("min", self2.config.time_24hr ? "0" : "1");
      self2.hourElement.setAttribute("max", self2.config.time_24hr ? "23" : "12");
      self2.hourElement.setAttribute("maxlength", "2");
      self2.minuteElement.setAttribute("min", "0");
      self2.minuteElement.setAttribute("max", "59");
      self2.minuteElement.setAttribute("maxlength", "2");
      self2.timeContainer.appendChild(hourInput);
      self2.timeContainer.appendChild(separator);
      self2.timeContainer.appendChild(minuteInput);
      if (self2.config.time_24hr)
        self2.timeContainer.classList.add("time24hr");
      if (self2.config.enableSeconds) {
        self2.timeContainer.classList.add("hasSeconds");
        var secondInput = createNumberInput2("flatpickr-second");
        self2.secondElement = secondInput.getElementsByTagName("input")[0];
        self2.secondElement.value = pad2(self2.latestSelectedDateObj ? self2.latestSelectedDateObj.getSeconds() : defaults4.seconds);
        self2.secondElement.setAttribute("step", self2.minuteElement.getAttribute("step"));
        self2.secondElement.setAttribute("min", "0");
        self2.secondElement.setAttribute("max", "59");
        self2.secondElement.setAttribute("maxlength", "2");
        self2.timeContainer.appendChild(createElement2("span", "flatpickr-time-separator", ":"));
        self2.timeContainer.appendChild(secondInput);
      }
      if (!self2.config.time_24hr) {
        self2.amPM = createElement2("span", "flatpickr-am-pm", self2.l10n.amPM[int2((self2.latestSelectedDateObj ? self2.hourElement.value : self2.config.defaultHour) > 11)]);
        self2.amPM.title = self2.l10n.toggleTitle;
        self2.amPM.tabIndex = -1;
        self2.timeContainer.appendChild(self2.amPM);
      }
      return self2.timeContainer;
    }
    __name(buildTime, "buildTime");
    function buildWeekdays() {
      if (!self2.weekdayContainer)
        self2.weekdayContainer = createElement2("div", "flatpickr-weekdays");
      else
        clearNode2(self2.weekdayContainer);
      for (var i3 = self2.config.showMonths; i3--; ) {
        var container = createElement2("div", "flatpickr-weekdaycontainer");
        self2.weekdayContainer.appendChild(container);
      }
      updateWeekdays();
      return self2.weekdayContainer;
    }
    __name(buildWeekdays, "buildWeekdays");
    function updateWeekdays() {
      if (!self2.weekdayContainer) {
        return;
      }
      var firstDayOfWeek = self2.l10n.firstDayOfWeek;
      var weekdays = __spreadArrays2(self2.l10n.weekdays.shorthand);
      if (firstDayOfWeek > 0 && firstDayOfWeek < weekdays.length) {
        weekdays = __spreadArrays2(weekdays.splice(firstDayOfWeek, weekdays.length), weekdays.splice(0, firstDayOfWeek));
      }
      for (var i3 = self2.config.showMonths; i3--; ) {
        self2.weekdayContainer.children[i3].innerHTML = "\n      <span class='flatpickr-weekday'>\n        " + weekdays.join("</span><span class='flatpickr-weekday'>") + "\n      </span>\n      ";
      }
    }
    __name(updateWeekdays, "updateWeekdays");
    function buildWeeks() {
      self2.calendarContainer.classList.add("hasWeeks");
      var weekWrapper = createElement2("div", "flatpickr-weekwrapper");
      weekWrapper.appendChild(createElement2("span", "flatpickr-weekday", self2.l10n.weekAbbreviation));
      var weekNumbers = createElement2("div", "flatpickr-weeks");
      weekWrapper.appendChild(weekNumbers);
      return {
        weekWrapper,
        weekNumbers
      };
    }
    __name(buildWeeks, "buildWeeks");
    function changeMonth(value, isOffset) {
      if (isOffset === void 0) {
        isOffset = true;
      }
      var delta = isOffset ? value : value - self2.currentMonth;
      if (delta < 0 && self2._hidePrevMonthArrow === true || delta > 0 && self2._hideNextMonthArrow === true)
        return;
      self2.currentMonth += delta;
      if (self2.currentMonth < 0 || self2.currentMonth > 11) {
        self2.currentYear += self2.currentMonth > 11 ? 1 : -1;
        self2.currentMonth = (self2.currentMonth + 12) % 12;
        triggerEvent("onYearChange");
        buildMonthSwitch();
      }
      buildDays();
      triggerEvent("onMonthChange");
      updateNavigationCurrentMonth();
    }
    __name(changeMonth, "changeMonth");
    function clear(triggerChangeEvent, toInitial) {
      if (triggerChangeEvent === void 0) {
        triggerChangeEvent = true;
      }
      if (toInitial === void 0) {
        toInitial = true;
      }
      self2.input.value = "";
      if (self2.altInput !== void 0)
        self2.altInput.value = "";
      if (self2.mobileInput !== void 0)
        self2.mobileInput.value = "";
      self2.selectedDates = [];
      self2.latestSelectedDateObj = void 0;
      if (toInitial === true) {
        self2.currentYear = self2._initialDate.getFullYear();
        self2.currentMonth = self2._initialDate.getMonth();
      }
      if (self2.config.enableTime === true) {
        var _a = getDefaultHours2(self2.config), hours = _a.hours, minutes = _a.minutes, seconds = _a.seconds;
        setHours(hours, minutes, seconds);
      }
      self2.redraw();
      if (triggerChangeEvent)
        triggerEvent("onChange");
    }
    __name(clear, "clear");
    function close() {
      self2.isOpen = false;
      if (!self2.isMobile) {
        if (self2.calendarContainer !== void 0) {
          self2.calendarContainer.classList.remove("open");
        }
        if (self2._input !== void 0) {
          self2._input.classList.remove("active");
        }
      }
      triggerEvent("onClose");
    }
    __name(close, "close");
    function destroy2() {
      if (self2.config !== void 0)
        triggerEvent("onDestroy");
      for (var i3 = self2._handlers.length; i3--; ) {
        self2._handlers[i3].remove();
      }
      self2._handlers = [];
      if (self2.mobileInput) {
        if (self2.mobileInput.parentNode)
          self2.mobileInput.parentNode.removeChild(self2.mobileInput);
        self2.mobileInput = void 0;
      } else if (self2.calendarContainer && self2.calendarContainer.parentNode) {
        if (self2.config.static && self2.calendarContainer.parentNode) {
          var wrapper = self2.calendarContainer.parentNode;
          wrapper.lastChild && wrapper.removeChild(wrapper.lastChild);
          if (wrapper.parentNode) {
            while (wrapper.firstChild)
              wrapper.parentNode.insertBefore(wrapper.firstChild, wrapper);
            wrapper.parentNode.removeChild(wrapper);
          }
        } else
          self2.calendarContainer.parentNode.removeChild(self2.calendarContainer);
      }
      if (self2.altInput) {
        self2.input.type = "text";
        if (self2.altInput.parentNode)
          self2.altInput.parentNode.removeChild(self2.altInput);
        delete self2.altInput;
      }
      if (self2.input) {
        self2.input.type = self2.input._type;
        self2.input.classList.remove("flatpickr-input");
        self2.input.removeAttribute("readonly");
      }
      [
        "_showTimeInput",
        "latestSelectedDateObj",
        "_hideNextMonthArrow",
        "_hidePrevMonthArrow",
        "__hideNextMonthArrow",
        "__hidePrevMonthArrow",
        "isMobile",
        "isOpen",
        "selectedDateElem",
        "minDateHasTime",
        "maxDateHasTime",
        "days",
        "daysContainer",
        "_input",
        "_positionElement",
        "innerContainer",
        "rContainer",
        "monthNav",
        "todayDateElem",
        "calendarContainer",
        "weekdayContainer",
        "prevMonthNav",
        "nextMonthNav",
        "monthsDropdownContainer",
        "currentMonthElement",
        "currentYearElement",
        "navigationCurrentMonth",
        "selectedDateElem",
        "config"
      ].forEach(function(k3) {
        try {
          delete self2[k3];
        } catch (_2) {
        }
      });
    }
    __name(destroy2, "destroy");
    function isCalendarElem(elem) {
      return self2.calendarContainer.contains(elem);
    }
    __name(isCalendarElem, "isCalendarElem");
    function documentClick(e3) {
      if (self2.isOpen && !self2.config.inline) {
        var eventTarget_1 = getEventTarget2(e3);
        var isCalendarElement = isCalendarElem(eventTarget_1);
        var isInput = eventTarget_1 === self2.input || eventTarget_1 === self2.altInput || self2.element.contains(eventTarget_1) || e3.path && e3.path.indexOf && (~e3.path.indexOf(self2.input) || ~e3.path.indexOf(self2.altInput));
        var lostFocus = !isInput && !isCalendarElement && !isCalendarElem(e3.relatedTarget);
        var isIgnored = !self2.config.ignoredFocusElements.some(function(elem) {
          return elem.contains(eventTarget_1);
        });
        if (lostFocus && isIgnored) {
          if (self2.config.allowInput) {
            self2.setDate(self2._input.value, false, self2.config.altInput ? self2.config.altFormat : self2.config.dateFormat);
          }
          if (self2.timeContainer !== void 0 && self2.minuteElement !== void 0 && self2.hourElement !== void 0 && self2.input.value !== "" && self2.input.value !== void 0) {
            updateTime();
          }
          self2.close();
          if (self2.config && self2.config.mode === "range" && self2.selectedDates.length === 1)
            self2.clear(false);
        }
      }
    }
    __name(documentClick, "documentClick");
    function changeYear(newYear) {
      if (!newYear || self2.config.minDate && newYear < self2.config.minDate.getFullYear() || self2.config.maxDate && newYear > self2.config.maxDate.getFullYear())
        return;
      var newYearNum = newYear, isNewYear = self2.currentYear !== newYearNum;
      self2.currentYear = newYearNum || self2.currentYear;
      if (self2.config.maxDate && self2.currentYear === self2.config.maxDate.getFullYear()) {
        self2.currentMonth = Math.min(self2.config.maxDate.getMonth(), self2.currentMonth);
      } else if (self2.config.minDate && self2.currentYear === self2.config.minDate.getFullYear()) {
        self2.currentMonth = Math.max(self2.config.minDate.getMonth(), self2.currentMonth);
      }
      if (isNewYear) {
        self2.redraw();
        triggerEvent("onYearChange");
        buildMonthSwitch();
      }
    }
    __name(changeYear, "changeYear");
    function isEnabled(date, timeless) {
      var _a;
      if (timeless === void 0) {
        timeless = true;
      }
      var dateToCheck = self2.parseDate(date, void 0, timeless);
      if (self2.config.minDate && dateToCheck && compareDates2(dateToCheck, self2.config.minDate, timeless !== void 0 ? timeless : !self2.minDateHasTime) < 0 || self2.config.maxDate && dateToCheck && compareDates2(dateToCheck, self2.config.maxDate, timeless !== void 0 ? timeless : !self2.maxDateHasTime) > 0)
        return false;
      if (!self2.config.enable && self2.config.disable.length === 0)
        return true;
      if (dateToCheck === void 0)
        return false;
      var bool = !!self2.config.enable, array = (_a = self2.config.enable) !== null && _a !== void 0 ? _a : self2.config.disable;
      for (var i3 = 0, d3 = void 0; i3 < array.length; i3++) {
        d3 = array[i3];
        if (typeof d3 === "function" && d3(dateToCheck))
          return bool;
        else if (d3 instanceof Date && dateToCheck !== void 0 && d3.getTime() === dateToCheck.getTime())
          return bool;
        else if (typeof d3 === "string") {
          var parsed = self2.parseDate(d3, void 0, true);
          return parsed && parsed.getTime() === dateToCheck.getTime() ? bool : !bool;
        } else if (typeof d3 === "object" && dateToCheck !== void 0 && d3.from && d3.to && dateToCheck.getTime() >= d3.from.getTime() && dateToCheck.getTime() <= d3.to.getTime())
          return bool;
      }
      return !bool;
    }
    __name(isEnabled, "isEnabled");
    function isInView(elem) {
      if (self2.daysContainer !== void 0)
        return elem.className.indexOf("hidden") === -1 && elem.className.indexOf("flatpickr-disabled") === -1 && self2.daysContainer.contains(elem);
      return false;
    }
    __name(isInView, "isInView");
    function onBlur(e3) {
      var isInput = e3.target === self2._input;
      var valueChanged = self2._input.value.trimEnd() !== getDateStr();
      if (isInput && valueChanged && !(e3.relatedTarget && isCalendarElem(e3.relatedTarget))) {
        self2.setDate(self2._input.value, true, e3.target === self2.altInput ? self2.config.altFormat : self2.config.dateFormat);
      }
    }
    __name(onBlur, "onBlur");
    function onKeyDown(e3) {
      var eventTarget = getEventTarget2(e3);
      var isInput = self2.config.wrap ? element.contains(eventTarget) : eventTarget === self2._input;
      var allowInput = self2.config.allowInput;
      var allowKeydown = self2.isOpen && (!allowInput || !isInput);
      var allowInlineKeydown = self2.config.inline && isInput && !allowInput;
      if (e3.keyCode === 13 && isInput) {
        if (allowInput) {
          self2.setDate(self2._input.value, true, eventTarget === self2.altInput ? self2.config.altFormat : self2.config.dateFormat);
          self2.close();
          return eventTarget.blur();
        } else {
          self2.open();
        }
      } else if (isCalendarElem(eventTarget) || allowKeydown || allowInlineKeydown) {
        var isTimeObj = !!self2.timeContainer && self2.timeContainer.contains(eventTarget);
        switch (e3.keyCode) {
          case 13:
            if (isTimeObj) {
              e3.preventDefault();
              updateTime();
              focusAndClose();
            } else
              selectDate(e3);
            break;
          case 27:
            e3.preventDefault();
            focusAndClose();
            break;
          case 8:
          case 46:
            if (isInput && !self2.config.allowInput) {
              e3.preventDefault();
              self2.clear();
            }
            break;
          case 37:
          case 39:
            if (!isTimeObj && !isInput) {
              e3.preventDefault();
              var activeElement = getClosestActiveElement();
              if (self2.daysContainer !== void 0 && (allowInput === false || activeElement && isInView(activeElement))) {
                var delta_1 = e3.keyCode === 39 ? 1 : -1;
                if (!e3.ctrlKey)
                  focusOnDay(void 0, delta_1);
                else {
                  e3.stopPropagation();
                  changeMonth(delta_1);
                  focusOnDay(getFirstAvailableDay(1), 0);
                }
              }
            } else if (self2.hourElement)
              self2.hourElement.focus();
            break;
          case 38:
          case 40:
            e3.preventDefault();
            var delta = e3.keyCode === 40 ? 1 : -1;
            if (self2.daysContainer && eventTarget.$i !== void 0 || eventTarget === self2.input || eventTarget === self2.altInput) {
              if (e3.ctrlKey) {
                e3.stopPropagation();
                changeYear(self2.currentYear - delta);
                focusOnDay(getFirstAvailableDay(1), 0);
              } else if (!isTimeObj)
                focusOnDay(void 0, delta * 7);
            } else if (eventTarget === self2.currentYearElement) {
              changeYear(self2.currentYear - delta);
            } else if (self2.config.enableTime) {
              if (!isTimeObj && self2.hourElement)
                self2.hourElement.focus();
              updateTime(e3);
              self2._debouncedChange();
            }
            break;
          case 9:
            if (isTimeObj) {
              var elems = [
                self2.hourElement,
                self2.minuteElement,
                self2.secondElement,
                self2.amPM
              ].concat(self2.pluginElements).filter(function(x3) {
                return x3;
              });
              var i3 = elems.indexOf(eventTarget);
              if (i3 !== -1) {
                var target = elems[i3 + (e3.shiftKey ? -1 : 1)];
                e3.preventDefault();
                (target || self2._input).focus();
              }
            } else if (!self2.config.noCalendar && self2.daysContainer && self2.daysContainer.contains(eventTarget) && e3.shiftKey) {
              e3.preventDefault();
              self2._input.focus();
            }
            break;
          default:
            break;
        }
      }
      if (self2.amPM !== void 0 && eventTarget === self2.amPM) {
        switch (e3.key) {
          case self2.l10n.amPM[0].charAt(0):
          case self2.l10n.amPM[0].charAt(0).toLowerCase():
            self2.amPM.textContent = self2.l10n.amPM[0];
            setHoursFromInputs();
            updateValue();
            break;
          case self2.l10n.amPM[1].charAt(0):
          case self2.l10n.amPM[1].charAt(0).toLowerCase():
            self2.amPM.textContent = self2.l10n.amPM[1];
            setHoursFromInputs();
            updateValue();
            break;
        }
      }
      if (isInput || isCalendarElem(eventTarget)) {
        triggerEvent("onKeyDown", e3);
      }
    }
    __name(onKeyDown, "onKeyDown");
    function onMouseOver(elem, cellClass) {
      if (cellClass === void 0) {
        cellClass = "flatpickr-day";
      }
      if (self2.selectedDates.length !== 1 || elem && (!elem.classList.contains(cellClass) || elem.classList.contains("flatpickr-disabled")))
        return;
      var hoverDate = elem ? elem.dateObj.getTime() : self2.days.firstElementChild.dateObj.getTime(), initialDate = self2.parseDate(self2.selectedDates[0], void 0, true).getTime(), rangeStartDate = Math.min(hoverDate, self2.selectedDates[0].getTime()), rangeEndDate = Math.max(hoverDate, self2.selectedDates[0].getTime());
      var containsDisabled = false;
      var minRange = 0, maxRange = 0;
      for (var t3 = rangeStartDate; t3 < rangeEndDate; t3 += duration2.DAY) {
        if (!isEnabled(new Date(t3), true)) {
          containsDisabled = containsDisabled || t3 > rangeStartDate && t3 < rangeEndDate;
          if (t3 < initialDate && (!minRange || t3 > minRange))
            minRange = t3;
          else if (t3 > initialDate && (!maxRange || t3 < maxRange))
            maxRange = t3;
        }
      }
      var hoverableCells = Array.from(self2.rContainer.querySelectorAll("*:nth-child(-n+" + self2.config.showMonths + ") > ." + cellClass));
      hoverableCells.forEach(function(dayElem) {
        var date = dayElem.dateObj;
        var timestamp = date.getTime();
        var outOfRange = minRange > 0 && timestamp < minRange || maxRange > 0 && timestamp > maxRange;
        if (outOfRange) {
          dayElem.classList.add("notAllowed");
          ["inRange", "startRange", "endRange"].forEach(function(c3) {
            dayElem.classList.remove(c3);
          });
          return;
        } else if (containsDisabled && !outOfRange)
          return;
        ["startRange", "inRange", "endRange", "notAllowed"].forEach(function(c3) {
          dayElem.classList.remove(c3);
        });
        if (elem !== void 0) {
          elem.classList.add(hoverDate <= self2.selectedDates[0].getTime() ? "startRange" : "endRange");
          if (initialDate < hoverDate && timestamp === initialDate)
            dayElem.classList.add("startRange");
          else if (initialDate > hoverDate && timestamp === initialDate)
            dayElem.classList.add("endRange");
          if (timestamp >= minRange && (maxRange === 0 || timestamp <= maxRange) && isBetween2(timestamp, initialDate, hoverDate))
            dayElem.classList.add("inRange");
        }
      });
    }
    __name(onMouseOver, "onMouseOver");
    function onResize() {
      if (self2.isOpen && !self2.config.static && !self2.config.inline)
        positionCalendar();
    }
    __name(onResize, "onResize");
    function open(e3, positionElement) {
      if (positionElement === void 0) {
        positionElement = self2._positionElement;
      }
      if (self2.isMobile === true) {
        if (e3) {
          e3.preventDefault();
          var eventTarget = getEventTarget2(e3);
          if (eventTarget) {
            eventTarget.blur();
          }
        }
        if (self2.mobileInput !== void 0) {
          self2.mobileInput.focus();
          self2.mobileInput.click();
        }
        triggerEvent("onOpen");
        return;
      } else if (self2._input.disabled || self2.config.inline) {
        return;
      }
      var wasOpen = self2.isOpen;
      self2.isOpen = true;
      if (!wasOpen) {
        self2.calendarContainer.classList.add("open");
        self2._input.classList.add("active");
        triggerEvent("onOpen");
        positionCalendar(positionElement);
      }
      if (self2.config.enableTime === true && self2.config.noCalendar === true) {
        if (self2.config.allowInput === false && (e3 === void 0 || !self2.timeContainer.contains(e3.relatedTarget))) {
          setTimeout(function() {
            return self2.hourElement.select();
          }, 50);
        }
      }
    }
    __name(open, "open");
    function minMaxDateSetter(type) {
      return function(date) {
        var dateObj = self2.config["_" + type + "Date"] = self2.parseDate(date, self2.config.dateFormat);
        var inverseDateObj = self2.config["_" + (type === "min" ? "max" : "min") + "Date"];
        if (dateObj !== void 0) {
          self2[type === "min" ? "minDateHasTime" : "maxDateHasTime"] = dateObj.getHours() > 0 || dateObj.getMinutes() > 0 || dateObj.getSeconds() > 0;
        }
        if (self2.selectedDates) {
          self2.selectedDates = self2.selectedDates.filter(function(d3) {
            return isEnabled(d3);
          });
          if (!self2.selectedDates.length && type === "min")
            setHoursFromDate(dateObj);
          updateValue();
        }
        if (self2.daysContainer) {
          redraw();
          if (dateObj !== void 0)
            self2.currentYearElement[type] = dateObj.getFullYear().toString();
          else
            self2.currentYearElement.removeAttribute(type);
          self2.currentYearElement.disabled = !!inverseDateObj && dateObj !== void 0 && inverseDateObj.getFullYear() === dateObj.getFullYear();
        }
      };
    }
    __name(minMaxDateSetter, "minMaxDateSetter");
    function parseConfig() {
      var boolOpts = [
        "wrap",
        "weekNumbers",
        "allowInput",
        "allowInvalidPreload",
        "clickOpens",
        "time_24hr",
        "enableTime",
        "noCalendar",
        "altInput",
        "shorthandCurrentMonth",
        "inline",
        "static",
        "enableSeconds",
        "disableMobile"
      ];
      var userConfig = __assign2(__assign2({}, JSON.parse(JSON.stringify(element.dataset || {}))), instanceConfig);
      var formats3 = {};
      self2.config.parseDate = userConfig.parseDate;
      self2.config.formatDate = userConfig.formatDate;
      Object.defineProperty(self2.config, "enable", {
        get: function() {
          return self2.config._enable;
        },
        set: function(dates) {
          self2.config._enable = parseDateRules(dates);
        }
      });
      Object.defineProperty(self2.config, "disable", {
        get: function() {
          return self2.config._disable;
        },
        set: function(dates) {
          self2.config._disable = parseDateRules(dates);
        }
      });
      var timeMode = userConfig.mode === "time";
      if (!userConfig.dateFormat && (userConfig.enableTime || timeMode)) {
        var defaultDateFormat = flatpickr2.defaultConfig.dateFormat || defaults3.dateFormat;
        formats3.dateFormat = userConfig.noCalendar || timeMode ? "H:i" + (userConfig.enableSeconds ? ":S" : "") : defaultDateFormat + " H:i" + (userConfig.enableSeconds ? ":S" : "");
      }
      if (userConfig.altInput && (userConfig.enableTime || timeMode) && !userConfig.altFormat) {
        var defaultAltFormat = flatpickr2.defaultConfig.altFormat || defaults3.altFormat;
        formats3.altFormat = userConfig.noCalendar || timeMode ? "h:i" + (userConfig.enableSeconds ? ":S K" : " K") : defaultAltFormat + (" h:i" + (userConfig.enableSeconds ? ":S" : "") + " K");
      }
      Object.defineProperty(self2.config, "minDate", {
        get: function() {
          return self2.config._minDate;
        },
        set: minMaxDateSetter("min")
      });
      Object.defineProperty(self2.config, "maxDate", {
        get: function() {
          return self2.config._maxDate;
        },
        set: minMaxDateSetter("max")
      });
      var minMaxTimeSetter = /* @__PURE__ */ __name(function(type) {
        return function(val2) {
          self2.config[type === "min" ? "_minTime" : "_maxTime"] = self2.parseDate(val2, "H:i:S");
        };
      }, "minMaxTimeSetter");
      Object.defineProperty(self2.config, "minTime", {
        get: function() {
          return self2.config._minTime;
        },
        set: minMaxTimeSetter("min")
      });
      Object.defineProperty(self2.config, "maxTime", {
        get: function() {
          return self2.config._maxTime;
        },
        set: minMaxTimeSetter("max")
      });
      if (userConfig.mode === "time") {
        self2.config.noCalendar = true;
        self2.config.enableTime = true;
      }
      Object.assign(self2.config, formats3, userConfig);
      for (var i3 = 0; i3 < boolOpts.length; i3++)
        self2.config[boolOpts[i3]] = self2.config[boolOpts[i3]] === true || self2.config[boolOpts[i3]] === "true";
      HOOKS2.filter(function(hook) {
        return self2.config[hook] !== void 0;
      }).forEach(function(hook) {
        self2.config[hook] = arrayify2(self2.config[hook] || []).map(bindToInstance);
      });
      self2.isMobile = !self2.config.disableMobile && !self2.config.inline && self2.config.mode === "single" && !self2.config.disable.length && !self2.config.enable && !self2.config.weekNumbers && /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
      for (var i3 = 0; i3 < self2.config.plugins.length; i3++) {
        var pluginConf = self2.config.plugins[i3](self2) || {};
        for (var key in pluginConf) {
          if (HOOKS2.indexOf(key) > -1) {
            self2.config[key] = arrayify2(pluginConf[key]).map(bindToInstance).concat(self2.config[key]);
          } else if (typeof userConfig[key] === "undefined")
            self2.config[key] = pluginConf[key];
        }
      }
      if (!userConfig.altInputClass) {
        self2.config.altInputClass = getInputElem().className + " " + self2.config.altInputClass;
      }
      triggerEvent("onParseConfig");
    }
    __name(parseConfig, "parseConfig");
    function getInputElem() {
      return self2.config.wrap ? element.querySelector("[data-input]") : element;
    }
    __name(getInputElem, "getInputElem");
    function setupLocale() {
      if (typeof self2.config.locale !== "object" && typeof flatpickr2.l10ns[self2.config.locale] === "undefined")
        self2.config.errorHandler(new Error("flatpickr: invalid locale " + self2.config.locale));
      self2.l10n = __assign2(__assign2({}, flatpickr2.l10ns.default), typeof self2.config.locale === "object" ? self2.config.locale : self2.config.locale !== "default" ? flatpickr2.l10ns[self2.config.locale] : void 0);
      tokenRegex2.D = "(" + self2.l10n.weekdays.shorthand.join("|") + ")";
      tokenRegex2.l = "(" + self2.l10n.weekdays.longhand.join("|") + ")";
      tokenRegex2.M = "(" + self2.l10n.months.shorthand.join("|") + ")";
      tokenRegex2.F = "(" + self2.l10n.months.longhand.join("|") + ")";
      tokenRegex2.K = "(" + self2.l10n.amPM[0] + "|" + self2.l10n.amPM[1] + "|" + self2.l10n.amPM[0].toLowerCase() + "|" + self2.l10n.amPM[1].toLowerCase() + ")";
      var userConfig = __assign2(__assign2({}, instanceConfig), JSON.parse(JSON.stringify(element.dataset || {})));
      if (userConfig.time_24hr === void 0 && flatpickr2.defaultConfig.time_24hr === void 0) {
        self2.config.time_24hr = self2.l10n.time_24hr;
      }
      self2.formatDate = createDateFormatter2(self2);
      self2.parseDate = createDateParser2({ config: self2.config, l10n: self2.l10n });
    }
    __name(setupLocale, "setupLocale");
    function positionCalendar(customPositionElement) {
      if (typeof self2.config.position === "function") {
        return void self2.config.position(self2, customPositionElement);
      }
      if (self2.calendarContainer === void 0)
        return;
      triggerEvent("onPreCalendarPosition");
      var positionElement = customPositionElement || self2._positionElement;
      var calendarHeight = Array.prototype.reduce.call(self2.calendarContainer.children, function(acc, child) {
        return acc + child.offsetHeight;
      }, 0), calendarWidth = self2.calendarContainer.offsetWidth, configPos = self2.config.position.split(" "), configPosVertical = configPos[0], configPosHorizontal = configPos.length > 1 ? configPos[1] : null, inputBounds = positionElement.getBoundingClientRect(), distanceFromBottom = window.innerHeight - inputBounds.bottom, showOnTop = configPosVertical === "above" || configPosVertical !== "below" && distanceFromBottom < calendarHeight && inputBounds.top > calendarHeight;
      var top = window.pageYOffset + inputBounds.top + (!showOnTop ? positionElement.offsetHeight + 2 : -calendarHeight - 2);
      toggleClass3(self2.calendarContainer, "arrowTop", !showOnTop);
      toggleClass3(self2.calendarContainer, "arrowBottom", showOnTop);
      if (self2.config.inline)
        return;
      var left = window.pageXOffset + inputBounds.left;
      var isCenter = false;
      var isRight = false;
      if (configPosHorizontal === "center") {
        left -= (calendarWidth - inputBounds.width) / 2;
        isCenter = true;
      } else if (configPosHorizontal === "right") {
        left -= calendarWidth - inputBounds.width;
        isRight = true;
      }
      toggleClass3(self2.calendarContainer, "arrowLeft", !isCenter && !isRight);
      toggleClass3(self2.calendarContainer, "arrowCenter", isCenter);
      toggleClass3(self2.calendarContainer, "arrowRight", isRight);
      var right = window.document.body.offsetWidth - (window.pageXOffset + inputBounds.right);
      var rightMost = left + calendarWidth > window.document.body.offsetWidth;
      var centerMost = right + calendarWidth > window.document.body.offsetWidth;
      toggleClass3(self2.calendarContainer, "rightMost", rightMost);
      if (self2.config.static)
        return;
      self2.calendarContainer.style.top = top + "px";
      if (!rightMost) {
        self2.calendarContainer.style.left = left + "px";
        self2.calendarContainer.style.right = "auto";
      } else if (!centerMost) {
        self2.calendarContainer.style.left = "auto";
        self2.calendarContainer.style.right = right + "px";
      } else {
        var doc = getDocumentStyleSheet();
        if (doc === void 0)
          return;
        var bodyWidth = window.document.body.offsetWidth;
        var centerLeft = Math.max(0, bodyWidth / 2 - calendarWidth / 2);
        var centerBefore = ".flatpickr-calendar.centerMost:before";
        var centerAfter = ".flatpickr-calendar.centerMost:after";
        var centerIndex = doc.cssRules.length;
        var centerStyle = "{left:" + inputBounds.left + "px;right:auto;}";
        toggleClass3(self2.calendarContainer, "rightMost", false);
        toggleClass3(self2.calendarContainer, "centerMost", true);
        doc.insertRule(centerBefore + "," + centerAfter + centerStyle, centerIndex);
        self2.calendarContainer.style.left = centerLeft + "px";
        self2.calendarContainer.style.right = "auto";
      }
    }
    __name(positionCalendar, "positionCalendar");
    function getDocumentStyleSheet() {
      var editableSheet = null;
      for (var i3 = 0; i3 < document.styleSheets.length; i3++) {
        var sheet = document.styleSheets[i3];
        if (!sheet.cssRules)
          continue;
        try {
          sheet.cssRules;
        } catch (err) {
          continue;
        }
        editableSheet = sheet;
        break;
      }
      return editableSheet != null ? editableSheet : createStyleSheet();
    }
    __name(getDocumentStyleSheet, "getDocumentStyleSheet");
    function createStyleSheet() {
      var style = document.createElement("style");
      document.head.appendChild(style);
      return style.sheet;
    }
    __name(createStyleSheet, "createStyleSheet");
    function redraw() {
      if (self2.config.noCalendar || self2.isMobile)
        return;
      buildMonthSwitch();
      updateNavigationCurrentMonth();
      buildDays();
    }
    __name(redraw, "redraw");
    function focusAndClose() {
      self2._input.focus();
      if (window.navigator.userAgent.indexOf("MSIE") !== -1 || navigator.msMaxTouchPoints !== void 0) {
        setTimeout(self2.close, 0);
      } else {
        self2.close();
      }
    }
    __name(focusAndClose, "focusAndClose");
    function selectDate(e3) {
      e3.preventDefault();
      e3.stopPropagation();
      var isSelectable = /* @__PURE__ */ __name(function(day) {
        return day.classList && day.classList.contains("flatpickr-day") && !day.classList.contains("flatpickr-disabled") && !day.classList.contains("notAllowed");
      }, "isSelectable");
      var t3 = findParent2(getEventTarget2(e3), isSelectable);
      if (t3 === void 0)
        return;
      var target = t3;
      var selectedDate = self2.latestSelectedDateObj = new Date(target.dateObj.getTime());
      var shouldChangeMonth = (selectedDate.getMonth() < self2.currentMonth || selectedDate.getMonth() > self2.currentMonth + self2.config.showMonths - 1) && self2.config.mode !== "range";
      self2.selectedDateElem = target;
      if (self2.config.mode === "single")
        self2.selectedDates = [selectedDate];
      else if (self2.config.mode === "multiple") {
        var selectedIndex = isDateSelected(selectedDate);
        if (selectedIndex)
          self2.selectedDates.splice(parseInt(selectedIndex), 1);
        else
          self2.selectedDates.push(selectedDate);
      } else if (self2.config.mode === "range") {
        if (self2.selectedDates.length === 2) {
          self2.clear(false, false);
        }
        self2.latestSelectedDateObj = selectedDate;
        self2.selectedDates.push(selectedDate);
        if (compareDates2(selectedDate, self2.selectedDates[0], true) !== 0)
          self2.selectedDates.sort(function(a3, b3) {
            return a3.getTime() - b3.getTime();
          });
      }
      setHoursFromInputs();
      if (shouldChangeMonth) {
        var isNewYear = self2.currentYear !== selectedDate.getFullYear();
        self2.currentYear = selectedDate.getFullYear();
        self2.currentMonth = selectedDate.getMonth();
        if (isNewYear) {
          triggerEvent("onYearChange");
          buildMonthSwitch();
        }
        triggerEvent("onMonthChange");
      }
      updateNavigationCurrentMonth();
      buildDays();
      updateValue();
      if (!shouldChangeMonth && self2.config.mode !== "range" && self2.config.showMonths === 1)
        focusOnDayElem(target);
      else if (self2.selectedDateElem !== void 0 && self2.hourElement === void 0) {
        self2.selectedDateElem && self2.selectedDateElem.focus();
      }
      if (self2.hourElement !== void 0)
        self2.hourElement !== void 0 && self2.hourElement.focus();
      if (self2.config.closeOnSelect) {
        var single = self2.config.mode === "single" && !self2.config.enableTime;
        var range = self2.config.mode === "range" && self2.selectedDates.length === 2 && !self2.config.enableTime;
        if (single || range) {
          focusAndClose();
        }
      }
      triggerChange();
    }
    __name(selectDate, "selectDate");
    var CALLBACKS = {
      locale: [setupLocale, updateWeekdays],
      showMonths: [buildMonths, setCalendarWidth, buildWeekdays],
      minDate: [jumpToDate],
      maxDate: [jumpToDate],
      positionElement: [updatePositionElement],
      clickOpens: [
        function() {
          if (self2.config.clickOpens === true) {
            bind(self2._input, "focus", self2.open);
            bind(self2._input, "click", self2.open);
          } else {
            self2._input.removeEventListener("focus", self2.open);
            self2._input.removeEventListener("click", self2.open);
          }
        }
      ]
    };
    function set(option2, value) {
      if (option2 !== null && typeof option2 === "object") {
        Object.assign(self2.config, option2);
        for (var key in option2) {
          if (CALLBACKS[key] !== void 0)
            CALLBACKS[key].forEach(function(x3) {
              return x3();
            });
        }
      } else {
        self2.config[option2] = value;
        if (CALLBACKS[option2] !== void 0)
          CALLBACKS[option2].forEach(function(x3) {
            return x3();
          });
        else if (HOOKS2.indexOf(option2) > -1)
          self2.config[option2] = arrayify2(value);
      }
      self2.redraw();
      updateValue(true);
    }
    __name(set, "set");
    function setSelectedDate(inputDate, format) {
      var dates = [];
      if (inputDate instanceof Array)
        dates = inputDate.map(function(d3) {
          return self2.parseDate(d3, format);
        });
      else if (inputDate instanceof Date || typeof inputDate === "number")
        dates = [self2.parseDate(inputDate, format)];
      else if (typeof inputDate === "string") {
        switch (self2.config.mode) {
          case "single":
          case "time":
            dates = [self2.parseDate(inputDate, format)];
            break;
          case "multiple":
            dates = inputDate.split(self2.config.conjunction).map(function(date) {
              return self2.parseDate(date, format);
            });
            break;
          case "range":
            dates = inputDate.split(self2.l10n.rangeSeparator).map(function(date) {
              return self2.parseDate(date, format);
            });
            break;
          default:
            break;
        }
      } else
        self2.config.errorHandler(new Error("Invalid date supplied: " + JSON.stringify(inputDate)));
      self2.selectedDates = self2.config.allowInvalidPreload ? dates : dates.filter(function(d3) {
        return d3 instanceof Date && isEnabled(d3, false);
      });
      if (self2.config.mode === "range")
        self2.selectedDates.sort(function(a3, b3) {
          return a3.getTime() - b3.getTime();
        });
    }
    __name(setSelectedDate, "setSelectedDate");
    function setDate(date, triggerChange2, format) {
      if (triggerChange2 === void 0) {
        triggerChange2 = false;
      }
      if (format === void 0) {
        format = self2.config.dateFormat;
      }
      if (date !== 0 && !date || date instanceof Array && date.length === 0)
        return self2.clear(triggerChange2);
      setSelectedDate(date, format);
      self2.latestSelectedDateObj = self2.selectedDates[self2.selectedDates.length - 1];
      self2.redraw();
      jumpToDate(void 0, triggerChange2);
      setHoursFromDate();
      if (self2.selectedDates.length === 0) {
        self2.clear(false);
      }
      updateValue(triggerChange2);
      if (triggerChange2)
        triggerEvent("onChange");
    }
    __name(setDate, "setDate");
    function parseDateRules(arr) {
      return arr.slice().map(function(rule) {
        if (typeof rule === "string" || typeof rule === "number" || rule instanceof Date) {
          return self2.parseDate(rule, void 0, true);
        } else if (rule && typeof rule === "object" && rule.from && rule.to)
          return {
            from: self2.parseDate(rule.from, void 0),
            to: self2.parseDate(rule.to, void 0)
          };
        return rule;
      }).filter(function(x3) {
        return x3;
      });
    }
    __name(parseDateRules, "parseDateRules");
    function setupDates() {
      self2.selectedDates = [];
      self2.now = self2.parseDate(self2.config.now) || /* @__PURE__ */ new Date();
      var preloadedDate = self2.config.defaultDate || ((self2.input.nodeName === "INPUT" || self2.input.nodeName === "TEXTAREA") && self2.input.placeholder && self2.input.value === self2.input.placeholder ? null : self2.input.value);
      if (preloadedDate)
        setSelectedDate(preloadedDate, self2.config.dateFormat);
      self2._initialDate = self2.selectedDates.length > 0 ? self2.selectedDates[0] : self2.config.minDate && self2.config.minDate.getTime() > self2.now.getTime() ? self2.config.minDate : self2.config.maxDate && self2.config.maxDate.getTime() < self2.now.getTime() ? self2.config.maxDate : self2.now;
      self2.currentYear = self2._initialDate.getFullYear();
      self2.currentMonth = self2._initialDate.getMonth();
      if (self2.selectedDates.length > 0)
        self2.latestSelectedDateObj = self2.selectedDates[0];
      if (self2.config.minTime !== void 0)
        self2.config.minTime = self2.parseDate(self2.config.minTime, "H:i");
      if (self2.config.maxTime !== void 0)
        self2.config.maxTime = self2.parseDate(self2.config.maxTime, "H:i");
      self2.minDateHasTime = !!self2.config.minDate && (self2.config.minDate.getHours() > 0 || self2.config.minDate.getMinutes() > 0 || self2.config.minDate.getSeconds() > 0);
      self2.maxDateHasTime = !!self2.config.maxDate && (self2.config.maxDate.getHours() > 0 || self2.config.maxDate.getMinutes() > 0 || self2.config.maxDate.getSeconds() > 0);
    }
    __name(setupDates, "setupDates");
    function setupInputs() {
      self2.input = getInputElem();
      if (!self2.input) {
        self2.config.errorHandler(new Error("Invalid input element specified"));
        return;
      }
      self2.input._type = self2.input.type;
      self2.input.type = "text";
      self2.input.classList.add("flatpickr-input");
      self2._input = self2.input;
      if (self2.config.altInput) {
        self2.altInput = createElement2(self2.input.nodeName, self2.config.altInputClass);
        self2._input = self2.altInput;
        self2.altInput.placeholder = self2.input.placeholder;
        self2.altInput.disabled = self2.input.disabled;
        self2.altInput.required = self2.input.required;
        self2.altInput.tabIndex = self2.input.tabIndex;
        self2.altInput.type = "text";
        self2.input.setAttribute("type", "hidden");
        if (!self2.config.static && self2.input.parentNode)
          self2.input.parentNode.insertBefore(self2.altInput, self2.input.nextSibling);
      }
      if (!self2.config.allowInput)
        self2._input.setAttribute("readonly", "readonly");
      updatePositionElement();
    }
    __name(setupInputs, "setupInputs");
    function updatePositionElement() {
      self2._positionElement = self2.config.positionElement || self2._input;
    }
    __name(updatePositionElement, "updatePositionElement");
    function setupMobile() {
      var inputType = self2.config.enableTime ? self2.config.noCalendar ? "time" : "datetime-local" : "date";
      self2.mobileInput = createElement2("input", self2.input.className + " flatpickr-mobile");
      self2.mobileInput.tabIndex = 1;
      self2.mobileInput.type = inputType;
      self2.mobileInput.disabled = self2.input.disabled;
      self2.mobileInput.required = self2.input.required;
      self2.mobileInput.placeholder = self2.input.placeholder;
      self2.mobileFormatStr = inputType === "datetime-local" ? "Y-m-d\\TH:i:S" : inputType === "date" ? "Y-m-d" : "H:i:S";
      if (self2.selectedDates.length > 0) {
        self2.mobileInput.defaultValue = self2.mobileInput.value = self2.formatDate(self2.selectedDates[0], self2.mobileFormatStr);
      }
      if (self2.config.minDate)
        self2.mobileInput.min = self2.formatDate(self2.config.minDate, "Y-m-d");
      if (self2.config.maxDate)
        self2.mobileInput.max = self2.formatDate(self2.config.maxDate, "Y-m-d");
      if (self2.input.getAttribute("step"))
        self2.mobileInput.step = String(self2.input.getAttribute("step"));
      self2.input.type = "hidden";
      if (self2.altInput !== void 0)
        self2.altInput.type = "hidden";
      try {
        if (self2.input.parentNode)
          self2.input.parentNode.insertBefore(self2.mobileInput, self2.input.nextSibling);
      } catch (_a) {
      }
      bind(self2.mobileInput, "change", function(e3) {
        self2.setDate(getEventTarget2(e3).value, false, self2.mobileFormatStr);
        triggerEvent("onChange");
        triggerEvent("onClose");
      });
    }
    __name(setupMobile, "setupMobile");
    function toggle(e3) {
      if (self2.isOpen === true)
        return self2.close();
      self2.open(e3);
    }
    __name(toggle, "toggle");
    function triggerEvent(event, data) {
      if (self2.config === void 0)
        return;
      var hooks = self2.config[event];
      if (hooks !== void 0 && hooks.length > 0) {
        for (var i3 = 0; hooks[i3] && i3 < hooks.length; i3++)
          hooks[i3](self2.selectedDates, self2.input.value, self2, data);
      }
      if (event === "onChange") {
        self2.input.dispatchEvent(createEvent("change"));
        self2.input.dispatchEvent(createEvent("input"));
      }
    }
    __name(triggerEvent, "triggerEvent");
    function createEvent(name) {
      var e3 = document.createEvent("Event");
      e3.initEvent(name, true, true);
      return e3;
    }
    __name(createEvent, "createEvent");
    function isDateSelected(date) {
      for (var i3 = 0; i3 < self2.selectedDates.length; i3++) {
        var selectedDate = self2.selectedDates[i3];
        if (selectedDate instanceof Date && compareDates2(selectedDate, date) === 0)
          return "" + i3;
      }
      return false;
    }
    __name(isDateSelected, "isDateSelected");
    function isDateInRange(date) {
      if (self2.config.mode !== "range" || self2.selectedDates.length < 2)
        return false;
      return compareDates2(date, self2.selectedDates[0]) >= 0 && compareDates2(date, self2.selectedDates[1]) <= 0;
    }
    __name(isDateInRange, "isDateInRange");
    function updateNavigationCurrentMonth() {
      if (self2.config.noCalendar || self2.isMobile || !self2.monthNav)
        return;
      self2.yearElements.forEach(function(yearElement, i3) {
        var d3 = new Date(self2.currentYear, self2.currentMonth, 1);
        d3.setMonth(self2.currentMonth + i3);
        if (self2.config.showMonths > 1 || self2.config.monthSelectorType === "static") {
          self2.monthElements[i3].textContent = monthToStr2(d3.getMonth(), self2.config.shorthandCurrentMonth, self2.l10n) + " ";
        } else {
          self2.monthsDropdownContainer.value = d3.getMonth().toString();
        }
        yearElement.value = d3.getFullYear().toString();
      });
      self2._hidePrevMonthArrow = self2.config.minDate !== void 0 && (self2.currentYear === self2.config.minDate.getFullYear() ? self2.currentMonth <= self2.config.minDate.getMonth() : self2.currentYear < self2.config.minDate.getFullYear());
      self2._hideNextMonthArrow = self2.config.maxDate !== void 0 && (self2.currentYear === self2.config.maxDate.getFullYear() ? self2.currentMonth + 1 > self2.config.maxDate.getMonth() : self2.currentYear > self2.config.maxDate.getFullYear());
    }
    __name(updateNavigationCurrentMonth, "updateNavigationCurrentMonth");
    function getDateStr(specificFormat) {
      var format = specificFormat || (self2.config.altInput ? self2.config.altFormat : self2.config.dateFormat);
      return self2.selectedDates.map(function(dObj) {
        return self2.formatDate(dObj, format);
      }).filter(function(d3, i3, arr) {
        return self2.config.mode !== "range" || self2.config.enableTime || arr.indexOf(d3) === i3;
      }).join(self2.config.mode !== "range" ? self2.config.conjunction : self2.l10n.rangeSeparator);
    }
    __name(getDateStr, "getDateStr");
    function updateValue(triggerChange2) {
      if (triggerChange2 === void 0) {
        triggerChange2 = true;
      }
      if (self2.mobileInput !== void 0 && self2.mobileFormatStr) {
        self2.mobileInput.value = self2.latestSelectedDateObj !== void 0 ? self2.formatDate(self2.latestSelectedDateObj, self2.mobileFormatStr) : "";
      }
      self2.input.value = getDateStr(self2.config.dateFormat);
      if (self2.altInput !== void 0) {
        self2.altInput.value = getDateStr(self2.config.altFormat);
      }
      if (triggerChange2 !== false)
        triggerEvent("onValueUpdate");
    }
    __name(updateValue, "updateValue");
    function onMonthNavClick(e3) {
      var eventTarget = getEventTarget2(e3);
      var isPrevMonth = self2.prevMonthNav.contains(eventTarget);
      var isNextMonth = self2.nextMonthNav.contains(eventTarget);
      if (isPrevMonth || isNextMonth) {
        changeMonth(isPrevMonth ? -1 : 1);
      } else if (self2.yearElements.indexOf(eventTarget) >= 0) {
        eventTarget.select();
      } else if (eventTarget.classList.contains("arrowUp")) {
        self2.changeYear(self2.currentYear + 1);
      } else if (eventTarget.classList.contains("arrowDown")) {
        self2.changeYear(self2.currentYear - 1);
      }
    }
    __name(onMonthNavClick, "onMonthNavClick");
    function timeWrapper(e3) {
      e3.preventDefault();
      var isKeyDown = e3.type === "keydown", eventTarget = getEventTarget2(e3), input = eventTarget;
      if (self2.amPM !== void 0 && eventTarget === self2.amPM) {
        self2.amPM.textContent = self2.l10n.amPM[int2(self2.amPM.textContent === self2.l10n.amPM[0])];
      }
      var min = parseFloat(input.getAttribute("min")), max = parseFloat(input.getAttribute("max")), step = parseFloat(input.getAttribute("step")), curValue = parseInt(input.value, 10), delta = e3.delta || (isKeyDown ? e3.which === 38 ? 1 : -1 : 0);
      var newValue = curValue + step * delta;
      if (typeof input.value !== "undefined" && input.value.length === 2) {
        var isHourElem = input === self2.hourElement, isMinuteElem = input === self2.minuteElement;
        if (newValue < min) {
          newValue = max + newValue + int2(!isHourElem) + (int2(isHourElem) && int2(!self2.amPM));
          if (isMinuteElem)
            incrementNumInput(void 0, -1, self2.hourElement);
        } else if (newValue > max) {
          newValue = input === self2.hourElement ? newValue - max - int2(!self2.amPM) : min;
          if (isMinuteElem)
            incrementNumInput(void 0, 1, self2.hourElement);
        }
        if (self2.amPM && isHourElem && (step === 1 ? newValue + curValue === 23 : Math.abs(newValue - curValue) > step)) {
          self2.amPM.textContent = self2.l10n.amPM[int2(self2.amPM.textContent === self2.l10n.amPM[0])];
        }
        input.value = pad2(newValue);
      }
    }
    __name(timeWrapper, "timeWrapper");
    init2();
    return self2;
  }
  __name(FlatpickrInstance2, "FlatpickrInstance");
  function _flatpickr2(nodeList, config4) {
    var nodes = Array.prototype.slice.call(nodeList).filter(function(x3) {
      return x3 instanceof HTMLElement;
    });
    var instances = [];
    for (var i3 = 0; i3 < nodes.length; i3++) {
      var node = nodes[i3];
      try {
        if (node.getAttribute("data-fp-omit") !== null)
          continue;
        if (node._flatpickr !== void 0) {
          node._flatpickr.destroy();
          node._flatpickr = void 0;
        }
        node._flatpickr = FlatpickrInstance2(node, config4 || {});
        instances.push(node._flatpickr);
      } catch (e3) {
        console.error(e3);
      }
    }
    return instances.length === 1 ? instances[0] : instances;
  }
  __name(_flatpickr2, "_flatpickr");
  if (typeof HTMLElement !== "undefined" && typeof HTMLCollection !== "undefined" && typeof NodeList !== "undefined") {
    HTMLCollection.prototype.flatpickr = NodeList.prototype.flatpickr = function(config4) {
      return _flatpickr2(this, config4);
    };
    HTMLElement.prototype.flatpickr = function(config4) {
      return _flatpickr2([this], config4);
    };
  }
  var flatpickr2 = /* @__PURE__ */ __name(function(selector, config4) {
    if (typeof selector === "string") {
      return _flatpickr2(window.document.querySelectorAll(selector), config4);
    } else if (selector instanceof Node) {
      return _flatpickr2([selector], config4);
    } else {
      return _flatpickr2(selector, config4);
    }
  }, "flatpickr");
  flatpickr2.defaultConfig = {};
  flatpickr2.l10ns = {
    en: __assign2({}, default_default2),
    default: __assign2({}, default_default2)
  };
  flatpickr2.localize = function(l10n) {
    flatpickr2.l10ns.default = __assign2(__assign2({}, flatpickr2.l10ns.default), l10n);
  };
  flatpickr2.setDefaults = function(config4) {
    flatpickr2.defaultConfig = __assign2(__assign2({}, flatpickr2.defaultConfig), config4);
  };
  flatpickr2.parseDate = createDateParser2({});
  flatpickr2.formatDate = createDateFormatter2({});
  flatpickr2.compareDates = compareDates2;
  if (typeof jQuery !== "undefined" && typeof jQuery.fn !== "undefined") {
    jQuery.fn.flatpickr = function(config4) {
      return _flatpickr2(this, config4);
    };
  }
  Date.prototype.fp_incr = function(days) {
    return new Date(this.getFullYear(), this.getMonth(), this.getDate() + (typeof days === "string" ? parseInt(days, 10) : days));
  };
  if (typeof window !== "undefined") {
    window.flatpickr = flatpickr2;
  }

  // ../highway/app/javascript/admin/lead_dialog_controller.js
  var LeadDialogController = class extends Controller2 {
    static {
      __name(this, "LeadDialogController");
    }
    static targets = ["dialog"];
    openDialog() {
      this.dialogTarget.showModal();
    }
    closeDialog() {
      this.dialogTarget.close();
    }
  };

  // ../highway/app/javascript/admin/lead_filters_controller.js
  var LeadFiltersController = class extends Controller2 {
    static {
      __name(this, "LeadFiltersController");
    }
    static targets = ["filter"];
    connect() {
      console.log(this.filterTargets);
    }
  };

  // ../highway/app/javascript/admin/lead_group_controller.js
  var LeadGroupController = class extends Controller2 {
    static {
      __name(this, "LeadGroupController");
    }
    connect() {
      this.sortable = sortable_core_esm_default.create(this, {
        animation: 150,
        group: "lead_groups",
        onEnd: this.onReorder.bind(this)
      });
    }
    createPatchForm(values) {
      let inputs = "";
      for (var i3 in values) {
        inputs += `<input type="hidden" name="lead[${i3}]" value="${values[i3]}">`;
      }
      const f3 = `<form><input type="hidden" name="_method" value="PATCH" />${inputs}</form>`;
      const parser = new DOMParser();
      return parser.parseFromString(f3, "text/html").querySelector("form");
    }
    getCookieValue(cookieName) {
      if (cookieName != null) {
        const cookies = document.cookie ? document.cookie.split("; ") : [];
        const cookie = cookies.find((cookie2) => cookie2.startsWith(cookieName));
        if (cookie) {
          const value = cookie.split("=").slice(1).join("=");
          return value ? decodeURIComponent(value) : void 0;
        }
      }
    }
    getMetaContent(name) {
      const element = document.querySelector(`meta[name="${name}"]`);
      return element && element.content;
    }
    async performSubmit(form, id) {
      const token = this.getCookieValue(this.getMetaContent("csrf-param")) || this.getMetaContent("csrf-token");
      const data = new FormData(form);
      const strippedId = id.replace("lead_", "");
      return fetch(`/admin/my_leads/${strippedId}`, {
        method: "POST",
        headers: { "Accept": "application/json", "X-CSRF-Token": token },
        body: data
      });
    }
    alertErrorResponse(item) {
      return async function(response) {
        if (response.status == 200) {
          window.Turbo.renderStreamMessage(await response.text());
        } else {
          const json = await response.json();
          alert("Ett fel uppstod!\n" + json.errors);
        }
      };
    }
    async onReorder(e3) {
      const f3 = this.createPatchForm({ status: e3.to.dataset["groupName"], position: e3.newIndex + 1 });
      await this.performSubmit(f3, e3.item.id).then(this.alertErrorResponse(e3.item));
    }
  };

  // ../highway/app/javascript/admin/leaflet_controller.js
  var import_leaflet = __toESM(require_leaflet_src());
  var LeafletController = class extends Controller2 {
    static {
      __name(this, "LeafletController");
    }
    connect() {
      this.markers = JSON.parse(this.dataset["markers"]);
      if (this.markers.length) {
        this.initializeMap();
        this.addMarkers();
        this.setZoomLevel();
      }
    }
    initializeMap() {
      this.map = import_leaflet.default.map(this.firstElementChild);
      import_leaflet.default.tileLayer("https://tile.openstreetmap.org/{z}/{x}/{y}.png", {
        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
      }).addTo(this.map);
    }
    addMarkers() {
      this.markers.forEach(this.addMarker.bind(this));
    }
    addMarker(marker) {
      if (marker.c) {
        const m3 = import_leaflet.default.marker(marker.c).addTo(this.map);
        const pop = `<a href="${marker.e}" target="_blank">${marker.n}</a><br><span>${marker.l}</span><br>`;
        m3.bindPopup(pop);
      } else {
        import_leaflet.default.marker(marker).addTo(this.map);
      }
    }
    markerCoordinates() {
      if (this.markers[0].c) {
        return this.markers.map((m3) => m3.c);
      }
      return this.markers;
    }
    setZoomLevel() {
      if (this.markers.length > 1) {
        this.map.fitBounds(this.markerCoordinates());
      } else {
        this.map.setView(this.markers[0], 7);
      }
    }
  };

  // ../highway/app/javascript/admin/past_closed_at_controller.js
  var PastClosedAtController = class extends Controller2 {
    static {
      __name(this, "PastClosedAtController");
    }
    onSubmit(e3) {
      const date = this.closedAtDate();
      if (date - Date.now() <= 0) {
        const really = confirm("Vill du verkligen spara auktionen med ett st\xE4ngningsdatum som passerats?");
        if (really == false) {
          e3.preventDefault();
        }
      }
    }
    closedAtDate() {
      return Date.parse(document.getElementById("auction_closed_at").value);
    }
  };

  // app/javascript/controllers/relation_search_controller.js
  var import_debounce3 = __toESM(require_debounce());
  var RelationSearchController = class extends Controller {
    static {
      __name(this, "RelationSearchController");
    }
    static targets = ["field", "visibleField", "results"];
    static values = { model: String };
    connect() {
      this.debouncedFetchData = (0, import_debounce3.default)(this.fetchData.bind(this), 500);
    }
    change(e3) {
      this.debouncedFetchData(e3.target.value);
    }
    fetchData(text, update) {
      fetch("/admin/relations?" + new URLSearchParams({ m: this.modelValue, q: text })).then((response) => response.text()).then((response) => this.display(response));
    }
    display(response) {
      this.resultsTarget.innerHTML = response;
      this.bindNewActions(this.resultsTarget);
    }
    bindNewActions(el) {
      const actionElements = Array.from(el.querySelectorAll("[data-action]"));
      const actions = actionElements.flatMap(this.parseAction.bind(this));
      actions.forEach(this.bindAction.bind(this));
    }
    select(e3) {
      const item = e3.currentTarget;
      this.visibleFieldTarget.value = item.getAttribute("name");
      this.fieldTarget.value = item.id;
      this.resultsTarget.innerHTML = "";
    }
  };

  // ../highway/app/javascript/admin/reserve_guard_controller.js
  var ReserveGuardController = class extends Controller2 {
    static {
      __name(this, "ReserveGuardController");
    }
    onSubmit(e3) {
      const field = document.getElementById("auction_reserve_price_without_cents");
      const cash = parseInt(field.value.replace(" ", ""));
      if (cash < 1e5) {
        const really = confirm(
          "Reserv f\xF6r den h\xE4r auktionen \xE4r l\xE4gre \xE4n 100.000SEK. Vill du fortfarande spara?"
        );
        if (really == false) {
          e3.preventDefault();
        }
      }
    }
  };

  // node_modules/lodash-es/_freeGlobal.js
  var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
  var freeGlobal_default = freeGlobal;

  // node_modules/lodash-es/_root.js
  var freeSelf = typeof self == "object" && self && self.Object === Object && self;
  var root = freeGlobal_default || freeSelf || Function("return this")();
  var root_default = root;

  // node_modules/lodash-es/_Symbol.js
  var Symbol2 = root_default.Symbol;
  var Symbol_default = Symbol2;

  // node_modules/lodash-es/_getRawTag.js
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var nativeObjectToString = objectProto.toString;
  var symToStringTag = Symbol_default ? Symbol_default.toStringTag : void 0;
  function getRawTag(value) {
    var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
    try {
      value[symToStringTag] = void 0;
      var unmasked = true;
    } catch (e3) {
    }
    var result = nativeObjectToString.call(value);
    if (unmasked) {
      if (isOwn) {
        value[symToStringTag] = tag;
      } else {
        delete value[symToStringTag];
      }
    }
    return result;
  }
  __name(getRawTag, "getRawTag");
  var getRawTag_default = getRawTag;

  // node_modules/lodash-es/_objectToString.js
  var objectProto2 = Object.prototype;
  var nativeObjectToString2 = objectProto2.toString;
  function objectToString(value) {
    return nativeObjectToString2.call(value);
  }
  __name(objectToString, "objectToString");
  var objectToString_default = objectToString;

  // node_modules/lodash-es/_baseGetTag.js
  var nullTag = "[object Null]";
  var undefinedTag = "[object Undefined]";
  var symToStringTag2 = Symbol_default ? Symbol_default.toStringTag : void 0;
  function baseGetTag(value) {
    if (value == null) {
      return value === void 0 ? undefinedTag : nullTag;
    }
    return symToStringTag2 && symToStringTag2 in Object(value) ? getRawTag_default(value) : objectToString_default(value);
  }
  __name(baseGetTag, "baseGetTag");
  var baseGetTag_default = baseGetTag;

  // node_modules/lodash-es/isObjectLike.js
  function isObjectLike(value) {
    return value != null && typeof value == "object";
  }
  __name(isObjectLike, "isObjectLike");
  var isObjectLike_default = isObjectLike;

  // node_modules/lodash-es/isArray.js
  var isArray = Array.isArray;
  var isArray_default = isArray;

  // node_modules/lodash-es/isObject.js
  function isObject(value) {
    var type = typeof value;
    return value != null && (type == "object" || type == "function");
  }
  __name(isObject, "isObject");
  var isObject_default = isObject;

  // node_modules/lodash-es/identity.js
  function identity(value) {
    return value;
  }
  __name(identity, "identity");
  var identity_default = identity;

  // node_modules/lodash-es/isFunction.js
  var asyncTag = "[object AsyncFunction]";
  var funcTag = "[object Function]";
  var genTag = "[object GeneratorFunction]";
  var proxyTag = "[object Proxy]";
  function isFunction(value) {
    if (!isObject_default(value)) {
      return false;
    }
    var tag = baseGetTag_default(value);
    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
  }
  __name(isFunction, "isFunction");
  var isFunction_default = isFunction;

  // node_modules/lodash-es/_coreJsData.js
  var coreJsData = root_default["__core-js_shared__"];
  var coreJsData_default = coreJsData;

  // node_modules/lodash-es/_isMasked.js
  var maskSrcKey = function() {
    var uid = /[^.]+$/.exec(coreJsData_default && coreJsData_default.keys && coreJsData_default.keys.IE_PROTO || "");
    return uid ? "Symbol(src)_1." + uid : "";
  }();
  function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
  }
  __name(isMasked, "isMasked");
  var isMasked_default = isMasked;

  // node_modules/lodash-es/_toSource.js
  var funcProto = Function.prototype;
  var funcToString = funcProto.toString;
  function toSource(func) {
    if (func != null) {
      try {
        return funcToString.call(func);
      } catch (e3) {
      }
      try {
        return func + "";
      } catch (e3) {
      }
    }
    return "";
  }
  __name(toSource, "toSource");
  var toSource_default = toSource;

  // node_modules/lodash-es/_baseIsNative.js
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
  var reIsHostCtor = /^\[object .+?Constructor\]$/;
  var funcProto2 = Function.prototype;
  var objectProto3 = Object.prototype;
  var funcToString2 = funcProto2.toString;
  var hasOwnProperty2 = objectProto3.hasOwnProperty;
  var reIsNative = RegExp(
    "^" + funcToString2.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  );
  function baseIsNative(value) {
    if (!isObject_default(value) || isMasked_default(value)) {
      return false;
    }
    var pattern = isFunction_default(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource_default(value));
  }
  __name(baseIsNative, "baseIsNative");
  var baseIsNative_default = baseIsNative;

  // node_modules/lodash-es/_getValue.js
  function getValue(object, key) {
    return object == null ? void 0 : object[key];
  }
  __name(getValue, "getValue");
  var getValue_default = getValue;

  // node_modules/lodash-es/_getNative.js
  function getNative(object, key) {
    var value = getValue_default(object, key);
    return baseIsNative_default(value) ? value : void 0;
  }
  __name(getNative, "getNative");
  var getNative_default = getNative;

  // node_modules/lodash-es/_WeakMap.js
  var WeakMap2 = getNative_default(root_default, "WeakMap");
  var WeakMap_default = WeakMap2;

  // node_modules/lodash-es/_baseCreate.js
  var objectCreate = Object.create;
  var baseCreate = /* @__PURE__ */ function() {
    function object() {
    }
    __name(object, "object");
    return function(proto) {
      if (!isObject_default(proto)) {
        return {};
      }
      if (objectCreate) {
        return objectCreate(proto);
      }
      object.prototype = proto;
      var result = new object();
      object.prototype = void 0;
      return result;
    };
  }();
  var baseCreate_default = baseCreate;

  // node_modules/lodash-es/_apply.js
  function apply(func, thisArg, args) {
    switch (args.length) {
      case 0:
        return func.call(thisArg);
      case 1:
        return func.call(thisArg, args[0]);
      case 2:
        return func.call(thisArg, args[0], args[1]);
      case 3:
        return func.call(thisArg, args[0], args[1], args[2]);
    }
    return func.apply(thisArg, args);
  }
  __name(apply, "apply");
  var apply_default = apply;

  // node_modules/lodash-es/_copyArray.js
  function copyArray(source, array) {
    var index2 = -1, length = source.length;
    array || (array = Array(length));
    while (++index2 < length) {
      array[index2] = source[index2];
    }
    return array;
  }
  __name(copyArray, "copyArray");
  var copyArray_default = copyArray;

  // node_modules/lodash-es/_shortOut.js
  var HOT_COUNT = 800;
  var HOT_SPAN = 16;
  var nativeNow = Date.now;
  function shortOut(func) {
    var count = 0, lastCalled = 0;
    return function() {
      var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
      lastCalled = stamp;
      if (remaining > 0) {
        if (++count >= HOT_COUNT) {
          return arguments[0];
        }
      } else {
        count = 0;
      }
      return func.apply(void 0, arguments);
    };
  }
  __name(shortOut, "shortOut");
  var shortOut_default = shortOut;

  // node_modules/lodash-es/constant.js
  function constant(value) {
    return function() {
      return value;
    };
  }
  __name(constant, "constant");
  var constant_default = constant;

  // node_modules/lodash-es/_defineProperty.js
  var defineProperty = function() {
    try {
      var func = getNative_default(Object, "defineProperty");
      func({}, "", {});
      return func;
    } catch (e3) {
    }
  }();
  var defineProperty_default = defineProperty;

  // node_modules/lodash-es/_baseSetToString.js
  var baseSetToString = !defineProperty_default ? identity_default : function(func, string) {
    return defineProperty_default(func, "toString", {
      "configurable": true,
      "enumerable": false,
      "value": constant_default(string),
      "writable": true
    });
  };
  var baseSetToString_default = baseSetToString;

  // node_modules/lodash-es/_setToString.js
  var setToString = shortOut_default(baseSetToString_default);
  var setToString_default = setToString;

  // node_modules/lodash-es/_arrayEach.js
  function arrayEach(array, iteratee) {
    var index2 = -1, length = array == null ? 0 : array.length;
    while (++index2 < length) {
      if (iteratee(array[index2], index2, array) === false) {
        break;
      }
    }
    return array;
  }
  __name(arrayEach, "arrayEach");
  var arrayEach_default = arrayEach;

  // node_modules/lodash-es/_isIndex.js
  var MAX_SAFE_INTEGER = 9007199254740991;
  var reIsUint = /^(?:0|[1-9]\d*)$/;
  function isIndex(value, length) {
    var type = typeof value;
    length = length == null ? MAX_SAFE_INTEGER : length;
    return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
  }
  __name(isIndex, "isIndex");
  var isIndex_default = isIndex;

  // node_modules/lodash-es/_baseAssignValue.js
  function baseAssignValue(object, key, value) {
    if (key == "__proto__" && defineProperty_default) {
      defineProperty_default(object, key, {
        "configurable": true,
        "enumerable": true,
        "value": value,
        "writable": true
      });
    } else {
      object[key] = value;
    }
  }
  __name(baseAssignValue, "baseAssignValue");
  var baseAssignValue_default = baseAssignValue;

  // node_modules/lodash-es/eq.js
  function eq(value, other) {
    return value === other || value !== value && other !== other;
  }
  __name(eq, "eq");
  var eq_default = eq;

  // node_modules/lodash-es/_assignValue.js
  var objectProto4 = Object.prototype;
  var hasOwnProperty3 = objectProto4.hasOwnProperty;
  function assignValue(object, key, value) {
    var objValue = object[key];
    if (!(hasOwnProperty3.call(object, key) && eq_default(objValue, value)) || value === void 0 && !(key in object)) {
      baseAssignValue_default(object, key, value);
    }
  }
  __name(assignValue, "assignValue");
  var assignValue_default = assignValue;

  // node_modules/lodash-es/_copyObject.js
  function copyObject(source, props, object, customizer) {
    var isNew = !object;
    object || (object = {});
    var index2 = -1, length = props.length;
    while (++index2 < length) {
      var key = props[index2];
      var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
      if (newValue === void 0) {
        newValue = source[key];
      }
      if (isNew) {
        baseAssignValue_default(object, key, newValue);
      } else {
        assignValue_default(object, key, newValue);
      }
    }
    return object;
  }
  __name(copyObject, "copyObject");
  var copyObject_default = copyObject;

  // node_modules/lodash-es/_overRest.js
  var nativeMax = Math.max;
  function overRest(func, start2, transform) {
    start2 = nativeMax(start2 === void 0 ? func.length - 1 : start2, 0);
    return function() {
      var args = arguments, index2 = -1, length = nativeMax(args.length - start2, 0), array = Array(length);
      while (++index2 < length) {
        array[index2] = args[start2 + index2];
      }
      index2 = -1;
      var otherArgs = Array(start2 + 1);
      while (++index2 < start2) {
        otherArgs[index2] = args[index2];
      }
      otherArgs[start2] = transform(array);
      return apply_default(func, this, otherArgs);
    };
  }
  __name(overRest, "overRest");
  var overRest_default = overRest;

  // node_modules/lodash-es/_baseRest.js
  function baseRest(func, start2) {
    return setToString_default(overRest_default(func, start2, identity_default), func + "");
  }
  __name(baseRest, "baseRest");
  var baseRest_default = baseRest;

  // node_modules/lodash-es/isLength.js
  var MAX_SAFE_INTEGER2 = 9007199254740991;
  function isLength(value) {
    return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER2;
  }
  __name(isLength, "isLength");
  var isLength_default = isLength;

  // node_modules/lodash-es/isArrayLike.js
  function isArrayLike(value) {
    return value != null && isLength_default(value.length) && !isFunction_default(value);
  }
  __name(isArrayLike, "isArrayLike");
  var isArrayLike_default = isArrayLike;

  // node_modules/lodash-es/_isIterateeCall.js
  function isIterateeCall(value, index2, object) {
    if (!isObject_default(object)) {
      return false;
    }
    var type = typeof index2;
    if (type == "number" ? isArrayLike_default(object) && isIndex_default(index2, object.length) : type == "string" && index2 in object) {
      return eq_default(object[index2], value);
    }
    return false;
  }
  __name(isIterateeCall, "isIterateeCall");
  var isIterateeCall_default = isIterateeCall;

  // node_modules/lodash-es/_createAssigner.js
  function createAssigner(assigner) {
    return baseRest_default(function(object, sources) {
      var index2 = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
      customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
      if (guard && isIterateeCall_default(sources[0], sources[1], guard)) {
        customizer = length < 3 ? void 0 : customizer;
        length = 1;
      }
      object = Object(object);
      while (++index2 < length) {
        var source = sources[index2];
        if (source) {
          assigner(object, source, index2, customizer);
        }
      }
      return object;
    });
  }
  __name(createAssigner, "createAssigner");
  var createAssigner_default = createAssigner;

  // node_modules/lodash-es/_isPrototype.js
  var objectProto5 = Object.prototype;
  function isPrototype(value) {
    var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto5;
    return value === proto;
  }
  __name(isPrototype, "isPrototype");
  var isPrototype_default = isPrototype;

  // node_modules/lodash-es/_baseTimes.js
  function baseTimes(n3, iteratee) {
    var index2 = -1, result = Array(n3);
    while (++index2 < n3) {
      result[index2] = iteratee(index2);
    }
    return result;
  }
  __name(baseTimes, "baseTimes");
  var baseTimes_default = baseTimes;

  // node_modules/lodash-es/_baseIsArguments.js
  var argsTag = "[object Arguments]";
  function baseIsArguments(value) {
    return isObjectLike_default(value) && baseGetTag_default(value) == argsTag;
  }
  __name(baseIsArguments, "baseIsArguments");
  var baseIsArguments_default = baseIsArguments;

  // node_modules/lodash-es/isArguments.js
  var objectProto6 = Object.prototype;
  var hasOwnProperty4 = objectProto6.hasOwnProperty;
  var propertyIsEnumerable = objectProto6.propertyIsEnumerable;
  var isArguments = baseIsArguments_default(/* @__PURE__ */ function() {
    return arguments;
  }()) ? baseIsArguments_default : function(value) {
    return isObjectLike_default(value) && hasOwnProperty4.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
  };
  var isArguments_default = isArguments;

  // node_modules/lodash-es/stubFalse.js
  function stubFalse() {
    return false;
  }
  __name(stubFalse, "stubFalse");
  var stubFalse_default = stubFalse;

  // node_modules/lodash-es/isBuffer.js
  var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
  var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var Buffer2 = moduleExports ? root_default.Buffer : void 0;
  var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
  var isBuffer = nativeIsBuffer || stubFalse_default;
  var isBuffer_default = isBuffer;

  // node_modules/lodash-es/_baseIsTypedArray.js
  var argsTag2 = "[object Arguments]";
  var arrayTag = "[object Array]";
  var boolTag = "[object Boolean]";
  var dateTag = "[object Date]";
  var errorTag = "[object Error]";
  var funcTag2 = "[object Function]";
  var mapTag = "[object Map]";
  var numberTag = "[object Number]";
  var objectTag = "[object Object]";
  var regexpTag = "[object RegExp]";
  var setTag = "[object Set]";
  var stringTag = "[object String]";
  var weakMapTag = "[object WeakMap]";
  var arrayBufferTag = "[object ArrayBuffer]";
  var dataViewTag = "[object DataView]";
  var float32Tag = "[object Float32Array]";
  var float64Tag = "[object Float64Array]";
  var int8Tag = "[object Int8Array]";
  var int16Tag = "[object Int16Array]";
  var int32Tag = "[object Int32Array]";
  var uint8Tag = "[object Uint8Array]";
  var uint8ClampedTag = "[object Uint8ClampedArray]";
  var uint16Tag = "[object Uint16Array]";
  var uint32Tag = "[object Uint32Array]";
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag2] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag2] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
  function baseIsTypedArray(value) {
    return isObjectLike_default(value) && isLength_default(value.length) && !!typedArrayTags[baseGetTag_default(value)];
  }
  __name(baseIsTypedArray, "baseIsTypedArray");
  var baseIsTypedArray_default = baseIsTypedArray;

  // node_modules/lodash-es/_baseUnary.js
  function baseUnary(func) {
    return function(value) {
      return func(value);
    };
  }
  __name(baseUnary, "baseUnary");
  var baseUnary_default = baseUnary;

  // node_modules/lodash-es/_nodeUtil.js
  var freeExports2 = typeof exports == "object" && exports && !exports.nodeType && exports;
  var freeModule2 = freeExports2 && typeof module == "object" && module && !module.nodeType && module;
  var moduleExports2 = freeModule2 && freeModule2.exports === freeExports2;
  var freeProcess = moduleExports2 && freeGlobal_default.process;
  var nodeUtil = function() {
    try {
      var types = freeModule2 && freeModule2.require && freeModule2.require("util").types;
      if (types) {
        return types;
      }
      return freeProcess && freeProcess.binding && freeProcess.binding("util");
    } catch (e3) {
    }
  }();
  var nodeUtil_default = nodeUtil;

  // node_modules/lodash-es/isTypedArray.js
  var nodeIsTypedArray = nodeUtil_default && nodeUtil_default.isTypedArray;
  var isTypedArray = nodeIsTypedArray ? baseUnary_default(nodeIsTypedArray) : baseIsTypedArray_default;
  var isTypedArray_default = isTypedArray;

  // node_modules/lodash-es/_arrayLikeKeys.js
  var objectProto7 = Object.prototype;
  var hasOwnProperty5 = objectProto7.hasOwnProperty;
  function arrayLikeKeys(value, inherited) {
    var isArr = isArray_default(value), isArg = !isArr && isArguments_default(value), isBuff = !isArr && !isArg && isBuffer_default(value), isType = !isArr && !isArg && !isBuff && isTypedArray_default(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes_default(value.length, String) : [], length = result.length;
    for (var key in value) {
      if ((inherited || hasOwnProperty5.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
      (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
      isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
      isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
      isIndex_default(key, length)))) {
        result.push(key);
      }
    }
    return result;
  }
  __name(arrayLikeKeys, "arrayLikeKeys");
  var arrayLikeKeys_default = arrayLikeKeys;

  // node_modules/lodash-es/_overArg.js
  function overArg(func, transform) {
    return function(arg) {
      return func(transform(arg));
    };
  }
  __name(overArg, "overArg");
  var overArg_default = overArg;

  // node_modules/lodash-es/_nativeKeys.js
  var nativeKeys = overArg_default(Object.keys, Object);
  var nativeKeys_default = nativeKeys;

  // node_modules/lodash-es/_baseKeys.js
  var objectProto8 = Object.prototype;
  var hasOwnProperty6 = objectProto8.hasOwnProperty;
  function baseKeys(object) {
    if (!isPrototype_default(object)) {
      return nativeKeys_default(object);
    }
    var result = [];
    for (var key in Object(object)) {
      if (hasOwnProperty6.call(object, key) && key != "constructor") {
        result.push(key);
      }
    }
    return result;
  }
  __name(baseKeys, "baseKeys");
  var baseKeys_default = baseKeys;

  // node_modules/lodash-es/keys.js
  function keys(object) {
    return isArrayLike_default(object) ? arrayLikeKeys_default(object) : baseKeys_default(object);
  }
  __name(keys, "keys");
  var keys_default = keys;

  // node_modules/lodash-es/_nativeKeysIn.js
  function nativeKeysIn(object) {
    var result = [];
    if (object != null) {
      for (var key in Object(object)) {
        result.push(key);
      }
    }
    return result;
  }
  __name(nativeKeysIn, "nativeKeysIn");
  var nativeKeysIn_default = nativeKeysIn;

  // node_modules/lodash-es/_baseKeysIn.js
  var objectProto9 = Object.prototype;
  var hasOwnProperty7 = objectProto9.hasOwnProperty;
  function baseKeysIn(object) {
    if (!isObject_default(object)) {
      return nativeKeysIn_default(object);
    }
    var isProto = isPrototype_default(object), result = [];
    for (var key in object) {
      if (!(key == "constructor" && (isProto || !hasOwnProperty7.call(object, key)))) {
        result.push(key);
      }
    }
    return result;
  }
  __name(baseKeysIn, "baseKeysIn");
  var baseKeysIn_default = baseKeysIn;

  // node_modules/lodash-es/keysIn.js
  function keysIn(object) {
    return isArrayLike_default(object) ? arrayLikeKeys_default(object, true) : baseKeysIn_default(object);
  }
  __name(keysIn, "keysIn");
  var keysIn_default = keysIn;

  // node_modules/lodash-es/_nativeCreate.js
  var nativeCreate = getNative_default(Object, "create");
  var nativeCreate_default = nativeCreate;

  // node_modules/lodash-es/_hashClear.js
  function hashClear() {
    this.__data__ = nativeCreate_default ? nativeCreate_default(null) : {};
    this.size = 0;
  }
  __name(hashClear, "hashClear");
  var hashClear_default = hashClear;

  // node_modules/lodash-es/_hashDelete.js
  function hashDelete(key) {
    var result = this.has(key) && delete this.__data__[key];
    this.size -= result ? 1 : 0;
    return result;
  }
  __name(hashDelete, "hashDelete");
  var hashDelete_default = hashDelete;

  // node_modules/lodash-es/_hashGet.js
  var HASH_UNDEFINED = "__lodash_hash_undefined__";
  var objectProto10 = Object.prototype;
  var hasOwnProperty8 = objectProto10.hasOwnProperty;
  function hashGet(key) {
    var data = this.__data__;
    if (nativeCreate_default) {
      var result = data[key];
      return result === HASH_UNDEFINED ? void 0 : result;
    }
    return hasOwnProperty8.call(data, key) ? data[key] : void 0;
  }
  __name(hashGet, "hashGet");
  var hashGet_default = hashGet;

  // node_modules/lodash-es/_hashHas.js
  var objectProto11 = Object.prototype;
  var hasOwnProperty9 = objectProto11.hasOwnProperty;
  function hashHas(key) {
    var data = this.__data__;
    return nativeCreate_default ? data[key] !== void 0 : hasOwnProperty9.call(data, key);
  }
  __name(hashHas, "hashHas");
  var hashHas_default = hashHas;

  // node_modules/lodash-es/_hashSet.js
  var HASH_UNDEFINED2 = "__lodash_hash_undefined__";
  function hashSet(key, value) {
    var data = this.__data__;
    this.size += this.has(key) ? 0 : 1;
    data[key] = nativeCreate_default && value === void 0 ? HASH_UNDEFINED2 : value;
    return this;
  }
  __name(hashSet, "hashSet");
  var hashSet_default = hashSet;

  // node_modules/lodash-es/_Hash.js
  function Hash(entries) {
    var index2 = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index2 < length) {
      var entry = entries[index2];
      this.set(entry[0], entry[1]);
    }
  }
  __name(Hash, "Hash");
  Hash.prototype.clear = hashClear_default;
  Hash.prototype["delete"] = hashDelete_default;
  Hash.prototype.get = hashGet_default;
  Hash.prototype.has = hashHas_default;
  Hash.prototype.set = hashSet_default;
  var Hash_default = Hash;

  // node_modules/lodash-es/_listCacheClear.js
  function listCacheClear() {
    this.__data__ = [];
    this.size = 0;
  }
  __name(listCacheClear, "listCacheClear");
  var listCacheClear_default = listCacheClear;

  // node_modules/lodash-es/_assocIndexOf.js
  function assocIndexOf(array, key) {
    var length = array.length;
    while (length--) {
      if (eq_default(array[length][0], key)) {
        return length;
      }
    }
    return -1;
  }
  __name(assocIndexOf, "assocIndexOf");
  var assocIndexOf_default = assocIndexOf;

  // node_modules/lodash-es/_listCacheDelete.js
  var arrayProto = Array.prototype;
  var splice = arrayProto.splice;
  function listCacheDelete(key) {
    var data = this.__data__, index2 = assocIndexOf_default(data, key);
    if (index2 < 0) {
      return false;
    }
    var lastIndex = data.length - 1;
    if (index2 == lastIndex) {
      data.pop();
    } else {
      splice.call(data, index2, 1);
    }
    --this.size;
    return true;
  }
  __name(listCacheDelete, "listCacheDelete");
  var listCacheDelete_default = listCacheDelete;

  // node_modules/lodash-es/_listCacheGet.js
  function listCacheGet(key) {
    var data = this.__data__, index2 = assocIndexOf_default(data, key);
    return index2 < 0 ? void 0 : data[index2][1];
  }
  __name(listCacheGet, "listCacheGet");
  var listCacheGet_default = listCacheGet;

  // node_modules/lodash-es/_listCacheHas.js
  function listCacheHas(key) {
    return assocIndexOf_default(this.__data__, key) > -1;
  }
  __name(listCacheHas, "listCacheHas");
  var listCacheHas_default = listCacheHas;

  // node_modules/lodash-es/_listCacheSet.js
  function listCacheSet(key, value) {
    var data = this.__data__, index2 = assocIndexOf_default(data, key);
    if (index2 < 0) {
      ++this.size;
      data.push([key, value]);
    } else {
      data[index2][1] = value;
    }
    return this;
  }
  __name(listCacheSet, "listCacheSet");
  var listCacheSet_default = listCacheSet;

  // node_modules/lodash-es/_ListCache.js
  function ListCache(entries) {
    var index2 = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index2 < length) {
      var entry = entries[index2];
      this.set(entry[0], entry[1]);
    }
  }
  __name(ListCache, "ListCache");
  ListCache.prototype.clear = listCacheClear_default;
  ListCache.prototype["delete"] = listCacheDelete_default;
  ListCache.prototype.get = listCacheGet_default;
  ListCache.prototype.has = listCacheHas_default;
  ListCache.prototype.set = listCacheSet_default;
  var ListCache_default = ListCache;

  // node_modules/lodash-es/_Map.js
  var Map2 = getNative_default(root_default, "Map");
  var Map_default = Map2;

  // node_modules/lodash-es/_mapCacheClear.js
  function mapCacheClear() {
    this.size = 0;
    this.__data__ = {
      "hash": new Hash_default(),
      "map": new (Map_default || ListCache_default)(),
      "string": new Hash_default()
    };
  }
  __name(mapCacheClear, "mapCacheClear");
  var mapCacheClear_default = mapCacheClear;

  // node_modules/lodash-es/_isKeyable.js
  function isKeyable(value) {
    var type = typeof value;
    return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
  }
  __name(isKeyable, "isKeyable");
  var isKeyable_default = isKeyable;

  // node_modules/lodash-es/_getMapData.js
  function getMapData(map2, key) {
    var data = map2.__data__;
    return isKeyable_default(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
  }
  __name(getMapData, "getMapData");
  var getMapData_default = getMapData;

  // node_modules/lodash-es/_mapCacheDelete.js
  function mapCacheDelete(key) {
    var result = getMapData_default(this, key)["delete"](key);
    this.size -= result ? 1 : 0;
    return result;
  }
  __name(mapCacheDelete, "mapCacheDelete");
  var mapCacheDelete_default = mapCacheDelete;

  // node_modules/lodash-es/_mapCacheGet.js
  function mapCacheGet(key) {
    return getMapData_default(this, key).get(key);
  }
  __name(mapCacheGet, "mapCacheGet");
  var mapCacheGet_default = mapCacheGet;

  // node_modules/lodash-es/_mapCacheHas.js
  function mapCacheHas(key) {
    return getMapData_default(this, key).has(key);
  }
  __name(mapCacheHas, "mapCacheHas");
  var mapCacheHas_default = mapCacheHas;

  // node_modules/lodash-es/_mapCacheSet.js
  function mapCacheSet(key, value) {
    var data = getMapData_default(this, key), size = data.size;
    data.set(key, value);
    this.size += data.size == size ? 0 : 1;
    return this;
  }
  __name(mapCacheSet, "mapCacheSet");
  var mapCacheSet_default = mapCacheSet;

  // node_modules/lodash-es/_MapCache.js
  function MapCache(entries) {
    var index2 = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index2 < length) {
      var entry = entries[index2];
      this.set(entry[0], entry[1]);
    }
  }
  __name(MapCache, "MapCache");
  MapCache.prototype.clear = mapCacheClear_default;
  MapCache.prototype["delete"] = mapCacheDelete_default;
  MapCache.prototype.get = mapCacheGet_default;
  MapCache.prototype.has = mapCacheHas_default;
  MapCache.prototype.set = mapCacheSet_default;
  var MapCache_default = MapCache;

  // node_modules/lodash-es/_arrayPush.js
  function arrayPush(array, values) {
    var index2 = -1, length = values.length, offset = array.length;
    while (++index2 < length) {
      array[offset + index2] = values[index2];
    }
    return array;
  }
  __name(arrayPush, "arrayPush");
  var arrayPush_default = arrayPush;

  // node_modules/lodash-es/_getPrototype.js
  var getPrototype = overArg_default(Object.getPrototypeOf, Object);
  var getPrototype_default = getPrototype;

  // node_modules/lodash-es/isPlainObject.js
  var objectTag2 = "[object Object]";
  var funcProto3 = Function.prototype;
  var objectProto12 = Object.prototype;
  var funcToString3 = funcProto3.toString;
  var hasOwnProperty10 = objectProto12.hasOwnProperty;
  var objectCtorString = funcToString3.call(Object);
  function isPlainObject(value) {
    if (!isObjectLike_default(value) || baseGetTag_default(value) != objectTag2) {
      return false;
    }
    var proto = getPrototype_default(value);
    if (proto === null) {
      return true;
    }
    var Ctor = hasOwnProperty10.call(proto, "constructor") && proto.constructor;
    return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString3.call(Ctor) == objectCtorString;
  }
  __name(isPlainObject, "isPlainObject");
  var isPlainObject_default = isPlainObject;

  // node_modules/lodash-es/_stackClear.js
  function stackClear() {
    this.__data__ = new ListCache_default();
    this.size = 0;
  }
  __name(stackClear, "stackClear");
  var stackClear_default = stackClear;

  // node_modules/lodash-es/_stackDelete.js
  function stackDelete(key) {
    var data = this.__data__, result = data["delete"](key);
    this.size = data.size;
    return result;
  }
  __name(stackDelete, "stackDelete");
  var stackDelete_default = stackDelete;

  // node_modules/lodash-es/_stackGet.js
  function stackGet(key) {
    return this.__data__.get(key);
  }
  __name(stackGet, "stackGet");
  var stackGet_default = stackGet;

  // node_modules/lodash-es/_stackHas.js
  function stackHas(key) {
    return this.__data__.has(key);
  }
  __name(stackHas, "stackHas");
  var stackHas_default = stackHas;

  // node_modules/lodash-es/_stackSet.js
  var LARGE_ARRAY_SIZE = 200;
  function stackSet(key, value) {
    var data = this.__data__;
    if (data instanceof ListCache_default) {
      var pairs = data.__data__;
      if (!Map_default || pairs.length < LARGE_ARRAY_SIZE - 1) {
        pairs.push([key, value]);
        this.size = ++data.size;
        return this;
      }
      data = this.__data__ = new MapCache_default(pairs);
    }
    data.set(key, value);
    this.size = data.size;
    return this;
  }
  __name(stackSet, "stackSet");
  var stackSet_default = stackSet;

  // node_modules/lodash-es/_Stack.js
  function Stack(entries) {
    var data = this.__data__ = new ListCache_default(entries);
    this.size = data.size;
  }
  __name(Stack, "Stack");
  Stack.prototype.clear = stackClear_default;
  Stack.prototype["delete"] = stackDelete_default;
  Stack.prototype.get = stackGet_default;
  Stack.prototype.has = stackHas_default;
  Stack.prototype.set = stackSet_default;
  var Stack_default = Stack;

  // node_modules/lodash-es/_baseAssign.js
  function baseAssign(object, source) {
    return object && copyObject_default(source, keys_default(source), object);
  }
  __name(baseAssign, "baseAssign");
  var baseAssign_default = baseAssign;

  // node_modules/lodash-es/_baseAssignIn.js
  function baseAssignIn(object, source) {
    return object && copyObject_default(source, keysIn_default(source), object);
  }
  __name(baseAssignIn, "baseAssignIn");
  var baseAssignIn_default = baseAssignIn;

  // node_modules/lodash-es/_cloneBuffer.js
  var freeExports3 = typeof exports == "object" && exports && !exports.nodeType && exports;
  var freeModule3 = freeExports3 && typeof module == "object" && module && !module.nodeType && module;
  var moduleExports3 = freeModule3 && freeModule3.exports === freeExports3;
  var Buffer3 = moduleExports3 ? root_default.Buffer : void 0;
  var allocUnsafe = Buffer3 ? Buffer3.allocUnsafe : void 0;
  function cloneBuffer(buffer, isDeep) {
    if (isDeep) {
      return buffer.slice();
    }
    var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
    buffer.copy(result);
    return result;
  }
  __name(cloneBuffer, "cloneBuffer");
  var cloneBuffer_default = cloneBuffer;

  // node_modules/lodash-es/_arrayFilter.js
  function arrayFilter(array, predicate) {
    var index2 = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
    while (++index2 < length) {
      var value = array[index2];
      if (predicate(value, index2, array)) {
        result[resIndex++] = value;
      }
    }
    return result;
  }
  __name(arrayFilter, "arrayFilter");
  var arrayFilter_default = arrayFilter;

  // node_modules/lodash-es/stubArray.js
  function stubArray() {
    return [];
  }
  __name(stubArray, "stubArray");
  var stubArray_default = stubArray;

  // node_modules/lodash-es/_getSymbols.js
  var objectProto13 = Object.prototype;
  var propertyIsEnumerable2 = objectProto13.propertyIsEnumerable;
  var nativeGetSymbols = Object.getOwnPropertySymbols;
  var getSymbols = !nativeGetSymbols ? stubArray_default : function(object) {
    if (object == null) {
      return [];
    }
    object = Object(object);
    return arrayFilter_default(nativeGetSymbols(object), function(symbol) {
      return propertyIsEnumerable2.call(object, symbol);
    });
  };
  var getSymbols_default = getSymbols;

  // node_modules/lodash-es/_copySymbols.js
  function copySymbols(source, object) {
    return copyObject_default(source, getSymbols_default(source), object);
  }
  __name(copySymbols, "copySymbols");
  var copySymbols_default = copySymbols;

  // node_modules/lodash-es/_getSymbolsIn.js
  var nativeGetSymbols2 = Object.getOwnPropertySymbols;
  var getSymbolsIn = !nativeGetSymbols2 ? stubArray_default : function(object) {
    var result = [];
    while (object) {
      arrayPush_default(result, getSymbols_default(object));
      object = getPrototype_default(object);
    }
    return result;
  };
  var getSymbolsIn_default = getSymbolsIn;

  // node_modules/lodash-es/_copySymbolsIn.js
  function copySymbolsIn(source, object) {
    return copyObject_default(source, getSymbolsIn_default(source), object);
  }
  __name(copySymbolsIn, "copySymbolsIn");
  var copySymbolsIn_default = copySymbolsIn;

  // node_modules/lodash-es/_baseGetAllKeys.js
  function baseGetAllKeys(object, keysFunc, symbolsFunc) {
    var result = keysFunc(object);
    return isArray_default(object) ? result : arrayPush_default(result, symbolsFunc(object));
  }
  __name(baseGetAllKeys, "baseGetAllKeys");
  var baseGetAllKeys_default = baseGetAllKeys;

  // node_modules/lodash-es/_getAllKeys.js
  function getAllKeys(object) {
    return baseGetAllKeys_default(object, keys_default, getSymbols_default);
  }
  __name(getAllKeys, "getAllKeys");
  var getAllKeys_default = getAllKeys;

  // node_modules/lodash-es/_getAllKeysIn.js
  function getAllKeysIn(object) {
    return baseGetAllKeys_default(object, keysIn_default, getSymbolsIn_default);
  }
  __name(getAllKeysIn, "getAllKeysIn");
  var getAllKeysIn_default = getAllKeysIn;

  // node_modules/lodash-es/_DataView.js
  var DataView2 = getNative_default(root_default, "DataView");
  var DataView_default = DataView2;

  // node_modules/lodash-es/_Promise.js
  var Promise2 = getNative_default(root_default, "Promise");
  var Promise_default = Promise2;

  // node_modules/lodash-es/_Set.js
  var Set2 = getNative_default(root_default, "Set");
  var Set_default = Set2;

  // node_modules/lodash-es/_getTag.js
  var mapTag2 = "[object Map]";
  var objectTag3 = "[object Object]";
  var promiseTag = "[object Promise]";
  var setTag2 = "[object Set]";
  var weakMapTag2 = "[object WeakMap]";
  var dataViewTag2 = "[object DataView]";
  var dataViewCtorString = toSource_default(DataView_default);
  var mapCtorString = toSource_default(Map_default);
  var promiseCtorString = toSource_default(Promise_default);
  var setCtorString = toSource_default(Set_default);
  var weakMapCtorString = toSource_default(WeakMap_default);
  var getTag = baseGetTag_default;
  if (DataView_default && getTag(new DataView_default(new ArrayBuffer(1))) != dataViewTag2 || Map_default && getTag(new Map_default()) != mapTag2 || Promise_default && getTag(Promise_default.resolve()) != promiseTag || Set_default && getTag(new Set_default()) != setTag2 || WeakMap_default && getTag(new WeakMap_default()) != weakMapTag2) {
    getTag = /* @__PURE__ */ __name(function(value) {
      var result = baseGetTag_default(value), Ctor = result == objectTag3 ? value.constructor : void 0, ctorString = Ctor ? toSource_default(Ctor) : "";
      if (ctorString) {
        switch (ctorString) {
          case dataViewCtorString:
            return dataViewTag2;
          case mapCtorString:
            return mapTag2;
          case promiseCtorString:
            return promiseTag;
          case setCtorString:
            return setTag2;
          case weakMapCtorString:
            return weakMapTag2;
        }
      }
      return result;
    }, "getTag");
  }
  var getTag_default = getTag;

  // node_modules/lodash-es/_initCloneArray.js
  var objectProto14 = Object.prototype;
  var hasOwnProperty11 = objectProto14.hasOwnProperty;
  function initCloneArray(array) {
    var length = array.length, result = new array.constructor(length);
    if (length && typeof array[0] == "string" && hasOwnProperty11.call(array, "index")) {
      result.index = array.index;
      result.input = array.input;
    }
    return result;
  }
  __name(initCloneArray, "initCloneArray");
  var initCloneArray_default = initCloneArray;

  // node_modules/lodash-es/_Uint8Array.js
  var Uint8Array2 = root_default.Uint8Array;
  var Uint8Array_default = Uint8Array2;

  // node_modules/lodash-es/_cloneArrayBuffer.js
  function cloneArrayBuffer(arrayBuffer) {
    var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
    new Uint8Array_default(result).set(new Uint8Array_default(arrayBuffer));
    return result;
  }
  __name(cloneArrayBuffer, "cloneArrayBuffer");
  var cloneArrayBuffer_default = cloneArrayBuffer;

  // node_modules/lodash-es/_cloneDataView.js
  function cloneDataView(dataView, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer_default(dataView.buffer) : dataView.buffer;
    return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
  }
  __name(cloneDataView, "cloneDataView");
  var cloneDataView_default = cloneDataView;

  // node_modules/lodash-es/_cloneRegExp.js
  var reFlags = /\w*$/;
  function cloneRegExp(regexp) {
    var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
    result.lastIndex = regexp.lastIndex;
    return result;
  }
  __name(cloneRegExp, "cloneRegExp");
  var cloneRegExp_default = cloneRegExp;

  // node_modules/lodash-es/_cloneSymbol.js
  var symbolProto = Symbol_default ? Symbol_default.prototype : void 0;
  var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
  function cloneSymbol(symbol) {
    return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
  }
  __name(cloneSymbol, "cloneSymbol");
  var cloneSymbol_default = cloneSymbol;

  // node_modules/lodash-es/_cloneTypedArray.js
  function cloneTypedArray(typedArray, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer_default(typedArray.buffer) : typedArray.buffer;
    return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
  }
  __name(cloneTypedArray, "cloneTypedArray");
  var cloneTypedArray_default = cloneTypedArray;

  // node_modules/lodash-es/_initCloneByTag.js
  var boolTag2 = "[object Boolean]";
  var dateTag2 = "[object Date]";
  var mapTag3 = "[object Map]";
  var numberTag2 = "[object Number]";
  var regexpTag2 = "[object RegExp]";
  var setTag3 = "[object Set]";
  var stringTag2 = "[object String]";
  var symbolTag = "[object Symbol]";
  var arrayBufferTag2 = "[object ArrayBuffer]";
  var dataViewTag3 = "[object DataView]";
  var float32Tag2 = "[object Float32Array]";
  var float64Tag2 = "[object Float64Array]";
  var int8Tag2 = "[object Int8Array]";
  var int16Tag2 = "[object Int16Array]";
  var int32Tag2 = "[object Int32Array]";
  var uint8Tag2 = "[object Uint8Array]";
  var uint8ClampedTag2 = "[object Uint8ClampedArray]";
  var uint16Tag2 = "[object Uint16Array]";
  var uint32Tag2 = "[object Uint32Array]";
  function initCloneByTag(object, tag, isDeep) {
    var Ctor = object.constructor;
    switch (tag) {
      case arrayBufferTag2:
        return cloneArrayBuffer_default(object);
      case boolTag2:
      case dateTag2:
        return new Ctor(+object);
      case dataViewTag3:
        return cloneDataView_default(object, isDeep);
      case float32Tag2:
      case float64Tag2:
      case int8Tag2:
      case int16Tag2:
      case int32Tag2:
      case uint8Tag2:
      case uint8ClampedTag2:
      case uint16Tag2:
      case uint32Tag2:
        return cloneTypedArray_default(object, isDeep);
      case mapTag3:
        return new Ctor();
      case numberTag2:
      case stringTag2:
        return new Ctor(object);
      case regexpTag2:
        return cloneRegExp_default(object);
      case setTag3:
        return new Ctor();
      case symbolTag:
        return cloneSymbol_default(object);
    }
  }
  __name(initCloneByTag, "initCloneByTag");
  var initCloneByTag_default = initCloneByTag;

  // node_modules/lodash-es/_initCloneObject.js
  function initCloneObject(object) {
    return typeof object.constructor == "function" && !isPrototype_default(object) ? baseCreate_default(getPrototype_default(object)) : {};
  }
  __name(initCloneObject, "initCloneObject");
  var initCloneObject_default = initCloneObject;

  // node_modules/lodash-es/_baseIsMap.js
  var mapTag4 = "[object Map]";
  function baseIsMap(value) {
    return isObjectLike_default(value) && getTag_default(value) == mapTag4;
  }
  __name(baseIsMap, "baseIsMap");
  var baseIsMap_default = baseIsMap;

  // node_modules/lodash-es/isMap.js
  var nodeIsMap = nodeUtil_default && nodeUtil_default.isMap;
  var isMap = nodeIsMap ? baseUnary_default(nodeIsMap) : baseIsMap_default;
  var isMap_default = isMap;

  // node_modules/lodash-es/_baseIsSet.js
  var setTag4 = "[object Set]";
  function baseIsSet(value) {
    return isObjectLike_default(value) && getTag_default(value) == setTag4;
  }
  __name(baseIsSet, "baseIsSet");
  var baseIsSet_default = baseIsSet;

  // node_modules/lodash-es/isSet.js
  var nodeIsSet = nodeUtil_default && nodeUtil_default.isSet;
  var isSet = nodeIsSet ? baseUnary_default(nodeIsSet) : baseIsSet_default;
  var isSet_default = isSet;

  // node_modules/lodash-es/_baseClone.js
  var CLONE_DEEP_FLAG = 1;
  var CLONE_FLAT_FLAG = 2;
  var CLONE_SYMBOLS_FLAG = 4;
  var argsTag3 = "[object Arguments]";
  var arrayTag2 = "[object Array]";
  var boolTag3 = "[object Boolean]";
  var dateTag3 = "[object Date]";
  var errorTag2 = "[object Error]";
  var funcTag3 = "[object Function]";
  var genTag2 = "[object GeneratorFunction]";
  var mapTag5 = "[object Map]";
  var numberTag3 = "[object Number]";
  var objectTag4 = "[object Object]";
  var regexpTag3 = "[object RegExp]";
  var setTag5 = "[object Set]";
  var stringTag3 = "[object String]";
  var symbolTag2 = "[object Symbol]";
  var weakMapTag3 = "[object WeakMap]";
  var arrayBufferTag3 = "[object ArrayBuffer]";
  var dataViewTag4 = "[object DataView]";
  var float32Tag3 = "[object Float32Array]";
  var float64Tag3 = "[object Float64Array]";
  var int8Tag3 = "[object Int8Array]";
  var int16Tag3 = "[object Int16Array]";
  var int32Tag3 = "[object Int32Array]";
  var uint8Tag3 = "[object Uint8Array]";
  var uint8ClampedTag3 = "[object Uint8ClampedArray]";
  var uint16Tag3 = "[object Uint16Array]";
  var uint32Tag3 = "[object Uint32Array]";
  var cloneableTags = {};
  cloneableTags[argsTag3] = cloneableTags[arrayTag2] = cloneableTags[arrayBufferTag3] = cloneableTags[dataViewTag4] = cloneableTags[boolTag3] = cloneableTags[dateTag3] = cloneableTags[float32Tag3] = cloneableTags[float64Tag3] = cloneableTags[int8Tag3] = cloneableTags[int16Tag3] = cloneableTags[int32Tag3] = cloneableTags[mapTag5] = cloneableTags[numberTag3] = cloneableTags[objectTag4] = cloneableTags[regexpTag3] = cloneableTags[setTag5] = cloneableTags[stringTag3] = cloneableTags[symbolTag2] = cloneableTags[uint8Tag3] = cloneableTags[uint8ClampedTag3] = cloneableTags[uint16Tag3] = cloneableTags[uint32Tag3] = true;
  cloneableTags[errorTag2] = cloneableTags[funcTag3] = cloneableTags[weakMapTag3] = false;
  function baseClone(value, bitmask, customizer, key, object, stack) {
    var result, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
    if (customizer) {
      result = object ? customizer(value, key, object, stack) : customizer(value);
    }
    if (result !== void 0) {
      return result;
    }
    if (!isObject_default(value)) {
      return value;
    }
    var isArr = isArray_default(value);
    if (isArr) {
      result = initCloneArray_default(value);
      if (!isDeep) {
        return copyArray_default(value, result);
      }
    } else {
      var tag = getTag_default(value), isFunc = tag == funcTag3 || tag == genTag2;
      if (isBuffer_default(value)) {
        return cloneBuffer_default(value, isDeep);
      }
      if (tag == objectTag4 || tag == argsTag3 || isFunc && !object) {
        result = isFlat || isFunc ? {} : initCloneObject_default(value);
        if (!isDeep) {
          return isFlat ? copySymbolsIn_default(value, baseAssignIn_default(result, value)) : copySymbols_default(value, baseAssign_default(result, value));
        }
      } else {
        if (!cloneableTags[tag]) {
          return object ? value : {};
        }
        result = initCloneByTag_default(value, tag, isDeep);
      }
    }
    stack || (stack = new Stack_default());
    var stacked = stack.get(value);
    if (stacked) {
      return stacked;
    }
    stack.set(value, result);
    if (isSet_default(value)) {
      value.forEach(function(subValue) {
        result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
      });
    } else if (isMap_default(value)) {
      value.forEach(function(subValue, key2) {
        result.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
      });
    }
    var keysFunc = isFull ? isFlat ? getAllKeysIn_default : getAllKeys_default : isFlat ? keysIn_default : keys_default;
    var props = isArr ? void 0 : keysFunc(value);
    arrayEach_default(props || value, function(subValue, key2) {
      if (props) {
        key2 = subValue;
        subValue = value[key2];
      }
      assignValue_default(result, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
    });
    return result;
  }
  __name(baseClone, "baseClone");
  var baseClone_default = baseClone;

  // node_modules/lodash-es/cloneDeep.js
  var CLONE_DEEP_FLAG2 = 1;
  var CLONE_SYMBOLS_FLAG2 = 4;
  function cloneDeep(value) {
    return baseClone_default(value, CLONE_DEEP_FLAG2 | CLONE_SYMBOLS_FLAG2);
  }
  __name(cloneDeep, "cloneDeep");
  var cloneDeep_default = cloneDeep;

  // node_modules/lodash-es/_setCacheAdd.js
  var HASH_UNDEFINED3 = "__lodash_hash_undefined__";
  function setCacheAdd(value) {
    this.__data__.set(value, HASH_UNDEFINED3);
    return this;
  }
  __name(setCacheAdd, "setCacheAdd");
  var setCacheAdd_default = setCacheAdd;

  // node_modules/lodash-es/_setCacheHas.js
  function setCacheHas(value) {
    return this.__data__.has(value);
  }
  __name(setCacheHas, "setCacheHas");
  var setCacheHas_default = setCacheHas;

  // node_modules/lodash-es/_SetCache.js
  function SetCache(values) {
    var index2 = -1, length = values == null ? 0 : values.length;
    this.__data__ = new MapCache_default();
    while (++index2 < length) {
      this.add(values[index2]);
    }
  }
  __name(SetCache, "SetCache");
  SetCache.prototype.add = SetCache.prototype.push = setCacheAdd_default;
  SetCache.prototype.has = setCacheHas_default;
  var SetCache_default = SetCache;

  // node_modules/lodash-es/_arraySome.js
  function arraySome(array, predicate) {
    var index2 = -1, length = array == null ? 0 : array.length;
    while (++index2 < length) {
      if (predicate(array[index2], index2, array)) {
        return true;
      }
    }
    return false;
  }
  __name(arraySome, "arraySome");
  var arraySome_default = arraySome;

  // node_modules/lodash-es/_cacheHas.js
  function cacheHas(cache3, key) {
    return cache3.has(key);
  }
  __name(cacheHas, "cacheHas");
  var cacheHas_default = cacheHas;

  // node_modules/lodash-es/_equalArrays.js
  var COMPARE_PARTIAL_FLAG = 1;
  var COMPARE_UNORDERED_FLAG = 2;
  function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
    if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
      return false;
    }
    var arrStacked = stack.get(array);
    var othStacked = stack.get(other);
    if (arrStacked && othStacked) {
      return arrStacked == other && othStacked == array;
    }
    var index2 = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache_default() : void 0;
    stack.set(array, other);
    stack.set(other, array);
    while (++index2 < arrLength) {
      var arrValue = array[index2], othValue = other[index2];
      if (customizer) {
        var compared = isPartial ? customizer(othValue, arrValue, index2, other, array, stack) : customizer(arrValue, othValue, index2, array, other, stack);
      }
      if (compared !== void 0) {
        if (compared) {
          continue;
        }
        result = false;
        break;
      }
      if (seen) {
        if (!arraySome_default(other, function(othValue2, othIndex) {
          if (!cacheHas_default(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
            return seen.push(othIndex);
          }
        })) {
          result = false;
          break;
        }
      } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
        result = false;
        break;
      }
    }
    stack["delete"](array);
    stack["delete"](other);
    return result;
  }
  __name(equalArrays, "equalArrays");
  var equalArrays_default = equalArrays;

  // node_modules/lodash-es/_mapToArray.js
  function mapToArray(map2) {
    var index2 = -1, result = Array(map2.size);
    map2.forEach(function(value, key) {
      result[++index2] = [key, value];
    });
    return result;
  }
  __name(mapToArray, "mapToArray");
  var mapToArray_default = mapToArray;

  // node_modules/lodash-es/_setToArray.js
  function setToArray(set) {
    var index2 = -1, result = Array(set.size);
    set.forEach(function(value) {
      result[++index2] = value;
    });
    return result;
  }
  __name(setToArray, "setToArray");
  var setToArray_default = setToArray;

  // node_modules/lodash-es/_equalByTag.js
  var COMPARE_PARTIAL_FLAG2 = 1;
  var COMPARE_UNORDERED_FLAG2 = 2;
  var boolTag4 = "[object Boolean]";
  var dateTag4 = "[object Date]";
  var errorTag3 = "[object Error]";
  var mapTag6 = "[object Map]";
  var numberTag4 = "[object Number]";
  var regexpTag4 = "[object RegExp]";
  var setTag6 = "[object Set]";
  var stringTag4 = "[object String]";
  var symbolTag3 = "[object Symbol]";
  var arrayBufferTag4 = "[object ArrayBuffer]";
  var dataViewTag5 = "[object DataView]";
  var symbolProto2 = Symbol_default ? Symbol_default.prototype : void 0;
  var symbolValueOf2 = symbolProto2 ? symbolProto2.valueOf : void 0;
  function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
    switch (tag) {
      case dataViewTag5:
        if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
          return false;
        }
        object = object.buffer;
        other = other.buffer;
      case arrayBufferTag4:
        if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array_default(object), new Uint8Array_default(other))) {
          return false;
        }
        return true;
      case boolTag4:
      case dateTag4:
      case numberTag4:
        return eq_default(+object, +other);
      case errorTag3:
        return object.name == other.name && object.message == other.message;
      case regexpTag4:
      case stringTag4:
        return object == other + "";
      case mapTag6:
        var convert = mapToArray_default;
      case setTag6:
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG2;
        convert || (convert = setToArray_default);
        if (object.size != other.size && !isPartial) {
          return false;
        }
        var stacked = stack.get(object);
        if (stacked) {
          return stacked == other;
        }
        bitmask |= COMPARE_UNORDERED_FLAG2;
        stack.set(object, other);
        var result = equalArrays_default(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
        stack["delete"](object);
        return result;
      case symbolTag3:
        if (symbolValueOf2) {
          return symbolValueOf2.call(object) == symbolValueOf2.call(other);
        }
    }
    return false;
  }
  __name(equalByTag, "equalByTag");
  var equalByTag_default = equalByTag;

  // node_modules/lodash-es/_equalObjects.js
  var COMPARE_PARTIAL_FLAG3 = 1;
  var objectProto15 = Object.prototype;
  var hasOwnProperty12 = objectProto15.hasOwnProperty;
  function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG3, objProps = getAllKeys_default(object), objLength = objProps.length, othProps = getAllKeys_default(other), othLength = othProps.length;
    if (objLength != othLength && !isPartial) {
      return false;
    }
    var index2 = objLength;
    while (index2--) {
      var key = objProps[index2];
      if (!(isPartial ? key in other : hasOwnProperty12.call(other, key))) {
        return false;
      }
    }
    var objStacked = stack.get(object);
    var othStacked = stack.get(other);
    if (objStacked && othStacked) {
      return objStacked == other && othStacked == object;
    }
    var result = true;
    stack.set(object, other);
    stack.set(other, object);
    var skipCtor = isPartial;
    while (++index2 < objLength) {
      key = objProps[index2];
      var objValue = object[key], othValue = other[key];
      if (customizer) {
        var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
      }
      if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
        result = false;
        break;
      }
      skipCtor || (skipCtor = key == "constructor");
    }
    if (result && !skipCtor) {
      var objCtor = object.constructor, othCtor = other.constructor;
      if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
        result = false;
      }
    }
    stack["delete"](object);
    stack["delete"](other);
    return result;
  }
  __name(equalObjects, "equalObjects");
  var equalObjects_default = equalObjects;

  // node_modules/lodash-es/_baseIsEqualDeep.js
  var COMPARE_PARTIAL_FLAG4 = 1;
  var argsTag4 = "[object Arguments]";
  var arrayTag3 = "[object Array]";
  var objectTag5 = "[object Object]";
  var objectProto16 = Object.prototype;
  var hasOwnProperty13 = objectProto16.hasOwnProperty;
  function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
    var objIsArr = isArray_default(object), othIsArr = isArray_default(other), objTag = objIsArr ? arrayTag3 : getTag_default(object), othTag = othIsArr ? arrayTag3 : getTag_default(other);
    objTag = objTag == argsTag4 ? objectTag5 : objTag;
    othTag = othTag == argsTag4 ? objectTag5 : othTag;
    var objIsObj = objTag == objectTag5, othIsObj = othTag == objectTag5, isSameTag = objTag == othTag;
    if (isSameTag && isBuffer_default(object)) {
      if (!isBuffer_default(other)) {
        return false;
      }
      objIsArr = true;
      objIsObj = false;
    }
    if (isSameTag && !objIsObj) {
      stack || (stack = new Stack_default());
      return objIsArr || isTypedArray_default(object) ? equalArrays_default(object, other, bitmask, customizer, equalFunc, stack) : equalByTag_default(object, other, objTag, bitmask, customizer, equalFunc, stack);
    }
    if (!(bitmask & COMPARE_PARTIAL_FLAG4)) {
      var objIsWrapped = objIsObj && hasOwnProperty13.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty13.call(other, "__wrapped__");
      if (objIsWrapped || othIsWrapped) {
        var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
        stack || (stack = new Stack_default());
        return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
      }
    }
    if (!isSameTag) {
      return false;
    }
    stack || (stack = new Stack_default());
    return equalObjects_default(object, other, bitmask, customizer, equalFunc, stack);
  }
  __name(baseIsEqualDeep, "baseIsEqualDeep");
  var baseIsEqualDeep_default = baseIsEqualDeep;

  // node_modules/lodash-es/_baseIsEqual.js
  function baseIsEqual(value, other, bitmask, customizer, stack) {
    if (value === other) {
      return true;
    }
    if (value == null || other == null || !isObjectLike_default(value) && !isObjectLike_default(other)) {
      return value !== value && other !== other;
    }
    return baseIsEqualDeep_default(value, other, bitmask, customizer, baseIsEqual, stack);
  }
  __name(baseIsEqual, "baseIsEqual");
  var baseIsEqual_default = baseIsEqual;

  // node_modules/lodash-es/_createBaseFor.js
  function createBaseFor(fromRight) {
    return function(object, iteratee, keysFunc) {
      var index2 = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
      while (length--) {
        var key = props[fromRight ? length : ++index2];
        if (iteratee(iterable[key], key, iterable) === false) {
          break;
        }
      }
      return object;
    };
  }
  __name(createBaseFor, "createBaseFor");
  var createBaseFor_default = createBaseFor;

  // node_modules/lodash-es/_baseFor.js
  var baseFor = createBaseFor_default();
  var baseFor_default = baseFor;

  // node_modules/lodash-es/_assignMergeValue.js
  function assignMergeValue(object, key, value) {
    if (value !== void 0 && !eq_default(object[key], value) || value === void 0 && !(key in object)) {
      baseAssignValue_default(object, key, value);
    }
  }
  __name(assignMergeValue, "assignMergeValue");
  var assignMergeValue_default = assignMergeValue;

  // node_modules/lodash-es/isArrayLikeObject.js
  function isArrayLikeObject(value) {
    return isObjectLike_default(value) && isArrayLike_default(value);
  }
  __name(isArrayLikeObject, "isArrayLikeObject");
  var isArrayLikeObject_default = isArrayLikeObject;

  // node_modules/lodash-es/_safeGet.js
  function safeGet(object, key) {
    if (key === "constructor" && typeof object[key] === "function") {
      return;
    }
    if (key == "__proto__") {
      return;
    }
    return object[key];
  }
  __name(safeGet, "safeGet");
  var safeGet_default = safeGet;

  // node_modules/lodash-es/toPlainObject.js
  function toPlainObject(value) {
    return copyObject_default(value, keysIn_default(value));
  }
  __name(toPlainObject, "toPlainObject");
  var toPlainObject_default = toPlainObject;

  // node_modules/lodash-es/_baseMergeDeep.js
  function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
    var objValue = safeGet_default(object, key), srcValue = safeGet_default(source, key), stacked = stack.get(srcValue);
    if (stacked) {
      assignMergeValue_default(object, key, stacked);
      return;
    }
    var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : void 0;
    var isCommon = newValue === void 0;
    if (isCommon) {
      var isArr = isArray_default(srcValue), isBuff = !isArr && isBuffer_default(srcValue), isTyped = !isArr && !isBuff && isTypedArray_default(srcValue);
      newValue = srcValue;
      if (isArr || isBuff || isTyped) {
        if (isArray_default(objValue)) {
          newValue = objValue;
        } else if (isArrayLikeObject_default(objValue)) {
          newValue = copyArray_default(objValue);
        } else if (isBuff) {
          isCommon = false;
          newValue = cloneBuffer_default(srcValue, true);
        } else if (isTyped) {
          isCommon = false;
          newValue = cloneTypedArray_default(srcValue, true);
        } else {
          newValue = [];
        }
      } else if (isPlainObject_default(srcValue) || isArguments_default(srcValue)) {
        newValue = objValue;
        if (isArguments_default(objValue)) {
          newValue = toPlainObject_default(objValue);
        } else if (!isObject_default(objValue) || isFunction_default(objValue)) {
          newValue = initCloneObject_default(srcValue);
        }
      } else {
        isCommon = false;
      }
    }
    if (isCommon) {
      stack.set(srcValue, newValue);
      mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
      stack["delete"](srcValue);
    }
    assignMergeValue_default(object, key, newValue);
  }
  __name(baseMergeDeep, "baseMergeDeep");
  var baseMergeDeep_default = baseMergeDeep;

  // node_modules/lodash-es/_baseMerge.js
  function baseMerge(object, source, srcIndex, customizer, stack) {
    if (object === source) {
      return;
    }
    baseFor_default(source, function(srcValue, key) {
      stack || (stack = new Stack_default());
      if (isObject_default(srcValue)) {
        baseMergeDeep_default(object, source, key, srcIndex, baseMerge, customizer, stack);
      } else {
        var newValue = customizer ? customizer(safeGet_default(object, key), srcValue, key + "", object, source, stack) : void 0;
        if (newValue === void 0) {
          newValue = srcValue;
        }
        assignMergeValue_default(object, key, newValue);
      }
    }, keysIn_default);
  }
  __name(baseMerge, "baseMerge");
  var baseMerge_default = baseMerge;

  // node_modules/lodash-es/isEqual.js
  function isEqual(value, other) {
    return baseIsEqual_default(value, other);
  }
  __name(isEqual, "isEqual");
  var isEqual_default = isEqual;

  // node_modules/lodash-es/merge.js
  var merge = createAssigner_default(function(object, source, srcIndex) {
    baseMerge_default(object, source, srcIndex);
  });
  var merge_default = merge;

  // node_modules/parchment/dist/parchment.js
  var parchment_exports = {};
  __export(parchment_exports, {
    Attributor: () => Attributor,
    AttributorStore: () => AttributorStore$1,
    BlockBlot: () => BlockBlot$1,
    ClassAttributor: () => ClassAttributor$1,
    ContainerBlot: () => ContainerBlot$1,
    EmbedBlot: () => EmbedBlot$1,
    InlineBlot: () => InlineBlot$1,
    LeafBlot: () => LeafBlot$1,
    ParentBlot: () => ParentBlot$1,
    Registry: () => Registry,
    Scope: () => Scope,
    ScrollBlot: () => ScrollBlot$1,
    StyleAttributor: () => StyleAttributor$1,
    TextBlot: () => TextBlot$1
  });
  var Scope = /* @__PURE__ */ ((Scope2) => (Scope2[Scope2.TYPE = 3] = "TYPE", Scope2[Scope2.LEVEL = 12] = "LEVEL", Scope2[Scope2.ATTRIBUTE = 13] = "ATTRIBUTE", Scope2[Scope2.BLOT = 14] = "BLOT", Scope2[Scope2.INLINE = 7] = "INLINE", Scope2[Scope2.BLOCK = 11] = "BLOCK", Scope2[Scope2.BLOCK_BLOT = 10] = "BLOCK_BLOT", Scope2[Scope2.INLINE_BLOT = 6] = "INLINE_BLOT", Scope2[Scope2.BLOCK_ATTRIBUTE = 9] = "BLOCK_ATTRIBUTE", Scope2[Scope2.INLINE_ATTRIBUTE = 5] = "INLINE_ATTRIBUTE", Scope2[Scope2.ANY = 15] = "ANY", Scope2))(Scope || {});
  var Attributor = class {
    static {
      __name(this, "Attributor");
    }
    constructor(attrName, keyName, options = {}) {
      this.attrName = attrName, this.keyName = keyName;
      const attributeBit = Scope.TYPE & Scope.ATTRIBUTE;
      this.scope = options.scope != null ? (
        // Ignore type bits, force attribute bit
        options.scope & Scope.LEVEL | attributeBit
      ) : Scope.ATTRIBUTE, options.whitelist != null && (this.whitelist = options.whitelist);
    }
    static keys(node) {
      return Array.from(node.attributes).map((item) => item.name);
    }
    add(node, value) {
      return this.canAdd(node, value) ? (node.setAttribute(this.keyName, value), true) : false;
    }
    canAdd(_node, value) {
      return this.whitelist == null ? true : typeof value == "string" ? this.whitelist.indexOf(value.replace(/["']/g, "")) > -1 : this.whitelist.indexOf(value) > -1;
    }
    remove(node) {
      node.removeAttribute(this.keyName);
    }
    value(node) {
      const value = node.getAttribute(this.keyName);
      return this.canAdd(node, value) && value ? value : "";
    }
  };
  var ParchmentError = class extends Error {
    static {
      __name(this, "ParchmentError");
    }
    constructor(message) {
      message = "[Parchment] " + message, super(message), this.message = message, this.name = this.constructor.name;
    }
  };
  var _Registry = class _Registry2 {
    static {
      __name(this, "_Registry");
    }
    constructor() {
      this.attributes = {}, this.classes = {}, this.tags = {}, this.types = {};
    }
    static find(node, bubble = false) {
      if (node == null)
        return null;
      if (this.blots.has(node))
        return this.blots.get(node) || null;
      if (bubble) {
        let parentNode = null;
        try {
          parentNode = node.parentNode;
        } catch {
          return null;
        }
        return this.find(parentNode, bubble);
      }
      return null;
    }
    create(scroll, input, value) {
      const match2 = this.query(input);
      if (match2 == null)
        throw new ParchmentError(`Unable to create ${input} blot`);
      const blotClass = match2, node = (
        // @ts-expect-error Fix me later
        input instanceof Node || input.nodeType === Node.TEXT_NODE ? input : blotClass.create(value)
      ), blot = new blotClass(scroll, node, value);
      return _Registry2.blots.set(blot.domNode, blot), blot;
    }
    find(node, bubble = false) {
      return _Registry2.find(node, bubble);
    }
    query(query, scope = Scope.ANY) {
      let match2;
      return typeof query == "string" ? match2 = this.types[query] || this.attributes[query] : query instanceof Text || query.nodeType === Node.TEXT_NODE ? match2 = this.types.text : typeof query == "number" ? query & Scope.LEVEL & Scope.BLOCK ? match2 = this.types.block : query & Scope.LEVEL & Scope.INLINE && (match2 = this.types.inline) : query instanceof Element && ((query.getAttribute("class") || "").split(/\s+/).some((name) => (match2 = this.classes[name], !!match2)), match2 = match2 || this.tags[query.tagName]), match2 == null ? null : "scope" in match2 && scope & Scope.LEVEL & match2.scope && scope & Scope.TYPE & match2.scope ? match2 : null;
    }
    register(...definitions) {
      return definitions.map((definition) => {
        const isBlot = "blotName" in definition, isAttr = "attrName" in definition;
        if (!isBlot && !isAttr)
          throw new ParchmentError("Invalid definition");
        if (isBlot && definition.blotName === "abstract")
          throw new ParchmentError("Cannot register abstract class");
        const key = isBlot ? definition.blotName : isAttr ? definition.attrName : void 0;
        return this.types[key] = definition, isAttr ? typeof definition.keyName == "string" && (this.attributes[definition.keyName] = definition) : isBlot && (definition.className && (this.classes[definition.className] = definition), definition.tagName && (Array.isArray(definition.tagName) ? definition.tagName = definition.tagName.map((tagName) => tagName.toUpperCase()) : definition.tagName = definition.tagName.toUpperCase(), (Array.isArray(definition.tagName) ? definition.tagName : [definition.tagName]).forEach((tag) => {
          (this.tags[tag] == null || definition.className == null) && (this.tags[tag] = definition);
        }))), definition;
      });
    }
  };
  _Registry.blots = /* @__PURE__ */ new WeakMap();
  var Registry = _Registry;
  function match(node, prefix) {
    return (node.getAttribute("class") || "").split(/\s+/).filter((name) => name.indexOf(`${prefix}-`) === 0);
  }
  __name(match, "match");
  var ClassAttributor = class extends Attributor {
    static {
      __name(this, "ClassAttributor");
    }
    static keys(node) {
      return (node.getAttribute("class") || "").split(/\s+/).map((name) => name.split("-").slice(0, -1).join("-"));
    }
    add(node, value) {
      return this.canAdd(node, value) ? (this.remove(node), node.classList.add(`${this.keyName}-${value}`), true) : false;
    }
    remove(node) {
      match(node, this.keyName).forEach((name) => {
        node.classList.remove(name);
      }), node.classList.length === 0 && node.removeAttribute("class");
    }
    value(node) {
      const value = (match(node, this.keyName)[0] || "").slice(this.keyName.length + 1);
      return this.canAdd(node, value) ? value : "";
    }
  };
  var ClassAttributor$1 = ClassAttributor;
  function camelize(name) {
    const parts = name.split("-"), rest = parts.slice(1).map((part) => part[0].toUpperCase() + part.slice(1)).join("");
    return parts[0] + rest;
  }
  __name(camelize, "camelize");
  var StyleAttributor = class extends Attributor {
    static {
      __name(this, "StyleAttributor");
    }
    static keys(node) {
      return (node.getAttribute("style") || "").split(";").map((value) => value.split(":")[0].trim());
    }
    add(node, value) {
      return this.canAdd(node, value) ? (node.style[camelize(this.keyName)] = value, true) : false;
    }
    remove(node) {
      node.style[camelize(this.keyName)] = "", node.getAttribute("style") || node.removeAttribute("style");
    }
    value(node) {
      const value = node.style[camelize(this.keyName)];
      return this.canAdd(node, value) ? value : "";
    }
  };
  var StyleAttributor$1 = StyleAttributor;
  var AttributorStore = class {
    static {
      __name(this, "AttributorStore");
    }
    constructor(domNode) {
      this.attributes = {}, this.domNode = domNode, this.build();
    }
    attribute(attribute, value) {
      value ? attribute.add(this.domNode, value) && (attribute.value(this.domNode) != null ? this.attributes[attribute.attrName] = attribute : delete this.attributes[attribute.attrName]) : (attribute.remove(this.domNode), delete this.attributes[attribute.attrName]);
    }
    build() {
      this.attributes = {};
      const blot = Registry.find(this.domNode);
      if (blot == null)
        return;
      const attributes = Attributor.keys(this.domNode), classes = ClassAttributor$1.keys(this.domNode), styles = StyleAttributor$1.keys(this.domNode);
      attributes.concat(classes).concat(styles).forEach((name) => {
        const attr = blot.scroll.query(name, Scope.ATTRIBUTE);
        attr instanceof Attributor && (this.attributes[attr.attrName] = attr);
      });
    }
    copy(target) {
      Object.keys(this.attributes).forEach((key) => {
        const value = this.attributes[key].value(this.domNode);
        target.format(key, value);
      });
    }
    move(target) {
      this.copy(target), Object.keys(this.attributes).forEach((key) => {
        this.attributes[key].remove(this.domNode);
      }), this.attributes = {};
    }
    values() {
      return Object.keys(this.attributes).reduce(
        (attributes, name) => (attributes[name] = this.attributes[name].value(this.domNode), attributes),
        {}
      );
    }
  };
  var AttributorStore$1 = AttributorStore;
  var _ShadowBlot = class _ShadowBlot2 {
    static {
      __name(this, "_ShadowBlot");
    }
    constructor(scroll, domNode) {
      this.scroll = scroll, this.domNode = domNode, Registry.blots.set(domNode, this), this.prev = null, this.next = null;
    }
    static create(rawValue) {
      if (this.tagName == null)
        throw new ParchmentError("Blot definition missing tagName");
      let node, value;
      return Array.isArray(this.tagName) ? (typeof rawValue == "string" ? (value = rawValue.toUpperCase(), parseInt(value, 10).toString() === value && (value = parseInt(value, 10))) : typeof rawValue == "number" && (value = rawValue), typeof value == "number" ? node = document.createElement(this.tagName[value - 1]) : value && this.tagName.indexOf(value) > -1 ? node = document.createElement(value) : node = document.createElement(this.tagName[0])) : node = document.createElement(this.tagName), this.className && node.classList.add(this.className), node;
    }
    // Hack for accessing inherited static methods
    get statics() {
      return this.constructor;
    }
    attach() {
    }
    clone() {
      const domNode = this.domNode.cloneNode(false);
      return this.scroll.create(domNode);
    }
    detach() {
      this.parent != null && this.parent.removeChild(this), Registry.blots.delete(this.domNode);
    }
    deleteAt(index2, length) {
      this.isolate(index2, length).remove();
    }
    formatAt(index2, length, name, value) {
      const blot = this.isolate(index2, length);
      if (this.scroll.query(name, Scope.BLOT) != null && value)
        blot.wrap(name, value);
      else if (this.scroll.query(name, Scope.ATTRIBUTE) != null) {
        const parent = this.scroll.create(this.statics.scope);
        blot.wrap(parent), parent.format(name, value);
      }
    }
    insertAt(index2, value, def) {
      const blot = def == null ? this.scroll.create("text", value) : this.scroll.create(value, def), ref = this.split(index2);
      this.parent.insertBefore(blot, ref || void 0);
    }
    isolate(index2, length) {
      const target = this.split(index2);
      if (target == null)
        throw new Error("Attempt to isolate at end");
      return target.split(length), target;
    }
    length() {
      return 1;
    }
    offset(root2 = this.parent) {
      return this.parent == null || this === root2 ? 0 : this.parent.children.offset(this) + this.parent.offset(root2);
    }
    optimize(_context) {
      this.statics.requiredContainer && !(this.parent instanceof this.statics.requiredContainer) && this.wrap(this.statics.requiredContainer.blotName);
    }
    remove() {
      this.domNode.parentNode != null && this.domNode.parentNode.removeChild(this.domNode), this.detach();
    }
    replaceWith(name, value) {
      const replacement = typeof name == "string" ? this.scroll.create(name, value) : name;
      return this.parent != null && (this.parent.insertBefore(replacement, this.next || void 0), this.remove()), replacement;
    }
    split(index2, _force) {
      return index2 === 0 ? this : this.next;
    }
    update(_mutations, _context) {
    }
    wrap(name, value) {
      const wrapper = typeof name == "string" ? this.scroll.create(name, value) : name;
      if (this.parent != null && this.parent.insertBefore(wrapper, this.next || void 0), typeof wrapper.appendChild != "function")
        throw new ParchmentError(`Cannot wrap ${name}`);
      return wrapper.appendChild(this), wrapper;
    }
  };
  _ShadowBlot.blotName = "abstract";
  var ShadowBlot = _ShadowBlot;
  var _LeafBlot = class _LeafBlot2 extends ShadowBlot {
    static {
      __name(this, "_LeafBlot");
    }
    /**
     * Returns the value represented by domNode if it is this Blot's type
     * No checking that domNode can represent this Blot type is required so
     * applications needing it should check externally before calling.
     */
    static value(_domNode) {
      return true;
    }
    /**
     * Given location represented by node and offset from DOM Selection Range,
     * return index to that location.
     */
    index(node, offset) {
      return this.domNode === node || this.domNode.compareDocumentPosition(node) & Node.DOCUMENT_POSITION_CONTAINED_BY ? Math.min(offset, 1) : -1;
    }
    /**
     * Given index to location within blot, return node and offset representing
     * that location, consumable by DOM Selection Range
     */
    position(index2, _inclusive) {
      let offset = Array.from(this.parent.domNode.childNodes).indexOf(this.domNode);
      return index2 > 0 && (offset += 1), [this.parent.domNode, offset];
    }
    /**
     * Return value represented by this blot
     * Should not change without interaction from API or
     * user change detectable by update()
     */
    value() {
      return {
        [this.statics.blotName]: this.statics.value(this.domNode) || true
      };
    }
  };
  _LeafBlot.scope = Scope.INLINE_BLOT;
  var LeafBlot = _LeafBlot;
  var LeafBlot$1 = LeafBlot;
  var LinkedList = class {
    static {
      __name(this, "LinkedList");
    }
    constructor() {
      this.head = null, this.tail = null, this.length = 0;
    }
    append(...nodes) {
      if (this.insertBefore(nodes[0], null), nodes.length > 1) {
        const rest = nodes.slice(1);
        this.append(...rest);
      }
    }
    at(index2) {
      const next = this.iterator();
      let cur = next();
      for (; cur && index2 > 0; )
        index2 -= 1, cur = next();
      return cur;
    }
    contains(node) {
      const next = this.iterator();
      let cur = next();
      for (; cur; ) {
        if (cur === node)
          return true;
        cur = next();
      }
      return false;
    }
    indexOf(node) {
      const next = this.iterator();
      let cur = next(), index2 = 0;
      for (; cur; ) {
        if (cur === node)
          return index2;
        index2 += 1, cur = next();
      }
      return -1;
    }
    insertBefore(node, refNode) {
      node != null && (this.remove(node), node.next = refNode, refNode != null ? (node.prev = refNode.prev, refNode.prev != null && (refNode.prev.next = node), refNode.prev = node, refNode === this.head && (this.head = node)) : this.tail != null ? (this.tail.next = node, node.prev = this.tail, this.tail = node) : (node.prev = null, this.head = this.tail = node), this.length += 1);
    }
    offset(target) {
      let index2 = 0, cur = this.head;
      for (; cur != null; ) {
        if (cur === target)
          return index2;
        index2 += cur.length(), cur = cur.next;
      }
      return -1;
    }
    remove(node) {
      this.contains(node) && (node.prev != null && (node.prev.next = node.next), node.next != null && (node.next.prev = node.prev), node === this.head && (this.head = node.next), node === this.tail && (this.tail = node.prev), this.length -= 1);
    }
    iterator(curNode = this.head) {
      return () => {
        const ret = curNode;
        return curNode != null && (curNode = curNode.next), ret;
      };
    }
    find(index2, inclusive = false) {
      const next = this.iterator();
      let cur = next();
      for (; cur; ) {
        const length = cur.length();
        if (index2 < length || inclusive && index2 === length && (cur.next == null || cur.next.length() !== 0))
          return [cur, index2];
        index2 -= length, cur = next();
      }
      return [null, 0];
    }
    forEach(callback) {
      const next = this.iterator();
      let cur = next();
      for (; cur; )
        callback(cur), cur = next();
    }
    forEachAt(index2, length, callback) {
      if (length <= 0)
        return;
      const [startNode, offset] = this.find(index2);
      let curIndex = index2 - offset;
      const next = this.iterator(startNode);
      let cur = next();
      for (; cur && curIndex < index2 + length; ) {
        const curLength = cur.length();
        index2 > curIndex ? callback(
          cur,
          index2 - curIndex,
          Math.min(length, curIndex + curLength - index2)
        ) : callback(cur, 0, Math.min(curLength, index2 + length - curIndex)), curIndex += curLength, cur = next();
      }
    }
    map(callback) {
      return this.reduce((memo, cur) => (memo.push(callback(cur)), memo), []);
    }
    reduce(callback, memo) {
      const next = this.iterator();
      let cur = next();
      for (; cur; )
        memo = callback(memo, cur), cur = next();
      return memo;
    }
  };
  function makeAttachedBlot(node, scroll) {
    const found = scroll.find(node);
    if (found)
      return found;
    try {
      return scroll.create(node);
    } catch {
      const blot = scroll.create(Scope.INLINE);
      return Array.from(node.childNodes).forEach((child) => {
        blot.domNode.appendChild(child);
      }), node.parentNode && node.parentNode.replaceChild(blot.domNode, node), blot.attach(), blot;
    }
  }
  __name(makeAttachedBlot, "makeAttachedBlot");
  var _ParentBlot = class _ParentBlot2 extends ShadowBlot {
    static {
      __name(this, "_ParentBlot");
    }
    constructor(scroll, domNode) {
      super(scroll, domNode), this.uiNode = null, this.build();
    }
    appendChild(other) {
      this.insertBefore(other);
    }
    attach() {
      super.attach(), this.children.forEach((child) => {
        child.attach();
      });
    }
    attachUI(node) {
      this.uiNode != null && this.uiNode.remove(), this.uiNode = node, _ParentBlot2.uiClass && this.uiNode.classList.add(_ParentBlot2.uiClass), this.uiNode.setAttribute("contenteditable", "false"), this.domNode.insertBefore(this.uiNode, this.domNode.firstChild);
    }
    /**
     * Called during construction, should fill its own children LinkedList.
     */
    build() {
      this.children = new LinkedList(), Array.from(this.domNode.childNodes).filter((node) => node !== this.uiNode).reverse().forEach((node) => {
        try {
          const child = makeAttachedBlot(node, this.scroll);
          this.insertBefore(child, this.children.head || void 0);
        } catch (err) {
          if (err instanceof ParchmentError)
            return;
          throw err;
        }
      });
    }
    deleteAt(index2, length) {
      if (index2 === 0 && length === this.length())
        return this.remove();
      this.children.forEachAt(index2, length, (child, offset, childLength) => {
        child.deleteAt(offset, childLength);
      });
    }
    descendant(criteria, index2 = 0) {
      const [child, offset] = this.children.find(index2);
      return criteria.blotName == null && criteria(child) || criteria.blotName != null && child instanceof criteria ? [child, offset] : child instanceof _ParentBlot2 ? child.descendant(criteria, offset) : [null, -1];
    }
    descendants(criteria, index2 = 0, length = Number.MAX_VALUE) {
      let descendants = [], lengthLeft = length;
      return this.children.forEachAt(
        index2,
        length,
        (child, childIndex, childLength) => {
          (criteria.blotName == null && criteria(child) || criteria.blotName != null && child instanceof criteria) && descendants.push(child), child instanceof _ParentBlot2 && (descendants = descendants.concat(
            child.descendants(criteria, childIndex, lengthLeft)
          )), lengthLeft -= childLength;
        }
      ), descendants;
    }
    detach() {
      this.children.forEach((child) => {
        child.detach();
      }), super.detach();
    }
    enforceAllowedChildren() {
      let done = false;
      this.children.forEach((child) => {
        done || this.statics.allowedChildren.some(
          (def) => child instanceof def
        ) || (child.statics.scope === Scope.BLOCK_BLOT ? (child.next != null && this.splitAfter(child), child.prev != null && this.splitAfter(child.prev), child.parent.unwrap(), done = true) : child instanceof _ParentBlot2 ? child.unwrap() : child.remove());
      });
    }
    formatAt(index2, length, name, value) {
      this.children.forEachAt(index2, length, (child, offset, childLength) => {
        child.formatAt(offset, childLength, name, value);
      });
    }
    insertAt(index2, value, def) {
      const [child, offset] = this.children.find(index2);
      if (child)
        child.insertAt(offset, value, def);
      else {
        const blot = def == null ? this.scroll.create("text", value) : this.scroll.create(value, def);
        this.appendChild(blot);
      }
    }
    insertBefore(childBlot, refBlot) {
      childBlot.parent != null && childBlot.parent.children.remove(childBlot);
      let refDomNode = null;
      this.children.insertBefore(childBlot, refBlot || null), childBlot.parent = this, refBlot != null && (refDomNode = refBlot.domNode), (this.domNode.parentNode !== childBlot.domNode || this.domNode.nextSibling !== refDomNode) && this.domNode.insertBefore(childBlot.domNode, refDomNode), childBlot.attach();
    }
    length() {
      return this.children.reduce((memo, child) => memo + child.length(), 0);
    }
    moveChildren(targetParent, refNode) {
      this.children.forEach((child) => {
        targetParent.insertBefore(child, refNode);
      });
    }
    optimize(context) {
      if (super.optimize(context), this.enforceAllowedChildren(), this.uiNode != null && this.uiNode !== this.domNode.firstChild && this.domNode.insertBefore(this.uiNode, this.domNode.firstChild), this.children.length === 0)
        if (this.statics.defaultChild != null) {
          const child = this.scroll.create(this.statics.defaultChild.blotName);
          this.appendChild(child);
        } else
          this.remove();
    }
    path(index2, inclusive = false) {
      const [child, offset] = this.children.find(index2, inclusive), position = [[this, index2]];
      return child instanceof _ParentBlot2 ? position.concat(child.path(offset, inclusive)) : (child != null && position.push([child, offset]), position);
    }
    removeChild(child) {
      this.children.remove(child);
    }
    replaceWith(name, value) {
      const replacement = typeof name == "string" ? this.scroll.create(name, value) : name;
      return replacement instanceof _ParentBlot2 && this.moveChildren(replacement), super.replaceWith(replacement);
    }
    split(index2, force = false) {
      if (!force) {
        if (index2 === 0)
          return this;
        if (index2 === this.length())
          return this.next;
      }
      const after = this.clone();
      return this.parent && this.parent.insertBefore(after, this.next || void 0), this.children.forEachAt(index2, this.length(), (child, offset, _length) => {
        const split = child.split(offset, force);
        split != null && after.appendChild(split);
      }), after;
    }
    splitAfter(child) {
      const after = this.clone();
      for (; child.next != null; )
        after.appendChild(child.next);
      return this.parent && this.parent.insertBefore(after, this.next || void 0), after;
    }
    unwrap() {
      this.parent && this.moveChildren(this.parent, this.next || void 0), this.remove();
    }
    update(mutations, _context) {
      const addedNodes = [], removedNodes = [];
      mutations.forEach((mutation) => {
        mutation.target === this.domNode && mutation.type === "childList" && (addedNodes.push(...mutation.addedNodes), removedNodes.push(...mutation.removedNodes));
      }), removedNodes.forEach((node) => {
        if (node.parentNode != null && // @ts-expect-error Fix me later
        node.tagName !== "IFRAME" && document.body.compareDocumentPosition(node) & Node.DOCUMENT_POSITION_CONTAINED_BY)
          return;
        const blot = this.scroll.find(node);
        blot != null && (blot.domNode.parentNode == null || blot.domNode.parentNode === this.domNode) && blot.detach();
      }), addedNodes.filter((node) => node.parentNode === this.domNode && node !== this.uiNode).sort((a3, b3) => a3 === b3 ? 0 : a3.compareDocumentPosition(b3) & Node.DOCUMENT_POSITION_FOLLOWING ? 1 : -1).forEach((node) => {
        let refBlot = null;
        node.nextSibling != null && (refBlot = this.scroll.find(node.nextSibling));
        const blot = makeAttachedBlot(node, this.scroll);
        (blot.next !== refBlot || blot.next == null) && (blot.parent != null && blot.parent.removeChild(this), this.insertBefore(blot, refBlot || void 0));
      }), this.enforceAllowedChildren();
    }
  };
  _ParentBlot.uiClass = "";
  var ParentBlot = _ParentBlot;
  var ParentBlot$1 = ParentBlot;
  function isEqual2(obj1, obj2) {
    if (Object.keys(obj1).length !== Object.keys(obj2).length)
      return false;
    for (const prop in obj1)
      if (obj1[prop] !== obj2[prop])
        return false;
    return true;
  }
  __name(isEqual2, "isEqual");
  var _InlineBlot = class _InlineBlot2 extends ParentBlot$1 {
    static {
      __name(this, "_InlineBlot");
    }
    static create(value) {
      return super.create(value);
    }
    static formats(domNode, scroll) {
      const match2 = scroll.query(_InlineBlot2.blotName);
      if (!(match2 != null && domNode.tagName === match2.tagName)) {
        if (typeof this.tagName == "string")
          return true;
        if (Array.isArray(this.tagName))
          return domNode.tagName.toLowerCase();
      }
    }
    constructor(scroll, domNode) {
      super(scroll, domNode), this.attributes = new AttributorStore$1(this.domNode);
    }
    format(name, value) {
      if (name === this.statics.blotName && !value)
        this.children.forEach((child) => {
          child instanceof _InlineBlot2 || (child = child.wrap(_InlineBlot2.blotName, true)), this.attributes.copy(child);
        }), this.unwrap();
      else {
        const format = this.scroll.query(name, Scope.INLINE);
        if (format == null)
          return;
        format instanceof Attributor ? this.attributes.attribute(format, value) : value && (name !== this.statics.blotName || this.formats()[name] !== value) && this.replaceWith(name, value);
      }
    }
    formats() {
      const formats3 = this.attributes.values(), format = this.statics.formats(this.domNode, this.scroll);
      return format != null && (formats3[this.statics.blotName] = format), formats3;
    }
    formatAt(index2, length, name, value) {
      this.formats()[name] != null || this.scroll.query(name, Scope.ATTRIBUTE) ? this.isolate(index2, length).format(name, value) : super.formatAt(index2, length, name, value);
    }
    optimize(context) {
      super.optimize(context);
      const formats3 = this.formats();
      if (Object.keys(formats3).length === 0)
        return this.unwrap();
      const next = this.next;
      next instanceof _InlineBlot2 && next.prev === this && isEqual2(formats3, next.formats()) && (next.moveChildren(this), next.remove());
    }
    replaceWith(name, value) {
      const replacement = super.replaceWith(name, value);
      return this.attributes.copy(replacement), replacement;
    }
    update(mutations, context) {
      super.update(mutations, context), mutations.some(
        (mutation) => mutation.target === this.domNode && mutation.type === "attributes"
      ) && this.attributes.build();
    }
    wrap(name, value) {
      const wrapper = super.wrap(name, value);
      return wrapper instanceof _InlineBlot2 && this.attributes.move(wrapper), wrapper;
    }
  };
  _InlineBlot.allowedChildren = [_InlineBlot, LeafBlot$1], _InlineBlot.blotName = "inline", _InlineBlot.scope = Scope.INLINE_BLOT, _InlineBlot.tagName = "SPAN";
  var InlineBlot = _InlineBlot;
  var InlineBlot$1 = InlineBlot;
  var _BlockBlot = class _BlockBlot2 extends ParentBlot$1 {
    static {
      __name(this, "_BlockBlot");
    }
    static create(value) {
      return super.create(value);
    }
    static formats(domNode, scroll) {
      const match2 = scroll.query(_BlockBlot2.blotName);
      if (!(match2 != null && domNode.tagName === match2.tagName)) {
        if (typeof this.tagName == "string")
          return true;
        if (Array.isArray(this.tagName))
          return domNode.tagName.toLowerCase();
      }
    }
    constructor(scroll, domNode) {
      super(scroll, domNode), this.attributes = new AttributorStore$1(this.domNode);
    }
    format(name, value) {
      const format = this.scroll.query(name, Scope.BLOCK);
      format != null && (format instanceof Attributor ? this.attributes.attribute(format, value) : name === this.statics.blotName && !value ? this.replaceWith(_BlockBlot2.blotName) : value && (name !== this.statics.blotName || this.formats()[name] !== value) && this.replaceWith(name, value));
    }
    formats() {
      const formats3 = this.attributes.values(), format = this.statics.formats(this.domNode, this.scroll);
      return format != null && (formats3[this.statics.blotName] = format), formats3;
    }
    formatAt(index2, length, name, value) {
      this.scroll.query(name, Scope.BLOCK) != null ? this.format(name, value) : super.formatAt(index2, length, name, value);
    }
    insertAt(index2, value, def) {
      if (def == null || this.scroll.query(value, Scope.INLINE) != null)
        super.insertAt(index2, value, def);
      else {
        const after = this.split(index2);
        if (after != null) {
          const blot = this.scroll.create(value, def);
          after.parent.insertBefore(blot, after);
        } else
          throw new Error("Attempt to insertAt after block boundaries");
      }
    }
    replaceWith(name, value) {
      const replacement = super.replaceWith(name, value);
      return this.attributes.copy(replacement), replacement;
    }
    update(mutations, context) {
      super.update(mutations, context), mutations.some(
        (mutation) => mutation.target === this.domNode && mutation.type === "attributes"
      ) && this.attributes.build();
    }
  };
  _BlockBlot.blotName = "block", _BlockBlot.scope = Scope.BLOCK_BLOT, _BlockBlot.tagName = "P", _BlockBlot.allowedChildren = [
    InlineBlot$1,
    _BlockBlot,
    LeafBlot$1
  ];
  var BlockBlot = _BlockBlot;
  var BlockBlot$1 = BlockBlot;
  var _ContainerBlot = class _ContainerBlot2 extends ParentBlot$1 {
    static {
      __name(this, "_ContainerBlot");
    }
    checkMerge() {
      return this.next !== null && this.next.statics.blotName === this.statics.blotName;
    }
    deleteAt(index2, length) {
      super.deleteAt(index2, length), this.enforceAllowedChildren();
    }
    formatAt(index2, length, name, value) {
      super.formatAt(index2, length, name, value), this.enforceAllowedChildren();
    }
    insertAt(index2, value, def) {
      super.insertAt(index2, value, def), this.enforceAllowedChildren();
    }
    optimize(context) {
      super.optimize(context), this.children.length > 0 && this.next != null && this.checkMerge() && (this.next.moveChildren(this), this.next.remove());
    }
  };
  _ContainerBlot.blotName = "container", _ContainerBlot.scope = Scope.BLOCK_BLOT;
  var ContainerBlot = _ContainerBlot;
  var ContainerBlot$1 = ContainerBlot;
  var EmbedBlot = class extends LeafBlot$1 {
    static {
      __name(this, "EmbedBlot");
    }
    static formats(_domNode, _scroll) {
    }
    format(name, value) {
      super.formatAt(0, this.length(), name, value);
    }
    formatAt(index2, length, name, value) {
      index2 === 0 && length === this.length() ? this.format(name, value) : super.formatAt(index2, length, name, value);
    }
    formats() {
      return this.statics.formats(this.domNode, this.scroll);
    }
  };
  var EmbedBlot$1 = EmbedBlot;
  var OBSERVER_CONFIG = {
    attributes: true,
    characterData: true,
    characterDataOldValue: true,
    childList: true,
    subtree: true
  };
  var MAX_OPTIMIZE_ITERATIONS = 100;
  var _ScrollBlot = class _ScrollBlot2 extends ParentBlot$1 {
    static {
      __name(this, "_ScrollBlot");
    }
    constructor(registry, node) {
      super(null, node), this.registry = registry, this.scroll = this, this.build(), this.observer = new MutationObserver((mutations) => {
        this.update(mutations);
      }), this.observer.observe(this.domNode, OBSERVER_CONFIG), this.attach();
    }
    create(input, value) {
      return this.registry.create(this, input, value);
    }
    find(node, bubble = false) {
      const blot = this.registry.find(node, bubble);
      return blot ? blot.scroll === this ? blot : bubble ? this.find(blot.scroll.domNode.parentNode, true) : null : null;
    }
    query(query, scope = Scope.ANY) {
      return this.registry.query(query, scope);
    }
    register(...definitions) {
      return this.registry.register(...definitions);
    }
    build() {
      this.scroll != null && super.build();
    }
    detach() {
      super.detach(), this.observer.disconnect();
    }
    deleteAt(index2, length) {
      this.update(), index2 === 0 && length === this.length() ? this.children.forEach((child) => {
        child.remove();
      }) : super.deleteAt(index2, length);
    }
    formatAt(index2, length, name, value) {
      this.update(), super.formatAt(index2, length, name, value);
    }
    insertAt(index2, value, def) {
      this.update(), super.insertAt(index2, value, def);
    }
    optimize(mutations = [], context = {}) {
      super.optimize(context);
      const mutationsMap = context.mutationsMap || /* @__PURE__ */ new WeakMap();
      let records = Array.from(this.observer.takeRecords());
      for (; records.length > 0; )
        mutations.push(records.pop());
      const mark = /* @__PURE__ */ __name((blot, markParent = true) => {
        blot == null || blot === this || blot.domNode.parentNode != null && (mutationsMap.has(blot.domNode) || mutationsMap.set(blot.domNode, []), markParent && mark(blot.parent));
      }, "mark"), optimize = /* @__PURE__ */ __name((blot) => {
        mutationsMap.has(blot.domNode) && (blot instanceof ParentBlot$1 && blot.children.forEach(optimize), mutationsMap.delete(blot.domNode), blot.optimize(context));
      }, "optimize");
      let remaining = mutations;
      for (let i3 = 0; remaining.length > 0; i3 += 1) {
        if (i3 >= MAX_OPTIMIZE_ITERATIONS)
          throw new Error("[Parchment] Maximum optimize iterations reached");
        for (remaining.forEach((mutation) => {
          const blot = this.find(mutation.target, true);
          blot != null && (blot.domNode === mutation.target && (mutation.type === "childList" ? (mark(this.find(mutation.previousSibling, false)), Array.from(mutation.addedNodes).forEach((node) => {
            const child = this.find(node, false);
            mark(child, false), child instanceof ParentBlot$1 && child.children.forEach((grandChild) => {
              mark(grandChild, false);
            });
          })) : mutation.type === "attributes" && mark(blot.prev)), mark(blot));
        }), this.children.forEach(optimize), remaining = Array.from(this.observer.takeRecords()), records = remaining.slice(); records.length > 0; )
          mutations.push(records.pop());
      }
    }
    update(mutations, context = {}) {
      mutations = mutations || this.observer.takeRecords();
      const mutationsMap = /* @__PURE__ */ new WeakMap();
      mutations.map((mutation) => {
        const blot = this.find(mutation.target, true);
        return blot == null ? null : mutationsMap.has(blot.domNode) ? (mutationsMap.get(blot.domNode).push(mutation), null) : (mutationsMap.set(blot.domNode, [mutation]), blot);
      }).forEach((blot) => {
        blot != null && blot !== this && mutationsMap.has(blot.domNode) && blot.update(mutationsMap.get(blot.domNode) || [], context);
      }), context.mutationsMap = mutationsMap, mutationsMap.has(this.domNode) && super.update(mutationsMap.get(this.domNode), context), this.optimize(mutations, context);
    }
  };
  _ScrollBlot.blotName = "scroll", _ScrollBlot.defaultChild = BlockBlot$1, _ScrollBlot.allowedChildren = [BlockBlot$1, ContainerBlot$1], _ScrollBlot.scope = Scope.BLOCK_BLOT, _ScrollBlot.tagName = "DIV";
  var ScrollBlot = _ScrollBlot;
  var ScrollBlot$1 = ScrollBlot;
  var _TextBlot = class _TextBlot2 extends LeafBlot$1 {
    static {
      __name(this, "_TextBlot");
    }
    static create(value) {
      return document.createTextNode(value);
    }
    static value(domNode) {
      return domNode.data;
    }
    constructor(scroll, node) {
      super(scroll, node), this.text = this.statics.value(this.domNode);
    }
    deleteAt(index2, length) {
      this.domNode.data = this.text = this.text.slice(0, index2) + this.text.slice(index2 + length);
    }
    index(node, offset) {
      return this.domNode === node ? offset : -1;
    }
    insertAt(index2, value, def) {
      def == null ? (this.text = this.text.slice(0, index2) + value + this.text.slice(index2), this.domNode.data = this.text) : super.insertAt(index2, value, def);
    }
    length() {
      return this.text.length;
    }
    optimize(context) {
      super.optimize(context), this.text = this.statics.value(this.domNode), this.text.length === 0 ? this.remove() : this.next instanceof _TextBlot2 && this.next.prev === this && (this.insertAt(this.length(), this.next.value()), this.next.remove());
    }
    position(index2, _inclusive = false) {
      return [this.domNode, index2];
    }
    split(index2, force = false) {
      if (!force) {
        if (index2 === 0)
          return this;
        if (index2 === this.length())
          return this.next;
      }
      const after = this.scroll.create(this.domNode.splitText(index2));
      return this.parent.insertBefore(after, this.next || void 0), this.text = this.statics.value(this.domNode), after;
    }
    update(mutations, _context) {
      mutations.some((mutation) => mutation.type === "characterData" && mutation.target === this.domNode) && (this.text = this.statics.value(this.domNode));
    }
    value() {
      return this.text;
    }
  };
  _TextBlot.blotName = "text", _TextBlot.scope = Scope.INLINE_BLOT;
  var TextBlot = _TextBlot;
  var TextBlot$1 = TextBlot;

  // node_modules/quill/core/quill.js
  var import_quill_delta3 = __toESM(require_Delta(), 1);

  // node_modules/quill/core/editor.js
  var import_quill_delta2 = __toESM(require_Delta(), 1);

  // node_modules/quill/blots/block.js
  var import_quill_delta = __toESM(require_Delta(), 1);

  // node_modules/quill/blots/break.js
  var Break = class extends EmbedBlot$1 {
    static {
      __name(this, "Break");
    }
    static value() {
      return void 0;
    }
    optimize() {
      if (this.prev || this.next) {
        this.remove();
      }
    }
    length() {
      return 0;
    }
    value() {
      return "";
    }
  };
  Break.blotName = "break";
  Break.tagName = "BR";
  var break_default = Break;

  // node_modules/quill/blots/text.js
  var Text2 = class extends TextBlot$1 {
    static {
      __name(this, "Text");
    }
  };
  function escapeText(text) {
    return text.replace(/[&<>"']/g, (s3) => {
      const entityMap = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;"
      };
      return entityMap[s3];
    });
  }
  __name(escapeText, "escapeText");

  // node_modules/quill/blots/inline.js
  var Inline = class _Inline extends InlineBlot$1 {
    static {
      __name(this, "Inline");
    }
    static allowedChildren = [_Inline, break_default, EmbedBlot$1, Text2];
    // Lower index means deeper in the DOM tree, since not found (-1) is for embeds
    static order = [
      "cursor",
      "inline",
      // Must be lower
      "link",
      // Chrome wants <a> to be lower
      "underline",
      "strike",
      "italic",
      "bold",
      "script",
      "code"
      // Must be higher
    ];
    static compare(self2, other) {
      const selfIndex = _Inline.order.indexOf(self2);
      const otherIndex = _Inline.order.indexOf(other);
      if (selfIndex >= 0 || otherIndex >= 0) {
        return selfIndex - otherIndex;
      }
      if (self2 === other) {
        return 0;
      }
      if (self2 < other) {
        return -1;
      }
      return 1;
    }
    formatAt(index2, length, name, value) {
      if (_Inline.compare(this.statics.blotName, name) < 0 && this.scroll.query(name, Scope.BLOT)) {
        const blot = this.isolate(index2, length);
        if (value) {
          blot.wrap(name, value);
        }
      } else {
        super.formatAt(index2, length, name, value);
      }
    }
    optimize(context) {
      super.optimize(context);
      if (this.parent instanceof _Inline && _Inline.compare(this.statics.blotName, this.parent.statics.blotName) > 0) {
        const parent = this.parent.isolate(this.offset(), this.length());
        this.moveChildren(parent);
        parent.wrap(this);
      }
    }
  };
  var inline_default = Inline;

  // node_modules/quill/blots/block.js
  var NEWLINE_LENGTH = 1;
  var Block = class extends BlockBlot$1 {
    static {
      __name(this, "Block");
    }
    cache = {};
    delta() {
      if (this.cache.delta == null) {
        this.cache.delta = blockDelta(this);
      }
      return this.cache.delta;
    }
    deleteAt(index2, length) {
      super.deleteAt(index2, length);
      this.cache = {};
    }
    formatAt(index2, length, name, value) {
      if (length <= 0)
        return;
      if (this.scroll.query(name, Scope.BLOCK)) {
        if (index2 + length === this.length()) {
          this.format(name, value);
        }
      } else {
        super.formatAt(index2, Math.min(length, this.length() - index2 - 1), name, value);
      }
      this.cache = {};
    }
    insertAt(index2, value, def) {
      if (def != null) {
        super.insertAt(index2, value, def);
        this.cache = {};
        return;
      }
      if (value.length === 0)
        return;
      const lines = value.split("\n");
      const text = lines.shift();
      if (text.length > 0) {
        if (index2 < this.length() - 1 || this.children.tail == null) {
          super.insertAt(Math.min(index2, this.length() - 1), text);
        } else {
          this.children.tail.insertAt(this.children.tail.length(), text);
        }
        this.cache = {};
      }
      let block = this;
      lines.reduce((lineIndex, line) => {
        block = block.split(lineIndex, true);
        block.insertAt(0, line);
        return line.length;
      }, index2 + text.length);
    }
    insertBefore(blot, ref) {
      const {
        head
      } = this.children;
      super.insertBefore(blot, ref);
      if (head instanceof break_default) {
        head.remove();
      }
      this.cache = {};
    }
    length() {
      if (this.cache.length == null) {
        this.cache.length = super.length() + NEWLINE_LENGTH;
      }
      return this.cache.length;
    }
    moveChildren(target, ref) {
      super.moveChildren(target, ref);
      this.cache = {};
    }
    optimize(context) {
      super.optimize(context);
      this.cache = {};
    }
    path(index2) {
      return super.path(index2, true);
    }
    removeChild(child) {
      super.removeChild(child);
      this.cache = {};
    }
    split(index2) {
      let force = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      if (force && (index2 === 0 || index2 >= this.length() - NEWLINE_LENGTH)) {
        const clone2 = this.clone();
        if (index2 === 0) {
          this.parent.insertBefore(clone2, this);
          return this;
        }
        this.parent.insertBefore(clone2, this.next);
        return clone2;
      }
      const next = super.split(index2, force);
      this.cache = {};
      return next;
    }
  };
  Block.blotName = "block";
  Block.tagName = "P";
  Block.defaultChild = break_default;
  Block.allowedChildren = [break_default, inline_default, EmbedBlot$1, Text2];
  var BlockEmbed = class extends EmbedBlot$1 {
    static {
      __name(this, "BlockEmbed");
    }
    attach() {
      super.attach();
      this.attributes = new AttributorStore$1(this.domNode);
    }
    delta() {
      return new import_quill_delta.default().insert(this.value(), {
        ...this.formats(),
        ...this.attributes.values()
      });
    }
    format(name, value) {
      const attribute = this.scroll.query(name, Scope.BLOCK_ATTRIBUTE);
      if (attribute != null) {
        this.attributes.attribute(attribute, value);
      }
    }
    formatAt(index2, length, name, value) {
      this.format(name, value);
    }
    insertAt(index2, value, def) {
      if (def != null) {
        super.insertAt(index2, value, def);
        return;
      }
      const lines = value.split("\n");
      const text = lines.pop();
      const blocks = lines.map((line) => {
        const block = this.scroll.create(Block.blotName);
        block.insertAt(0, line);
        return block;
      });
      const ref = this.split(index2);
      blocks.forEach((block) => {
        this.parent.insertBefore(block, ref);
      });
      if (text) {
        this.parent.insertBefore(this.scroll.create("text", text), ref);
      }
    }
  };
  BlockEmbed.scope = Scope.BLOCK_BLOT;
  function blockDelta(blot) {
    let filter = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
    return blot.descendants(LeafBlot$1).reduce((delta, leaf) => {
      if (leaf.length() === 0) {
        return delta;
      }
      return delta.insert(leaf.value(), bubbleFormats(leaf, {}, filter));
    }, new import_quill_delta.default()).insert("\n", bubbleFormats(blot));
  }
  __name(blockDelta, "blockDelta");
  function bubbleFormats(blot) {
    let formats3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    let filter = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
    if (blot == null)
      return formats3;
    if ("formats" in blot && typeof blot.formats === "function") {
      formats3 = {
        ...formats3,
        ...blot.formats()
      };
      if (filter) {
        delete formats3["code-token"];
      }
    }
    if (blot.parent == null || blot.parent.statics.blotName === "scroll" || blot.parent.statics.scope !== blot.statics.scope) {
      return formats3;
    }
    return bubbleFormats(blot.parent, formats3, filter);
  }
  __name(bubbleFormats, "bubbleFormats");

  // node_modules/quill/blots/cursor.js
  var Cursor = class _Cursor extends EmbedBlot$1 {
    static {
      __name(this, "Cursor");
    }
    static blotName = "cursor";
    static className = "ql-cursor";
    static tagName = "span";
    static CONTENTS = "\uFEFF";
    // Zero width no break space
    static value() {
      return void 0;
    }
    constructor(scroll, domNode, selection) {
      super(scroll, domNode);
      this.selection = selection;
      this.textNode = document.createTextNode(_Cursor.CONTENTS);
      this.domNode.appendChild(this.textNode);
      this.savedLength = 0;
    }
    detach() {
      if (this.parent != null)
        this.parent.removeChild(this);
    }
    format(name, value) {
      if (this.savedLength !== 0) {
        super.format(name, value);
        return;
      }
      let target = this;
      let index2 = 0;
      while (target != null && target.statics.scope !== Scope.BLOCK_BLOT) {
        index2 += target.offset(target.parent);
        target = target.parent;
      }
      if (target != null) {
        this.savedLength = _Cursor.CONTENTS.length;
        target.optimize();
        target.formatAt(index2, _Cursor.CONTENTS.length, name, value);
        this.savedLength = 0;
      }
    }
    index(node, offset) {
      if (node === this.textNode)
        return 0;
      return super.index(node, offset);
    }
    length() {
      return this.savedLength;
    }
    position() {
      return [this.textNode, this.textNode.data.length];
    }
    remove() {
      super.remove();
      this.parent = null;
    }
    restore() {
      if (this.selection.composing || this.parent == null)
        return null;
      const range = this.selection.getNativeRange();
      while (this.domNode.lastChild != null && this.domNode.lastChild !== this.textNode) {
        this.domNode.parentNode.insertBefore(this.domNode.lastChild, this.domNode);
      }
      const prevTextBlot = this.prev instanceof Text2 ? this.prev : null;
      const prevTextLength = prevTextBlot ? prevTextBlot.length() : 0;
      const nextTextBlot = this.next instanceof Text2 ? this.next : null;
      const nextText = nextTextBlot ? nextTextBlot.text : "";
      const {
        textNode
      } = this;
      const newText = textNode.data.split(_Cursor.CONTENTS).join("");
      textNode.data = _Cursor.CONTENTS;
      let mergedTextBlot;
      if (prevTextBlot) {
        mergedTextBlot = prevTextBlot;
        if (newText || nextTextBlot) {
          prevTextBlot.insertAt(prevTextBlot.length(), newText + nextText);
          if (nextTextBlot) {
            nextTextBlot.remove();
          }
        }
      } else if (nextTextBlot) {
        mergedTextBlot = nextTextBlot;
        nextTextBlot.insertAt(0, newText);
      } else {
        const newTextNode = document.createTextNode(newText);
        mergedTextBlot = this.scroll.create(newTextNode);
        this.parent.insertBefore(mergedTextBlot, this);
      }
      this.remove();
      if (range) {
        const remapOffset = /* @__PURE__ */ __name((node, offset) => {
          if (prevTextBlot && node === prevTextBlot.domNode) {
            return offset;
          }
          if (node === textNode) {
            return prevTextLength + offset - 1;
          }
          if (nextTextBlot && node === nextTextBlot.domNode) {
            return prevTextLength + newText.length + offset;
          }
          return null;
        }, "remapOffset");
        const start2 = remapOffset(range.start.node, range.start.offset);
        const end = remapOffset(range.end.node, range.end.offset);
        if (start2 !== null && end !== null) {
          return {
            startNode: mergedTextBlot.domNode,
            startOffset: start2,
            endNode: mergedTextBlot.domNode,
            endOffset: end
          };
        }
      }
      return null;
    }
    update(mutations, context) {
      if (mutations.some((mutation) => {
        return mutation.type === "characterData" && mutation.target === this.textNode;
      })) {
        const range = this.restore();
        if (range)
          context.range = range;
      }
    }
    // Avoid .ql-cursor being a descendant of `<a/>`.
    // The reason is Safari pushes down `<a/>` on text insertion.
    // That will cause DOM nodes not sync with the model.
    //
    // For example ({I} is the caret), given the markup:
    //    <a><span class="ql-cursor">\uFEFF{I}</span></a>
    // When typing a char "x", `<a/>` will be pushed down inside the `<span>` first:
    //    <span class="ql-cursor"><a>\uFEFF{I}</a></span>
    // And then "x" will be inserted after `<a/>`:
    //    <span class="ql-cursor"><a>\uFEFF</a>d{I}</span>
    optimize(context) {
      super.optimize(context);
      let {
        parent
      } = this;
      while (parent) {
        if (parent.domNode.tagName === "A") {
          this.savedLength = _Cursor.CONTENTS.length;
          parent.isolate(this.offset(parent), this.length()).unwrap();
          this.savedLength = 0;
          break;
        }
        parent = parent.parent;
      }
    }
    value() {
      return "";
    }
  };
  var cursor_default = Cursor;

  // node_modules/eventemitter3/index.mjs
  var import_index = __toESM(require_eventemitter3(), 1);

  // node_modules/quill/core/instances.js
  var instances_default = /* @__PURE__ */ new WeakMap();

  // node_modules/quill/core/logger.js
  var levels = ["error", "warn", "log", "info"];
  var level = "warn";
  function debug(method) {
    if (level) {
      if (levels.indexOf(method) <= levels.indexOf(level)) {
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }
        console[method](...args);
      }
    }
  }
  __name(debug, "debug");
  function namespace(ns) {
    return levels.reduce((logger2, method) => {
      logger2[method] = debug.bind(console, method, ns);
      return logger2;
    }, {});
  }
  __name(namespace, "namespace");
  namespace.level = (newLevel) => {
    level = newLevel;
  };
  debug.level = namespace.level;
  var logger_default2 = namespace;

  // node_modules/quill/core/emitter.js
  var debug2 = logger_default2("quill:events");
  var EVENTS = ["selectionchange", "mousedown", "mouseup", "click"];
  EVENTS.forEach((eventName) => {
    document.addEventListener(eventName, function() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      Array.from(document.querySelectorAll(".ql-container")).forEach((node) => {
        const quill = instances_default.get(node);
        if (quill && quill.emitter) {
          quill.emitter.handleDOM(...args);
        }
      });
    });
  });
  var Emitter = class extends import_index.default {
    static {
      __name(this, "Emitter");
    }
    static events = {
      EDITOR_CHANGE: "editor-change",
      SCROLL_BEFORE_UPDATE: "scroll-before-update",
      SCROLL_BLOT_MOUNT: "scroll-blot-mount",
      SCROLL_BLOT_UNMOUNT: "scroll-blot-unmount",
      SCROLL_OPTIMIZE: "scroll-optimize",
      SCROLL_UPDATE: "scroll-update",
      SCROLL_EMBED_UPDATE: "scroll-embed-update",
      SELECTION_CHANGE: "selection-change",
      TEXT_CHANGE: "text-change",
      COMPOSITION_BEFORE_START: "composition-before-start",
      COMPOSITION_START: "composition-start",
      COMPOSITION_BEFORE_END: "composition-before-end",
      COMPOSITION_END: "composition-end"
    };
    static sources = {
      API: "api",
      SILENT: "silent",
      USER: "user"
    };
    constructor() {
      super();
      this.domListeners = {};
      this.on("error", debug2.error);
    }
    emit() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      debug2.log.call(debug2, ...args);
      return super.emit(...args);
    }
    handleDOM(event) {
      for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
        args[_key3 - 1] = arguments[_key3];
      }
      (this.domListeners[event.type] || []).forEach((_ref) => {
        let {
          node,
          handler
        } = _ref;
        if (event.target === node || node.contains(event.target)) {
          handler(event, ...args);
        }
      });
    }
    listenDOM(eventName, node, handler) {
      if (!this.domListeners[eventName]) {
        this.domListeners[eventName] = [];
      }
      this.domListeners[eventName].push({
        node,
        handler
      });
    }
  };
  var emitter_default = Emitter;

  // node_modules/quill/core/selection.js
  var debug3 = logger_default2("quill:selection");
  var Range = class {
    static {
      __name(this, "Range");
    }
    constructor(index2) {
      let length = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      this.index = index2;
      this.length = length;
    }
  };
  var Selection = class {
    static {
      __name(this, "Selection");
    }
    constructor(scroll, emitter) {
      this.emitter = emitter;
      this.scroll = scroll;
      this.composing = false;
      this.mouseDown = false;
      this.root = this.scroll.domNode;
      this.cursor = this.scroll.create("cursor", this);
      this.savedRange = new Range(0, 0);
      this.lastRange = this.savedRange;
      this.lastNative = null;
      this.handleComposition();
      this.handleDragging();
      this.emitter.listenDOM("selectionchange", document, () => {
        if (!this.mouseDown && !this.composing) {
          setTimeout(this.update.bind(this, emitter_default.sources.USER), 1);
        }
      });
      this.emitter.on(emitter_default.events.SCROLL_BEFORE_UPDATE, () => {
        if (!this.hasFocus())
          return;
        const native = this.getNativeRange();
        if (native == null)
          return;
        if (native.start.node === this.cursor.textNode)
          return;
        this.emitter.once(emitter_default.events.SCROLL_UPDATE, (source, mutations) => {
          try {
            if (this.root.contains(native.start.node) && this.root.contains(native.end.node)) {
              this.setNativeRange(native.start.node, native.start.offset, native.end.node, native.end.offset);
            }
            const triggeredByTyping = mutations.some((mutation) => mutation.type === "characterData" || mutation.type === "childList" || mutation.type === "attributes" && mutation.target === this.root);
            this.update(triggeredByTyping ? emitter_default.sources.SILENT : source);
          } catch (ignored) {
          }
        });
      });
      this.emitter.on(emitter_default.events.SCROLL_OPTIMIZE, (mutations, context) => {
        if (context.range) {
          const {
            startNode,
            startOffset,
            endNode,
            endOffset
          } = context.range;
          this.setNativeRange(startNode, startOffset, endNode, endOffset);
          this.update(emitter_default.sources.SILENT);
        }
      });
      this.update(emitter_default.sources.SILENT);
    }
    handleComposition() {
      this.emitter.on(emitter_default.events.COMPOSITION_BEFORE_START, () => {
        this.composing = true;
      });
      this.emitter.on(emitter_default.events.COMPOSITION_END, () => {
        this.composing = false;
        if (this.cursor.parent) {
          const range = this.cursor.restore();
          if (!range)
            return;
          setTimeout(() => {
            this.setNativeRange(range.startNode, range.startOffset, range.endNode, range.endOffset);
          }, 1);
        }
      });
    }
    handleDragging() {
      this.emitter.listenDOM("mousedown", document.body, () => {
        this.mouseDown = true;
      });
      this.emitter.listenDOM("mouseup", document.body, () => {
        this.mouseDown = false;
        this.update(emitter_default.sources.USER);
      });
    }
    focus() {
      if (this.hasFocus())
        return;
      this.root.focus({
        preventScroll: true
      });
      this.setRange(this.savedRange);
    }
    format(format, value) {
      this.scroll.update();
      const nativeRange = this.getNativeRange();
      if (nativeRange == null || !nativeRange.native.collapsed || this.scroll.query(format, Scope.BLOCK))
        return;
      if (nativeRange.start.node !== this.cursor.textNode) {
        const blot = this.scroll.find(nativeRange.start.node, false);
        if (blot == null)
          return;
        if (blot instanceof LeafBlot$1) {
          const after = blot.split(nativeRange.start.offset);
          blot.parent.insertBefore(this.cursor, after);
        } else {
          blot.insertBefore(this.cursor, nativeRange.start.node);
        }
        this.cursor.attach();
      }
      this.cursor.format(format, value);
      this.scroll.optimize();
      this.setNativeRange(this.cursor.textNode, this.cursor.textNode.data.length);
      this.update();
    }
    getBounds(index2) {
      let length = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      const scrollLength = this.scroll.length();
      index2 = Math.min(index2, scrollLength - 1);
      length = Math.min(index2 + length, scrollLength - 1) - index2;
      let node;
      let [leaf, offset] = this.scroll.leaf(index2);
      if (leaf == null)
        return null;
      if (length > 0 && offset === leaf.length()) {
        const [next] = this.scroll.leaf(index2 + 1);
        if (next) {
          const [line] = this.scroll.line(index2);
          const [nextLine] = this.scroll.line(index2 + 1);
          if (line === nextLine) {
            leaf = next;
            offset = 0;
          }
        }
      }
      [node, offset] = leaf.position(offset, true);
      const range = document.createRange();
      if (length > 0) {
        range.setStart(node, offset);
        [leaf, offset] = this.scroll.leaf(index2 + length);
        if (leaf == null)
          return null;
        [node, offset] = leaf.position(offset, true);
        range.setEnd(node, offset);
        return range.getBoundingClientRect();
      }
      let side = "left";
      let rect;
      if (node instanceof Text) {
        if (!node.data.length) {
          return null;
        }
        if (offset < node.data.length) {
          range.setStart(node, offset);
          range.setEnd(node, offset + 1);
        } else {
          range.setStart(node, offset - 1);
          range.setEnd(node, offset);
          side = "right";
        }
        rect = range.getBoundingClientRect();
      } else {
        if (!(leaf.domNode instanceof Element))
          return null;
        rect = leaf.domNode.getBoundingClientRect();
        if (offset > 0)
          side = "right";
      }
      return {
        bottom: rect.top + rect.height,
        height: rect.height,
        left: rect[side],
        right: rect[side],
        top: rect.top,
        width: 0
      };
    }
    getNativeRange() {
      const selection = document.getSelection();
      if (selection == null || selection.rangeCount <= 0)
        return null;
      const nativeRange = selection.getRangeAt(0);
      if (nativeRange == null)
        return null;
      const range = this.normalizeNative(nativeRange);
      debug3.info("getNativeRange", range);
      return range;
    }
    getRange() {
      const root2 = this.scroll.domNode;
      if ("isConnected" in root2 && !root2.isConnected) {
        return [null, null];
      }
      const normalized = this.getNativeRange();
      if (normalized == null)
        return [null, null];
      const range = this.normalizedToRange(normalized);
      return [range, normalized];
    }
    hasFocus() {
      return document.activeElement === this.root || document.activeElement != null && contains(this.root, document.activeElement);
    }
    normalizedToRange(range) {
      const positions = [[range.start.node, range.start.offset]];
      if (!range.native.collapsed) {
        positions.push([range.end.node, range.end.offset]);
      }
      const indexes = positions.map((position) => {
        const [node, offset] = position;
        const blot = this.scroll.find(node, true);
        const index2 = blot.offset(this.scroll);
        if (offset === 0) {
          return index2;
        }
        if (blot instanceof LeafBlot$1) {
          return index2 + blot.index(node, offset);
        }
        return index2 + blot.length();
      });
      const end = Math.min(Math.max(...indexes), this.scroll.length() - 1);
      const start2 = Math.min(end, ...indexes);
      return new Range(start2, end - start2);
    }
    normalizeNative(nativeRange) {
      if (!contains(this.root, nativeRange.startContainer) || !nativeRange.collapsed && !contains(this.root, nativeRange.endContainer)) {
        return null;
      }
      const range = {
        start: {
          node: nativeRange.startContainer,
          offset: nativeRange.startOffset
        },
        end: {
          node: nativeRange.endContainer,
          offset: nativeRange.endOffset
        },
        native: nativeRange
      };
      [range.start, range.end].forEach((position) => {
        let {
          node,
          offset
        } = position;
        while (!(node instanceof Text) && node.childNodes.length > 0) {
          if (node.childNodes.length > offset) {
            node = node.childNodes[offset];
            offset = 0;
          } else if (node.childNodes.length === offset) {
            node = node.lastChild;
            if (node instanceof Text) {
              offset = node.data.length;
            } else if (node.childNodes.length > 0) {
              offset = node.childNodes.length;
            } else {
              offset = node.childNodes.length + 1;
            }
          } else {
            break;
          }
        }
        position.node = node;
        position.offset = offset;
      });
      return range;
    }
    rangeToNative(range) {
      const scrollLength = this.scroll.length();
      const getPosition = /* @__PURE__ */ __name((index2, inclusive) => {
        index2 = Math.min(scrollLength - 1, index2);
        const [leaf, leafOffset] = this.scroll.leaf(index2);
        return leaf ? leaf.position(leafOffset, inclusive) : [null, -1];
      }, "getPosition");
      return [...getPosition(range.index, false), ...getPosition(range.index + range.length, true)];
    }
    setNativeRange(startNode, startOffset) {
      let endNode = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : startNode;
      let endOffset = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : startOffset;
      let force = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;
      debug3.info("setNativeRange", startNode, startOffset, endNode, endOffset);
      if (startNode != null && (this.root.parentNode == null || startNode.parentNode == null || // @ts-expect-error Fix me later
      endNode.parentNode == null)) {
        return;
      }
      const selection = document.getSelection();
      if (selection == null)
        return;
      if (startNode != null) {
        if (!this.hasFocus())
          this.root.focus({
            preventScroll: true
          });
        const {
          native
        } = this.getNativeRange() || {};
        if (native == null || force || startNode !== native.startContainer || startOffset !== native.startOffset || endNode !== native.endContainer || endOffset !== native.endOffset) {
          if (startNode instanceof Element && startNode.tagName === "BR") {
            startOffset = Array.from(startNode.parentNode.childNodes).indexOf(startNode);
            startNode = startNode.parentNode;
          }
          if (endNode instanceof Element && endNode.tagName === "BR") {
            endOffset = Array.from(endNode.parentNode.childNodes).indexOf(endNode);
            endNode = endNode.parentNode;
          }
          const range = document.createRange();
          range.setStart(startNode, startOffset);
          range.setEnd(endNode, endOffset);
          selection.removeAllRanges();
          selection.addRange(range);
        }
      } else {
        selection.removeAllRanges();
        this.root.blur();
      }
    }
    setRange(range) {
      let force = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      let source = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : emitter_default.sources.API;
      if (typeof force === "string") {
        source = force;
        force = false;
      }
      debug3.info("setRange", range);
      if (range != null) {
        const args = this.rangeToNative(range);
        this.setNativeRange(...args, force);
      } else {
        this.setNativeRange(null);
      }
      this.update(source);
    }
    update() {
      let source = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : emitter_default.sources.USER;
      const oldRange = this.lastRange;
      const [lastRange, nativeRange] = this.getRange();
      this.lastRange = lastRange;
      this.lastNative = nativeRange;
      if (this.lastRange != null) {
        this.savedRange = this.lastRange;
      }
      if (!isEqual_default(oldRange, this.lastRange)) {
        if (!this.composing && nativeRange != null && nativeRange.native.collapsed && nativeRange.start.node !== this.cursor.textNode) {
          const range = this.cursor.restore();
          if (range) {
            this.setNativeRange(range.startNode, range.startOffset, range.endNode, range.endOffset);
          }
        }
        const args = [emitter_default.events.SELECTION_CHANGE, cloneDeep_default(this.lastRange), cloneDeep_default(oldRange), source];
        this.emitter.emit(emitter_default.events.EDITOR_CHANGE, ...args);
        if (source !== emitter_default.sources.SILENT) {
          this.emitter.emit(...args);
        }
      }
    }
  };
  function contains(parent, descendant) {
    try {
      descendant.parentNode;
    } catch (e3) {
      return false;
    }
    return parent.contains(descendant);
  }
  __name(contains, "contains");
  var selection_default = Selection;

  // node_modules/quill/core/editor.js
  var ASCII = /^[ -~]*$/;
  var Editor = class {
    static {
      __name(this, "Editor");
    }
    constructor(scroll) {
      this.scroll = scroll;
      this.delta = this.getDelta();
    }
    applyDelta(delta) {
      this.scroll.update();
      let scrollLength = this.scroll.length();
      this.scroll.batchStart();
      const normalizedDelta = normalizeDelta(delta);
      const deleteDelta = new import_quill_delta2.default();
      const normalizedOps = splitOpLines(normalizedDelta.ops.slice());
      normalizedOps.reduce((index2, op) => {
        const length = import_quill_delta2.Op.length(op);
        let attributes = op.attributes || {};
        let isImplicitNewlinePrepended = false;
        let isImplicitNewlineAppended = false;
        if (op.insert != null) {
          deleteDelta.retain(length);
          if (typeof op.insert === "string") {
            const text = op.insert;
            isImplicitNewlineAppended = !text.endsWith("\n") && (scrollLength <= index2 || !!this.scroll.descendant(BlockEmbed, index2)[0]);
            this.scroll.insertAt(index2, text);
            const [line, offset] = this.scroll.line(index2);
            let formats3 = merge_default({}, bubbleFormats(line));
            if (line instanceof Block) {
              const [leaf] = line.descendant(LeafBlot$1, offset);
              if (leaf) {
                formats3 = merge_default(formats3, bubbleFormats(leaf));
              }
            }
            attributes = import_quill_delta2.AttributeMap.diff(formats3, attributes) || {};
          } else if (typeof op.insert === "object") {
            const key = Object.keys(op.insert)[0];
            if (key == null)
              return index2;
            const isInlineEmbed = this.scroll.query(key, Scope.INLINE) != null;
            if (isInlineEmbed) {
              if (scrollLength <= index2 || !!this.scroll.descendant(BlockEmbed, index2)[0]) {
                isImplicitNewlineAppended = true;
              }
            } else if (index2 > 0) {
              const [leaf, offset] = this.scroll.descendant(LeafBlot$1, index2 - 1);
              if (leaf instanceof Text2) {
                const text = leaf.value();
                if (text[offset] !== "\n") {
                  isImplicitNewlinePrepended = true;
                }
              } else if (leaf instanceof EmbedBlot$1 && leaf.statics.scope === Scope.INLINE_BLOT) {
                isImplicitNewlinePrepended = true;
              }
            }
            this.scroll.insertAt(index2, key, op.insert[key]);
            if (isInlineEmbed) {
              const [leaf] = this.scroll.descendant(LeafBlot$1, index2);
              if (leaf) {
                const formats3 = merge_default({}, bubbleFormats(leaf));
                attributes = import_quill_delta2.AttributeMap.diff(formats3, attributes) || {};
              }
            }
          }
          scrollLength += length;
        } else {
          deleteDelta.push(op);
          if (op.retain !== null && typeof op.retain === "object") {
            const key = Object.keys(op.retain)[0];
            if (key == null)
              return index2;
            this.scroll.updateEmbedAt(index2, key, op.retain[key]);
          }
        }
        Object.keys(attributes).forEach((name) => {
          this.scroll.formatAt(index2, length, name, attributes[name]);
        });
        const prependedLength = isImplicitNewlinePrepended ? 1 : 0;
        const addedLength = isImplicitNewlineAppended ? 1 : 0;
        scrollLength += prependedLength + addedLength;
        deleteDelta.retain(prependedLength);
        deleteDelta.delete(addedLength);
        return index2 + length + prependedLength + addedLength;
      }, 0);
      deleteDelta.reduce((index2, op) => {
        if (typeof op.delete === "number") {
          this.scroll.deleteAt(index2, op.delete);
          return index2;
        }
        return index2 + import_quill_delta2.Op.length(op);
      }, 0);
      this.scroll.batchEnd();
      this.scroll.optimize();
      return this.update(normalizedDelta);
    }
    deleteText(index2, length) {
      this.scroll.deleteAt(index2, length);
      return this.update(new import_quill_delta2.default().retain(index2).delete(length));
    }
    formatLine(index2, length) {
      let formats3 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      this.scroll.update();
      Object.keys(formats3).forEach((format) => {
        this.scroll.lines(index2, Math.max(length, 1)).forEach((line) => {
          line.format(format, formats3[format]);
        });
      });
      this.scroll.optimize();
      const delta = new import_quill_delta2.default().retain(index2).retain(length, cloneDeep_default(formats3));
      return this.update(delta);
    }
    formatText(index2, length) {
      let formats3 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      Object.keys(formats3).forEach((format) => {
        this.scroll.formatAt(index2, length, format, formats3[format]);
      });
      const delta = new import_quill_delta2.default().retain(index2).retain(length, cloneDeep_default(formats3));
      return this.update(delta);
    }
    getContents(index2, length) {
      return this.delta.slice(index2, index2 + length);
    }
    getDelta() {
      return this.scroll.lines().reduce((delta, line) => {
        return delta.concat(line.delta());
      }, new import_quill_delta2.default());
    }
    getFormat(index2) {
      let length = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      let lines = [];
      let leaves = [];
      if (length === 0) {
        this.scroll.path(index2).forEach((path) => {
          const [blot] = path;
          if (blot instanceof Block) {
            lines.push(blot);
          } else if (blot instanceof LeafBlot$1) {
            leaves.push(blot);
          }
        });
      } else {
        lines = this.scroll.lines(index2, length);
        leaves = this.scroll.descendants(LeafBlot$1, index2, length);
      }
      const [lineFormats, leafFormats] = [lines, leaves].map((blots) => {
        const blot = blots.shift();
        if (blot == null)
          return {};
        let formats3 = bubbleFormats(blot);
        while (Object.keys(formats3).length > 0) {
          const blot2 = blots.shift();
          if (blot2 == null)
            return formats3;
          formats3 = combineFormats(bubbleFormats(blot2), formats3);
        }
        return formats3;
      });
      return {
        ...lineFormats,
        ...leafFormats
      };
    }
    getHTML(index2, length) {
      const [line, lineOffset] = this.scroll.line(index2);
      if (line) {
        const lineLength = line.length();
        const isWithinLine = line.length() >= lineOffset + length;
        if (isWithinLine && !(lineOffset === 0 && length === lineLength)) {
          return convertHTML(line, lineOffset, length, true);
        }
        return convertHTML(this.scroll, index2, length, true);
      }
      return "";
    }
    getText(index2, length) {
      return this.getContents(index2, length).filter((op) => typeof op.insert === "string").map((op) => op.insert).join("");
    }
    insertContents(index2, contents) {
      const normalizedDelta = normalizeDelta(contents);
      const change = new import_quill_delta2.default().retain(index2).concat(normalizedDelta);
      this.scroll.insertContents(index2, normalizedDelta);
      return this.update(change);
    }
    insertEmbed(index2, embed, value) {
      this.scroll.insertAt(index2, embed, value);
      return this.update(new import_quill_delta2.default().retain(index2).insert({
        [embed]: value
      }));
    }
    insertText(index2, text) {
      let formats3 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      text = text.replace(/\r\n/g, "\n").replace(/\r/g, "\n");
      this.scroll.insertAt(index2, text);
      Object.keys(formats3).forEach((format) => {
        this.scroll.formatAt(index2, text.length, format, formats3[format]);
      });
      return this.update(new import_quill_delta2.default().retain(index2).insert(text, cloneDeep_default(formats3)));
    }
    isBlank() {
      if (this.scroll.children.length === 0)
        return true;
      if (this.scroll.children.length > 1)
        return false;
      const blot = this.scroll.children.head;
      if (blot?.statics.blotName !== Block.blotName)
        return false;
      const block = blot;
      if (block.children.length > 1)
        return false;
      return block.children.head instanceof break_default;
    }
    removeFormat(index2, length) {
      const text = this.getText(index2, length);
      const [line, offset] = this.scroll.line(index2 + length);
      let suffixLength = 0;
      let suffix = new import_quill_delta2.default();
      if (line != null) {
        suffixLength = line.length() - offset;
        suffix = line.delta().slice(offset, offset + suffixLength - 1).insert("\n");
      }
      const contents = this.getContents(index2, length + suffixLength);
      const diff = contents.diff(new import_quill_delta2.default().insert(text).concat(suffix));
      const delta = new import_quill_delta2.default().retain(index2).concat(diff);
      return this.applyDelta(delta);
    }
    update(change) {
      let mutations = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
      let selectionInfo = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : void 0;
      const oldDelta = this.delta;
      if (mutations.length === 1 && mutations[0].type === "characterData" && // @ts-expect-error Fix me later
      mutations[0].target.data.match(ASCII) && this.scroll.find(mutations[0].target)) {
        const textBlot = this.scroll.find(mutations[0].target);
        const formats3 = bubbleFormats(textBlot);
        const index2 = textBlot.offset(this.scroll);
        const oldValue = mutations[0].oldValue.replace(cursor_default.CONTENTS, "");
        const oldText = new import_quill_delta2.default().insert(oldValue);
        const newText = new import_quill_delta2.default().insert(textBlot.value());
        const relativeSelectionInfo = selectionInfo && {
          oldRange: shiftRange(selectionInfo.oldRange, -index2),
          newRange: shiftRange(selectionInfo.newRange, -index2)
        };
        const diffDelta = new import_quill_delta2.default().retain(index2).concat(oldText.diff(newText, relativeSelectionInfo));
        change = diffDelta.reduce((delta, op) => {
          if (op.insert) {
            return delta.insert(op.insert, formats3);
          }
          return delta.push(op);
        }, new import_quill_delta2.default());
        this.delta = oldDelta.compose(change);
      } else {
        this.delta = this.getDelta();
        if (!change || !isEqual_default(oldDelta.compose(change), this.delta)) {
          change = oldDelta.diff(this.delta, selectionInfo);
        }
      }
      return change;
    }
  };
  function convertListHTML(items, lastIndent, types) {
    if (items.length === 0) {
      const [endTag2] = getListType(types.pop());
      if (lastIndent <= 0) {
        return `</li></${endTag2}>`;
      }
      return `</li></${endTag2}>${convertListHTML([], lastIndent - 1, types)}`;
    }
    const [{
      child,
      offset,
      length,
      indent,
      type
    }, ...rest] = items;
    const [tag, attribute] = getListType(type);
    if (indent > lastIndent) {
      types.push(type);
      if (indent === lastIndent + 1) {
        return `<${tag}><li${attribute}>${convertHTML(child, offset, length)}${convertListHTML(rest, indent, types)}`;
      }
      return `<${tag}><li>${convertListHTML(items, lastIndent + 1, types)}`;
    }
    const previousType = types[types.length - 1];
    if (indent === lastIndent && type === previousType) {
      return `</li><li${attribute}>${convertHTML(child, offset, length)}${convertListHTML(rest, indent, types)}`;
    }
    const [endTag] = getListType(types.pop());
    return `</li></${endTag}>${convertListHTML(items, lastIndent - 1, types)}`;
  }
  __name(convertListHTML, "convertListHTML");
  function convertHTML(blot, index2, length) {
    let isRoot = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
    if ("html" in blot && typeof blot.html === "function") {
      return blot.html(index2, length);
    }
    if (blot instanceof Text2) {
      return escapeText(blot.value().slice(index2, index2 + length));
    }
    if (blot instanceof ParentBlot$1) {
      if (blot.statics.blotName === "list-container") {
        const items = [];
        blot.children.forEachAt(index2, length, (child, offset, childLength) => {
          const formats3 = "formats" in child && typeof child.formats === "function" ? child.formats() : {};
          items.push({
            child,
            offset,
            length: childLength,
            indent: formats3.indent || 0,
            type: formats3.list
          });
        });
        return convertListHTML(items, -1, []);
      }
      const parts = [];
      blot.children.forEachAt(index2, length, (child, offset, childLength) => {
        parts.push(convertHTML(child, offset, childLength));
      });
      if (isRoot || blot.statics.blotName === "list") {
        return parts.join("");
      }
      const {
        outerHTML,
        innerHTML
      } = blot.domNode;
      const [start2, end] = outerHTML.split(`>${innerHTML}<`);
      if (start2 === "<table") {
        return `<table style="border: 1px solid #000;">${parts.join("")}<${end}`;
      }
      return `${start2}>${parts.join("")}<${end}`;
    }
    return blot.domNode instanceof Element ? blot.domNode.outerHTML : "";
  }
  __name(convertHTML, "convertHTML");
  function combineFormats(formats3, combined) {
    return Object.keys(combined).reduce((merged, name) => {
      if (formats3[name] == null)
        return merged;
      const combinedValue = combined[name];
      if (combinedValue === formats3[name]) {
        merged[name] = combinedValue;
      } else if (Array.isArray(combinedValue)) {
        if (combinedValue.indexOf(formats3[name]) < 0) {
          merged[name] = combinedValue.concat([formats3[name]]);
        } else {
          merged[name] = combinedValue;
        }
      } else {
        merged[name] = [combinedValue, formats3[name]];
      }
      return merged;
    }, {});
  }
  __name(combineFormats, "combineFormats");
  function getListType(type) {
    const tag = type === "ordered" ? "ol" : "ul";
    switch (type) {
      case "checked":
        return [tag, ' data-list="checked"'];
      case "unchecked":
        return [tag, ' data-list="unchecked"'];
      default:
        return [tag, ""];
    }
  }
  __name(getListType, "getListType");
  function normalizeDelta(delta) {
    return delta.reduce((normalizedDelta, op) => {
      if (typeof op.insert === "string") {
        const text = op.insert.replace(/\r\n/g, "\n").replace(/\r/g, "\n");
        return normalizedDelta.insert(text, op.attributes);
      }
      return normalizedDelta.push(op);
    }, new import_quill_delta2.default());
  }
  __name(normalizeDelta, "normalizeDelta");
  function shiftRange(_ref, amount) {
    let {
      index: index2,
      length
    } = _ref;
    return new Range(index2 + amount, length);
  }
  __name(shiftRange, "shiftRange");
  function splitOpLines(ops) {
    const split = [];
    ops.forEach((op) => {
      if (typeof op.insert === "string") {
        const lines = op.insert.split("\n");
        lines.forEach((line, index2) => {
          if (index2)
            split.push({
              insert: "\n",
              attributes: op.attributes
            });
          if (line)
            split.push({
              insert: line,
              attributes: op.attributes
            });
        });
      } else {
        split.push(op);
      }
    });
    return split;
  }
  __name(splitOpLines, "splitOpLines");
  var editor_default = Editor;

  // node_modules/quill/core/module.js
  var Module = class {
    static {
      __name(this, "Module");
    }
    static DEFAULTS = {};
    constructor(quill) {
      let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      this.quill = quill;
      this.options = options;
    }
  };
  var module_default = Module;

  // node_modules/quill/blots/embed.js
  var GUARD_TEXT = "\uFEFF";
  var Embed = class extends EmbedBlot$1 {
    static {
      __name(this, "Embed");
    }
    constructor(scroll, node) {
      super(scroll, node);
      this.contentNode = document.createElement("span");
      this.contentNode.setAttribute("contenteditable", "false");
      Array.from(this.domNode.childNodes).forEach((childNode) => {
        this.contentNode.appendChild(childNode);
      });
      this.leftGuard = document.createTextNode(GUARD_TEXT);
      this.rightGuard = document.createTextNode(GUARD_TEXT);
      this.domNode.appendChild(this.leftGuard);
      this.domNode.appendChild(this.contentNode);
      this.domNode.appendChild(this.rightGuard);
    }
    index(node, offset) {
      if (node === this.leftGuard)
        return 0;
      if (node === this.rightGuard)
        return 1;
      return super.index(node, offset);
    }
    restore(node) {
      let range = null;
      let textNode;
      const text = node.data.split(GUARD_TEXT).join("");
      if (node === this.leftGuard) {
        if (this.prev instanceof Text2) {
          const prevLength = this.prev.length();
          this.prev.insertAt(prevLength, text);
          range = {
            startNode: this.prev.domNode,
            startOffset: prevLength + text.length
          };
        } else {
          textNode = document.createTextNode(text);
          this.parent.insertBefore(this.scroll.create(textNode), this);
          range = {
            startNode: textNode,
            startOffset: text.length
          };
        }
      } else if (node === this.rightGuard) {
        if (this.next instanceof Text2) {
          this.next.insertAt(0, text);
          range = {
            startNode: this.next.domNode,
            startOffset: text.length
          };
        } else {
          textNode = document.createTextNode(text);
          this.parent.insertBefore(this.scroll.create(textNode), this.next);
          range = {
            startNode: textNode,
            startOffset: text.length
          };
        }
      }
      node.data = GUARD_TEXT;
      return range;
    }
    update(mutations, context) {
      mutations.forEach((mutation) => {
        if (mutation.type === "characterData" && (mutation.target === this.leftGuard || mutation.target === this.rightGuard)) {
          const range = this.restore(mutation.target);
          if (range)
            context.range = range;
        }
      });
    }
  };
  var embed_default = Embed;

  // node_modules/quill/core/composition.js
  var Composition = class {
    static {
      __name(this, "Composition");
    }
    isComposing = false;
    constructor(scroll, emitter) {
      this.scroll = scroll;
      this.emitter = emitter;
      this.setupListeners();
    }
    setupListeners() {
      this.scroll.domNode.addEventListener("compositionstart", (event) => {
        if (!this.isComposing) {
          this.handleCompositionStart(event);
        }
      });
      this.scroll.domNode.addEventListener("compositionend", (event) => {
        if (this.isComposing) {
          queueMicrotask(() => {
            this.handleCompositionEnd(event);
          });
        }
      });
    }
    handleCompositionStart(event) {
      const blot = event.target instanceof Node ? this.scroll.find(event.target, true) : null;
      if (blot && !(blot instanceof embed_default)) {
        this.emitter.emit(emitter_default.events.COMPOSITION_BEFORE_START, event);
        this.scroll.batchStart();
        this.emitter.emit(emitter_default.events.COMPOSITION_START, event);
        this.isComposing = true;
      }
    }
    handleCompositionEnd(event) {
      this.emitter.emit(emitter_default.events.COMPOSITION_BEFORE_END, event);
      this.scroll.batchEnd();
      this.emitter.emit(emitter_default.events.COMPOSITION_END, event);
      this.isComposing = false;
    }
  };
  var composition_default = Composition;

  // node_modules/quill/core/theme.js
  var Theme = class _Theme {
    static {
      __name(this, "Theme");
    }
    static DEFAULTS = {
      modules: {}
    };
    static themes = {
      default: _Theme
    };
    modules = {};
    constructor(quill, options) {
      this.quill = quill;
      this.options = options;
    }
    init() {
      Object.keys(this.options.modules).forEach((name) => {
        if (this.modules[name] == null) {
          this.addModule(name);
        }
      });
    }
    addModule(name) {
      const ModuleClass = this.quill.constructor.import(`modules/${name}`);
      this.modules[name] = new ModuleClass(this.quill, this.options.modules[name] || {});
      return this.modules[name];
    }
  };
  var theme_default = Theme;

  // node_modules/quill/core/utils/scrollRectIntoView.js
  var getParentElement = /* @__PURE__ */ __name((element) => element.parentElement || element.getRootNode().host || null, "getParentElement");
  var getElementRect = /* @__PURE__ */ __name((element) => {
    const rect = element.getBoundingClientRect();
    const scaleX = "offsetWidth" in element && Math.abs(rect.width) / element.offsetWidth || 1;
    const scaleY = "offsetHeight" in element && Math.abs(rect.height) / element.offsetHeight || 1;
    return {
      top: rect.top,
      right: rect.left + element.clientWidth * scaleX,
      bottom: rect.top + element.clientHeight * scaleY,
      left: rect.left
    };
  }, "getElementRect");
  var paddingValueToInt = /* @__PURE__ */ __name((value) => {
    const number = parseInt(value, 10);
    return Number.isNaN(number) ? 0 : number;
  }, "paddingValueToInt");
  var getScrollDistance = /* @__PURE__ */ __name((targetStart, targetEnd, scrollStart, scrollEnd, scrollPaddingStart, scrollPaddingEnd) => {
    if (targetStart < scrollStart && targetEnd > scrollEnd) {
      return 0;
    }
    if (targetStart < scrollStart) {
      return -(scrollStart - targetStart + scrollPaddingStart);
    }
    if (targetEnd > scrollEnd) {
      return targetEnd - targetStart > scrollEnd - scrollStart ? targetStart + scrollPaddingStart - scrollStart : targetEnd - scrollEnd + scrollPaddingEnd;
    }
    return 0;
  }, "getScrollDistance");
  var scrollRectIntoView = /* @__PURE__ */ __name((root2, targetRect) => {
    const document2 = root2.ownerDocument;
    let rect = targetRect;
    let current = root2;
    while (current) {
      const isDocumentBody = current === document2.body;
      const bounding = isDocumentBody ? {
        top: 0,
        right: window.visualViewport?.width ?? document2.documentElement.clientWidth,
        bottom: window.visualViewport?.height ?? document2.documentElement.clientHeight,
        left: 0
      } : getElementRect(current);
      const style = getComputedStyle(current);
      const scrollDistanceX = getScrollDistance(rect.left, rect.right, bounding.left, bounding.right, paddingValueToInt(style.scrollPaddingLeft), paddingValueToInt(style.scrollPaddingRight));
      const scrollDistanceY = getScrollDistance(rect.top, rect.bottom, bounding.top, bounding.bottom, paddingValueToInt(style.scrollPaddingTop), paddingValueToInt(style.scrollPaddingBottom));
      if (scrollDistanceX || scrollDistanceY) {
        if (isDocumentBody) {
          document2.defaultView?.scrollBy(scrollDistanceX, scrollDistanceY);
        } else {
          const {
            scrollLeft,
            scrollTop
          } = current;
          if (scrollDistanceY) {
            current.scrollTop += scrollDistanceY;
          }
          if (scrollDistanceX) {
            current.scrollLeft += scrollDistanceX;
          }
          const scrolledLeft = current.scrollLeft - scrollLeft;
          const scrolledTop = current.scrollTop - scrollTop;
          rect = {
            left: rect.left - scrolledLeft,
            top: rect.top - scrolledTop,
            right: rect.right - scrolledLeft,
            bottom: rect.bottom - scrolledTop
          };
        }
      }
      current = isDocumentBody || style.position === "fixed" ? null : getParentElement(current);
    }
  }, "scrollRectIntoView");
  var scrollRectIntoView_default = scrollRectIntoView;

  // node_modules/quill/core/utils/createRegistryWithFormats.js
  var MAX_REGISTER_ITERATIONS = 100;
  var CORE_FORMATS = ["block", "break", "cursor", "inline", "scroll", "text"];
  var createRegistryWithFormats = /* @__PURE__ */ __name((formats3, sourceRegistry, debug8) => {
    const registry = new Registry();
    CORE_FORMATS.forEach((name) => {
      const coreBlot = sourceRegistry.query(name);
      if (coreBlot)
        registry.register(coreBlot);
    });
    formats3.forEach((name) => {
      let format = sourceRegistry.query(name);
      if (!format) {
        debug8.error(`Cannot register "${name}" specified in "formats" config. Are you sure it was registered?`);
      }
      let iterations = 0;
      while (format) {
        registry.register(format);
        format = "blotName" in format ? format.requiredContainer ?? null : null;
        iterations += 1;
        if (iterations > MAX_REGISTER_ITERATIONS) {
          debug8.error(`Cycle detected in registering blot requiredContainer: "${name}"`);
          break;
        }
      }
    });
    return registry;
  }, "createRegistryWithFormats");
  var createRegistryWithFormats_default = createRegistryWithFormats;

  // node_modules/quill/core/quill.js
  var debug4 = logger_default2("quill");
  var globalRegistry = new Registry();
  ParentBlot$1.uiClass = "ql-ui";
  var Quill = class _Quill {
    static {
      __name(this, "Quill");
    }
    static DEFAULTS = {
      bounds: null,
      modules: {
        clipboard: true,
        keyboard: true,
        history: true,
        uploader: true
      },
      placeholder: "",
      readOnly: false,
      registry: globalRegistry,
      theme: "default"
    };
    static events = emitter_default.events;
    static sources = emitter_default.sources;
    static version = false ? "dev" : "2.0.0";
    static imports = {
      delta: import_quill_delta3.default,
      parchment: parchment_exports,
      "core/module": module_default,
      "core/theme": theme_default
    };
    static debug(limit) {
      if (limit === true) {
        limit = "log";
      }
      logger_default2.level(limit);
    }
    static find(node) {
      let bubble = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      return instances_default.get(node) || globalRegistry.find(node, bubble);
    }
    static import(name) {
      if (this.imports[name] == null) {
        debug4.error(`Cannot import ${name}. Are you sure it was registered?`);
      }
      return this.imports[name];
    }
    static register(path, target) {
      let overwrite = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      if (typeof path !== "string") {
        const name = "attrName" in path ? path.attrName : path.blotName;
        if (typeof name === "string") {
          this.register(`formats/${name}`, path, target);
        } else {
          Object.keys(path).forEach((key) => {
            this.register(key, path[key], target);
          });
        }
      } else {
        if (this.imports[path] != null && !overwrite) {
          debug4.warn(`Overwriting ${path} with`, target);
        }
        this.imports[path] = target;
        if ((path.startsWith("blots/") || path.startsWith("formats/")) && target && typeof target !== "boolean" && // @ts-expect-error
        target.blotName !== "abstract") {
          globalRegistry.register(target);
        }
        if (typeof target.register === "function") {
          target.register(globalRegistry);
        }
      }
    }
    constructor(container) {
      let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      this.options = expandConfig(container, options);
      this.container = this.options.container;
      if (this.container == null) {
        debug4.error("Invalid Quill container", container);
        return;
      }
      if (this.options.debug) {
        _Quill.debug(this.options.debug);
      }
      const html = this.container.innerHTML.trim();
      this.container.classList.add("ql-container");
      this.container.innerHTML = "";
      instances_default.set(this.container, this);
      this.root = this.addContainer("ql-editor");
      this.root.classList.add("ql-blank");
      this.emitter = new emitter_default();
      const scrollBlotName = ScrollBlot$1.blotName;
      const ScrollBlot2 = this.options.registry.query(scrollBlotName);
      if (!ScrollBlot2 || !("blotName" in ScrollBlot2)) {
        throw new Error(`Cannot initialize Quill without "${scrollBlotName}" blot`);
      }
      this.scroll = new ScrollBlot2(this.options.registry, this.root, {
        emitter: this.emitter
      });
      this.editor = new editor_default(this.scroll);
      this.selection = new selection_default(this.scroll, this.emitter);
      this.composition = new composition_default(this.scroll, this.emitter);
      this.theme = new this.options.theme(this, this.options);
      this.keyboard = this.theme.addModule("keyboard");
      this.clipboard = this.theme.addModule("clipboard");
      this.history = this.theme.addModule("history");
      this.uploader = this.theme.addModule("uploader");
      this.theme.addModule("input");
      this.theme.addModule("uiNode");
      this.theme.init();
      this.emitter.on(emitter_default.events.EDITOR_CHANGE, (type) => {
        if (type === emitter_default.events.TEXT_CHANGE) {
          this.root.classList.toggle("ql-blank", this.editor.isBlank());
        }
      });
      this.emitter.on(emitter_default.events.SCROLL_UPDATE, (source, mutations) => {
        const oldRange = this.selection.lastRange;
        const [newRange] = this.selection.getRange();
        const selectionInfo = oldRange && newRange ? {
          oldRange,
          newRange
        } : void 0;
        modify.call(this, () => this.editor.update(null, mutations, selectionInfo), source);
      });
      this.emitter.on(emitter_default.events.SCROLL_EMBED_UPDATE, (blot, delta) => {
        const oldRange = this.selection.lastRange;
        const [newRange] = this.selection.getRange();
        const selectionInfo = oldRange && newRange ? {
          oldRange,
          newRange
        } : void 0;
        modify.call(this, () => {
          const change = new import_quill_delta3.default().retain(blot.offset(this)).retain({
            [blot.statics.blotName]: delta
          });
          return this.editor.update(change, [], selectionInfo);
        }, _Quill.sources.USER);
      });
      if (html) {
        const contents = this.clipboard.convert({
          html: `${html}<p><br></p>`,
          text: "\n"
        });
        this.setContents(contents);
      }
      this.history.clear();
      if (this.options.placeholder) {
        this.root.setAttribute("data-placeholder", this.options.placeholder);
      }
      if (this.options.readOnly) {
        this.disable();
      }
      this.allowReadOnlyEdits = false;
    }
    addContainer(container) {
      let refNode = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
      if (typeof container === "string") {
        const className = container;
        container = document.createElement("div");
        container.classList.add(className);
      }
      this.container.insertBefore(container, refNode);
      return container;
    }
    blur() {
      this.selection.setRange(null);
    }
    deleteText(index2, length, source) {
      [index2, length, , source] = overload(index2, length, source);
      return modify.call(this, () => {
        return this.editor.deleteText(index2, length);
      }, source, index2, -1 * length);
    }
    disable() {
      this.enable(false);
    }
    editReadOnly(modifier) {
      this.allowReadOnlyEdits = true;
      const value = modifier();
      this.allowReadOnlyEdits = false;
      return value;
    }
    enable() {
      let enabled = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
      this.scroll.enable(enabled);
      this.container.classList.toggle("ql-disabled", !enabled);
    }
    focus() {
      let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      this.selection.focus();
      if (!options.preventScroll) {
        this.scrollSelectionIntoView();
      }
    }
    format(name, value) {
      let source = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : emitter_default.sources.API;
      return modify.call(this, () => {
        const range = this.getSelection(true);
        let change = new import_quill_delta3.default();
        if (range == null)
          return change;
        if (this.scroll.query(name, Scope.BLOCK)) {
          change = this.editor.formatLine(range.index, range.length, {
            [name]: value
          });
        } else if (range.length === 0) {
          this.selection.format(name, value);
          return change;
        } else {
          change = this.editor.formatText(range.index, range.length, {
            [name]: value
          });
        }
        this.setSelection(range, emitter_default.sources.SILENT);
        return change;
      }, source);
    }
    formatLine(index2, length, name, value, source) {
      let formats3;
      [index2, length, formats3, source] = overload(
        index2,
        length,
        // @ts-expect-error
        name,
        value,
        source
      );
      return modify.call(this, () => {
        return this.editor.formatLine(index2, length, formats3);
      }, source, index2, 0);
    }
    formatText(index2, length, name, value, source) {
      let formats3;
      [index2, length, formats3, source] = overload(
        // @ts-expect-error
        index2,
        length,
        name,
        value,
        source
      );
      return modify.call(this, () => {
        return this.editor.formatText(index2, length, formats3);
      }, source, index2, 0);
    }
    getBounds(index2) {
      let length = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      let bounds = null;
      if (typeof index2 === "number") {
        bounds = this.selection.getBounds(index2, length);
      } else {
        bounds = this.selection.getBounds(index2.index, index2.length);
      }
      if (!bounds)
        return null;
      const containerBounds = this.container.getBoundingClientRect();
      return {
        bottom: bounds.bottom - containerBounds.top,
        height: bounds.height,
        left: bounds.left - containerBounds.left,
        right: bounds.right - containerBounds.left,
        top: bounds.top - containerBounds.top,
        width: bounds.width
      };
    }
    getContents() {
      let index2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      let length = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.getLength() - index2;
      [index2, length] = overload(index2, length);
      return this.editor.getContents(index2, length);
    }
    getFormat() {
      let index2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.getSelection(true);
      let length = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      if (typeof index2 === "number") {
        return this.editor.getFormat(index2, length);
      }
      return this.editor.getFormat(index2.index, index2.length);
    }
    getIndex(blot) {
      return blot.offset(this.scroll);
    }
    getLength() {
      return this.scroll.length();
    }
    getLeaf(index2) {
      return this.scroll.leaf(index2);
    }
    getLine(index2) {
      return this.scroll.line(index2);
    }
    getLines() {
      let index2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      let length = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Number.MAX_VALUE;
      if (typeof index2 !== "number") {
        return this.scroll.lines(index2.index, index2.length);
      }
      return this.scroll.lines(index2, length);
    }
    getModule(name) {
      return this.theme.modules[name];
    }
    getSelection() {
      let focus = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
      if (focus)
        this.focus();
      this.update();
      return this.selection.getRange()[0];
    }
    getSemanticHTML() {
      let index2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      let length = arguments.length > 1 ? arguments[1] : void 0;
      if (typeof index2 === "number") {
        length = length ?? this.getLength() - index2;
      }
      [index2, length] = overload(index2, length);
      return this.editor.getHTML(index2, length);
    }
    getText() {
      let index2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      let length = arguments.length > 1 ? arguments[1] : void 0;
      if (typeof index2 === "number") {
        length = length ?? this.getLength() - index2;
      }
      [index2, length] = overload(index2, length);
      return this.editor.getText(index2, length);
    }
    hasFocus() {
      return this.selection.hasFocus();
    }
    insertEmbed(index2, embed, value) {
      let source = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : _Quill.sources.API;
      return modify.call(this, () => {
        return this.editor.insertEmbed(index2, embed, value);
      }, source, index2);
    }
    insertText(index2, text, name, value, source) {
      let formats3;
      [index2, , formats3, source] = overload(index2, 0, name, value, source);
      return modify.call(this, () => {
        return this.editor.insertText(index2, text, formats3);
      }, source, index2, text.length);
    }
    isEnabled() {
      return this.scroll.isEnabled();
    }
    off() {
      return this.emitter.off(...arguments);
    }
    on() {
      return this.emitter.on(...arguments);
    }
    once() {
      return this.emitter.once(...arguments);
    }
    removeFormat(index2, length, source) {
      [index2, length, , source] = overload(index2, length, source);
      return modify.call(this, () => {
        return this.editor.removeFormat(index2, length);
      }, source, index2);
    }
    scrollRectIntoView(rect) {
      scrollRectIntoView_default(this.root, rect);
    }
    /**
     * @deprecated Use Quill#scrollSelectionIntoView() instead.
     */
    scrollIntoView() {
      console.warn("Quill#scrollIntoView() has been deprecated and will be removed in the near future. Please use Quill#scrollSelectionIntoView() instead.");
      this.scrollSelectionIntoView();
    }
    /**
     * Scroll the current selection into the visible area.
     * If the selection is already visible, no scrolling will occur.
     */
    scrollSelectionIntoView() {
      const range = this.selection.lastRange;
      const bounds = range && this.selection.getBounds(range.index, range.length);
      if (bounds) {
        this.scrollRectIntoView(bounds);
      }
    }
    setContents(delta) {
      let source = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : emitter_default.sources.API;
      return modify.call(this, () => {
        delta = new import_quill_delta3.default(delta);
        const length = this.getLength();
        const delete1 = this.editor.deleteText(0, length);
        const applied = this.editor.insertContents(0, delta);
        const delete2 = this.editor.deleteText(this.getLength() - 1, 1);
        return delete1.compose(applied).compose(delete2);
      }, source);
    }
    setSelection(index2, length, source) {
      if (index2 == null) {
        this.selection.setRange(null, length || _Quill.sources.API);
      } else {
        [index2, length, , source] = overload(index2, length, source);
        this.selection.setRange(new Range(Math.max(0, index2), length), source);
        if (source !== emitter_default.sources.SILENT) {
          this.scrollSelectionIntoView();
        }
      }
    }
    setText(text) {
      let source = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : emitter_default.sources.API;
      const delta = new import_quill_delta3.default().insert(text);
      return this.setContents(delta, source);
    }
    update() {
      let source = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : emitter_default.sources.USER;
      const change = this.scroll.update(source);
      this.selection.update(source);
      return change;
    }
    updateContents(delta) {
      let source = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : emitter_default.sources.API;
      return modify.call(this, () => {
        delta = new import_quill_delta3.default(delta);
        return this.editor.applyDelta(delta);
      }, source, true);
    }
  };
  function resolveSelector(selector) {
    return typeof selector === "string" ? document.querySelector(selector) : selector;
  }
  __name(resolveSelector, "resolveSelector");
  function expandModuleConfig(config4) {
    return Object.entries(config4 ?? {}).reduce((expanded, _ref) => {
      let [key, value] = _ref;
      return {
        ...expanded,
        [key]: value === true ? {} : value
      };
    }, {});
  }
  __name(expandModuleConfig, "expandModuleConfig");
  function omitUndefinedValuesFromOptions(obj) {
    return Object.fromEntries(Object.entries(obj).filter((entry) => entry[1] !== void 0));
  }
  __name(omitUndefinedValuesFromOptions, "omitUndefinedValuesFromOptions");
  function expandConfig(containerOrSelector, options) {
    const container = resolveSelector(containerOrSelector);
    if (!container) {
      throw new Error("Invalid Quill container");
    }
    const shouldUseDefaultTheme = !options.theme || options.theme === Quill.DEFAULTS.theme;
    const theme = shouldUseDefaultTheme ? theme_default : Quill.import(`themes/${options.theme}`);
    if (!theme) {
      throw new Error(`Invalid theme ${options.theme}. Did you register it?`);
    }
    const {
      modules: quillModuleDefaults,
      ...quillDefaults
    } = Quill.DEFAULTS;
    const {
      modules: themeModuleDefaults,
      ...themeDefaults
    } = theme.DEFAULTS;
    const modules = merge_default({}, expandModuleConfig(quillModuleDefaults), expandModuleConfig(themeModuleDefaults), expandModuleConfig(options.modules));
    if (modules != null && modules.toolbar && modules.toolbar.constructor !== Object) {
      modules.toolbar = {
        container: modules.toolbar
      };
    }
    const config4 = {
      ...quillDefaults,
      ...omitUndefinedValuesFromOptions(themeDefaults),
      ...omitUndefinedValuesFromOptions(options)
    };
    let registry = options.registry;
    if (registry) {
      if (options.formats) {
        debug4.warn('Ignoring "formats" option because "registry" is specified');
      }
    } else {
      registry = options.formats ? createRegistryWithFormats_default(options.formats, config4.registry, debug4) : config4.registry;
    }
    return {
      ...config4,
      registry,
      container,
      theme,
      modules: Object.entries(modules).reduce((modulesWithDefaults, _ref2) => {
        let [name, value] = _ref2;
        if (!value)
          return modulesWithDefaults;
        const moduleClass = Quill.import(`modules/${name}`);
        if (moduleClass == null) {
          debug4.error(`Cannot load ${name} module. Are you sure you registered it?`);
          return modulesWithDefaults;
        }
        return {
          ...modulesWithDefaults,
          // @ts-expect-error
          [name]: merge_default({}, moduleClass.DEFAULTS || {}, value)
        };
      }, {}),
      bounds: resolveSelector(config4.bounds)
    };
  }
  __name(expandConfig, "expandConfig");
  function modify(modifier, source, index2, shift) {
    if (!this.isEnabled() && source === emitter_default.sources.USER && !this.allowReadOnlyEdits) {
      return new import_quill_delta3.default();
    }
    let range = index2 == null ? null : this.getSelection();
    const oldDelta = this.editor.delta;
    const change = modifier();
    if (range != null) {
      if (index2 === true) {
        index2 = range.index;
      }
      if (shift == null) {
        range = shiftRange2(range, change, source);
      } else if (shift !== 0) {
        range = shiftRange2(range, index2, shift, source);
      }
      this.setSelection(range, emitter_default.sources.SILENT);
    }
    if (change.length() > 0) {
      const args = [emitter_default.events.TEXT_CHANGE, change, oldDelta, source];
      this.emitter.emit(emitter_default.events.EDITOR_CHANGE, ...args);
      if (source !== emitter_default.sources.SILENT) {
        this.emitter.emit(...args);
      }
    }
    return change;
  }
  __name(modify, "modify");
  function overload(index2, length, name, value, source) {
    let formats3 = {};
    if (typeof index2.index === "number" && typeof index2.length === "number") {
      if (typeof length !== "number") {
        source = value;
        value = name;
        name = length;
        length = index2.length;
        index2 = index2.index;
      } else {
        length = index2.length;
        index2 = index2.index;
      }
    } else if (typeof length !== "number") {
      source = value;
      value = name;
      name = length;
      length = 0;
    }
    if (typeof name === "object") {
      formats3 = name;
      source = value;
    } else if (typeof name === "string") {
      if (value != null) {
        formats3[name] = value;
      } else {
        source = name;
      }
    }
    source = source || emitter_default.sources.API;
    return [index2, length, formats3, source];
  }
  __name(overload, "overload");
  function shiftRange2(range, index2, lengthOrSource, source) {
    const length = typeof lengthOrSource === "number" ? lengthOrSource : 0;
    if (range == null)
      return null;
    let start2;
    let end;
    if (index2 && typeof index2.transformPosition === "function") {
      [start2, end] = [range.index, range.index + range.length].map((pos) => (
        // @ts-expect-error -- TODO: add a better type guard around `index`
        index2.transformPosition(pos, source !== emitter_default.sources.USER)
      ));
    } else {
      [start2, end] = [range.index, range.index + range.length].map((pos) => {
        if (pos < index2 || pos === index2 && source === emitter_default.sources.USER)
          return pos;
        if (length >= 0) {
          return pos + length;
        }
        return Math.max(index2, pos + length);
      });
    }
    return new Range(start2, end - start2);
  }
  __name(shiftRange2, "shiftRange");

  // node_modules/quill/blots/container.js
  var Container = class extends ContainerBlot$1 {
    static {
      __name(this, "Container");
    }
  };
  var container_default = Container;

  // node_modules/quill/blots/scroll.js
  var import_quill_delta4 = __toESM(require_Delta(), 1);
  function isLine(blot) {
    return blot instanceof Block || blot instanceof BlockEmbed;
  }
  __name(isLine, "isLine");
  function isUpdatable(blot) {
    return typeof blot.updateContent === "function";
  }
  __name(isUpdatable, "isUpdatable");
  var Scroll = class extends ScrollBlot$1 {
    static {
      __name(this, "Scroll");
    }
    static blotName = "scroll";
    static className = "ql-editor";
    static tagName = "DIV";
    static defaultChild = Block;
    static allowedChildren = [Block, BlockEmbed, container_default];
    constructor(registry, domNode, _ref) {
      let {
        emitter
      } = _ref;
      super(registry, domNode);
      this.emitter = emitter;
      this.batch = false;
      this.optimize();
      this.enable();
      this.domNode.addEventListener("dragstart", (e3) => this.handleDragStart(e3));
    }
    batchStart() {
      if (!Array.isArray(this.batch)) {
        this.batch = [];
      }
    }
    batchEnd() {
      if (!this.batch)
        return;
      const mutations = this.batch;
      this.batch = false;
      this.update(mutations);
    }
    emitMount(blot) {
      this.emitter.emit(emitter_default.events.SCROLL_BLOT_MOUNT, blot);
    }
    emitUnmount(blot) {
      this.emitter.emit(emitter_default.events.SCROLL_BLOT_UNMOUNT, blot);
    }
    emitEmbedUpdate(blot, change) {
      this.emitter.emit(emitter_default.events.SCROLL_EMBED_UPDATE, blot, change);
    }
    deleteAt(index2, length) {
      const [first, offset] = this.line(index2);
      const [last] = this.line(index2 + length);
      super.deleteAt(index2, length);
      if (last != null && first !== last && offset > 0) {
        if (first instanceof BlockEmbed || last instanceof BlockEmbed) {
          this.optimize();
          return;
        }
        const ref = last.children.head instanceof break_default ? null : last.children.head;
        first.moveChildren(last, ref);
        first.remove();
      }
      this.optimize();
    }
    enable() {
      let enabled = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
      this.domNode.setAttribute("contenteditable", enabled ? "true" : "false");
    }
    formatAt(index2, length, format, value) {
      super.formatAt(index2, length, format, value);
      this.optimize();
    }
    insertAt(index2, value, def) {
      if (index2 >= this.length()) {
        if (def == null || this.scroll.query(value, Scope.BLOCK) == null) {
          const blot = this.scroll.create(this.statics.defaultChild.blotName);
          this.appendChild(blot);
          if (def == null && value.endsWith("\n")) {
            blot.insertAt(0, value.slice(0, -1), def);
          } else {
            blot.insertAt(0, value, def);
          }
        } else {
          const embed = this.scroll.create(value, def);
          this.appendChild(embed);
        }
      } else {
        super.insertAt(index2, value, def);
      }
      this.optimize();
    }
    insertBefore(blot, ref) {
      if (blot.statics.scope === Scope.INLINE_BLOT) {
        const wrapper = this.scroll.create(this.statics.defaultChild.blotName);
        wrapper.appendChild(blot);
        super.insertBefore(wrapper, ref);
      } else {
        super.insertBefore(blot, ref);
      }
    }
    insertContents(index2, delta) {
      const renderBlocks = this.deltaToRenderBlocks(delta.concat(new import_quill_delta4.default().insert("\n")));
      const last = renderBlocks.pop();
      if (last == null)
        return;
      this.batchStart();
      const first = renderBlocks.shift();
      if (first) {
        const shouldInsertNewlineChar = first.type === "block" && (first.delta.length() === 0 || !this.descendant(BlockEmbed, index2)[0] && index2 < this.length());
        const delta2 = first.type === "block" ? first.delta : new import_quill_delta4.default().insert({
          [first.key]: first.value
        });
        insertInlineContents(this, index2, delta2);
        const newlineCharLength = first.type === "block" ? 1 : 0;
        const lineEndIndex = index2 + delta2.length() + newlineCharLength;
        if (shouldInsertNewlineChar) {
          this.insertAt(lineEndIndex - 1, "\n");
        }
        const formats3 = bubbleFormats(this.line(index2)[0]);
        const attributes = import_quill_delta4.AttributeMap.diff(formats3, first.attributes) || {};
        Object.keys(attributes).forEach((name) => {
          this.formatAt(lineEndIndex - 1, 1, name, attributes[name]);
        });
        index2 = lineEndIndex;
      }
      let [refBlot, refBlotOffset] = this.children.find(index2);
      if (renderBlocks.length) {
        if (refBlot) {
          refBlot = refBlot.split(refBlotOffset);
          refBlotOffset = 0;
        }
        renderBlocks.forEach((renderBlock) => {
          if (renderBlock.type === "block") {
            const block = this.createBlock(renderBlock.attributes, refBlot || void 0);
            insertInlineContents(block, 0, renderBlock.delta);
          } else {
            const blockEmbed = this.create(renderBlock.key, renderBlock.value);
            this.insertBefore(blockEmbed, refBlot || void 0);
            Object.keys(renderBlock.attributes).forEach((name) => {
              blockEmbed.format(name, renderBlock.attributes[name]);
            });
          }
        });
      }
      if (last.type === "block" && last.delta.length()) {
        const offset = refBlot ? refBlot.offset(refBlot.scroll) + refBlotOffset : this.length();
        insertInlineContents(this, offset, last.delta);
      }
      this.batchEnd();
      this.optimize();
    }
    isEnabled() {
      return this.domNode.getAttribute("contenteditable") === "true";
    }
    leaf(index2) {
      const last = this.path(index2).pop();
      if (!last) {
        return [null, -1];
      }
      const [blot, offset] = last;
      return blot instanceof LeafBlot$1 ? [blot, offset] : [null, -1];
    }
    line(index2) {
      if (index2 === this.length()) {
        return this.line(index2 - 1);
      }
      return this.descendant(isLine, index2);
    }
    lines() {
      let index2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      let length = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Number.MAX_VALUE;
      const getLines = /* @__PURE__ */ __name((blot, blotIndex, blotLength) => {
        let lines = [];
        let lengthLeft = blotLength;
        blot.children.forEachAt(blotIndex, blotLength, (child, childIndex, childLength) => {
          if (isLine(child)) {
            lines.push(child);
          } else if (child instanceof ContainerBlot$1) {
            lines = lines.concat(getLines(child, childIndex, lengthLeft));
          }
          lengthLeft -= childLength;
        });
        return lines;
      }, "getLines");
      return getLines(this, index2, length);
    }
    optimize() {
      let mutations = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      let context = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (this.batch)
        return;
      super.optimize(mutations, context);
      if (mutations.length > 0) {
        this.emitter.emit(emitter_default.events.SCROLL_OPTIMIZE, mutations, context);
      }
    }
    path(index2) {
      return super.path(index2).slice(1);
    }
    remove() {
    }
    update(mutations) {
      if (this.batch) {
        if (Array.isArray(mutations)) {
          this.batch = this.batch.concat(mutations);
        }
        return;
      }
      let source = emitter_default.sources.USER;
      if (typeof mutations === "string") {
        source = mutations;
      }
      if (!Array.isArray(mutations)) {
        mutations = this.observer.takeRecords();
      }
      mutations = mutations.filter((_ref2) => {
        let {
          target
        } = _ref2;
        const blot = this.find(target, true);
        return blot && !isUpdatable(blot);
      });
      if (mutations.length > 0) {
        this.emitter.emit(emitter_default.events.SCROLL_BEFORE_UPDATE, source, mutations);
      }
      super.update(mutations.concat([]));
      if (mutations.length > 0) {
        this.emitter.emit(emitter_default.events.SCROLL_UPDATE, source, mutations);
      }
    }
    updateEmbedAt(index2, key, change) {
      const [blot] = this.descendant((b3) => b3 instanceof BlockEmbed, index2);
      if (blot && blot.statics.blotName === key && isUpdatable(blot)) {
        blot.updateContent(change);
      }
    }
    handleDragStart(event) {
      event.preventDefault();
    }
    deltaToRenderBlocks(delta) {
      const renderBlocks = [];
      let currentBlockDelta = new import_quill_delta4.default();
      delta.forEach((op) => {
        const insert = op?.insert;
        if (!insert)
          return;
        if (typeof insert === "string") {
          const splitted = insert.split("\n");
          splitted.slice(0, -1).forEach((text) => {
            currentBlockDelta.insert(text, op.attributes);
            renderBlocks.push({
              type: "block",
              delta: currentBlockDelta,
              attributes: op.attributes ?? {}
            });
            currentBlockDelta = new import_quill_delta4.default();
          });
          const last = splitted[splitted.length - 1];
          if (last) {
            currentBlockDelta.insert(last, op.attributes);
          }
        } else {
          const key = Object.keys(insert)[0];
          if (!key)
            return;
          if (this.query(key, Scope.INLINE)) {
            currentBlockDelta.push(op);
          } else {
            if (currentBlockDelta.length()) {
              renderBlocks.push({
                type: "block",
                delta: currentBlockDelta,
                attributes: {}
              });
            }
            currentBlockDelta = new import_quill_delta4.default();
            renderBlocks.push({
              type: "blockEmbed",
              key,
              value: insert[key],
              attributes: op.attributes ?? {}
            });
          }
        }
      });
      if (currentBlockDelta.length()) {
        renderBlocks.push({
          type: "block",
          delta: currentBlockDelta,
          attributes: {}
        });
      }
      return renderBlocks;
    }
    createBlock(attributes, refBlot) {
      let blotName;
      const formats3 = {};
      Object.entries(attributes).forEach((_ref3) => {
        let [key, value] = _ref3;
        const isBlockBlot = this.query(key, Scope.BLOCK & Scope.BLOT) != null;
        if (isBlockBlot) {
          blotName = key;
        } else {
          formats3[key] = value;
        }
      });
      const block = this.create(blotName || this.statics.defaultChild.blotName, blotName ? attributes[blotName] : void 0);
      this.insertBefore(block, refBlot || void 0);
      const length = block.length();
      Object.entries(formats3).forEach((_ref4) => {
        let [key, value] = _ref4;
        block.formatAt(0, length, key, value);
      });
      return block;
    }
  };
  function insertInlineContents(parent, index2, inlineContents) {
    inlineContents.reduce((index3, op) => {
      const length = import_quill_delta4.Op.length(op);
      let attributes = op.attributes || {};
      if (op.insert != null) {
        if (typeof op.insert === "string") {
          const text = op.insert;
          parent.insertAt(index3, text);
          const [leaf] = parent.descendant(LeafBlot$1, index3);
          const formats3 = bubbleFormats(leaf);
          attributes = import_quill_delta4.AttributeMap.diff(formats3, attributes) || {};
        } else if (typeof op.insert === "object") {
          const key = Object.keys(op.insert)[0];
          if (key == null)
            return index3;
          parent.insertAt(index3, key, op.insert[key]);
          const isInlineEmbed = parent.scroll.query(key, Scope.INLINE) != null;
          if (isInlineEmbed) {
            const [leaf] = parent.descendant(LeafBlot$1, index3);
            const formats3 = bubbleFormats(leaf);
            attributes = import_quill_delta4.AttributeMap.diff(formats3, attributes) || {};
          }
        }
      }
      Object.keys(attributes).forEach((key) => {
        parent.formatAt(index3, length, key, attributes[key]);
      });
      return index3 + length;
    }, index2);
  }
  __name(insertInlineContents, "insertInlineContents");
  var scroll_default = Scroll;

  // node_modules/quill/modules/clipboard.js
  var import_quill_delta6 = __toESM(require_Delta(), 1);

  // node_modules/quill/formats/align.js
  var config = {
    scope: Scope.BLOCK,
    whitelist: ["right", "center", "justify"]
  };
  var AlignAttribute = new Attributor("align", "align", config);
  var AlignClass = new ClassAttributor$1("align", "ql-align", config);
  var AlignStyle = new StyleAttributor$1("align", "text-align", config);

  // node_modules/quill/formats/color.js
  var ColorAttributor = class extends StyleAttributor$1 {
    static {
      __name(this, "ColorAttributor");
    }
    value(domNode) {
      let value = super.value(domNode);
      if (!value.startsWith("rgb("))
        return value;
      value = value.replace(/^[^\d]+/, "").replace(/[^\d]+$/, "");
      const hex = value.split(",").map((component) => `00${parseInt(component, 10).toString(16)}`.slice(-2)).join("");
      return `#${hex}`;
    }
  };
  var ColorClass = new ClassAttributor$1("color", "ql-color", {
    scope: Scope.INLINE
  });
  var ColorStyle = new ColorAttributor("color", "color", {
    scope: Scope.INLINE
  });

  // node_modules/quill/formats/background.js
  var BackgroundClass = new ClassAttributor$1("background", "ql-bg", {
    scope: Scope.INLINE
  });
  var BackgroundStyle = new ColorAttributor("background", "background-color", {
    scope: Scope.INLINE
  });

  // node_modules/quill/formats/code.js
  var CodeBlockContainer = class extends container_default {
    static {
      __name(this, "CodeBlockContainer");
    }
    static create(value) {
      const domNode = super.create(value);
      domNode.setAttribute("spellcheck", "false");
      return domNode;
    }
    code(index2, length) {
      return this.children.map((child) => child.length() <= 1 ? "" : child.domNode.innerText).join("\n").slice(index2, index2 + length);
    }
    html(index2, length) {
      return `<pre>
${escapeText(this.code(index2, length))}
</pre>`;
    }
  };
  var CodeBlock = class extends Block {
    static {
      __name(this, "CodeBlock");
    }
    static TAB = "  ";
    static register() {
      Quill.register(CodeBlockContainer);
    }
  };
  var Code = class extends inline_default {
    static {
      __name(this, "Code");
    }
  };
  Code.blotName = "code";
  Code.tagName = "CODE";
  CodeBlock.blotName = "code-block";
  CodeBlock.className = "ql-code-block";
  CodeBlock.tagName = "DIV";
  CodeBlockContainer.blotName = "code-block-container";
  CodeBlockContainer.className = "ql-code-block-container";
  CodeBlockContainer.tagName = "DIV";
  CodeBlockContainer.allowedChildren = [CodeBlock];
  CodeBlock.allowedChildren = [Text2, break_default, cursor_default];
  CodeBlock.requiredContainer = CodeBlockContainer;

  // node_modules/quill/formats/direction.js
  var config2 = {
    scope: Scope.BLOCK,
    whitelist: ["rtl"]
  };
  var DirectionAttribute = new Attributor("direction", "dir", config2);
  var DirectionClass = new ClassAttributor$1("direction", "ql-direction", config2);
  var DirectionStyle = new StyleAttributor$1("direction", "direction", config2);

  // node_modules/quill/formats/font.js
  var config3 = {
    scope: Scope.INLINE,
    whitelist: ["serif", "monospace"]
  };
  var FontClass = new ClassAttributor$1("font", "ql-font", config3);
  var FontStyleAttributor = class extends StyleAttributor$1 {
    static {
      __name(this, "FontStyleAttributor");
    }
    value(node) {
      return super.value(node).replace(/["']/g, "");
    }
  };
  var FontStyle = new FontStyleAttributor("font", "font-family", config3);

  // node_modules/quill/formats/size.js
  var SizeClass = new ClassAttributor$1("size", "ql-size", {
    scope: Scope.INLINE,
    whitelist: ["small", "large", "huge"]
  });
  var SizeStyle = new StyleAttributor$1("size", "font-size", {
    scope: Scope.INLINE,
    whitelist: ["10px", "18px", "32px"]
  });

  // node_modules/quill/modules/keyboard.js
  var import_quill_delta5 = __toESM(require_Delta(), 1);
  var debug5 = logger_default2("quill:keyboard");
  var SHORTKEY = /Mac/i.test(navigator.platform) ? "metaKey" : "ctrlKey";
  var Keyboard = class _Keyboard extends module_default {
    static {
      __name(this, "Keyboard");
    }
    static match(evt, binding) {
      if (["altKey", "ctrlKey", "metaKey", "shiftKey"].some((key) => {
        return !!binding[key] !== evt[key] && binding[key] !== null;
      })) {
        return false;
      }
      return binding.key === evt.key || binding.key === evt.which;
    }
    constructor(quill, options) {
      super(quill, options);
      this.bindings = {};
      Object.keys(this.options.bindings).forEach((name) => {
        if (this.options.bindings[name]) {
          this.addBinding(this.options.bindings[name]);
        }
      });
      this.addBinding({
        key: "Enter",
        shiftKey: null
      }, this.handleEnter);
      this.addBinding({
        key: "Enter",
        metaKey: null,
        ctrlKey: null,
        altKey: null
      }, () => {
      });
      if (/Firefox/i.test(navigator.userAgent)) {
        this.addBinding({
          key: "Backspace"
        }, {
          collapsed: true
        }, this.handleBackspace);
        this.addBinding({
          key: "Delete"
        }, {
          collapsed: true
        }, this.handleDelete);
      } else {
        this.addBinding({
          key: "Backspace"
        }, {
          collapsed: true,
          prefix: /^.?$/
        }, this.handleBackspace);
        this.addBinding({
          key: "Delete"
        }, {
          collapsed: true,
          suffix: /^.?$/
        }, this.handleDelete);
      }
      this.addBinding({
        key: "Backspace"
      }, {
        collapsed: false
      }, this.handleDeleteRange);
      this.addBinding({
        key: "Delete"
      }, {
        collapsed: false
      }, this.handleDeleteRange);
      this.addBinding({
        key: "Backspace",
        altKey: null,
        ctrlKey: null,
        metaKey: null,
        shiftKey: null
      }, {
        collapsed: true,
        offset: 0
      }, this.handleBackspace);
      this.listen();
    }
    addBinding(keyBinding) {
      let context = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      let handler = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      const binding = normalize(keyBinding);
      if (binding == null) {
        debug5.warn("Attempted to add invalid keyboard binding", binding);
        return;
      }
      if (typeof context === "function") {
        context = {
          handler: context
        };
      }
      if (typeof handler === "function") {
        handler = {
          handler
        };
      }
      const keys2 = Array.isArray(binding.key) ? binding.key : [binding.key];
      keys2.forEach((key) => {
        const singleBinding = {
          ...binding,
          key,
          ...context,
          ...handler
        };
        this.bindings[singleBinding.key] = this.bindings[singleBinding.key] || [];
        this.bindings[singleBinding.key].push(singleBinding);
      });
    }
    listen() {
      this.quill.root.addEventListener("keydown", (evt) => {
        if (evt.defaultPrevented || evt.isComposing)
          return;
        const bindings = (this.bindings[evt.key] || []).concat(this.bindings[evt.which] || []);
        const matches2 = bindings.filter((binding) => _Keyboard.match(evt, binding));
        if (matches2.length === 0)
          return;
        const blot = Quill.find(evt.target, true);
        if (blot && blot.scroll !== this.quill.scroll)
          return;
        const range = this.quill.getSelection();
        if (range == null || !this.quill.hasFocus())
          return;
        const [line, offset] = this.quill.getLine(range.index);
        const [leafStart, offsetStart] = this.quill.getLeaf(range.index);
        const [leafEnd, offsetEnd] = range.length === 0 ? [leafStart, offsetStart] : this.quill.getLeaf(range.index + range.length);
        const prefixText = leafStart instanceof TextBlot$1 ? leafStart.value().slice(0, offsetStart) : "";
        const suffixText = leafEnd instanceof TextBlot$1 ? leafEnd.value().slice(offsetEnd) : "";
        const curContext = {
          collapsed: range.length === 0,
          // @ts-expect-error Fix me later
          empty: range.length === 0 && line.length() <= 1,
          format: this.quill.getFormat(range),
          line,
          offset,
          prefix: prefixText,
          suffix: suffixText,
          event: evt
        };
        const prevented = matches2.some((binding) => {
          if (binding.collapsed != null && binding.collapsed !== curContext.collapsed) {
            return false;
          }
          if (binding.empty != null && binding.empty !== curContext.empty) {
            return false;
          }
          if (binding.offset != null && binding.offset !== curContext.offset) {
            return false;
          }
          if (Array.isArray(binding.format)) {
            if (binding.format.every((name) => curContext.format[name] == null)) {
              return false;
            }
          } else if (typeof binding.format === "object") {
            if (!Object.keys(binding.format).every((name) => {
              if (binding.format[name] === true)
                return curContext.format[name] != null;
              if (binding.format[name] === false)
                return curContext.format[name] == null;
              return isEqual_default(binding.format[name], curContext.format[name]);
            })) {
              return false;
            }
          }
          if (binding.prefix != null && !binding.prefix.test(curContext.prefix)) {
            return false;
          }
          if (binding.suffix != null && !binding.suffix.test(curContext.suffix)) {
            return false;
          }
          return binding.handler.call(this, range, curContext, binding) !== true;
        });
        if (prevented) {
          evt.preventDefault();
        }
      });
    }
    handleBackspace(range, context) {
      const length = /[\uD800-\uDBFF][\uDC00-\uDFFF]$/.test(context.prefix) ? 2 : 1;
      if (range.index === 0 || this.quill.getLength() <= 1)
        return;
      let formats3 = {};
      const [line] = this.quill.getLine(range.index);
      let delta = new import_quill_delta5.default().retain(range.index - length).delete(length);
      if (context.offset === 0) {
        const [prev] = this.quill.getLine(range.index - 1);
        if (prev) {
          const isPrevLineEmpty = prev.statics.blotName === "block" && prev.length() <= 1;
          if (!isPrevLineEmpty) {
            const curFormats = line.formats();
            const prevFormats = this.quill.getFormat(range.index - 1, 1);
            formats3 = import_quill_delta5.AttributeMap.diff(curFormats, prevFormats) || {};
            if (Object.keys(formats3).length > 0) {
              const formatDelta = new import_quill_delta5.default().retain(range.index + line.length() - 2).retain(1, formats3);
              delta = delta.compose(formatDelta);
            }
          }
        }
      }
      this.quill.updateContents(delta, Quill.sources.USER);
      this.quill.focus();
    }
    handleDelete(range, context) {
      const length = /^[\uD800-\uDBFF][\uDC00-\uDFFF]/.test(context.suffix) ? 2 : 1;
      if (range.index >= this.quill.getLength() - length)
        return;
      let formats3 = {};
      const [line] = this.quill.getLine(range.index);
      let delta = new import_quill_delta5.default().retain(range.index).delete(length);
      if (context.offset >= line.length() - 1) {
        const [next] = this.quill.getLine(range.index + 1);
        if (next) {
          const curFormats = line.formats();
          const nextFormats = this.quill.getFormat(range.index, 1);
          formats3 = import_quill_delta5.AttributeMap.diff(curFormats, nextFormats) || {};
          if (Object.keys(formats3).length > 0) {
            delta = delta.retain(next.length() - 1).retain(1, formats3);
          }
        }
      }
      this.quill.updateContents(delta, Quill.sources.USER);
      this.quill.focus();
    }
    handleDeleteRange(range) {
      deleteRange({
        range,
        quill: this.quill
      });
      this.quill.focus();
    }
    handleEnter(range, context) {
      const lineFormats = Object.keys(context.format).reduce((formats3, format) => {
        if (this.quill.scroll.query(format, Scope.BLOCK) && !Array.isArray(context.format[format])) {
          formats3[format] = context.format[format];
        }
        return formats3;
      }, {});
      const delta = new import_quill_delta5.default().retain(range.index).delete(range.length).insert("\n", lineFormats);
      this.quill.updateContents(delta, Quill.sources.USER);
      this.quill.setSelection(range.index + 1, Quill.sources.SILENT);
      this.quill.focus();
    }
  };
  var defaultOptions2 = {
    bindings: {
      bold: makeFormatHandler("bold"),
      italic: makeFormatHandler("italic"),
      underline: makeFormatHandler("underline"),
      indent: {
        // highlight tab or tab at beginning of list, indent or blockquote
        key: "Tab",
        format: ["blockquote", "indent", "list"],
        handler(range, context) {
          if (context.collapsed && context.offset !== 0)
            return true;
          this.quill.format("indent", "+1", Quill.sources.USER);
          return false;
        }
      },
      outdent: {
        key: "Tab",
        shiftKey: true,
        format: ["blockquote", "indent", "list"],
        // highlight tab or tab at beginning of list, indent or blockquote
        handler(range, context) {
          if (context.collapsed && context.offset !== 0)
            return true;
          this.quill.format("indent", "-1", Quill.sources.USER);
          return false;
        }
      },
      "outdent backspace": {
        key: "Backspace",
        collapsed: true,
        shiftKey: null,
        metaKey: null,
        ctrlKey: null,
        altKey: null,
        format: ["indent", "list"],
        offset: 0,
        handler(range, context) {
          if (context.format.indent != null) {
            this.quill.format("indent", "-1", Quill.sources.USER);
          } else if (context.format.list != null) {
            this.quill.format("list", false, Quill.sources.USER);
          }
        }
      },
      "indent code-block": makeCodeBlockHandler(true),
      "outdent code-block": makeCodeBlockHandler(false),
      "remove tab": {
        key: "Tab",
        shiftKey: true,
        collapsed: true,
        prefix: /\t$/,
        handler(range) {
          this.quill.deleteText(range.index - 1, 1, Quill.sources.USER);
        }
      },
      tab: {
        key: "Tab",
        handler(range, context) {
          if (context.format.table)
            return true;
          this.quill.history.cutoff();
          const delta = new import_quill_delta5.default().retain(range.index).delete(range.length).insert("	");
          this.quill.updateContents(delta, Quill.sources.USER);
          this.quill.history.cutoff();
          this.quill.setSelection(range.index + 1, Quill.sources.SILENT);
          return false;
        }
      },
      "blockquote empty enter": {
        key: "Enter",
        collapsed: true,
        format: ["blockquote"],
        empty: true,
        handler() {
          this.quill.format("blockquote", false, Quill.sources.USER);
        }
      },
      "list empty enter": {
        key: "Enter",
        collapsed: true,
        format: ["list"],
        empty: true,
        handler(range, context) {
          const formats3 = {
            list: false
          };
          if (context.format.indent) {
            formats3.indent = false;
          }
          this.quill.formatLine(range.index, range.length, formats3, Quill.sources.USER);
        }
      },
      "checklist enter": {
        key: "Enter",
        collapsed: true,
        format: {
          list: "checked"
        },
        handler(range) {
          const [line, offset] = this.quill.getLine(range.index);
          const formats3 = {
            // @ts-expect-error Fix me later
            ...line.formats(),
            list: "checked"
          };
          const delta = new import_quill_delta5.default().retain(range.index).insert("\n", formats3).retain(line.length() - offset - 1).retain(1, {
            list: "unchecked"
          });
          this.quill.updateContents(delta, Quill.sources.USER);
          this.quill.setSelection(range.index + 1, Quill.sources.SILENT);
          this.quill.scrollSelectionIntoView();
        }
      },
      "header enter": {
        key: "Enter",
        collapsed: true,
        format: ["header"],
        suffix: /^$/,
        handler(range, context) {
          const [line, offset] = this.quill.getLine(range.index);
          const delta = new import_quill_delta5.default().retain(range.index).insert("\n", context.format).retain(line.length() - offset - 1).retain(1, {
            header: null
          });
          this.quill.updateContents(delta, Quill.sources.USER);
          this.quill.setSelection(range.index + 1, Quill.sources.SILENT);
          this.quill.scrollSelectionIntoView();
        }
      },
      "table backspace": {
        key: "Backspace",
        format: ["table"],
        collapsed: true,
        offset: 0,
        handler() {
        }
      },
      "table delete": {
        key: "Delete",
        format: ["table"],
        collapsed: true,
        suffix: /^$/,
        handler() {
        }
      },
      "table enter": {
        key: "Enter",
        shiftKey: null,
        format: ["table"],
        handler(range) {
          const module2 = this.quill.getModule("table");
          if (module2) {
            const [table, row, cell, offset] = module2.getTable(range);
            const shift = tableSide(table, row, cell, offset);
            if (shift == null)
              return;
            let index2 = table.offset();
            if (shift < 0) {
              const delta = new import_quill_delta5.default().retain(index2).insert("\n");
              this.quill.updateContents(delta, Quill.sources.USER);
              this.quill.setSelection(range.index + 1, range.length, Quill.sources.SILENT);
            } else if (shift > 0) {
              index2 += table.length();
              const delta = new import_quill_delta5.default().retain(index2).insert("\n");
              this.quill.updateContents(delta, Quill.sources.USER);
              this.quill.setSelection(index2, Quill.sources.USER);
            }
          }
        }
      },
      "table tab": {
        key: "Tab",
        shiftKey: null,
        format: ["table"],
        handler(range, context) {
          const {
            event,
            line: cell
          } = context;
          const offset = cell.offset(this.quill.scroll);
          if (event.shiftKey) {
            this.quill.setSelection(offset - 1, Quill.sources.USER);
          } else {
            this.quill.setSelection(offset + cell.length(), Quill.sources.USER);
          }
        }
      },
      "list autofill": {
        key: " ",
        shiftKey: null,
        collapsed: true,
        format: {
          "code-block": false,
          blockquote: false,
          table: false
        },
        prefix: /^\s*?(\d+\.|-|\*|\[ ?\]|\[x\])$/,
        handler(range, context) {
          if (this.quill.scroll.query("list") == null)
            return true;
          const {
            length
          } = context.prefix;
          const [line, offset] = this.quill.getLine(range.index);
          if (offset > length)
            return true;
          let value;
          switch (context.prefix.trim()) {
            case "[]":
            case "[ ]":
              value = "unchecked";
              break;
            case "[x]":
              value = "checked";
              break;
            case "-":
            case "*":
              value = "bullet";
              break;
            default:
              value = "ordered";
          }
          this.quill.insertText(range.index, " ", Quill.sources.USER);
          this.quill.history.cutoff();
          const delta = new import_quill_delta5.default().retain(range.index - offset).delete(length + 1).retain(line.length() - 2 - offset).retain(1, {
            list: value
          });
          this.quill.updateContents(delta, Quill.sources.USER);
          this.quill.history.cutoff();
          this.quill.setSelection(range.index - length, Quill.sources.SILENT);
          return false;
        }
      },
      "code exit": {
        key: "Enter",
        collapsed: true,
        format: ["code-block"],
        prefix: /^$/,
        suffix: /^\s*$/,
        handler(range) {
          const [line, offset] = this.quill.getLine(range.index);
          let numLines = 2;
          let cur = line;
          while (cur != null && cur.length() <= 1 && cur.formats()["code-block"]) {
            cur = cur.prev;
            numLines -= 1;
            if (numLines <= 0) {
              const delta = new import_quill_delta5.default().retain(range.index + line.length() - offset - 2).retain(1, {
                "code-block": null
              }).delete(1);
              this.quill.updateContents(delta, Quill.sources.USER);
              this.quill.setSelection(range.index - 1, Quill.sources.SILENT);
              return false;
            }
          }
          return true;
        }
      },
      "embed left": makeEmbedArrowHandler("ArrowLeft", false),
      "embed left shift": makeEmbedArrowHandler("ArrowLeft", true),
      "embed right": makeEmbedArrowHandler("ArrowRight", false),
      "embed right shift": makeEmbedArrowHandler("ArrowRight", true),
      "table down": makeTableArrowHandler(false),
      "table up": makeTableArrowHandler(true)
    }
  };
  Keyboard.DEFAULTS = defaultOptions2;
  function makeCodeBlockHandler(indent) {
    return {
      key: "Tab",
      shiftKey: !indent,
      format: {
        "code-block": true
      },
      handler(range, _ref) {
        let {
          event
        } = _ref;
        const CodeBlock2 = this.quill.scroll.query("code-block");
        const {
          TAB
        } = CodeBlock2;
        if (range.length === 0 && !event.shiftKey) {
          this.quill.insertText(range.index, TAB, Quill.sources.USER);
          this.quill.setSelection(range.index + TAB.length, Quill.sources.SILENT);
          return;
        }
        const lines = range.length === 0 ? this.quill.getLines(range.index, 1) : this.quill.getLines(range);
        let {
          index: index2,
          length
        } = range;
        lines.forEach((line, i3) => {
          if (indent) {
            line.insertAt(0, TAB);
            if (i3 === 0) {
              index2 += TAB.length;
            } else {
              length += TAB.length;
            }
          } else if (line.domNode.textContent.startsWith(TAB)) {
            line.deleteAt(0, TAB.length);
            if (i3 === 0) {
              index2 -= TAB.length;
            } else {
              length -= TAB.length;
            }
          }
        });
        this.quill.update(Quill.sources.USER);
        this.quill.setSelection(index2, length, Quill.sources.SILENT);
      }
    };
  }
  __name(makeCodeBlockHandler, "makeCodeBlockHandler");
  function makeEmbedArrowHandler(key, shiftKey) {
    const where = key === "ArrowLeft" ? "prefix" : "suffix";
    return {
      key,
      shiftKey,
      altKey: null,
      [where]: /^$/,
      handler(range) {
        let {
          index: index2
        } = range;
        if (key === "ArrowRight") {
          index2 += range.length + 1;
        }
        const [leaf] = this.quill.getLeaf(index2);
        if (!(leaf instanceof EmbedBlot$1))
          return true;
        if (key === "ArrowLeft") {
          if (shiftKey) {
            this.quill.setSelection(range.index - 1, range.length + 1, Quill.sources.USER);
          } else {
            this.quill.setSelection(range.index - 1, Quill.sources.USER);
          }
        } else if (shiftKey) {
          this.quill.setSelection(range.index, range.length + 1, Quill.sources.USER);
        } else {
          this.quill.setSelection(range.index + range.length + 1, Quill.sources.USER);
        }
        return false;
      }
    };
  }
  __name(makeEmbedArrowHandler, "makeEmbedArrowHandler");
  function makeFormatHandler(format) {
    return {
      key: format[0],
      shortKey: true,
      handler(range, context) {
        this.quill.format(format, !context.format[format], Quill.sources.USER);
      }
    };
  }
  __name(makeFormatHandler, "makeFormatHandler");
  function makeTableArrowHandler(up) {
    return {
      key: up ? "ArrowUp" : "ArrowDown",
      collapsed: true,
      format: ["table"],
      handler(range, context) {
        const key = up ? "prev" : "next";
        const cell = context.line;
        const targetRow = cell.parent[key];
        if (targetRow != null) {
          if (targetRow.statics.blotName === "table-row") {
            let targetCell = targetRow.children.head;
            let cur = cell;
            while (cur.prev != null) {
              cur = cur.prev;
              targetCell = targetCell.next;
            }
            const index2 = targetCell.offset(this.quill.scroll) + Math.min(context.offset, targetCell.length() - 1);
            this.quill.setSelection(index2, 0, Quill.sources.USER);
          }
        } else {
          const targetLine = cell.table()[key];
          if (targetLine != null) {
            if (up) {
              this.quill.setSelection(targetLine.offset(this.quill.scroll) + targetLine.length() - 1, 0, Quill.sources.USER);
            } else {
              this.quill.setSelection(targetLine.offset(this.quill.scroll), 0, Quill.sources.USER);
            }
          }
        }
        return false;
      }
    };
  }
  __name(makeTableArrowHandler, "makeTableArrowHandler");
  function normalize(binding) {
    if (typeof binding === "string" || typeof binding === "number") {
      binding = {
        key: binding
      };
    } else if (typeof binding === "object") {
      binding = cloneDeep_default(binding);
    } else {
      return null;
    }
    if (binding.shortKey) {
      binding[SHORTKEY] = binding.shortKey;
      delete binding.shortKey;
    }
    return binding;
  }
  __name(normalize, "normalize");
  function deleteRange(_ref2) {
    let {
      quill,
      range
    } = _ref2;
    const lines = quill.getLines(range);
    let formats3 = {};
    if (lines.length > 1) {
      const firstFormats = lines[0].formats();
      const lastFormats = lines[lines.length - 1].formats();
      formats3 = import_quill_delta5.AttributeMap.diff(lastFormats, firstFormats) || {};
    }
    quill.deleteText(range, Quill.sources.USER);
    if (Object.keys(formats3).length > 0) {
      quill.formatLine(range.index, 1, formats3, Quill.sources.USER);
    }
    quill.setSelection(range.index, Quill.sources.SILENT);
  }
  __name(deleteRange, "deleteRange");
  function tableSide(_table, row, cell, offset) {
    if (row.prev == null && row.next == null) {
      if (cell.prev == null && cell.next == null) {
        return offset === 0 ? -1 : 1;
      }
      return cell.prev == null ? -1 : 1;
    }
    if (row.prev == null) {
      return -1;
    }
    if (row.next == null) {
      return 1;
    }
    return null;
  }
  __name(tableSide, "tableSide");

  // node_modules/quill/modules/normalizeExternalHTML/normalizers/googleDocs.js
  var normalWeightRegexp = /font-weight:\s*normal/;
  var blockTagNames = ["P", "OL", "UL"];
  var isBlockElement = /* @__PURE__ */ __name((element) => {
    return element && blockTagNames.includes(element.tagName);
  }, "isBlockElement");
  var normalizeEmptyLines = /* @__PURE__ */ __name((doc) => {
    Array.from(doc.querySelectorAll("br")).filter((br2) => isBlockElement(br2.previousElementSibling) && isBlockElement(br2.nextElementSibling)).forEach((br2) => {
      br2.parentNode?.removeChild(br2);
    });
  }, "normalizeEmptyLines");
  var normalizeFontWeight = /* @__PURE__ */ __name((doc) => {
    Array.from(doc.querySelectorAll('b[style*="font-weight"]')).filter((node) => node.getAttribute("style")?.match(normalWeightRegexp)).forEach((node) => {
      const fragment = doc.createDocumentFragment();
      fragment.append(...node.childNodes);
      node.parentNode?.replaceChild(fragment, node);
    });
  }, "normalizeFontWeight");
  function normalize2(doc) {
    if (doc.querySelector('[id^="docs-internal-guid-"]')) {
      normalizeFontWeight(doc);
      normalizeEmptyLines(doc);
    }
  }
  __name(normalize2, "normalize");

  // node_modules/quill/modules/normalizeExternalHTML/normalizers/msWord.js
  var ignoreRegexp = /\bmso-list:[^;]*ignore/i;
  var idRegexp = /\bmso-list:[^;]*\bl(\d+)/i;
  var indentRegexp = /\bmso-list:[^;]*\blevel(\d+)/i;
  var parseListItem = /* @__PURE__ */ __name((element, html) => {
    const style = element.getAttribute("style");
    const idMatch = style?.match(idRegexp);
    if (!idMatch) {
      return null;
    }
    const id = Number(idMatch[1]);
    const indentMatch = style?.match(indentRegexp);
    const indent = indentMatch ? Number(indentMatch[1]) : 1;
    const typeRegexp = new RegExp(`@list l${id}:level${indent}\\s*\\{[^\\}]*mso-level-number-format:\\s*([\\w-]+)`, "i");
    const typeMatch = html.match(typeRegexp);
    const type = typeMatch && typeMatch[1] === "bullet" ? "bullet" : "ordered";
    return {
      id,
      indent,
      type,
      element
    };
  }, "parseListItem");
  var normalizeListItem = /* @__PURE__ */ __name((doc) => {
    const msoList = Array.from(doc.querySelectorAll("[style*=mso-list]"));
    const ignored = [];
    const others = [];
    msoList.forEach((node) => {
      const shouldIgnore = (node.getAttribute("style") || "").match(ignoreRegexp);
      if (shouldIgnore) {
        ignored.push(node);
      } else {
        others.push(node);
      }
    });
    ignored.forEach((node) => node.parentNode?.removeChild(node));
    const html = doc.documentElement.innerHTML;
    const listItems = others.map((element) => parseListItem(element, html)).filter((parsed) => parsed);
    while (listItems.length) {
      const childListItems = [];
      let current = listItems.shift();
      while (current) {
        childListItems.push(current);
        current = listItems.length && listItems[0]?.element === current.element.nextElementSibling && // Different id means the next item doesn't belong to this group.
        listItems[0].id === current.id ? listItems.shift() : null;
      }
      const ul = document.createElement("ul");
      childListItems.forEach((listItem) => {
        const li = document.createElement("li");
        li.setAttribute("data-list", listItem.type);
        if (listItem.indent > 1) {
          li.setAttribute("class", `ql-indent-${listItem.indent - 1}`);
        }
        li.innerHTML = listItem.element.innerHTML;
        ul.appendChild(li);
      });
      const element = childListItems[0]?.element;
      const {
        parentNode
      } = element ?? {};
      if (element) {
        parentNode?.replaceChild(ul, element);
      }
      childListItems.slice(1).forEach((_ref) => {
        let {
          element: e3
        } = _ref;
        parentNode?.removeChild(e3);
      });
    }
  }, "normalizeListItem");
  function normalize3(doc) {
    if (doc.documentElement.getAttribute("xmlns:w") === "urn:schemas-microsoft-com:office:word") {
      normalizeListItem(doc);
    }
  }
  __name(normalize3, "normalize");

  // node_modules/quill/modules/normalizeExternalHTML/index.js
  var NORMALIZERS = [normalize3, normalize2];
  var normalizeExternalHTML = /* @__PURE__ */ __name((doc) => {
    if (doc.documentElement) {
      NORMALIZERS.forEach((normalize4) => {
        normalize4(doc);
      });
    }
  }, "normalizeExternalHTML");
  var normalizeExternalHTML_default = normalizeExternalHTML;

  // node_modules/quill/modules/clipboard.js
  var debug6 = logger_default2("quill:clipboard");
  var CLIPBOARD_CONFIG = [[Node.TEXT_NODE, matchText], [Node.TEXT_NODE, matchNewline], ["br", matchBreak], [Node.ELEMENT_NODE, matchNewline], [Node.ELEMENT_NODE, matchBlot], [Node.ELEMENT_NODE, matchAttributor], [Node.ELEMENT_NODE, matchStyles], ["li", matchIndent], ["ol, ul", matchList], ["pre", matchCodeBlock], ["tr", matchTable], ["b", createMatchAlias("bold")], ["i", createMatchAlias("italic")], ["strike", createMatchAlias("strike")], ["style", matchIgnore]];
  var ATTRIBUTE_ATTRIBUTORS = [AlignAttribute, DirectionAttribute].reduce((memo, attr) => {
    memo[attr.keyName] = attr;
    return memo;
  }, {});
  var STYLE_ATTRIBUTORS = [AlignStyle, BackgroundStyle, ColorStyle, DirectionStyle, FontStyle, SizeStyle].reduce((memo, attr) => {
    memo[attr.keyName] = attr;
    return memo;
  }, {});
  var Clipboard = class extends module_default {
    static {
      __name(this, "Clipboard");
    }
    static DEFAULTS = {
      matchers: []
    };
    constructor(quill, options) {
      super(quill, options);
      this.quill.root.addEventListener("copy", (e3) => this.onCaptureCopy(e3, false));
      this.quill.root.addEventListener("cut", (e3) => this.onCaptureCopy(e3, true));
      this.quill.root.addEventListener("paste", this.onCapturePaste.bind(this));
      this.matchers = [];
      CLIPBOARD_CONFIG.concat(this.options.matchers ?? []).forEach((_ref) => {
        let [selector, matcher] = _ref;
        this.addMatcher(selector, matcher);
      });
    }
    addMatcher(selector, matcher) {
      this.matchers.push([selector, matcher]);
    }
    convert(_ref2) {
      let {
        html,
        text
      } = _ref2;
      let formats3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (formats3[CodeBlock.blotName]) {
        return new import_quill_delta6.default().insert(text || "", {
          [CodeBlock.blotName]: formats3[CodeBlock.blotName]
        });
      }
      if (!html) {
        return new import_quill_delta6.default().insert(text || "", formats3);
      }
      const delta = this.convertHTML(html);
      if (deltaEndsWith(delta, "\n") && (delta.ops[delta.ops.length - 1].attributes == null || formats3.table)) {
        return delta.compose(new import_quill_delta6.default().retain(delta.length() - 1).delete(1));
      }
      return delta;
    }
    normalizeHTML(doc) {
      normalizeExternalHTML_default(doc);
    }
    convertHTML(html) {
      const doc = new DOMParser().parseFromString(html, "text/html");
      this.normalizeHTML(doc);
      const container = doc.body;
      const nodeMatches = /* @__PURE__ */ new WeakMap();
      const [elementMatchers, textMatchers] = this.prepareMatching(container, nodeMatches);
      return traverse(this.quill.scroll, container, elementMatchers, textMatchers, nodeMatches);
    }
    dangerouslyPasteHTML(index2, html) {
      let source = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Quill.sources.API;
      if (typeof index2 === "string") {
        const delta = this.convert({
          html: index2,
          text: ""
        });
        this.quill.setContents(delta, html);
        this.quill.setSelection(0, Quill.sources.SILENT);
      } else {
        const paste = this.convert({
          html,
          text: ""
        });
        this.quill.updateContents(new import_quill_delta6.default().retain(index2).concat(paste), source);
        this.quill.setSelection(index2 + paste.length(), Quill.sources.SILENT);
      }
    }
    onCaptureCopy(e3) {
      let isCut = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      if (e3.defaultPrevented)
        return;
      e3.preventDefault();
      const [range] = this.quill.selection.getRange();
      if (range == null)
        return;
      const {
        html,
        text
      } = this.onCopy(range, isCut);
      e3.clipboardData?.setData("text/plain", text);
      e3.clipboardData?.setData("text/html", html);
      if (isCut) {
        deleteRange({
          range,
          quill: this.quill
        });
      }
    }
    /*
     * https://www.iana.org/assignments/media-types/text/uri-list
     */
    normalizeURIList(urlList) {
      return urlList.split(/\r?\n/).filter((url) => url[0] !== "#").join("\n");
    }
    onCapturePaste(e3) {
      if (e3.defaultPrevented || !this.quill.isEnabled())
        return;
      e3.preventDefault();
      const range = this.quill.getSelection(true);
      if (range == null)
        return;
      const html = e3.clipboardData?.getData("text/html");
      let text = e3.clipboardData?.getData("text/plain");
      if (!html && !text) {
        const urlList = e3.clipboardData?.getData("text/uri-list");
        if (urlList) {
          text = this.normalizeURIList(urlList);
        }
      }
      const files = Array.from(e3.clipboardData?.files || []);
      if (!html && files.length > 0) {
        this.quill.uploader.upload(range, files);
        return;
      }
      if (html && files.length > 0) {
        const doc = new DOMParser().parseFromString(html, "text/html");
        if (doc.body.childElementCount === 1 && doc.body.firstElementChild?.tagName === "IMG") {
          this.quill.uploader.upload(range, files);
          return;
        }
      }
      this.onPaste(range, {
        html,
        text
      });
    }
    onCopy(range) {
      const text = this.quill.getText(range);
      const html = this.quill.getSemanticHTML(range);
      return {
        html,
        text
      };
    }
    onPaste(range, _ref3) {
      let {
        text,
        html
      } = _ref3;
      const formats3 = this.quill.getFormat(range.index);
      const pastedDelta = this.convert({
        text,
        html
      }, formats3);
      debug6.log("onPaste", pastedDelta, {
        text,
        html
      });
      const delta = new import_quill_delta6.default().retain(range.index).delete(range.length).concat(pastedDelta);
      this.quill.updateContents(delta, Quill.sources.USER);
      this.quill.setSelection(delta.length() - range.length, Quill.sources.SILENT);
      this.quill.scrollSelectionIntoView();
    }
    prepareMatching(container, nodeMatches) {
      const elementMatchers = [];
      const textMatchers = [];
      this.matchers.forEach((pair) => {
        const [selector, matcher] = pair;
        switch (selector) {
          case Node.TEXT_NODE:
            textMatchers.push(matcher);
            break;
          case Node.ELEMENT_NODE:
            elementMatchers.push(matcher);
            break;
          default:
            Array.from(container.querySelectorAll(selector)).forEach((node) => {
              if (nodeMatches.has(node)) {
                const matches2 = nodeMatches.get(node);
                matches2?.push(matcher);
              } else {
                nodeMatches.set(node, [matcher]);
              }
            });
            break;
        }
      });
      return [elementMatchers, textMatchers];
    }
  };
  function applyFormat(delta, format, value, scroll) {
    if (!scroll.query(format)) {
      return delta;
    }
    return delta.reduce((newDelta, op) => {
      if (!op.insert)
        return newDelta;
      if (op.attributes && op.attributes[format]) {
        return newDelta.push(op);
      }
      const formats3 = value ? {
        [format]: value
      } : {};
      return newDelta.insert(op.insert, {
        ...formats3,
        ...op.attributes
      });
    }, new import_quill_delta6.default());
  }
  __name(applyFormat, "applyFormat");
  function deltaEndsWith(delta, text) {
    let endText = "";
    for (let i3 = delta.ops.length - 1; i3 >= 0 && endText.length < text.length; --i3) {
      const op = delta.ops[i3];
      if (typeof op.insert !== "string")
        break;
      endText = op.insert + endText;
    }
    return endText.slice(-1 * text.length) === text;
  }
  __name(deltaEndsWith, "deltaEndsWith");
  function isLine2(node, scroll) {
    if (!(node instanceof Element))
      return false;
    const match2 = scroll.query(node);
    if (match2 && match2.prototype instanceof EmbedBlot$1)
      return false;
    return ["address", "article", "blockquote", "canvas", "dd", "div", "dl", "dt", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "header", "iframe", "li", "main", "nav", "ol", "output", "p", "pre", "section", "table", "td", "tr", "ul", "video"].includes(node.tagName.toLowerCase());
  }
  __name(isLine2, "isLine");
  function isBetweenInlineElements(node, scroll) {
    return node.previousElementSibling && node.nextElementSibling && !isLine2(node.previousElementSibling, scroll) && !isLine2(node.nextElementSibling, scroll);
  }
  __name(isBetweenInlineElements, "isBetweenInlineElements");
  var preNodes = /* @__PURE__ */ new WeakMap();
  function isPre(node) {
    if (node == null)
      return false;
    if (!preNodes.has(node)) {
      if (node.tagName === "PRE") {
        preNodes.set(node, true);
      } else {
        preNodes.set(node, isPre(node.parentNode));
      }
    }
    return preNodes.get(node);
  }
  __name(isPre, "isPre");
  function traverse(scroll, node, elementMatchers, textMatchers, nodeMatches) {
    if (node.nodeType === node.TEXT_NODE) {
      return textMatchers.reduce((delta, matcher) => {
        return matcher(node, delta, scroll);
      }, new import_quill_delta6.default());
    }
    if (node.nodeType === node.ELEMENT_NODE) {
      return Array.from(node.childNodes || []).reduce((delta, childNode) => {
        let childrenDelta = traverse(scroll, childNode, elementMatchers, textMatchers, nodeMatches);
        if (childNode.nodeType === node.ELEMENT_NODE) {
          childrenDelta = elementMatchers.reduce((reducedDelta, matcher) => {
            return matcher(childNode, reducedDelta, scroll);
          }, childrenDelta);
          childrenDelta = (nodeMatches.get(childNode) || []).reduce((reducedDelta, matcher) => {
            return matcher(childNode, reducedDelta, scroll);
          }, childrenDelta);
        }
        return delta.concat(childrenDelta);
      }, new import_quill_delta6.default());
    }
    return new import_quill_delta6.default();
  }
  __name(traverse, "traverse");
  function createMatchAlias(format) {
    return (_node, delta, scroll) => {
      return applyFormat(delta, format, true, scroll);
    };
  }
  __name(createMatchAlias, "createMatchAlias");
  function matchAttributor(node, delta, scroll) {
    const attributes = Attributor.keys(node);
    const classes = ClassAttributor$1.keys(node);
    const styles = StyleAttributor$1.keys(node);
    const formats3 = {};
    attributes.concat(classes).concat(styles).forEach((name) => {
      let attr = scroll.query(name, Scope.ATTRIBUTE);
      if (attr != null) {
        formats3[attr.attrName] = attr.value(node);
        if (formats3[attr.attrName])
          return;
      }
      attr = ATTRIBUTE_ATTRIBUTORS[name];
      if (attr != null && (attr.attrName === name || attr.keyName === name)) {
        formats3[attr.attrName] = attr.value(node) || void 0;
      }
      attr = STYLE_ATTRIBUTORS[name];
      if (attr != null && (attr.attrName === name || attr.keyName === name)) {
        attr = STYLE_ATTRIBUTORS[name];
        formats3[attr.attrName] = attr.value(node) || void 0;
      }
    });
    return Object.entries(formats3).reduce((newDelta, _ref4) => {
      let [name, value] = _ref4;
      return applyFormat(newDelta, name, value, scroll);
    }, delta);
  }
  __name(matchAttributor, "matchAttributor");
  function matchBlot(node, delta, scroll) {
    const match2 = scroll.query(node);
    if (match2 == null)
      return delta;
    if (match2.prototype instanceof EmbedBlot$1) {
      const embed = {};
      const value = match2.value(node);
      if (value != null) {
        embed[match2.blotName] = value;
        return new import_quill_delta6.default().insert(embed, match2.formats(node, scroll));
      }
    } else {
      if (match2.prototype instanceof BlockBlot$1 && !deltaEndsWith(delta, "\n")) {
        delta.insert("\n");
      }
      if ("blotName" in match2 && "formats" in match2 && typeof match2.formats === "function") {
        return applyFormat(delta, match2.blotName, match2.formats(node, scroll), scroll);
      }
    }
    return delta;
  }
  __name(matchBlot, "matchBlot");
  function matchBreak(node, delta) {
    if (!deltaEndsWith(delta, "\n")) {
      delta.insert("\n");
    }
    return delta;
  }
  __name(matchBreak, "matchBreak");
  function matchCodeBlock(node, delta, scroll) {
    const match2 = scroll.query("code-block");
    const language = match2 && "formats" in match2 && typeof match2.formats === "function" ? match2.formats(node, scroll) : true;
    return applyFormat(delta, "code-block", language, scroll);
  }
  __name(matchCodeBlock, "matchCodeBlock");
  function matchIgnore() {
    return new import_quill_delta6.default();
  }
  __name(matchIgnore, "matchIgnore");
  function matchIndent(node, delta, scroll) {
    const match2 = scroll.query(node);
    if (match2 == null || // @ts-expect-error
    match2.blotName !== "list" || !deltaEndsWith(delta, "\n")) {
      return delta;
    }
    let indent = -1;
    let parent = node.parentNode;
    while (parent != null) {
      if (["OL", "UL"].includes(parent.tagName)) {
        indent += 1;
      }
      parent = parent.parentNode;
    }
    if (indent <= 0)
      return delta;
    return delta.reduce((composed, op) => {
      if (!op.insert)
        return composed;
      if (op.attributes && typeof op.attributes.indent === "number") {
        return composed.push(op);
      }
      return composed.insert(op.insert, {
        indent,
        ...op.attributes || {}
      });
    }, new import_quill_delta6.default());
  }
  __name(matchIndent, "matchIndent");
  function matchList(node, delta, scroll) {
    const element = node;
    let list = element.tagName === "OL" ? "ordered" : "bullet";
    const checkedAttr = element.getAttribute("data-checked");
    if (checkedAttr) {
      list = checkedAttr === "true" ? "checked" : "unchecked";
    }
    return applyFormat(delta, "list", list, scroll);
  }
  __name(matchList, "matchList");
  function matchNewline(node, delta, scroll) {
    if (!deltaEndsWith(delta, "\n")) {
      if (isLine2(node, scroll) && (node.childNodes.length > 0 || node instanceof HTMLParagraphElement)) {
        return delta.insert("\n");
      }
      if (delta.length() > 0 && node.nextSibling) {
        let nextSibling = node.nextSibling;
        while (nextSibling != null) {
          if (isLine2(nextSibling, scroll)) {
            return delta.insert("\n");
          }
          const match2 = scroll.query(nextSibling);
          if (match2 && match2.prototype instanceof BlockEmbed) {
            return delta.insert("\n");
          }
          nextSibling = nextSibling.firstChild;
        }
      }
    }
    return delta;
  }
  __name(matchNewline, "matchNewline");
  function matchStyles(node, delta, scroll) {
    const formats3 = {};
    const style = node.style || {};
    if (style.fontStyle === "italic") {
      formats3.italic = true;
    }
    if (style.textDecoration === "underline") {
      formats3.underline = true;
    }
    if (style.textDecoration === "line-through") {
      formats3.strike = true;
    }
    if (style.fontWeight?.startsWith("bold") || // @ts-expect-error Fix me later
    parseInt(style.fontWeight, 10) >= 700) {
      formats3.bold = true;
    }
    delta = Object.entries(formats3).reduce((newDelta, _ref5) => {
      let [name, value] = _ref5;
      return applyFormat(newDelta, name, value, scroll);
    }, delta);
    if (parseFloat(style.textIndent || 0) > 0) {
      return new import_quill_delta6.default().insert("	").concat(delta);
    }
    return delta;
  }
  __name(matchStyles, "matchStyles");
  function matchTable(node, delta, scroll) {
    const table = node.parentElement?.tagName === "TABLE" ? node.parentElement : node.parentElement?.parentElement;
    if (table != null) {
      const rows = Array.from(table.querySelectorAll("tr"));
      const row = rows.indexOf(node) + 1;
      return applyFormat(delta, "table", row, scroll);
    }
    return delta;
  }
  __name(matchTable, "matchTable");
  function matchText(node, delta, scroll) {
    let text = node.data;
    if (node.parentElement?.tagName === "O:P") {
      return delta.insert(text.trim());
    }
    if (!isPre(node)) {
      if (text.trim().length === 0 && text.includes("\n") && !isBetweenInlineElements(node, scroll)) {
        return delta;
      }
      const replacer = /* @__PURE__ */ __name((collapse, match2) => {
        const replaced = match2.replace(/[^\u00a0]/g, "");
        return replaced.length < 1 && collapse ? " " : replaced;
      }, "replacer");
      text = text.replace(/\r\n/g, " ").replace(/\n/g, " ");
      text = text.replace(/\s\s+/g, replacer.bind(replacer, true));
      if (node.previousSibling == null && node.parentElement != null && isLine2(node.parentElement, scroll) || node.previousSibling instanceof Element && isLine2(node.previousSibling, scroll)) {
        text = text.replace(/^\s+/, replacer.bind(replacer, false));
      }
      if (node.nextSibling == null && node.parentElement != null && isLine2(node.parentElement, scroll) || node.nextSibling instanceof Element && isLine2(node.nextSibling, scroll)) {
        text = text.replace(/\s+$/, replacer.bind(replacer, false));
      }
    }
    return delta.insert(text);
  }
  __name(matchText, "matchText");

  // node_modules/quill/modules/history.js
  var History2 = class extends module_default {
    static {
      __name(this, "History");
    }
    static DEFAULTS = {
      delay: 1e3,
      maxStack: 100,
      userOnly: false
    };
    lastRecorded = 0;
    ignoreChange = false;
    stack = {
      undo: [],
      redo: []
    };
    currentRange = null;
    constructor(quill, options) {
      super(quill, options);
      this.quill.on(Quill.events.EDITOR_CHANGE, (eventName, value, oldValue, source) => {
        if (eventName === Quill.events.SELECTION_CHANGE) {
          if (value && source !== Quill.sources.SILENT) {
            this.currentRange = value;
          }
        } else if (eventName === Quill.events.TEXT_CHANGE) {
          if (!this.ignoreChange) {
            if (!this.options.userOnly || source === Quill.sources.USER) {
              this.record(value, oldValue);
            } else {
              this.transform(value);
            }
          }
          this.currentRange = transformRange(this.currentRange, value);
        }
      });
      this.quill.keyboard.addBinding({
        key: "z",
        shortKey: true
      }, this.undo.bind(this));
      this.quill.keyboard.addBinding({
        key: ["z", "Z"],
        shortKey: true,
        shiftKey: true
      }, this.redo.bind(this));
      if (/Win/i.test(navigator.platform)) {
        this.quill.keyboard.addBinding({
          key: "y",
          shortKey: true
        }, this.redo.bind(this));
      }
      this.quill.root.addEventListener("beforeinput", (event) => {
        if (event.inputType === "historyUndo") {
          this.undo();
          event.preventDefault();
        } else if (event.inputType === "historyRedo") {
          this.redo();
          event.preventDefault();
        }
      });
    }
    change(source, dest) {
      if (this.stack[source].length === 0)
        return;
      const item = this.stack[source].pop();
      if (!item)
        return;
      const base = this.quill.getContents();
      const inverseDelta = item.delta.invert(base);
      this.stack[dest].push({
        delta: inverseDelta,
        range: transformRange(item.range, inverseDelta)
      });
      this.lastRecorded = 0;
      this.ignoreChange = true;
      this.quill.updateContents(item.delta, Quill.sources.USER);
      this.ignoreChange = false;
      this.restoreSelection(item);
    }
    clear() {
      this.stack = {
        undo: [],
        redo: []
      };
    }
    cutoff() {
      this.lastRecorded = 0;
    }
    record(changeDelta, oldDelta) {
      if (changeDelta.ops.length === 0)
        return;
      this.stack.redo = [];
      let undoDelta = changeDelta.invert(oldDelta);
      let undoRange = this.currentRange;
      const timestamp = Date.now();
      if (
        // @ts-expect-error Fix me later
        this.lastRecorded + this.options.delay > timestamp && this.stack.undo.length > 0
      ) {
        const item = this.stack.undo.pop();
        if (item) {
          undoDelta = undoDelta.compose(item.delta);
          undoRange = item.range;
        }
      } else {
        this.lastRecorded = timestamp;
      }
      if (undoDelta.length() === 0)
        return;
      this.stack.undo.push({
        delta: undoDelta,
        range: undoRange
      });
      if (this.stack.undo.length > this.options.maxStack) {
        this.stack.undo.shift();
      }
    }
    redo() {
      this.change("redo", "undo");
    }
    transform(delta) {
      transformStack(this.stack.undo, delta);
      transformStack(this.stack.redo, delta);
    }
    undo() {
      this.change("undo", "redo");
    }
    restoreSelection(stackItem) {
      if (stackItem.range) {
        this.quill.setSelection(stackItem.range, Quill.sources.USER);
      } else {
        const index2 = getLastChangeIndex(this.quill.scroll, stackItem.delta);
        this.quill.setSelection(index2, Quill.sources.USER);
      }
    }
  };
  function transformStack(stack, delta) {
    let remoteDelta = delta;
    for (let i3 = stack.length - 1; i3 >= 0; i3 -= 1) {
      const oldItem = stack[i3];
      stack[i3] = {
        delta: remoteDelta.transform(oldItem.delta, true),
        range: oldItem.range && transformRange(oldItem.range, remoteDelta)
      };
      remoteDelta = oldItem.delta.transform(remoteDelta);
      if (stack[i3].delta.length() === 0) {
        stack.splice(i3, 1);
      }
    }
  }
  __name(transformStack, "transformStack");
  function endsWithNewlineChange(scroll, delta) {
    const lastOp = delta.ops[delta.ops.length - 1];
    if (lastOp == null)
      return false;
    if (lastOp.insert != null) {
      return typeof lastOp.insert === "string" && lastOp.insert.endsWith("\n");
    }
    if (lastOp.attributes != null) {
      return Object.keys(lastOp.attributes).some((attr) => {
        return scroll.query(attr, Scope.BLOCK) != null;
      });
    }
    return false;
  }
  __name(endsWithNewlineChange, "endsWithNewlineChange");
  function getLastChangeIndex(scroll, delta) {
    const deleteLength = delta.reduce((length, op) => {
      return length + (op.delete || 0);
    }, 0);
    let changeIndex = delta.length() - deleteLength;
    if (endsWithNewlineChange(scroll, delta)) {
      changeIndex -= 1;
    }
    return changeIndex;
  }
  __name(getLastChangeIndex, "getLastChangeIndex");
  function transformRange(range, delta) {
    if (!range)
      return range;
    const start2 = delta.transformPosition(range.index);
    const end = delta.transformPosition(range.index + range.length);
    return {
      index: start2,
      length: end - start2
    };
  }
  __name(transformRange, "transformRange");

  // node_modules/quill/modules/uploader.js
  var import_quill_delta7 = __toESM(require_Delta(), 1);
  var Uploader = class extends module_default {
    static {
      __name(this, "Uploader");
    }
    constructor(quill, options) {
      super(quill, options);
      quill.root.addEventListener("drop", (e3) => {
        e3.preventDefault();
        let native = null;
        if (document.caretRangeFromPoint) {
          native = document.caretRangeFromPoint(e3.clientX, e3.clientY);
        } else if (document.caretPositionFromPoint) {
          const position = document.caretPositionFromPoint(e3.clientX, e3.clientY);
          native = document.createRange();
          native.setStart(position.offsetNode, position.offset);
          native.setEnd(position.offsetNode, position.offset);
        }
        const normalized = native && quill.selection.normalizeNative(native);
        if (normalized) {
          const range = quill.selection.normalizedToRange(normalized);
          if (e3.dataTransfer?.files) {
            this.upload(range, e3.dataTransfer.files);
          }
        }
      });
    }
    upload(range, files) {
      const uploads = [];
      Array.from(files).forEach((file) => {
        if (file && this.options.mimetypes?.includes(file.type)) {
          uploads.push(file);
        }
      });
      if (uploads.length > 0) {
        this.options.handler.call(this, range, uploads);
      }
    }
  };
  Uploader.DEFAULTS = {
    mimetypes: ["image/png", "image/jpeg"],
    handler(range, files) {
      const promises = files.map((file) => {
        return new Promise((resolve) => {
          const reader = new FileReader();
          reader.onload = (e3) => {
            resolve(e3.target.result);
          };
          reader.readAsDataURL(file);
        });
      });
      Promise.all(promises).then((images) => {
        const update = images.reduce((delta, image) => {
          return delta.insert({
            image
          });
        }, new import_quill_delta7.default().retain(range.index).delete(range.length));
        this.quill.updateContents(update, emitter_default.sources.USER);
        this.quill.setSelection(range.index + images.length, emitter_default.sources.SILENT);
      });
    }
  };
  var uploader_default = Uploader;

  // node_modules/quill/core.js
  var import_quill_delta9 = __toESM(require_Delta(), 1);

  // node_modules/quill/modules/input.js
  var import_quill_delta8 = __toESM(require_Delta(), 1);
  var INSERT_TYPES = ["insertText", "insertReplacementText"];
  var Input = class extends module_default {
    static {
      __name(this, "Input");
    }
    constructor(quill, options) {
      super(quill, options);
      quill.root.addEventListener("beforeinput", (event) => {
        this.handleBeforeInput(event);
      });
      if (!/Android/i.test(navigator.userAgent)) {
        quill.on(Quill.events.COMPOSITION_BEFORE_START, () => {
          this.handleCompositionStart();
        });
      }
    }
    deleteRange(range) {
      deleteRange({
        range,
        quill: this.quill
      });
    }
    replaceText(range) {
      let text = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
      if (range.length === 0)
        return false;
      if (text) {
        const formats3 = this.quill.getFormat(range.index, 1);
        this.deleteRange(range);
        this.quill.updateContents(new import_quill_delta8.default().retain(range.index).insert(text, formats3), Quill.sources.USER);
      } else {
        this.deleteRange(range);
      }
      this.quill.setSelection(range.index + text.length, 0, Quill.sources.SILENT);
      return true;
    }
    handleBeforeInput(event) {
      if (this.quill.composition.isComposing || event.defaultPrevented || !INSERT_TYPES.includes(event.inputType)) {
        return;
      }
      const staticRange = event.getTargetRanges ? event.getTargetRanges()[0] : null;
      if (!staticRange || staticRange.collapsed === true) {
        return;
      }
      const text = getPlainTextFromInputEvent(event);
      if (text == null) {
        return;
      }
      const normalized = this.quill.selection.normalizeNative(staticRange);
      const range = normalized ? this.quill.selection.normalizedToRange(normalized) : null;
      if (range && this.replaceText(range, text)) {
        event.preventDefault();
      }
    }
    handleCompositionStart() {
      const range = this.quill.getSelection();
      if (range) {
        this.replaceText(range);
      }
    }
  };
  function getPlainTextFromInputEvent(event) {
    if (typeof event.data === "string") {
      return event.data;
    }
    if (event.dataTransfer?.types.includes("text/plain")) {
      return event.dataTransfer.getData("text/plain");
    }
    return null;
  }
  __name(getPlainTextFromInputEvent, "getPlainTextFromInputEvent");
  var input_default = Input;

  // node_modules/quill/modules/uiNode.js
  var isMac = /Mac/i.test(navigator.platform);
  var TTL_FOR_VALID_SELECTION_CHANGE = 100;
  var canMoveCaretBeforeUINode = /* @__PURE__ */ __name((event) => {
    if (event.key === "ArrowLeft" || event.key === "ArrowRight" || // RTL scripts or moving from the end of the previous line
    event.key === "ArrowUp" || event.key === "ArrowDown" || event.key === "Home") {
      return true;
    }
    if (isMac && event.key === "a" && event.ctrlKey === true) {
      return true;
    }
    return false;
  }, "canMoveCaretBeforeUINode");
  var UINode = class extends module_default {
    static {
      __name(this, "UINode");
    }
    isListening = false;
    selectionChangeDeadline = 0;
    constructor(quill, options) {
      super(quill, options);
      this.handleArrowKeys();
      this.handleNavigationShortcuts();
    }
    handleArrowKeys() {
      this.quill.keyboard.addBinding({
        key: ["ArrowLeft", "ArrowRight"],
        offset: 0,
        shiftKey: null,
        handler(range, _ref) {
          let {
            line,
            event
          } = _ref;
          if (!(line instanceof ParentBlot$1) || !line.uiNode) {
            return true;
          }
          const isRTL = getComputedStyle(line.domNode)["direction"] === "rtl";
          if (isRTL && event.key !== "ArrowRight" || !isRTL && event.key !== "ArrowLeft") {
            return true;
          }
          this.quill.setSelection(range.index - 1, range.length + (event.shiftKey ? 1 : 0), Quill.sources.USER);
          return false;
        }
      });
    }
    handleNavigationShortcuts() {
      this.quill.root.addEventListener("keydown", (event) => {
        if (!event.defaultPrevented && canMoveCaretBeforeUINode(event)) {
          this.ensureListeningToSelectionChange();
        }
      });
    }
    /**
     * We only listen to the `selectionchange` event when
     * there is an intention of moving the caret to the beginning using shortcuts.
     * This is primarily implemented to prevent infinite loops, as we are changing
     * the selection within the handler of a `selectionchange` event.
     */
    ensureListeningToSelectionChange() {
      this.selectionChangeDeadline = Date.now() + TTL_FOR_VALID_SELECTION_CHANGE;
      if (this.isListening)
        return;
      this.isListening = true;
      const listener = /* @__PURE__ */ __name(() => {
        this.isListening = false;
        if (Date.now() <= this.selectionChangeDeadline) {
          this.handleSelectionChange();
        }
      }, "listener");
      document.addEventListener("selectionchange", listener, {
        once: true
      });
    }
    handleSelectionChange() {
      const selection = document.getSelection();
      if (!selection)
        return;
      const range = selection.getRangeAt(0);
      if (range.collapsed !== true || range.startOffset !== 0)
        return;
      const line = this.quill.scroll.find(range.startContainer);
      if (!(line instanceof ParentBlot$1) || !line.uiNode)
        return;
      const newRange = document.createRange();
      newRange.setStartAfter(line.uiNode);
      newRange.setEndAfter(line.uiNode);
      selection.removeAllRanges();
      selection.addRange(newRange);
    }
  };
  var uiNode_default = UINode;

  // node_modules/quill/core.js
  Quill.register({
    "blots/block": Block,
    "blots/block/embed": BlockEmbed,
    "blots/break": break_default,
    "blots/container": container_default,
    "blots/cursor": cursor_default,
    "blots/embed": embed_default,
    "blots/inline": inline_default,
    "blots/scroll": scroll_default,
    "blots/text": Text2,
    "modules/clipboard": Clipboard,
    "modules/history": History2,
    "modules/keyboard": Keyboard,
    "modules/uploader": uploader_default,
    "modules/input": input_default,
    "modules/uiNode": uiNode_default
  });
  var core_default = Quill;

  // node_modules/quill/formats/indent.js
  var IndentAttributor = class extends ClassAttributor$1 {
    static {
      __name(this, "IndentAttributor");
    }
    add(node, value) {
      let normalizedValue = 0;
      if (value === "+1" || value === "-1") {
        const indent = this.value(node) || 0;
        normalizedValue = value === "+1" ? indent + 1 : indent - 1;
      } else if (typeof value === "number") {
        normalizedValue = value;
      }
      if (normalizedValue === 0) {
        this.remove(node);
        return true;
      }
      return super.add(node, normalizedValue.toString());
    }
    canAdd(node, value) {
      return super.canAdd(node, value) || super.canAdd(node, parseInt(value, 10));
    }
    value(node) {
      return parseInt(super.value(node), 10) || void 0;
    }
  };
  var IndentClass = new IndentAttributor("indent", "ql-indent", {
    scope: Scope.BLOCK,
    // @ts-expect-error
    whitelist: [1, 2, 3, 4, 5, 6, 7, 8]
  });
  var indent_default = IndentClass;

  // node_modules/quill/formats/blockquote.js
  var Blockquote = class extends Block {
    static {
      __name(this, "Blockquote");
    }
    static blotName = "blockquote";
    static tagName = "blockquote";
  };
  var blockquote_default = Blockquote;

  // node_modules/quill/formats/header.js
  var Header = class extends Block {
    static {
      __name(this, "Header");
    }
    static blotName = "header";
    static tagName = ["H1", "H2", "H3", "H4", "H5", "H6"];
    static formats(domNode) {
      return this.tagName.indexOf(domNode.tagName) + 1;
    }
  };
  var header_default = Header;

  // node_modules/quill/formats/list.js
  var ListContainer = class extends container_default {
    static {
      __name(this, "ListContainer");
    }
  };
  ListContainer.blotName = "list-container";
  ListContainer.tagName = "OL";
  var ListItem = class extends Block {
    static {
      __name(this, "ListItem");
    }
    static create(value) {
      const node = super.create();
      node.setAttribute("data-list", value);
      return node;
    }
    static formats(domNode) {
      return domNode.getAttribute("data-list") || void 0;
    }
    static register() {
      Quill.register(ListContainer);
    }
    constructor(scroll, domNode) {
      super(scroll, domNode);
      const ui = domNode.ownerDocument.createElement("span");
      const listEventHandler = /* @__PURE__ */ __name((e3) => {
        if (!scroll.isEnabled())
          return;
        const format = this.statics.formats(domNode, scroll);
        if (format === "checked") {
          this.format("list", "unchecked");
          e3.preventDefault();
        } else if (format === "unchecked") {
          this.format("list", "checked");
          e3.preventDefault();
        }
      }, "listEventHandler");
      ui.addEventListener("mousedown", listEventHandler);
      ui.addEventListener("touchstart", listEventHandler);
      this.attachUI(ui);
    }
    format(name, value) {
      if (name === this.statics.blotName && value) {
        this.domNode.setAttribute("data-list", value);
      } else {
        super.format(name, value);
      }
    }
  };
  ListItem.blotName = "list";
  ListItem.tagName = "LI";
  ListContainer.allowedChildren = [ListItem];
  ListItem.requiredContainer = ListContainer;

  // node_modules/quill/formats/bold.js
  var Bold = class extends inline_default {
    static {
      __name(this, "Bold");
    }
    static blotName = "bold";
    static tagName = ["STRONG", "B"];
    static create() {
      return super.create();
    }
    static formats() {
      return true;
    }
    optimize(context) {
      super.optimize(context);
      if (this.domNode.tagName !== this.statics.tagName[0]) {
        this.replaceWith(this.statics.blotName);
      }
    }
  };
  var bold_default = Bold;

  // node_modules/quill/formats/italic.js
  var Italic = class extends bold_default {
    static {
      __name(this, "Italic");
    }
    static blotName = "italic";
    static tagName = ["EM", "I"];
  };
  var italic_default = Italic;

  // node_modules/quill/formats/link.js
  var Link = class extends inline_default {
    static {
      __name(this, "Link");
    }
    static blotName = "link";
    static tagName = "A";
    static SANITIZED_URL = "about:blank";
    static PROTOCOL_WHITELIST = ["http", "https", "mailto", "tel", "sms"];
    static create(value) {
      const node = super.create(value);
      node.setAttribute("href", this.sanitize(value));
      node.setAttribute("rel", "noopener noreferrer");
      node.setAttribute("target", "_blank");
      return node;
    }
    static formats(domNode) {
      return domNode.getAttribute("href");
    }
    static sanitize(url) {
      return sanitize(url, this.PROTOCOL_WHITELIST) ? url : this.SANITIZED_URL;
    }
    format(name, value) {
      if (name !== this.statics.blotName || !value) {
        super.format(name, value);
      } else {
        this.domNode.setAttribute("href", this.constructor.sanitize(value));
      }
    }
  };
  function sanitize(url, protocols2) {
    const anchor = document.createElement("a");
    anchor.href = url;
    const protocol = anchor.href.slice(0, anchor.href.indexOf(":"));
    return protocols2.indexOf(protocol) > -1;
  }
  __name(sanitize, "sanitize");

  // node_modules/quill/formats/script.js
  var Script = class extends inline_default {
    static {
      __name(this, "Script");
    }
    static blotName = "script";
    static tagName = ["SUB", "SUP"];
    static create(value) {
      if (value === "super") {
        return document.createElement("sup");
      }
      if (value === "sub") {
        return document.createElement("sub");
      }
      return super.create(value);
    }
    static formats(domNode) {
      if (domNode.tagName === "SUB")
        return "sub";
      if (domNode.tagName === "SUP")
        return "super";
      return void 0;
    }
  };
  var script_default = Script;

  // node_modules/quill/formats/strike.js
  var Strike = class extends bold_default {
    static {
      __name(this, "Strike");
    }
    static blotName = "strike";
    static tagName = ["S", "STRIKE"];
  };
  var strike_default = Strike;

  // node_modules/quill/formats/underline.js
  var Underline = class extends inline_default {
    static {
      __name(this, "Underline");
    }
    static blotName = "underline";
    static tagName = "U";
  };
  var underline_default = Underline;

  // node_modules/quill/formats/formula.js
  var Formula = class extends embed_default {
    static {
      __name(this, "Formula");
    }
    static blotName = "formula";
    static className = "ql-formula";
    static tagName = "SPAN";
    static create(value) {
      if (window.katex == null) {
        throw new Error("Formula module requires KaTeX.");
      }
      const node = super.create(value);
      if (typeof value === "string") {
        window.katex.render(value, node, {
          throwOnError: false,
          errorColor: "#f00"
        });
        node.setAttribute("data-value", value);
      }
      return node;
    }
    static value(domNode) {
      return domNode.getAttribute("data-value");
    }
    html() {
      const {
        formula
      } = this.value();
      return `<span>${formula}</span>`;
    }
  };
  var formula_default = Formula;

  // node_modules/quill/formats/image.js
  var ATTRIBUTES = ["alt", "height", "width"];
  var Image = class extends EmbedBlot$1 {
    static {
      __name(this, "Image");
    }
    static blotName = "image";
    static tagName = "IMG";
    static create(value) {
      const node = super.create(value);
      if (typeof value === "string") {
        node.setAttribute("src", this.sanitize(value));
      }
      return node;
    }
    static formats(domNode) {
      return ATTRIBUTES.reduce((formats3, attribute) => {
        if (domNode.hasAttribute(attribute)) {
          formats3[attribute] = domNode.getAttribute(attribute);
        }
        return formats3;
      }, {});
    }
    static match(url) {
      return /\.(jpe?g|gif|png)$/.test(url) || /^data:image\/.+;base64/.test(url);
    }
    static sanitize(url) {
      return sanitize(url, ["http", "https", "data"]) ? url : "//:0";
    }
    static value(domNode) {
      return domNode.getAttribute("src");
    }
    format(name, value) {
      if (ATTRIBUTES.indexOf(name) > -1) {
        if (value) {
          this.domNode.setAttribute(name, value);
        } else {
          this.domNode.removeAttribute(name);
        }
      } else {
        super.format(name, value);
      }
    }
  };
  var image_default = Image;

  // node_modules/quill/formats/video.js
  var ATTRIBUTES2 = ["height", "width"];
  var Video = class extends BlockEmbed {
    static {
      __name(this, "Video");
    }
    static blotName = "video";
    static className = "ql-video";
    static tagName = "IFRAME";
    static create(value) {
      const node = super.create(value);
      node.setAttribute("frameborder", "0");
      node.setAttribute("allowfullscreen", "true");
      node.setAttribute("src", this.sanitize(value));
      return node;
    }
    static formats(domNode) {
      return ATTRIBUTES2.reduce((formats3, attribute) => {
        if (domNode.hasAttribute(attribute)) {
          formats3[attribute] = domNode.getAttribute(attribute);
        }
        return formats3;
      }, {});
    }
    static sanitize(url) {
      return Link.sanitize(url);
    }
    static value(domNode) {
      return domNode.getAttribute("src");
    }
    format(name, value) {
      if (ATTRIBUTES2.indexOf(name) > -1) {
        if (value) {
          this.domNode.setAttribute(name, value);
        } else {
          this.domNode.removeAttribute(name);
        }
      } else {
        super.format(name, value);
      }
    }
    html() {
      const {
        video
      } = this.value();
      return `<a href="${video}">${video}</a>`;
    }
  };
  var video_default = Video;

  // node_modules/quill/modules/syntax.js
  var import_quill_delta10 = __toESM(require_Delta(), 1);
  var TokenAttributor = new ClassAttributor$1("code-token", "hljs", {
    scope: Scope.INLINE
  });
  var CodeToken = class _CodeToken extends inline_default {
    static {
      __name(this, "CodeToken");
    }
    static formats(node, scroll) {
      while (node != null && node !== scroll.domNode) {
        if (node.classList && node.classList.contains(CodeBlock.className)) {
          return super.formats(node, scroll);
        }
        node = node.parentNode;
      }
      return void 0;
    }
    constructor(scroll, domNode, value) {
      super(scroll, domNode, value);
      TokenAttributor.add(this.domNode, value);
    }
    format(format, value) {
      if (format !== _CodeToken.blotName) {
        super.format(format, value);
      } else if (value) {
        TokenAttributor.add(this.domNode, value);
      } else {
        TokenAttributor.remove(this.domNode);
        this.domNode.classList.remove(this.statics.className);
      }
    }
    optimize() {
      super.optimize(...arguments);
      if (!TokenAttributor.value(this.domNode)) {
        this.unwrap();
      }
    }
  };
  CodeToken.blotName = "code-token";
  CodeToken.className = "ql-token";
  var SyntaxCodeBlock = class extends CodeBlock {
    static {
      __name(this, "SyntaxCodeBlock");
    }
    static create(value) {
      const domNode = super.create(value);
      if (typeof value === "string") {
        domNode.setAttribute("data-language", value);
      }
      return domNode;
    }
    static formats(domNode) {
      return domNode.getAttribute("data-language") || "plain";
    }
    static register() {
    }
    // Syntax module will register
    format(name, value) {
      if (name === this.statics.blotName && value) {
        this.domNode.setAttribute("data-language", value);
      } else {
        super.format(name, value);
      }
    }
    replaceWith(name, value) {
      this.formatAt(0, this.length(), CodeToken.blotName, false);
      return super.replaceWith(name, value);
    }
  };
  var SyntaxCodeBlockContainer = class extends CodeBlockContainer {
    static {
      __name(this, "SyntaxCodeBlockContainer");
    }
    attach() {
      super.attach();
      this.forceNext = false;
      this.scroll.emitMount(this);
    }
    format(name, value) {
      if (name === SyntaxCodeBlock.blotName) {
        this.forceNext = true;
        this.children.forEach((child) => {
          child.format(name, value);
        });
      }
    }
    formatAt(index2, length, name, value) {
      if (name === SyntaxCodeBlock.blotName) {
        this.forceNext = true;
      }
      super.formatAt(index2, length, name, value);
    }
    highlight(highlight2) {
      let forced = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      if (this.children.head == null)
        return;
      const nodes = Array.from(this.domNode.childNodes).filter((node) => node !== this.uiNode);
      const text = `${nodes.map((node) => node.textContent).join("\n")}
`;
      const language = SyntaxCodeBlock.formats(this.children.head.domNode);
      if (forced || this.forceNext || this.cachedText !== text) {
        if (text.trim().length > 0 || this.cachedText == null) {
          const oldDelta = this.children.reduce((delta2, child) => {
            return delta2.concat(blockDelta(child, false));
          }, new import_quill_delta10.default());
          const delta = highlight2(text, language);
          oldDelta.diff(delta).reduce((index2, _ref) => {
            let {
              retain,
              attributes
            } = _ref;
            if (!retain)
              return index2;
            if (attributes) {
              Object.keys(attributes).forEach((format) => {
                if ([SyntaxCodeBlock.blotName, CodeToken.blotName].includes(format)) {
                  this.formatAt(index2, retain, format, attributes[format]);
                }
              });
            }
            return index2 + retain;
          }, 0);
        }
        this.cachedText = text;
        this.forceNext = false;
      }
    }
    html(index2, length) {
      const [codeBlock] = this.children.find(index2);
      const language = codeBlock ? SyntaxCodeBlock.formats(codeBlock.domNode) : "plain";
      return `<pre data-language="${language}">
${escapeText(this.code(index2, length))}
</pre>`;
    }
    optimize(context) {
      super.optimize(context);
      if (this.parent != null && this.children.head != null && this.uiNode != null) {
        const language = SyntaxCodeBlock.formats(this.children.head.domNode);
        if (language !== this.uiNode.value) {
          this.uiNode.value = language;
        }
      }
    }
  };
  SyntaxCodeBlockContainer.allowedChildren = [SyntaxCodeBlock];
  SyntaxCodeBlock.requiredContainer = SyntaxCodeBlockContainer;
  SyntaxCodeBlock.allowedChildren = [CodeToken, cursor_default, Text2, break_default];
  var highlight = /* @__PURE__ */ __name((lib, language, text) => {
    if (typeof lib.versionString === "string") {
      const majorVersion = lib.versionString.split(".")[0];
      if (parseInt(majorVersion, 10) >= 11) {
        return lib.highlight(text, {
          language
        }).value;
      }
    }
    return lib.highlight(language, text).value;
  }, "highlight");
  var Syntax = class extends module_default {
    static {
      __name(this, "Syntax");
    }
    static register() {
      Quill.register(CodeToken, true);
      Quill.register(SyntaxCodeBlock, true);
      Quill.register(SyntaxCodeBlockContainer, true);
    }
    constructor(quill, options) {
      super(quill, options);
      if (this.options.hljs == null) {
        throw new Error("Syntax module requires highlight.js. Please include the library on the page before Quill.");
      }
      this.languages = this.options.languages.reduce((memo, _ref2) => {
        let {
          key
        } = _ref2;
        memo[key] = true;
        return memo;
      }, {});
      this.highlightBlot = this.highlightBlot.bind(this);
      this.initListener();
      this.initTimer();
    }
    initListener() {
      this.quill.on(Quill.events.SCROLL_BLOT_MOUNT, (blot) => {
        if (!(blot instanceof SyntaxCodeBlockContainer))
          return;
        const select = this.quill.root.ownerDocument.createElement("select");
        this.options.languages.forEach((_ref3) => {
          let {
            key,
            label
          } = _ref3;
          const option2 = select.ownerDocument.createElement("option");
          option2.textContent = label;
          option2.setAttribute("value", key);
          select.appendChild(option2);
        });
        select.addEventListener("change", () => {
          blot.format(SyntaxCodeBlock.blotName, select.value);
          this.quill.root.focus();
          this.highlight(blot, true);
        });
        if (blot.uiNode == null) {
          blot.attachUI(select);
          if (blot.children.head) {
            select.value = SyntaxCodeBlock.formats(blot.children.head.domNode);
          }
        }
      });
    }
    initTimer() {
      let timer = null;
      this.quill.on(Quill.events.SCROLL_OPTIMIZE, () => {
        if (timer) {
          clearTimeout(timer);
        }
        timer = setTimeout(() => {
          this.highlight();
          timer = null;
        }, this.options.interval);
      });
    }
    highlight() {
      let blot = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
      let force = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      if (this.quill.selection.composing)
        return;
      this.quill.update(Quill.sources.USER);
      const range = this.quill.getSelection();
      const blots = blot == null ? this.quill.scroll.descendants(SyntaxCodeBlockContainer) : [blot];
      blots.forEach((container) => {
        container.highlight(this.highlightBlot, force);
      });
      this.quill.update(Quill.sources.SILENT);
      if (range != null) {
        this.quill.setSelection(range, Quill.sources.SILENT);
      }
    }
    highlightBlot(text) {
      let language = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "plain";
      language = this.languages[language] ? language : "plain";
      if (language === "plain") {
        return escapeText(text).split("\n").reduce((delta, line, i3) => {
          if (i3 !== 0) {
            delta.insert("\n", {
              [CodeBlock.blotName]: language
            });
          }
          return delta.insert(line);
        }, new import_quill_delta10.default());
      }
      const container = this.quill.root.ownerDocument.createElement("div");
      container.classList.add(CodeBlock.className);
      container.innerHTML = highlight(this.options.hljs, language, text);
      return traverse(this.quill.scroll, container, [(node, delta) => {
        const value = TokenAttributor.value(node);
        if (value) {
          return delta.compose(new import_quill_delta10.default().retain(delta.length(), {
            [CodeToken.blotName]: value
          }));
        }
        return delta;
      }], [(node, delta) => {
        return node.data.split("\n").reduce((memo, nodeText, i3) => {
          if (i3 !== 0)
            memo.insert("\n", {
              [CodeBlock.blotName]: language
            });
          return memo.insert(nodeText);
        }, delta);
      }], /* @__PURE__ */ new WeakMap());
    }
  };
  Syntax.DEFAULTS = {
    hljs: (() => {
      return window.hljs;
    })(),
    interval: 1e3,
    languages: [{
      key: "plain",
      label: "Plain"
    }, {
      key: "bash",
      label: "Bash"
    }, {
      key: "cpp",
      label: "C++"
    }, {
      key: "cs",
      label: "C#"
    }, {
      key: "css",
      label: "CSS"
    }, {
      key: "diff",
      label: "Diff"
    }, {
      key: "xml",
      label: "HTML/XML"
    }, {
      key: "java",
      label: "Java"
    }, {
      key: "javascript",
      label: "JavaScript"
    }, {
      key: "markdown",
      label: "Markdown"
    }, {
      key: "php",
      label: "PHP"
    }, {
      key: "python",
      label: "Python"
    }, {
      key: "ruby",
      label: "Ruby"
    }, {
      key: "sql",
      label: "SQL"
    }]
  };

  // node_modules/quill/modules/table.js
  var import_quill_delta11 = __toESM(require_Delta(), 1);

  // node_modules/quill/formats/table.js
  var TableCell = class _TableCell extends Block {
    static {
      __name(this, "TableCell");
    }
    static blotName = "table";
    static tagName = "TD";
    static create(value) {
      const node = super.create();
      if (value) {
        node.setAttribute("data-row", value);
      } else {
        node.setAttribute("data-row", tableId());
      }
      return node;
    }
    static formats(domNode) {
      if (domNode.hasAttribute("data-row")) {
        return domNode.getAttribute("data-row");
      }
      return void 0;
    }
    cellOffset() {
      if (this.parent) {
        return this.parent.children.indexOf(this);
      }
      return -1;
    }
    format(name, value) {
      if (name === _TableCell.blotName && value) {
        this.domNode.setAttribute("data-row", value);
      } else {
        super.format(name, value);
      }
    }
    row() {
      return this.parent;
    }
    rowOffset() {
      if (this.row()) {
        return this.row().rowOffset();
      }
      return -1;
    }
    table() {
      return this.row() && this.row().table();
    }
  };
  var TableRow = class extends container_default {
    static {
      __name(this, "TableRow");
    }
    static blotName = "table-row";
    static tagName = "TR";
    checkMerge() {
      if (super.checkMerge() && this.next.children.head != null) {
        const thisHead = this.children.head.formats();
        const thisTail = this.children.tail.formats();
        const nextHead = this.next.children.head.formats();
        const nextTail = this.next.children.tail.formats();
        return thisHead.table === thisTail.table && thisHead.table === nextHead.table && thisHead.table === nextTail.table;
      }
      return false;
    }
    optimize(context) {
      super.optimize(context);
      this.children.forEach((child) => {
        if (child.next == null)
          return;
        const childFormats = child.formats();
        const nextFormats = child.next.formats();
        if (childFormats.table !== nextFormats.table) {
          const next = this.splitAfter(child);
          if (next) {
            next.optimize();
          }
          if (this.prev) {
            this.prev.optimize();
          }
        }
      });
    }
    rowOffset() {
      if (this.parent) {
        return this.parent.children.indexOf(this);
      }
      return -1;
    }
    table() {
      return this.parent && this.parent.parent;
    }
  };
  var TableBody = class extends container_default {
    static {
      __name(this, "TableBody");
    }
    static blotName = "table-body";
    static tagName = "TBODY";
  };
  var TableContainer = class extends container_default {
    static {
      __name(this, "TableContainer");
    }
    static blotName = "table-container";
    static tagName = "TABLE";
    balanceCells() {
      const rows = this.descendants(TableRow);
      const maxColumns = rows.reduce((max, row) => {
        return Math.max(row.children.length, max);
      }, 0);
      rows.forEach((row) => {
        new Array(maxColumns - row.children.length).fill(0).forEach(() => {
          let value;
          if (row.children.head != null) {
            value = TableCell.formats(row.children.head.domNode);
          }
          const blot = this.scroll.create(TableCell.blotName, value);
          row.appendChild(blot);
          blot.optimize();
        });
      });
    }
    cells(column) {
      return this.rows().map((row) => row.children.at(column));
    }
    deleteColumn(index2) {
      const [body] = this.descendant(TableBody);
      if (body == null || body.children.head == null)
        return;
      body.children.forEach((row) => {
        const cell = row.children.at(index2);
        if (cell != null) {
          cell.remove();
        }
      });
    }
    insertColumn(index2) {
      const [body] = this.descendant(TableBody);
      if (body == null || body.children.head == null)
        return;
      body.children.forEach((row) => {
        const ref = row.children.at(index2);
        const value = TableCell.formats(row.children.head.domNode);
        const cell = this.scroll.create(TableCell.blotName, value);
        row.insertBefore(cell, ref);
      });
    }
    insertRow(index2) {
      const [body] = this.descendant(TableBody);
      if (body == null || body.children.head == null)
        return;
      const id = tableId();
      const row = this.scroll.create(TableRow.blotName);
      body.children.head.children.forEach(() => {
        const cell = this.scroll.create(TableCell.blotName, id);
        row.appendChild(cell);
      });
      const ref = body.children.at(index2);
      body.insertBefore(row, ref);
    }
    rows() {
      const body = this.children.head;
      if (body == null)
        return [];
      return body.children.map((row) => row);
    }
  };
  TableContainer.allowedChildren = [TableBody];
  TableBody.requiredContainer = TableContainer;
  TableBody.allowedChildren = [TableRow];
  TableRow.requiredContainer = TableBody;
  TableRow.allowedChildren = [TableCell];
  TableCell.requiredContainer = TableRow;
  function tableId() {
    const id = Math.random().toString(36).slice(2, 6);
    return `row-${id}`;
  }
  __name(tableId, "tableId");

  // node_modules/quill/modules/table.js
  var Table = class extends module_default {
    static {
      __name(this, "Table");
    }
    static register() {
      Quill.register(TableCell);
      Quill.register(TableRow);
      Quill.register(TableBody);
      Quill.register(TableContainer);
    }
    constructor() {
      super(...arguments);
      this.listenBalanceCells();
    }
    balanceTables() {
      this.quill.scroll.descendants(TableContainer).forEach((table) => {
        table.balanceCells();
      });
    }
    deleteColumn() {
      const [table, , cell] = this.getTable();
      if (cell == null)
        return;
      table.deleteColumn(cell.cellOffset());
      this.quill.update(Quill.sources.USER);
    }
    deleteRow() {
      const [, row] = this.getTable();
      if (row == null)
        return;
      row.remove();
      this.quill.update(Quill.sources.USER);
    }
    deleteTable() {
      const [table] = this.getTable();
      if (table == null)
        return;
      const offset = table.offset();
      table.remove();
      this.quill.update(Quill.sources.USER);
      this.quill.setSelection(offset, Quill.sources.SILENT);
    }
    getTable() {
      let range = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.quill.getSelection();
      if (range == null)
        return [null, null, null, -1];
      const [cell, offset] = this.quill.getLine(range.index);
      if (cell == null || cell.statics.blotName !== TableCell.blotName) {
        return [null, null, null, -1];
      }
      const row = cell.parent;
      const table = row.parent.parent;
      return [table, row, cell, offset];
    }
    insertColumn(offset) {
      const range = this.quill.getSelection();
      if (!range)
        return;
      const [table, row, cell] = this.getTable(range);
      if (cell == null)
        return;
      const column = cell.cellOffset();
      table.insertColumn(column + offset);
      this.quill.update(Quill.sources.USER);
      let shift = row.rowOffset();
      if (offset === 0) {
        shift += 1;
      }
      this.quill.setSelection(range.index + shift, range.length, Quill.sources.SILENT);
    }
    insertColumnLeft() {
      this.insertColumn(0);
    }
    insertColumnRight() {
      this.insertColumn(1);
    }
    insertRow(offset) {
      const range = this.quill.getSelection();
      if (!range)
        return;
      const [table, row, cell] = this.getTable(range);
      if (cell == null)
        return;
      const index2 = row.rowOffset();
      table.insertRow(index2 + offset);
      this.quill.update(Quill.sources.USER);
      if (offset > 0) {
        this.quill.setSelection(range, Quill.sources.SILENT);
      } else {
        this.quill.setSelection(range.index + row.children.length, range.length, Quill.sources.SILENT);
      }
    }
    insertRowAbove() {
      this.insertRow(0);
    }
    insertRowBelow() {
      this.insertRow(1);
    }
    insertTable(rows, columns) {
      const range = this.quill.getSelection();
      if (range == null)
        return;
      const delta = new Array(rows).fill(0).reduce((memo) => {
        const text = new Array(columns).fill("\n").join("");
        return memo.insert(text, {
          table: tableId()
        });
      }, new import_quill_delta11.default().retain(range.index));
      this.quill.updateContents(delta, Quill.sources.USER);
      this.quill.setSelection(range.index, Quill.sources.SILENT);
      this.balanceTables();
    }
    listenBalanceCells() {
      this.quill.on(Quill.events.SCROLL_OPTIMIZE, (mutations) => {
        mutations.some((mutation) => {
          if (["TD", "TR", "TBODY", "TABLE"].includes(mutation.target.tagName)) {
            this.quill.once(Quill.events.TEXT_CHANGE, (delta, old, source) => {
              if (source !== Quill.sources.USER)
                return;
              this.balanceTables();
            });
            return true;
          }
          return false;
        });
      });
    }
  };
  var table_default = Table;

  // node_modules/quill/modules/toolbar.js
  var import_quill_delta12 = __toESM(require_Delta(), 1);
  var debug7 = logger_default2("quill:toolbar");
  var Toolbar = class extends module_default {
    static {
      __name(this, "Toolbar");
    }
    constructor(quill, options) {
      super(quill, options);
      if (Array.isArray(this.options.container)) {
        const container = document.createElement("div");
        container.setAttribute("role", "toolbar");
        addControls(container, this.options.container);
        quill.container?.parentNode?.insertBefore(container, quill.container);
        this.container = container;
      } else if (typeof this.options.container === "string") {
        this.container = document.querySelector(this.options.container);
      } else {
        this.container = this.options.container;
      }
      if (!(this.container instanceof HTMLElement)) {
        debug7.error("Container required for toolbar", this.options);
        return;
      }
      this.container.classList.add("ql-toolbar");
      this.controls = [];
      this.handlers = {};
      if (this.options.handlers) {
        Object.keys(this.options.handlers).forEach((format) => {
          const handler = this.options.handlers?.[format];
          if (handler) {
            this.addHandler(format, handler);
          }
        });
      }
      Array.from(this.container.querySelectorAll("button, select")).forEach((input) => {
        this.attach(input);
      });
      this.quill.on(Quill.events.EDITOR_CHANGE, () => {
        const [range] = this.quill.selection.getRange();
        this.update(range);
      });
    }
    addHandler(format, handler) {
      this.handlers[format] = handler;
    }
    attach(input) {
      let format = Array.from(input.classList).find((className) => {
        return className.indexOf("ql-") === 0;
      });
      if (!format)
        return;
      format = format.slice("ql-".length);
      if (input.tagName === "BUTTON") {
        input.setAttribute("type", "button");
      }
      if (this.handlers[format] == null && this.quill.scroll.query(format) == null) {
        debug7.warn("ignoring attaching to nonexistent format", format, input);
        return;
      }
      const eventName = input.tagName === "SELECT" ? "change" : "click";
      input.addEventListener(eventName, (e3) => {
        let value;
        if (input.tagName === "SELECT") {
          if (input.selectedIndex < 0)
            return;
          const selected = input.options[input.selectedIndex];
          if (selected.hasAttribute("selected")) {
            value = false;
          } else {
            value = selected.value || false;
          }
        } else {
          if (input.classList.contains("ql-active")) {
            value = false;
          } else {
            value = input.value || !input.hasAttribute("value");
          }
          e3.preventDefault();
        }
        this.quill.focus();
        const [range] = this.quill.selection.getRange();
        if (this.handlers[format] != null) {
          this.handlers[format].call(this, value);
        } else if (
          // @ts-expect-error
          this.quill.scroll.query(format).prototype instanceof EmbedBlot$1
        ) {
          value = prompt(`Enter ${format}`);
          if (!value)
            return;
          this.quill.updateContents(new import_quill_delta12.default().retain(range.index).delete(range.length).insert({
            [format]: value
          }), Quill.sources.USER);
        } else {
          this.quill.format(format, value, Quill.sources.USER);
        }
        this.update(range);
      });
      this.controls.push([format, input]);
    }
    update(range) {
      const formats3 = range == null ? {} : this.quill.getFormat(range);
      this.controls.forEach((pair) => {
        const [format, input] = pair;
        if (input.tagName === "SELECT") {
          let option2 = null;
          if (range == null) {
            option2 = null;
          } else if (formats3[format] == null) {
            option2 = input.querySelector("option[selected]");
          } else if (!Array.isArray(formats3[format])) {
            let value = formats3[format];
            if (typeof value === "string") {
              value = value.replace(/"/g, '\\"');
            }
            option2 = input.querySelector(`option[value="${value}"]`);
          }
          if (option2 == null) {
            input.value = "";
            input.selectedIndex = -1;
          } else {
            option2.selected = true;
          }
        } else if (range == null) {
          input.classList.remove("ql-active");
          input.setAttribute("aria-pressed", "false");
        } else if (input.hasAttribute("value")) {
          const value = formats3[format];
          const isActive = value === input.getAttribute("value") || value != null && value.toString() === input.getAttribute("value") || value == null && !input.getAttribute("value");
          input.classList.toggle("ql-active", isActive);
          input.setAttribute("aria-pressed", isActive.toString());
        } else {
          const isActive = formats3[format] != null;
          input.classList.toggle("ql-active", isActive);
          input.setAttribute("aria-pressed", isActive.toString());
        }
      });
    }
  };
  Toolbar.DEFAULTS = {};
  function addButton(container, format, value) {
    const input = document.createElement("button");
    input.setAttribute("type", "button");
    input.classList.add(`ql-${format}`);
    input.setAttribute("aria-pressed", "false");
    if (value != null) {
      input.value = value;
      input.setAttribute("aria-label", `${format}: ${value}`);
    } else {
      input.setAttribute("aria-label", format);
    }
    container.appendChild(input);
  }
  __name(addButton, "addButton");
  function addControls(container, groups) {
    if (!Array.isArray(groups[0])) {
      groups = [groups];
    }
    groups.forEach((controls) => {
      const group = document.createElement("span");
      group.classList.add("ql-formats");
      controls.forEach((control) => {
        if (typeof control === "string") {
          addButton(group, control);
        } else {
          const format = Object.keys(control)[0];
          const value = control[format];
          if (Array.isArray(value)) {
            addSelect(group, format, value);
          } else {
            addButton(group, format, value);
          }
        }
      });
      container.appendChild(group);
    });
  }
  __name(addControls, "addControls");
  function addSelect(container, format, values) {
    const input = document.createElement("select");
    input.classList.add(`ql-${format}`);
    values.forEach((value) => {
      const option2 = document.createElement("option");
      if (value !== false) {
        option2.setAttribute("value", String(value));
      } else {
        option2.setAttribute("selected", "selected");
      }
      input.appendChild(option2);
    });
    container.appendChild(input);
  }
  __name(addSelect, "addSelect");
  Toolbar.DEFAULTS = {
    container: null,
    handlers: {
      clean() {
        const range = this.quill.getSelection();
        if (range == null)
          return;
        if (range.length === 0) {
          const formats3 = this.quill.getFormat();
          Object.keys(formats3).forEach((name) => {
            if (this.quill.scroll.query(name, Scope.INLINE) != null) {
              this.quill.format(name, false, Quill.sources.USER);
            }
          });
        } else {
          this.quill.removeFormat(range, Quill.sources.USER);
        }
      },
      direction(value) {
        const {
          align
        } = this.quill.getFormat();
        if (value === "rtl" && align == null) {
          this.quill.format("align", "right", Quill.sources.USER);
        } else if (!value && align === "right") {
          this.quill.format("align", false, Quill.sources.USER);
        }
        this.quill.format("direction", value, Quill.sources.USER);
      },
      indent(value) {
        const range = this.quill.getSelection();
        const formats3 = this.quill.getFormat(range);
        const indent = parseInt(formats3.indent || 0, 10);
        if (value === "+1" || value === "-1") {
          let modifier = value === "+1" ? 1 : -1;
          if (formats3.direction === "rtl")
            modifier *= -1;
          this.quill.format("indent", indent + modifier, Quill.sources.USER);
        }
      },
      link(value) {
        if (value === true) {
          value = prompt("Enter link URL:");
        }
        this.quill.format("link", value, Quill.sources.USER);
      },
      list(value) {
        const range = this.quill.getSelection();
        const formats3 = this.quill.getFormat(range);
        if (value === "check") {
          if (formats3.list === "checked" || formats3.list === "unchecked") {
            this.quill.format("list", false, Quill.sources.USER);
          } else {
            this.quill.format("list", "unchecked", Quill.sources.USER);
          }
        } else {
          this.quill.format("list", value, Quill.sources.USER);
        }
      }
    }
  };

  // node_modules/quill/ui/icons.js
  var alignLeftIcon = '<svg viewbox="0 0 18 18"><line class="ql-stroke" x1="3" x2="15" y1="9" y2="9"/><line class="ql-stroke" x1="3" x2="13" y1="14" y2="14"/><line class="ql-stroke" x1="3" x2="9" y1="4" y2="4"/></svg>';
  var alignCenterIcon = '<svg viewbox="0 0 18 18"><line class="ql-stroke" x1="15" x2="3" y1="9" y2="9"/><line class="ql-stroke" x1="14" x2="4" y1="14" y2="14"/><line class="ql-stroke" x1="12" x2="6" y1="4" y2="4"/></svg>';
  var alignRightIcon = '<svg viewbox="0 0 18 18"><line class="ql-stroke" x1="15" x2="3" y1="9" y2="9"/><line class="ql-stroke" x1="15" x2="5" y1="14" y2="14"/><line class="ql-stroke" x1="15" x2="9" y1="4" y2="4"/></svg>';
  var alignJustifyIcon = '<svg viewbox="0 0 18 18"><line class="ql-stroke" x1="15" x2="3" y1="9" y2="9"/><line class="ql-stroke" x1="15" x2="3" y1="14" y2="14"/><line class="ql-stroke" x1="15" x2="3" y1="4" y2="4"/></svg>';
  var backgroundIcon = '<svg viewbox="0 0 18 18"><g class="ql-fill ql-color-label"><polygon points="6 6.868 6 6 5 6 5 7 5.942 7 6 6.868"/><rect height="1" width="1" x="4" y="4"/><polygon points="6.817 5 6 5 6 6 6.38 6 6.817 5"/><rect height="1" width="1" x="2" y="6"/><rect height="1" width="1" x="3" y="5"/><rect height="1" width="1" x="4" y="7"/><polygon points="4 11.439 4 11 3 11 3 12 3.755 12 4 11.439"/><rect height="1" width="1" x="2" y="12"/><rect height="1" width="1" x="2" y="9"/><rect height="1" width="1" x="2" y="15"/><polygon points="4.63 10 4 10 4 11 4.192 11 4.63 10"/><rect height="1" width="1" x="3" y="8"/><path d="M10.832,4.2L11,4.582V4H10.708A1.948,1.948,0,0,1,10.832,4.2Z"/><path d="M7,4.582L7.168,4.2A1.929,1.929,0,0,1,7.292,4H7V4.582Z"/><path d="M8,13H7.683l-0.351.8a1.933,1.933,0,0,1-.124.2H8V13Z"/><rect height="1" width="1" x="12" y="2"/><rect height="1" width="1" x="11" y="3"/><path d="M9,3H8V3.282A1.985,1.985,0,0,1,9,3Z"/><rect height="1" width="1" x="2" y="3"/><rect height="1" width="1" x="6" y="2"/><rect height="1" width="1" x="3" y="2"/><rect height="1" width="1" x="5" y="3"/><rect height="1" width="1" x="9" y="2"/><rect height="1" width="1" x="15" y="14"/><polygon points="13.447 10.174 13.469 10.225 13.472 10.232 13.808 11 14 11 14 10 13.37 10 13.447 10.174"/><rect height="1" width="1" x="13" y="7"/><rect height="1" width="1" x="15" y="5"/><rect height="1" width="1" x="14" y="6"/><rect height="1" width="1" x="15" y="8"/><rect height="1" width="1" x="14" y="9"/><path d="M3.775,14H3v1H4V14.314A1.97,1.97,0,0,1,3.775,14Z"/><rect height="1" width="1" x="14" y="3"/><polygon points="12 6.868 12 6 11.62 6 12 6.868"/><rect height="1" width="1" x="15" y="2"/><rect height="1" width="1" x="12" y="5"/><rect height="1" width="1" x="13" y="4"/><polygon points="12.933 9 13 9 13 8 12.495 8 12.933 9"/><rect height="1" width="1" x="9" y="14"/><rect height="1" width="1" x="8" y="15"/><path d="M6,14.926V15H7V14.316A1.993,1.993,0,0,1,6,14.926Z"/><rect height="1" width="1" x="5" y="15"/><path d="M10.668,13.8L10.317,13H10v1h0.792A1.947,1.947,0,0,1,10.668,13.8Z"/><rect height="1" width="1" x="11" y="15"/><path d="M14.332,12.2a1.99,1.99,0,0,1,.166.8H15V12H14.245Z"/><rect height="1" width="1" x="14" y="15"/><rect height="1" width="1" x="15" y="11"/></g><polyline class="ql-stroke" points="5.5 13 9 5 12.5 13"/><line class="ql-stroke" x1="11.63" x2="6.38" y1="11" y2="11"/></svg>';
  var blockquoteIcon = '<svg viewbox="0 0 18 18"><rect class="ql-fill ql-stroke" height="3" width="3" x="4" y="5"/><rect class="ql-fill ql-stroke" height="3" width="3" x="11" y="5"/><path class="ql-even ql-fill ql-stroke" d="M7,8c0,4.031-3,5-3,5"/><path class="ql-even ql-fill ql-stroke" d="M14,8c0,4.031-3,5-3,5"/></svg>';
  var boldIcon = '<svg viewbox="0 0 18 18"><path class="ql-stroke" d="M5,4H9.5A2.5,2.5,0,0,1,12,6.5v0A2.5,2.5,0,0,1,9.5,9H5A0,0,0,0,1,5,9V4A0,0,0,0,1,5,4Z"/><path class="ql-stroke" d="M5,9h5.5A2.5,2.5,0,0,1,13,11.5v0A2.5,2.5,0,0,1,10.5,14H5a0,0,0,0,1,0,0V9A0,0,0,0,1,5,9Z"/></svg>';
  var cleanIcon = '<svg class="" viewbox="0 0 18 18"><line class="ql-stroke" x1="5" x2="13" y1="3" y2="3"/><line class="ql-stroke" x1="6" x2="9.35" y1="12" y2="3"/><line class="ql-stroke" x1="11" x2="15" y1="11" y2="15"/><line class="ql-stroke" x1="15" x2="11" y1="11" y2="15"/><rect class="ql-fill" height="1" rx="0.5" ry="0.5" width="7" x="2" y="14"/></svg>';
  var codeIcon = '<svg viewbox="0 0 18 18"><polyline class="ql-even ql-stroke" points="5 7 3 9 5 11"/><polyline class="ql-even ql-stroke" points="13 7 15 9 13 11"/><line class="ql-stroke" x1="10" x2="8" y1="5" y2="13"/></svg>';
  var colorIcon = '<svg viewbox="0 0 18 18"><line class="ql-color-label ql-stroke ql-transparent" x1="3" x2="15" y1="15" y2="15"/><polyline class="ql-stroke" points="5.5 11 9 3 12.5 11"/><line class="ql-stroke" x1="11.63" x2="6.38" y1="9" y2="9"/></svg>';
  var directionLeftToRightIcon = '<svg viewbox="0 0 18 18"><polygon class="ql-stroke ql-fill" points="3 11 5 9 3 7 3 11"/><line class="ql-stroke ql-fill" x1="15" x2="11" y1="4" y2="4"/><path class="ql-fill" d="M11,3a3,3,0,0,0,0,6h1V3H11Z"/><rect class="ql-fill" height="11" width="1" x="11" y="4"/><rect class="ql-fill" height="11" width="1" x="13" y="4"/></svg>';
  var directionRightToLeftIcon = '<svg viewbox="0 0 18 18"><polygon class="ql-stroke ql-fill" points="15 12 13 10 15 8 15 12"/><line class="ql-stroke ql-fill" x1="9" x2="5" y1="4" y2="4"/><path class="ql-fill" d="M5,3A3,3,0,0,0,5,9H6V3H5Z"/><rect class="ql-fill" height="11" width="1" x="5" y="4"/><rect class="ql-fill" height="11" width="1" x="7" y="4"/></svg>';
  var formulaIcon = '<svg viewbox="0 0 18 18"><path class="ql-fill" d="M11.759,2.482a2.561,2.561,0,0,0-3.53.607A7.656,7.656,0,0,0,6.8,6.2C6.109,9.188,5.275,14.677,4.15,14.927a1.545,1.545,0,0,0-1.3-.933A0.922,0.922,0,0,0,2,15.036S1.954,16,4.119,16s3.091-2.691,3.7-5.553c0.177-.826.36-1.726,0.554-2.6L8.775,6.2c0.381-1.421.807-2.521,1.306-2.676a1.014,1.014,0,0,0,1.02.56A0.966,0.966,0,0,0,11.759,2.482Z"/><rect class="ql-fill" height="1.6" rx="0.8" ry="0.8" width="5" x="5.15" y="6.2"/><path class="ql-fill" d="M13.663,12.027a1.662,1.662,0,0,1,.266-0.276q0.193,0.069.456,0.138a2.1,2.1,0,0,0,.535.069,1.075,1.075,0,0,0,.767-0.3,1.044,1.044,0,0,0,.314-0.8,0.84,0.84,0,0,0-.238-0.619,0.8,0.8,0,0,0-.594-0.239,1.154,1.154,0,0,0-.781.3,4.607,4.607,0,0,0-.781,1q-0.091.15-.218,0.346l-0.246.38c-0.068-.288-0.137-0.582-0.212-0.885-0.459-1.847-2.494-.984-2.941-0.8-0.482.2-.353,0.647-0.094,0.529a0.869,0.869,0,0,1,1.281.585c0.217,0.751.377,1.436,0.527,2.038a5.688,5.688,0,0,1-.362.467,2.69,2.69,0,0,1-.264.271q-0.221-.08-0.471-0.147a2.029,2.029,0,0,0-.522-0.066,1.079,1.079,0,0,0-.768.3A1.058,1.058,0,0,0,9,15.131a0.82,0.82,0,0,0,.832.852,1.134,1.134,0,0,0,.787-0.3,5.11,5.11,0,0,0,.776-0.993q0.141-.219.215-0.34c0.046-.076.122-0.194,0.223-0.346a2.786,2.786,0,0,0,.918,1.726,2.582,2.582,0,0,0,2.376-.185c0.317-.181.212-0.565,0-0.494A0.807,0.807,0,0,1,14.176,15a5.159,5.159,0,0,1-.913-2.446l0,0Q13.487,12.24,13.663,12.027Z"/></svg>';
  var headerIcon = '<svg viewBox="0 0 18 18"><path class="ql-fill" d="M10,4V14a1,1,0,0,1-2,0V10H3v4a1,1,0,0,1-2,0V4A1,1,0,0,1,3,4V8H8V4a1,1,0,0,1,2,0Zm6.06787,9.209H14.98975V7.59863a.54085.54085,0,0,0-.605-.60547h-.62744a1.01119,1.01119,0,0,0-.748.29688L11.645,8.56641a.5435.5435,0,0,0-.022.8584l.28613.30762a.53861.53861,0,0,0,.84717.0332l.09912-.08789a1.2137,1.2137,0,0,0,.2417-.35254h.02246s-.01123.30859-.01123.60547V13.209H12.041a.54085.54085,0,0,0-.605.60547v.43945a.54085.54085,0,0,0,.605.60547h4.02686a.54085.54085,0,0,0,.605-.60547v-.43945A.54085.54085,0,0,0,16.06787,13.209Z"/></svg>';
  var header2Icon = '<svg viewBox="0 0 18 18"><path class="ql-fill" d="M16.73975,13.81445v.43945a.54085.54085,0,0,1-.605.60547H11.855a.58392.58392,0,0,1-.64893-.60547V14.0127c0-2.90527,3.39941-3.42187,3.39941-4.55469a.77675.77675,0,0,0-.84717-.78125,1.17684,1.17684,0,0,0-.83594.38477c-.2749.26367-.561.374-.85791.13184l-.4292-.34082c-.30811-.24219-.38525-.51758-.1543-.81445a2.97155,2.97155,0,0,1,2.45361-1.17676,2.45393,2.45393,0,0,1,2.68408,2.40918c0,2.45312-3.1792,2.92676-3.27832,3.93848h2.79443A.54085.54085,0,0,1,16.73975,13.81445ZM9,3A.99974.99974,0,0,0,8,4V8H3V4A1,1,0,0,0,1,4V14a1,1,0,0,0,2,0V10H8v4a1,1,0,0,0,2,0V4A.99974.99974,0,0,0,9,3Z"/></svg>';
  var italicIcon = '<svg viewbox="0 0 18 18"><line class="ql-stroke" x1="7" x2="13" y1="4" y2="4"/><line class="ql-stroke" x1="5" x2="11" y1="14" y2="14"/><line class="ql-stroke" x1="8" x2="10" y1="14" y2="4"/></svg>';
  var imageIcon = '<svg viewbox="0 0 18 18"><rect class="ql-stroke" height="10" width="12" x="3" y="4"/><circle class="ql-fill" cx="6" cy="7" r="1"/><polyline class="ql-even ql-fill" points="5 12 5 11 7 9 8 10 11 7 13 9 13 12 5 12"/></svg>';
  var indentIcon = '<svg viewbox="0 0 18 18"><line class="ql-stroke" x1="3" x2="15" y1="14" y2="14"/><line class="ql-stroke" x1="3" x2="15" y1="4" y2="4"/><line class="ql-stroke" x1="9" x2="15" y1="9" y2="9"/><polyline class="ql-fill ql-stroke" points="3 7 3 11 5 9 3 7"/></svg>';
  var outdentIcon = '<svg viewbox="0 0 18 18"><line class="ql-stroke" x1="3" x2="15" y1="14" y2="14"/><line class="ql-stroke" x1="3" x2="15" y1="4" y2="4"/><line class="ql-stroke" x1="9" x2="15" y1="9" y2="9"/><polyline class="ql-stroke" points="5 7 5 11 3 9 5 7"/></svg>';
  var linkIcon = '<svg viewbox="0 0 18 18"><line class="ql-stroke" x1="7" x2="11" y1="7" y2="11"/><path class="ql-even ql-stroke" d="M8.9,4.577a3.476,3.476,0,0,1,.36,4.679A3.476,3.476,0,0,1,4.577,8.9C3.185,7.5,2.035,6.4,4.217,4.217S7.5,3.185,8.9,4.577Z"/><path class="ql-even ql-stroke" d="M13.423,9.1a3.476,3.476,0,0,0-4.679-.36,3.476,3.476,0,0,0,.36,4.679c1.392,1.392,2.5,2.542,4.679.36S14.815,10.5,13.423,9.1Z"/></svg>';
  var listBulletIcon = '<svg viewbox="0 0 18 18"><line class="ql-stroke" x1="6" x2="15" y1="4" y2="4"/><line class="ql-stroke" x1="6" x2="15" y1="9" y2="9"/><line class="ql-stroke" x1="6" x2="15" y1="14" y2="14"/><line class="ql-stroke" x1="3" x2="3" y1="4" y2="4"/><line class="ql-stroke" x1="3" x2="3" y1="9" y2="9"/><line class="ql-stroke" x1="3" x2="3" y1="14" y2="14"/></svg>';
  var listCheckIcon = '<svg class="" viewbox="0 0 18 18"><line class="ql-stroke" x1="9" x2="15" y1="4" y2="4"/><polyline class="ql-stroke" points="3 4 4 5 6 3"/><line class="ql-stroke" x1="9" x2="15" y1="14" y2="14"/><polyline class="ql-stroke" points="3 14 4 15 6 13"/><line class="ql-stroke" x1="9" x2="15" y1="9" y2="9"/><polyline class="ql-stroke" points="3 9 4 10 6 8"/></svg>';
  var listOrderedIcon = '<svg viewbox="0 0 18 18"><line class="ql-stroke" x1="7" x2="15" y1="4" y2="4"/><line class="ql-stroke" x1="7" x2="15" y1="9" y2="9"/><line class="ql-stroke" x1="7" x2="15" y1="14" y2="14"/><line class="ql-stroke ql-thin" x1="2.5" x2="4.5" y1="5.5" y2="5.5"/><path class="ql-fill" d="M3.5,6A0.5,0.5,0,0,1,3,5.5V3.085l-0.276.138A0.5,0.5,0,0,1,2.053,3c-0.124-.247-0.023-0.324.224-0.447l1-.5A0.5,0.5,0,0,1,4,2.5v3A0.5,0.5,0,0,1,3.5,6Z"/><path class="ql-stroke ql-thin" d="M4.5,10.5h-2c0-.234,1.85-1.076,1.85-2.234A0.959,0.959,0,0,0,2.5,8.156"/><path class="ql-stroke ql-thin" d="M2.5,14.846a0.959,0.959,0,0,0,1.85-.109A0.7,0.7,0,0,0,3.75,14a0.688,0.688,0,0,0,.6-0.736,0.959,0.959,0,0,0-1.85-.109"/></svg>';
  var subscriptIcon = '<svg viewbox="0 0 18 18"><path class="ql-fill" d="M15.5,15H13.861a3.858,3.858,0,0,0,1.914-2.975,1.8,1.8,0,0,0-1.6-1.751A1.921,1.921,0,0,0,12.021,11.7a0.50013,0.50013,0,1,0,.957.291h0a0.914,0.914,0,0,1,1.053-.725,0.81,0.81,0,0,1,.744.762c0,1.076-1.16971,1.86982-1.93971,2.43082A1.45639,1.45639,0,0,0,12,15.5a0.5,0.5,0,0,0,.5.5h3A0.5,0.5,0,0,0,15.5,15Z"/><path class="ql-fill" d="M9.65,5.241a1,1,0,0,0-1.409.108L6,7.964,3.759,5.349A1,1,0,0,0,2.192,6.59178Q2.21541,6.6213,2.241,6.649L4.684,9.5,2.241,12.35A1,1,0,0,0,3.71,13.70722q0.02557-.02768.049-0.05722L6,11.036,8.241,13.65a1,1,0,1,0,1.567-1.24277Q9.78459,12.3777,9.759,12.35L7.316,9.5,9.759,6.651A1,1,0,0,0,9.65,5.241Z"/></svg>';
  var superscriptIcon = '<svg viewbox="0 0 18 18"><path class="ql-fill" d="M15.5,7H13.861a4.015,4.015,0,0,0,1.914-2.975,1.8,1.8,0,0,0-1.6-1.751A1.922,1.922,0,0,0,12.021,3.7a0.5,0.5,0,1,0,.957.291,0.917,0.917,0,0,1,1.053-.725,0.81,0.81,0,0,1,.744.762c0,1.077-1.164,1.925-1.934,2.486A1.423,1.423,0,0,0,12,7.5a0.5,0.5,0,0,0,.5.5h3A0.5,0.5,0,0,0,15.5,7Z"/><path class="ql-fill" d="M9.651,5.241a1,1,0,0,0-1.41.108L6,7.964,3.759,5.349a1,1,0,1,0-1.519,1.3L4.683,9.5,2.241,12.35a1,1,0,1,0,1.519,1.3L6,11.036,8.241,13.65a1,1,0,0,0,1.519-1.3L7.317,9.5,9.759,6.651A1,1,0,0,0,9.651,5.241Z"/></svg>';
  var strikeIcon = '<svg viewbox="0 0 18 18"><line class="ql-stroke ql-thin" x1="15.5" x2="2.5" y1="8.5" y2="9.5"/><path class="ql-fill" d="M9.007,8C6.542,7.791,6,7.519,6,6.5,6,5.792,7.283,5,9,5c1.571,0,2.765.679,2.969,1.309a1,1,0,0,0,1.9-.617C13.356,4.106,11.354,3,9,3,6.2,3,4,4.538,4,6.5a3.2,3.2,0,0,0,.5,1.843Z"/><path class="ql-fill" d="M8.984,10C11.457,10.208,12,10.479,12,11.5c0,0.708-1.283,1.5-3,1.5-1.571,0-2.765-.679-2.969-1.309a1,1,0,1,0-1.9.617C4.644,13.894,6.646,15,9,15c2.8,0,5-1.538,5-3.5a3.2,3.2,0,0,0-.5-1.843Z"/></svg>';
  var tableIcon = '<svg viewbox="0 0 18 18"><rect class="ql-stroke" height="12" width="12" x="3" y="3"/><rect class="ql-fill" height="2" width="3" x="5" y="5"/><rect class="ql-fill" height="2" width="4" x="9" y="5"/><g class="ql-fill ql-transparent"><rect height="2" width="3" x="5" y="8"/><rect height="2" width="4" x="9" y="8"/><rect height="2" width="3" x="5" y="11"/><rect height="2" width="4" x="9" y="11"/></g></svg>';
  var underlineIcon = '<svg viewbox="0 0 18 18"><path class="ql-stroke" d="M5,3V9a4.012,4.012,0,0,0,4,4H9a4.012,4.012,0,0,0,4-4V3"/><rect class="ql-fill" height="1" rx="0.5" ry="0.5" width="12" x="3" y="15"/></svg>';
  var videoIcon = '<svg viewbox="0 0 18 18"><rect class="ql-stroke" height="12" width="12" x="3" y="3"/><rect class="ql-fill" height="12" width="1" x="5" y="3"/><rect class="ql-fill" height="12" width="1" x="12" y="3"/><rect class="ql-fill" height="2" width="8" x="5" y="8"/><rect class="ql-fill" height="1" width="3" x="3" y="5"/><rect class="ql-fill" height="1" width="3" x="3" y="7"/><rect class="ql-fill" height="1" width="3" x="3" y="10"/><rect class="ql-fill" height="1" width="3" x="3" y="12"/><rect class="ql-fill" height="1" width="3" x="12" y="5"/><rect class="ql-fill" height="1" width="3" x="12" y="7"/><rect class="ql-fill" height="1" width="3" x="12" y="10"/><rect class="ql-fill" height="1" width="3" x="12" y="12"/></svg>';
  var icons_default = {
    align: {
      "": alignLeftIcon,
      center: alignCenterIcon,
      right: alignRightIcon,
      justify: alignJustifyIcon
    },
    background: backgroundIcon,
    blockquote: blockquoteIcon,
    bold: boldIcon,
    clean: cleanIcon,
    code: codeIcon,
    "code-block": codeIcon,
    color: colorIcon,
    direction: {
      "": directionLeftToRightIcon,
      rtl: directionRightToLeftIcon
    },
    formula: formulaIcon,
    header: {
      "1": headerIcon,
      "2": header2Icon
    },
    italic: italicIcon,
    image: imageIcon,
    indent: {
      "+1": indentIcon,
      "-1": outdentIcon
    },
    link: linkIcon,
    list: {
      bullet: listBulletIcon,
      check: listCheckIcon,
      ordered: listOrderedIcon
    },
    script: {
      sub: subscriptIcon,
      super: superscriptIcon
    },
    strike: strikeIcon,
    table: tableIcon,
    underline: underlineIcon,
    video: videoIcon
  };

  // node_modules/quill/ui/picker.js
  var DropdownIcon = '<svg viewbox="0 0 18 18"><polygon class="ql-stroke" points="7 11 9 13 11 11 7 11"/><polygon class="ql-stroke" points="7 7 9 5 11 7 7 7"/></svg>';
  var optionsCounter = 0;
  function toggleAriaAttribute(element, attribute) {
    element.setAttribute(attribute, `${!(element.getAttribute(attribute) === "true")}`);
  }
  __name(toggleAriaAttribute, "toggleAriaAttribute");
  var Picker = class {
    static {
      __name(this, "Picker");
    }
    constructor(select) {
      this.select = select;
      this.container = document.createElement("span");
      this.buildPicker();
      this.select.style.display = "none";
      this.select.parentNode.insertBefore(this.container, this.select);
      this.label.addEventListener("mousedown", () => {
        this.togglePicker();
      });
      this.label.addEventListener("keydown", (event) => {
        switch (event.key) {
          case "Enter":
            this.togglePicker();
            break;
          case "Escape":
            this.escape();
            event.preventDefault();
            break;
          default:
        }
      });
      this.select.addEventListener("change", this.update.bind(this));
    }
    togglePicker() {
      this.container.classList.toggle("ql-expanded");
      toggleAriaAttribute(this.label, "aria-expanded");
      toggleAriaAttribute(this.options, "aria-hidden");
    }
    buildItem(option2) {
      const item = document.createElement("span");
      item.tabIndex = "0";
      item.setAttribute("role", "button");
      item.classList.add("ql-picker-item");
      const value = option2.getAttribute("value");
      if (value) {
        item.setAttribute("data-value", value);
      }
      if (option2.textContent) {
        item.setAttribute("data-label", option2.textContent);
      }
      item.addEventListener("click", () => {
        this.selectItem(item, true);
      });
      item.addEventListener("keydown", (event) => {
        switch (event.key) {
          case "Enter":
            this.selectItem(item, true);
            event.preventDefault();
            break;
          case "Escape":
            this.escape();
            event.preventDefault();
            break;
          default:
        }
      });
      return item;
    }
    buildLabel() {
      const label = document.createElement("span");
      label.classList.add("ql-picker-label");
      label.innerHTML = DropdownIcon;
      label.tabIndex = "0";
      label.setAttribute("role", "button");
      label.setAttribute("aria-expanded", "false");
      this.container.appendChild(label);
      return label;
    }
    buildOptions() {
      const options = document.createElement("span");
      options.classList.add("ql-picker-options");
      options.setAttribute("aria-hidden", "true");
      options.tabIndex = "-1";
      options.id = `ql-picker-options-${optionsCounter}`;
      optionsCounter += 1;
      this.label.setAttribute("aria-controls", options.id);
      this.options = options;
      Array.from(this.select.options).forEach((option2) => {
        const item = this.buildItem(option2);
        options.appendChild(item);
        if (option2.selected === true) {
          this.selectItem(item);
        }
      });
      this.container.appendChild(options);
    }
    buildPicker() {
      Array.from(this.select.attributes).forEach((item) => {
        this.container.setAttribute(item.name, item.value);
      });
      this.container.classList.add("ql-picker");
      this.label = this.buildLabel();
      this.buildOptions();
    }
    escape() {
      this.close();
      setTimeout(() => this.label.focus(), 1);
    }
    close() {
      this.container.classList.remove("ql-expanded");
      this.label.setAttribute("aria-expanded", "false");
      this.options.setAttribute("aria-hidden", "true");
    }
    selectItem(item) {
      let trigger = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      const selected = this.container.querySelector(".ql-selected");
      if (item === selected)
        return;
      if (selected != null) {
        selected.classList.remove("ql-selected");
      }
      if (item == null)
        return;
      item.classList.add("ql-selected");
      this.select.selectedIndex = Array.from(item.parentNode.children).indexOf(item);
      if (item.hasAttribute("data-value")) {
        this.label.setAttribute("data-value", item.getAttribute("data-value"));
      } else {
        this.label.removeAttribute("data-value");
      }
      if (item.hasAttribute("data-label")) {
        this.label.setAttribute("data-label", item.getAttribute("data-label"));
      } else {
        this.label.removeAttribute("data-label");
      }
      if (trigger) {
        this.select.dispatchEvent(new Event("change"));
        this.close();
      }
    }
    update() {
      let option2;
      if (this.select.selectedIndex > -1) {
        const item = (
          // @ts-expect-error Fix me later
          this.container.querySelector(".ql-picker-options").children[this.select.selectedIndex]
        );
        option2 = this.select.options[this.select.selectedIndex];
        this.selectItem(item);
      } else {
        this.selectItem(null);
      }
      const isActive = option2 != null && option2 !== this.select.querySelector("option[selected]");
      this.label.classList.toggle("ql-active", isActive);
    }
  };
  var picker_default = Picker;

  // node_modules/quill/ui/color-picker.js
  var ColorPicker = class extends picker_default {
    static {
      __name(this, "ColorPicker");
    }
    constructor(select, label) {
      super(select);
      this.label.innerHTML = label;
      this.container.classList.add("ql-color-picker");
      Array.from(this.container.querySelectorAll(".ql-picker-item")).slice(0, 7).forEach((item) => {
        item.classList.add("ql-primary");
      });
    }
    buildItem(option2) {
      const item = super.buildItem(option2);
      item.style.backgroundColor = option2.getAttribute("value") || "";
      return item;
    }
    selectItem(item, trigger) {
      super.selectItem(item, trigger);
      const colorLabel = this.label.querySelector(".ql-color-label");
      const value = item ? item.getAttribute("data-value") || "" : "";
      if (colorLabel) {
        if (colorLabel.tagName === "line") {
          colorLabel.style.stroke = value;
        } else {
          colorLabel.style.fill = value;
        }
      }
    }
  };
  var color_picker_default = ColorPicker;

  // node_modules/quill/ui/icon-picker.js
  var IconPicker = class extends picker_default {
    static {
      __name(this, "IconPicker");
    }
    constructor(select, icons) {
      super(select);
      this.container.classList.add("ql-icon-picker");
      Array.from(this.container.querySelectorAll(".ql-picker-item")).forEach((item) => {
        item.innerHTML = icons[item.getAttribute("data-value") || ""];
      });
      this.defaultItem = this.container.querySelector(".ql-selected");
      this.selectItem(this.defaultItem);
    }
    selectItem(target, trigger) {
      super.selectItem(target, trigger);
      const item = target || this.defaultItem;
      if (item != null) {
        if (this.label.innerHTML === item.innerHTML)
          return;
        this.label.innerHTML = item.innerHTML;
      }
    }
  };
  var icon_picker_default = IconPicker;

  // node_modules/quill/ui/tooltip.js
  var isScrollable = /* @__PURE__ */ __name((el) => {
    const {
      overflowY
    } = getComputedStyle(el, null);
    return overflowY !== "visible" && overflowY !== "clip";
  }, "isScrollable");
  var Tooltip = class {
    static {
      __name(this, "Tooltip");
    }
    constructor(quill, boundsContainer) {
      this.quill = quill;
      this.boundsContainer = boundsContainer || document.body;
      this.root = quill.addContainer("ql-tooltip");
      this.root.innerHTML = this.constructor.TEMPLATE;
      if (isScrollable(this.quill.root)) {
        this.quill.root.addEventListener("scroll", () => {
          this.root.style.marginTop = `${-1 * this.quill.root.scrollTop}px`;
        });
      }
      this.hide();
    }
    hide() {
      this.root.classList.add("ql-hidden");
    }
    position(reference) {
      const left = reference.left + reference.width / 2 - this.root.offsetWidth / 2;
      const top = reference.bottom + this.quill.root.scrollTop;
      this.root.style.left = `${left}px`;
      this.root.style.top = `${top}px`;
      this.root.classList.remove("ql-flip");
      const containerBounds = this.boundsContainer.getBoundingClientRect();
      const rootBounds = this.root.getBoundingClientRect();
      let shift = 0;
      if (rootBounds.right > containerBounds.right) {
        shift = containerBounds.right - rootBounds.right;
        this.root.style.left = `${left + shift}px`;
      }
      if (rootBounds.left < containerBounds.left) {
        shift = containerBounds.left - rootBounds.left;
        this.root.style.left = `${left + shift}px`;
      }
      if (rootBounds.bottom > containerBounds.bottom) {
        const height = rootBounds.bottom - rootBounds.top;
        const verticalShift = reference.bottom - reference.top + height;
        this.root.style.top = `${top - verticalShift}px`;
        this.root.classList.add("ql-flip");
      }
      return shift;
    }
    show() {
      this.root.classList.remove("ql-editing");
      this.root.classList.remove("ql-hidden");
    }
  };
  var tooltip_default = Tooltip;

  // node_modules/quill/themes/base.js
  var ALIGNS = [false, "center", "right", "justify"];
  var COLORS = ["#000000", "#e60000", "#ff9900", "#ffff00", "#008a00", "#0066cc", "#9933ff", "#ffffff", "#facccc", "#ffebcc", "#ffffcc", "#cce8cc", "#cce0f5", "#ebd6ff", "#bbbbbb", "#f06666", "#ffc266", "#ffff66", "#66b966", "#66a3e0", "#c285ff", "#888888", "#a10000", "#b26b00", "#b2b200", "#006100", "#0047b2", "#6b24b2", "#444444", "#5c0000", "#663d00", "#666600", "#003700", "#002966", "#3d1466"];
  var FONTS = [false, "serif", "monospace"];
  var HEADERS = ["1", "2", "3", false];
  var SIZES = ["small", false, "large", "huge"];
  var BaseTheme = class extends theme_default {
    static {
      __name(this, "BaseTheme");
    }
    constructor(quill, options) {
      super(quill, options);
      const listener = /* @__PURE__ */ __name((e3) => {
        if (!document.body.contains(quill.root)) {
          document.body.removeEventListener("click", listener);
          return;
        }
        if (this.tooltip != null && // @ts-expect-error
        !this.tooltip.root.contains(e3.target) && // @ts-expect-error
        document.activeElement !== this.tooltip.textbox && !this.quill.hasFocus()) {
          this.tooltip.hide();
        }
        if (this.pickers != null) {
          this.pickers.forEach((picker) => {
            if (!picker.container.contains(e3.target)) {
              picker.close();
            }
          });
        }
      }, "listener");
      quill.emitter.listenDOM("click", document.body, listener);
    }
    addModule(name) {
      const module2 = super.addModule(name);
      if (name === "toolbar") {
        this.extendToolbar(module2);
      }
      return module2;
    }
    buildButtons(buttons, icons) {
      Array.from(buttons).forEach((button) => {
        const className = button.getAttribute("class") || "";
        className.split(/\s+/).forEach((name) => {
          if (!name.startsWith("ql-"))
            return;
          name = name.slice("ql-".length);
          if (icons[name] == null)
            return;
          if (name === "direction") {
            button.innerHTML = icons[name][""] + icons[name].rtl;
          } else if (typeof icons[name] === "string") {
            button.innerHTML = icons[name];
          } else {
            const value = button.value || "";
            if (value != null && icons[name][value]) {
              button.innerHTML = icons[name][value];
            }
          }
        });
      });
    }
    buildPickers(selects, icons) {
      this.pickers = Array.from(selects).map((select) => {
        if (select.classList.contains("ql-align")) {
          if (select.querySelector("option") == null) {
            fillSelect(select, ALIGNS);
          }
          if (typeof icons.align === "object") {
            return new icon_picker_default(select, icons.align);
          }
        }
        if (select.classList.contains("ql-background") || select.classList.contains("ql-color")) {
          const format = select.classList.contains("ql-background") ? "background" : "color";
          if (select.querySelector("option") == null) {
            fillSelect(select, COLORS, format === "background" ? "#ffffff" : "#000000");
          }
          return new color_picker_default(select, icons[format]);
        }
        if (select.querySelector("option") == null) {
          if (select.classList.contains("ql-font")) {
            fillSelect(select, FONTS);
          } else if (select.classList.contains("ql-header")) {
            fillSelect(select, HEADERS);
          } else if (select.classList.contains("ql-size")) {
            fillSelect(select, SIZES);
          }
        }
        return new picker_default(select);
      });
      const update = /* @__PURE__ */ __name(() => {
        this.pickers.forEach((picker) => {
          picker.update();
        });
      }, "update");
      this.quill.on(emitter_default.events.EDITOR_CHANGE, update);
    }
  };
  BaseTheme.DEFAULTS = merge_default({}, theme_default.DEFAULTS, {
    modules: {
      toolbar: {
        handlers: {
          formula() {
            this.quill.theme.tooltip.edit("formula");
          },
          image() {
            let fileInput = this.container.querySelector("input.ql-image[type=file]");
            if (fileInput == null) {
              fileInput = document.createElement("input");
              fileInput.setAttribute("type", "file");
              fileInput.setAttribute("accept", this.quill.uploader.options.mimetypes.join(", "));
              fileInput.classList.add("ql-image");
              fileInput.addEventListener("change", () => {
                const range = this.quill.getSelection(true);
                this.quill.uploader.upload(range, fileInput.files);
                fileInput.value = "";
              });
              this.container.appendChild(fileInput);
            }
            fileInput.click();
          },
          video() {
            this.quill.theme.tooltip.edit("video");
          }
        }
      }
    }
  });
  var BaseTooltip = class extends tooltip_default {
    static {
      __name(this, "BaseTooltip");
    }
    constructor(quill, boundsContainer) {
      super(quill, boundsContainer);
      this.textbox = this.root.querySelector('input[type="text"]');
      this.listen();
    }
    listen() {
      this.textbox.addEventListener("keydown", (event) => {
        if (event.key === "Enter") {
          this.save();
          event.preventDefault();
        } else if (event.key === "Escape") {
          this.cancel();
          event.preventDefault();
        }
      });
    }
    cancel() {
      this.hide();
      this.restoreFocus();
    }
    edit() {
      let mode = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "link";
      let preview = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
      this.root.classList.remove("ql-hidden");
      this.root.classList.add("ql-editing");
      if (this.textbox == null)
        return;
      if (preview != null) {
        this.textbox.value = preview;
      } else if (mode !== this.root.getAttribute("data-mode")) {
        this.textbox.value = "";
      }
      const bounds = this.quill.getBounds(this.quill.selection.savedRange);
      if (bounds != null) {
        this.position(bounds);
      }
      this.textbox.select();
      this.textbox.setAttribute("placeholder", this.textbox.getAttribute(`data-${mode}`) || "");
      this.root.setAttribute("data-mode", mode);
    }
    restoreFocus() {
      this.quill.focus({
        preventScroll: true
      });
    }
    save() {
      let {
        value
      } = this.textbox;
      switch (this.root.getAttribute("data-mode")) {
        case "link": {
          const {
            scrollTop
          } = this.quill.root;
          if (this.linkRange) {
            this.quill.formatText(this.linkRange, "link", value, emitter_default.sources.USER);
            delete this.linkRange;
          } else {
            this.restoreFocus();
            this.quill.format("link", value, emitter_default.sources.USER);
          }
          this.quill.root.scrollTop = scrollTop;
          break;
        }
        case "video": {
          value = extractVideoUrl(value);
        }
        case "formula": {
          if (!value)
            break;
          const range = this.quill.getSelection(true);
          if (range != null) {
            const index2 = range.index + range.length;
            this.quill.insertEmbed(
              index2,
              // @ts-expect-error Fix me later
              this.root.getAttribute("data-mode"),
              value,
              emitter_default.sources.USER
            );
            if (this.root.getAttribute("data-mode") === "formula") {
              this.quill.insertText(index2 + 1, " ", emitter_default.sources.USER);
            }
            this.quill.setSelection(index2 + 2, emitter_default.sources.USER);
          }
          break;
        }
        default:
      }
      this.textbox.value = "";
      this.hide();
    }
  };
  function extractVideoUrl(url) {
    let match2 = url.match(/^(?:(https?):\/\/)?(?:(?:www|m)\.)?youtube\.com\/watch.*v=([a-zA-Z0-9_-]+)/) || url.match(/^(?:(https?):\/\/)?(?:(?:www|m)\.)?youtu\.be\/([a-zA-Z0-9_-]+)/);
    if (match2) {
      return `${match2[1] || "https"}://www.youtube.com/embed/${match2[2]}?showinfo=0`;
    }
    if (match2 = url.match(/^(?:(https?):\/\/)?(?:www\.)?vimeo\.com\/(\d+)/)) {
      return `${match2[1] || "https"}://player.vimeo.com/video/${match2[2]}/`;
    }
    return url;
  }
  __name(extractVideoUrl, "extractVideoUrl");
  function fillSelect(select, values) {
    let defaultValue = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    values.forEach((value) => {
      const option2 = document.createElement("option");
      if (value === defaultValue) {
        option2.setAttribute("selected", "selected");
      } else {
        option2.setAttribute("value", String(value));
      }
      select.appendChild(option2);
    });
  }
  __name(fillSelect, "fillSelect");

  // node_modules/quill/themes/bubble.js
  var TOOLBAR_CONFIG = [["bold", "italic", "link"], [{
    header: 1
  }, {
    header: 2
  }, "blockquote"]];
  var BubbleTooltip = class extends BaseTooltip {
    static {
      __name(this, "BubbleTooltip");
    }
    static TEMPLATE = ['<span class="ql-tooltip-arrow"></span>', '<div class="ql-tooltip-editor">', '<input type="text" data-formula="e=mc^2" data-link="https://quilljs.com" data-video="Embed URL">', '<a class="ql-close"></a>', "</div>"].join("");
    constructor(quill, bounds) {
      super(quill, bounds);
      this.quill.on(emitter_default.events.EDITOR_CHANGE, (type, range, oldRange, source) => {
        if (type !== emitter_default.events.SELECTION_CHANGE)
          return;
        if (range != null && range.length > 0 && source === emitter_default.sources.USER) {
          this.show();
          this.root.style.left = "0px";
          this.root.style.width = "";
          this.root.style.width = `${this.root.offsetWidth}px`;
          const lines = this.quill.getLines(range.index, range.length);
          if (lines.length === 1) {
            const bounds2 = this.quill.getBounds(range);
            if (bounds2 != null) {
              this.position(bounds2);
            }
          } else {
            const lastLine = lines[lines.length - 1];
            const index2 = this.quill.getIndex(lastLine);
            const length = Math.min(lastLine.length() - 1, range.index + range.length - index2);
            const indexBounds = this.quill.getBounds(new Range(index2, length));
            if (indexBounds != null) {
              this.position(indexBounds);
            }
          }
        } else if (document.activeElement !== this.textbox && this.quill.hasFocus()) {
          this.hide();
        }
      });
    }
    listen() {
      super.listen();
      this.root.querySelector(".ql-close").addEventListener("click", () => {
        this.root.classList.remove("ql-editing");
      });
      this.quill.on(emitter_default.events.SCROLL_OPTIMIZE, () => {
        setTimeout(() => {
          if (this.root.classList.contains("ql-hidden"))
            return;
          const range = this.quill.getSelection();
          if (range != null) {
            const bounds = this.quill.getBounds(range);
            if (bounds != null) {
              this.position(bounds);
            }
          }
        }, 1);
      });
    }
    cancel() {
      this.show();
    }
    position(reference) {
      const shift = super.position(reference);
      const arrow = this.root.querySelector(".ql-tooltip-arrow");
      arrow.style.marginLeft = "";
      if (shift !== 0) {
        arrow.style.marginLeft = `${-1 * shift - arrow.offsetWidth / 2}px`;
      }
      return shift;
    }
  };
  var BubbleTheme = class extends BaseTheme {
    static {
      __name(this, "BubbleTheme");
    }
    constructor(quill, options) {
      if (options.modules.toolbar != null && options.modules.toolbar.container == null) {
        options.modules.toolbar.container = TOOLBAR_CONFIG;
      }
      super(quill, options);
      this.quill.container.classList.add("ql-bubble");
    }
    extendToolbar(toolbar) {
      this.tooltip = new BubbleTooltip(this.quill, this.options.bounds);
      if (toolbar.container != null) {
        this.tooltip.root.appendChild(toolbar.container);
        this.buildButtons(toolbar.container.querySelectorAll("button"), icons_default);
        this.buildPickers(toolbar.container.querySelectorAll("select"), icons_default);
      }
    }
  };
  BubbleTheme.DEFAULTS = merge_default({}, BaseTheme.DEFAULTS, {
    modules: {
      toolbar: {
        handlers: {
          link(value) {
            if (!value) {
              this.quill.format("link", false);
            } else {
              this.quill.theme.tooltip.edit();
            }
          }
        }
      }
    }
  });

  // node_modules/quill/themes/snow.js
  var TOOLBAR_CONFIG2 = [[{
    header: ["1", "2", "3", false]
  }], ["bold", "italic", "underline", "link"], [{
    list: "ordered"
  }, {
    list: "bullet"
  }], ["clean"]];
  var SnowTooltip = class extends BaseTooltip {
    static {
      __name(this, "SnowTooltip");
    }
    static TEMPLATE = ['<a class="ql-preview" rel="noopener noreferrer" target="_blank" href="about:blank"></a>', '<input type="text" data-formula="e=mc^2" data-link="https://quilljs.com" data-video="Embed URL">', '<a class="ql-action"></a>', '<a class="ql-remove"></a>'].join("");
    preview = this.root.querySelector("a.ql-preview");
    listen() {
      super.listen();
      this.root.querySelector("a.ql-action").addEventListener("click", (event) => {
        if (this.root.classList.contains("ql-editing")) {
          this.save();
        } else {
          this.edit("link", this.preview.textContent);
        }
        event.preventDefault();
      });
      this.root.querySelector("a.ql-remove").addEventListener("click", (event) => {
        if (this.linkRange != null) {
          const range = this.linkRange;
          this.restoreFocus();
          this.quill.formatText(range, "link", false, emitter_default.sources.USER);
          delete this.linkRange;
        }
        event.preventDefault();
        this.hide();
      });
      this.quill.on(emitter_default.events.SELECTION_CHANGE, (range, oldRange, source) => {
        if (range == null)
          return;
        if (range.length === 0 && source === emitter_default.sources.USER) {
          const [link, offset] = this.quill.scroll.descendant(Link, range.index);
          if (link != null) {
            this.linkRange = new Range(range.index - offset, link.length());
            const preview = Link.formats(link.domNode);
            this.preview.textContent = preview;
            this.preview.setAttribute("href", preview);
            this.show();
            const bounds = this.quill.getBounds(this.linkRange);
            if (bounds != null) {
              this.position(bounds);
            }
            return;
          }
        } else {
          delete this.linkRange;
        }
        this.hide();
      });
    }
    show() {
      super.show();
      this.root.removeAttribute("data-mode");
    }
  };
  var SnowTheme = class extends BaseTheme {
    static {
      __name(this, "SnowTheme");
    }
    constructor(quill, options) {
      if (options.modules.toolbar != null && options.modules.toolbar.container == null) {
        options.modules.toolbar.container = TOOLBAR_CONFIG2;
      }
      super(quill, options);
      this.quill.container.classList.add("ql-snow");
    }
    extendToolbar(toolbar) {
      if (toolbar.container != null) {
        toolbar.container.classList.add("ql-snow");
        this.buildButtons(toolbar.container.querySelectorAll("button"), icons_default);
        this.buildPickers(toolbar.container.querySelectorAll("select"), icons_default);
        this.tooltip = new SnowTooltip(this.quill, this.options.bounds);
        if (toolbar.container.querySelector(".ql-link")) {
          this.quill.keyboard.addBinding({
            key: "k",
            shortKey: true
          }, (_range, context) => {
            toolbar.handlers.link.call(toolbar, !context.format.link);
          });
        }
      }
    }
  };
  SnowTheme.DEFAULTS = merge_default({}, BaseTheme.DEFAULTS, {
    modules: {
      toolbar: {
        handlers: {
          link(value) {
            if (value) {
              const range = this.quill.getSelection();
              if (range == null || range.length === 0)
                return;
              let preview = this.quill.getText(range);
              if (/^\S+@\S+\.\S+$/.test(preview) && preview.indexOf("mailto:") !== 0) {
                preview = `mailto:${preview}`;
              }
              const {
                tooltip
              } = this.quill.theme;
              tooltip.edit("link", preview);
            } else {
              this.quill.format("link", false);
            }
          }
        }
      }
    }
  });
  var snow_default = SnowTheme;

  // node_modules/quill/quill.js
  core_default.register({
    "attributors/attribute/direction": DirectionAttribute,
    "attributors/class/align": AlignClass,
    "attributors/class/background": BackgroundClass,
    "attributors/class/color": ColorClass,
    "attributors/class/direction": DirectionClass,
    "attributors/class/font": FontClass,
    "attributors/class/size": SizeClass,
    "attributors/style/align": AlignStyle,
    "attributors/style/background": BackgroundStyle,
    "attributors/style/color": ColorStyle,
    "attributors/style/direction": DirectionStyle,
    "attributors/style/font": FontStyle,
    "attributors/style/size": SizeStyle
  }, true);
  core_default.register({
    "formats/align": AlignClass,
    "formats/direction": DirectionClass,
    "formats/indent": indent_default,
    "formats/background": BackgroundStyle,
    "formats/color": ColorStyle,
    "formats/font": FontClass,
    "formats/size": SizeClass,
    "formats/blockquote": blockquote_default,
    "formats/code-block": CodeBlock,
    "formats/header": header_default,
    "formats/list": ListItem,
    "formats/bold": bold_default,
    "formats/code": Code,
    "formats/italic": italic_default,
    "formats/link": Link,
    "formats/script": script_default,
    "formats/strike": strike_default,
    "formats/underline": underline_default,
    "formats/formula": formula_default,
    "formats/image": image_default,
    "formats/video": video_default,
    "modules/syntax": Syntax,
    "modules/table": table_default,
    "modules/toolbar": Toolbar,
    "themes/bubble": BubbleTheme,
    "themes/snow": snow_default,
    "ui/icons": icons_default,
    "ui/picker": picker_default,
    "ui/icon-picker": icon_picker_default,
    "ui/color-picker": color_picker_default,
    "ui/tooltip": tooltip_default
  }, true);
  var quill_default = core_default;

  // app/javascript/controllers/rich_text_editor_controller.js
  var import_quill_html_edit_button = __toESM(require_quill_htmlEditButton_min());

  // app/javascript/quill.image.js
  var InlineBlot2 = quill_default.import("blots/block");
  var LoadingImage = class extends InlineBlot2 {
    static {
      __name(this, "LoadingImage");
    }
    static create(src) {
      const node = super.create(src);
      if (src === true)
        return node;
      const image = document.createElement("img");
      image.setAttribute("src", src);
      node.appendChild(image);
      return node;
    }
    deleteAt(index2, length) {
      super.deleteAt(index2, length);
      this.cache = {};
    }
    static value(domNode) {
      const { src, custom } = domNode.dataset;
      return { src, custom };
    }
  };
  LoadingImage.blotName = "imageBlot";
  LoadingImage.className = "image-uploading";
  LoadingImage.tagName = "span";
  quill_default.register({ "formats/imageBlot": LoadingImage });
  var quill_image_default = LoadingImage;

  // app/javascript/quill.imageuploader.js
  var ImageUploader = class {
    static {
      __name(this, "ImageUploader");
    }
    constructor(quill, options) {
      this.quill = quill;
      this.options = options;
      this.range = null;
      this.placeholderDelta = null;
      if (typeof this.options.upload !== "function")
        console.warn(
          "[Missing config] upload function that returns a promise is required"
        );
      var toolbar = this.quill.getModule("toolbar");
      if (toolbar) {
        toolbar.addHandler("image", this.selectLocalImage.bind(this));
      }
      this.handleDrop = this.handleDrop.bind(this);
      this.handlePaste = this.handlePaste.bind(this);
      this.quill.root.addEventListener("drop", this.handleDrop, false);
      this.quill.root.addEventListener("paste", this.handlePaste, false);
    }
    selectLocalImage() {
      this.quill.focus();
      this.range = this.quill.getSelection();
      this.fileHolder = document.createElement("input");
      this.fileHolder.setAttribute("type", "file");
      this.fileHolder.setAttribute("accept", "image/*");
      this.fileHolder.setAttribute("style", "visibility:hidden");
      this.fileHolder.onchange = this.fileChanged.bind(this);
      document.body.appendChild(this.fileHolder);
      this.fileHolder.click();
      window.requestAnimationFrame(() => {
        document.body.removeChild(this.fileHolder);
      });
    }
    handleDrop(evt) {
      if (evt.dataTransfer && evt.dataTransfer.files && evt.dataTransfer.files.length) {
        evt.stopPropagation();
        evt.preventDefault();
        if (document.caretRangeFromPoint) {
          const selection = document.getSelection();
          const range = document.caretRangeFromPoint(evt.clientX, evt.clientY);
          if (selection && range) {
            selection.setBaseAndExtent(
              range.startContainer,
              range.startOffset,
              range.startContainer,
              range.startOffset
            );
          }
        } else {
          const selection = document.getSelection();
          const range = document.caretPositionFromPoint(evt.clientX, evt.clientY);
          if (selection && range) {
            selection.setBaseAndExtent(
              range.offsetNode,
              range.offset,
              range.offsetNode,
              range.offset
            );
          }
        }
        this.quill.focus();
        this.range = this.quill.getSelection();
        let file = evt.dataTransfer.files[0];
        setTimeout(() => {
          this.quill.focus();
          this.range = this.quill.getSelection();
          this.readAndUploadFile(file);
        }, 0);
      }
    }
    handlePaste(evt) {
      let clipboard = evt.clipboardData || window.clipboardData;
      if (clipboard && (clipboard.items || clipboard.files)) {
        let items = clipboard.items || clipboard.files;
        const IMAGE_MIME_REGEX = /^image\/(jpe?g|gif|png|svg|webp)$/i;
        for (let i3 = 0; i3 < items.length; i3++) {
          if (IMAGE_MIME_REGEX.test(items[i3].type)) {
            let file = items[i3].getAsFile ? items[i3].getAsFile() : items[i3];
            if (file) {
              this.quill.focus();
              this.range = this.quill.getSelection();
              evt.preventDefault();
              setTimeout(() => {
                this.quill.focus();
                this.range = this.quill.getSelection();
                this.readAndUploadFile(file);
              }, 0);
            }
          }
        }
      }
    }
    readAndUploadFile(file) {
      let isUploadReject = false;
      const fileReader = new FileReader();
      fileReader.addEventListener(
        "load",
        () => {
          if (!isUploadReject) {
            let base64ImageSrc = fileReader.result;
            this.insertBase64Image(base64ImageSrc);
          }
        },
        false
      );
      if (file) {
        fileReader.readAsDataURL(file);
      }
      this.options.upload(file).then(
        (imageUrl) => {
          this.insertToEditor(imageUrl);
        },
        (error) => {
          isUploadReject = true;
          this.removeBase64Image();
          console.warn(error);
        }
      );
    }
    fileChanged() {
      const file = this.fileHolder.files[0];
      this.readAndUploadFile(file);
    }
    insertBase64Image(url) {
      const range = this.range;
      this.placeholderDelta = this.quill.insertEmbed(
        range.index,
        quill_image_default.blotName,
        `${url}`,
        "user"
      );
    }
    insertToEditor(url) {
      const range = this.range;
      const lengthToDelete = this.calculatePlaceholderInsertLength();
      this.quill.deleteText(range.index, lengthToDelete, "user");
      this.quill.insertEmbed(range.index, "image", `${url}`, "user");
      range.index++;
      this.quill.setSelection(range, "user");
    }
    // The length of the insert delta from insertBase64Image can vary depending on what part of the line the insert occurs
    calculatePlaceholderInsertLength() {
      return this.placeholderDelta.ops.reduce((accumulator, deltaOperation) => {
        if (deltaOperation.hasOwnProperty("insert"))
          accumulator++;
        return accumulator;
      }, 0);
    }
    removeBase64Image() {
      const range = this.range;
      const lengthToDelete = this.calculatePlaceholderInsertLength();
      this.quill.deleteText(range.index, lengthToDelete, "user");
    }
  };
  window.ImageUploader = ImageUploader;
  var quill_imageuploader_default = ImageUploader;

  // node_modules/@smithy/protocol-http/dist-es/extensions/httpExtensionConfiguration.js
  var getHttpHandlerExtensionConfiguration = /* @__PURE__ */ __name((runtimeConfig) => {
    let httpHandler = runtimeConfig.httpHandler;
    return {
      setHttpHandler(handler) {
        httpHandler = handler;
      },
      httpHandler() {
        return httpHandler;
      },
      updateHttpClientConfig(key, value) {
        httpHandler.updateHttpClientConfig(key, value);
      },
      httpHandlerConfigs() {
        return httpHandler.httpHandlerConfigs();
      }
    };
  }, "getHttpHandlerExtensionConfiguration");
  var resolveHttpHandlerRuntimeConfig = /* @__PURE__ */ __name((httpHandlerExtensionConfiguration) => {
    return {
      httpHandler: httpHandlerExtensionConfiguration.httpHandler()
    };
  }, "resolveHttpHandlerRuntimeConfig");

  // node_modules/@smithy/types/dist-es/auth/auth.js
  var HttpAuthLocation;
  (function(HttpAuthLocation2) {
    HttpAuthLocation2["HEADER"] = "header";
    HttpAuthLocation2["QUERY"] = "query";
  })(HttpAuthLocation || (HttpAuthLocation = {}));

  // node_modules/@smithy/types/dist-es/auth/HttpApiKeyAuth.js
  var HttpApiKeyAuthLocation;
  (function(HttpApiKeyAuthLocation2) {
    HttpApiKeyAuthLocation2["HEADER"] = "header";
    HttpApiKeyAuthLocation2["QUERY"] = "query";
  })(HttpApiKeyAuthLocation || (HttpApiKeyAuthLocation = {}));

  // node_modules/@smithy/types/dist-es/endpoint.js
  var EndpointURLScheme;
  (function(EndpointURLScheme2) {
    EndpointURLScheme2["HTTP"] = "http";
    EndpointURLScheme2["HTTPS"] = "https";
  })(EndpointURLScheme || (EndpointURLScheme = {}));

  // node_modules/@smithy/types/dist-es/extensions/checksum.js
  var AlgorithmId;
  (function(AlgorithmId2) {
    AlgorithmId2["MD5"] = "md5";
    AlgorithmId2["CRC32"] = "crc32";
    AlgorithmId2["CRC32C"] = "crc32c";
    AlgorithmId2["SHA1"] = "sha1";
    AlgorithmId2["SHA256"] = "sha256";
  })(AlgorithmId || (AlgorithmId = {}));

  // node_modules/@smithy/types/dist-es/http.js
  var FieldPosition;
  (function(FieldPosition2) {
    FieldPosition2[FieldPosition2["HEADER"] = 0] = "HEADER";
    FieldPosition2[FieldPosition2["TRAILER"] = 1] = "TRAILER";
  })(FieldPosition || (FieldPosition = {}));

  // node_modules/@smithy/types/dist-es/middleware.js
  var SMITHY_CONTEXT_KEY = "__smithy_context";

  // node_modules/@smithy/types/dist-es/profile.js
  var IniSectionType;
  (function(IniSectionType2) {
    IniSectionType2["PROFILE"] = "profile";
    IniSectionType2["SSO_SESSION"] = "sso-session";
    IniSectionType2["SERVICES"] = "services";
  })(IniSectionType || (IniSectionType = {}));

  // node_modules/@smithy/types/dist-es/transfer.js
  var RequestHandlerProtocol;
  (function(RequestHandlerProtocol2) {
    RequestHandlerProtocol2["HTTP_0_9"] = "http/0.9";
    RequestHandlerProtocol2["HTTP_1_0"] = "http/1.0";
    RequestHandlerProtocol2["TDS_8_0"] = "tds/8.0";
  })(RequestHandlerProtocol || (RequestHandlerProtocol = {}));

  // node_modules/@smithy/protocol-http/dist-es/httpRequest.js
  var HttpRequest = class _HttpRequest {
    static {
      __name(this, "HttpRequest");
    }
    constructor(options) {
      this.method = options.method || "GET";
      this.hostname = options.hostname || "localhost";
      this.port = options.port;
      this.query = options.query || {};
      this.headers = options.headers || {};
      this.body = options.body;
      this.protocol = options.protocol ? options.protocol.slice(-1) !== ":" ? `${options.protocol}:` : options.protocol : "https:";
      this.path = options.path ? options.path.charAt(0) !== "/" ? `/${options.path}` : options.path : "/";
      this.username = options.username;
      this.password = options.password;
      this.fragment = options.fragment;
    }
    static clone(request) {
      const cloned = new _HttpRequest({
        ...request,
        headers: { ...request.headers }
      });
      if (cloned.query) {
        cloned.query = cloneQuery(cloned.query);
      }
      return cloned;
    }
    static isInstance(request) {
      if (!request) {
        return false;
      }
      const req = request;
      return "method" in req && "protocol" in req && "hostname" in req && "path" in req && typeof req["query"] === "object" && typeof req["headers"] === "object";
    }
    clone() {
      return _HttpRequest.clone(this);
    }
  };
  function cloneQuery(query) {
    return Object.keys(query).reduce((carry, paramName) => {
      const param = query[paramName];
      return {
        ...carry,
        [paramName]: Array.isArray(param) ? [...param] : param
      };
    }, {});
  }
  __name(cloneQuery, "cloneQuery");

  // node_modules/@smithy/protocol-http/dist-es/httpResponse.js
  var HttpResponse = class {
    static {
      __name(this, "HttpResponse");
    }
    constructor(options) {
      this.statusCode = options.statusCode;
      this.reason = options.reason;
      this.headers = options.headers || {};
      this.body = options.body;
    }
    static isInstance(response) {
      if (!response)
        return false;
      const resp = response;
      return typeof resp.statusCode === "number" && typeof resp.headers === "object";
    }
  };

  // node_modules/@aws-sdk/middleware-expect-continue/dist-es/index.js
  function addExpectContinueMiddleware(options) {
    return (next) => async (args) => {
      const { request } = args;
      if (HttpRequest.isInstance(request) && request.body && options.runtime === "node") {
        if (options.requestHandler?.constructor?.name !== "FetchHttpHandler") {
          request.headers = {
            ...request.headers,
            Expect: "100-continue"
          };
        }
      }
      return next({
        ...args,
        request
      });
    };
  }
  __name(addExpectContinueMiddleware, "addExpectContinueMiddleware");
  var addExpectContinueMiddlewareOptions = {
    step: "build",
    tags: ["SET_EXPECT_HEADER", "EXPECT_HEADER"],
    name: "addExpectContinueMiddleware",
    override: true
  };
  var getAddExpectContinuePlugin = /* @__PURE__ */ __name((options) => ({
    applyToStack: (clientStack) => {
      clientStack.add(addExpectContinueMiddleware(options), addExpectContinueMiddlewareOptions);
    }
  }), "getAddExpectContinuePlugin");

  // node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/constants.js
  var RequestChecksumCalculation = {
    WHEN_SUPPORTED: "WHEN_SUPPORTED",
    WHEN_REQUIRED: "WHEN_REQUIRED"
  };
  var DEFAULT_REQUEST_CHECKSUM_CALCULATION = RequestChecksumCalculation.WHEN_SUPPORTED;
  var ResponseChecksumValidation = {
    WHEN_SUPPORTED: "WHEN_SUPPORTED",
    WHEN_REQUIRED: "WHEN_REQUIRED"
  };
  var DEFAULT_RESPONSE_CHECKSUM_VALIDATION = RequestChecksumCalculation.WHEN_SUPPORTED;
  var ChecksumAlgorithm;
  (function(ChecksumAlgorithm2) {
    ChecksumAlgorithm2["MD5"] = "MD5";
    ChecksumAlgorithm2["CRC32"] = "CRC32";
    ChecksumAlgorithm2["CRC32C"] = "CRC32C";
    ChecksumAlgorithm2["CRC64NVME"] = "CRC64NVME";
    ChecksumAlgorithm2["SHA1"] = "SHA1";
    ChecksumAlgorithm2["SHA256"] = "SHA256";
  })(ChecksumAlgorithm || (ChecksumAlgorithm = {}));
  var ChecksumLocation;
  (function(ChecksumLocation2) {
    ChecksumLocation2["HEADER"] = "header";
    ChecksumLocation2["TRAILER"] = "trailer";
  })(ChecksumLocation || (ChecksumLocation = {}));
  var DEFAULT_CHECKSUM_ALGORITHM = ChecksumAlgorithm.CRC32;

  // node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/stringUnionSelector.js
  var SelectorType;
  (function(SelectorType3) {
    SelectorType3["ENV"] = "env";
    SelectorType3["CONFIG"] = "shared config entry";
  })(SelectorType || (SelectorType = {}));

  // node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/crc64-nvme-crt-container.js
  var crc64NvmeCrtContainer = {
    CrtCrc64Nvme: null
  };

  // node_modules/@aws-sdk/core/dist-es/submodules/client/setCredentialFeature.js
  function setCredentialFeature(credentials, feature, value) {
    if (!credentials.$source) {
      credentials.$source = {};
    }
    credentials.$source[feature] = value;
    return credentials;
  }
  __name(setCredentialFeature, "setCredentialFeature");

  // node_modules/@aws-sdk/core/dist-es/submodules/client/setFeature.js
  function setFeature(context, feature, value) {
    if (!context.__aws_sdk_context) {
      context.__aws_sdk_context = {
        features: {}
      };
    } else if (!context.__aws_sdk_context.features) {
      context.__aws_sdk_context.features = {};
    }
    context.__aws_sdk_context.features[feature] = value;
  }
  __name(setFeature, "setFeature");

  // node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/utils/getDateHeader.js
  var getDateHeader = /* @__PURE__ */ __name((response) => HttpResponse.isInstance(response) ? response.headers?.date ?? response.headers?.Date : void 0, "getDateHeader");

  // node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/utils/getSkewCorrectedDate.js
  var getSkewCorrectedDate = /* @__PURE__ */ __name((systemClockOffset) => new Date(Date.now() + systemClockOffset), "getSkewCorrectedDate");

  // node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/utils/isClockSkewed.js
  var isClockSkewed = /* @__PURE__ */ __name((clockTime, systemClockOffset) => Math.abs(getSkewCorrectedDate(systemClockOffset).getTime() - clockTime) >= 3e5, "isClockSkewed");

  // node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/utils/getUpdatedSystemClockOffset.js
  var getUpdatedSystemClockOffset = /* @__PURE__ */ __name((clockTime, currentSystemClockOffset) => {
    const clockTimeInMs = Date.parse(clockTime);
    if (isClockSkewed(clockTimeInMs, currentSystemClockOffset)) {
      return clockTimeInMs - Date.now();
    }
    return currentSystemClockOffset;
  }, "getUpdatedSystemClockOffset");

  // node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/aws_sdk/AwsSdkSigV4Signer.js
  var throwSigningPropertyError = /* @__PURE__ */ __name((name, property) => {
    if (!property) {
      throw new Error(`Property \`${name}\` is not resolved for AWS SDK SigV4Auth`);
    }
    return property;
  }, "throwSigningPropertyError");
  var validateSigningProperties = /* @__PURE__ */ __name(async (signingProperties) => {
    const context = throwSigningPropertyError("context", signingProperties.context);
    const config4 = throwSigningPropertyError("config", signingProperties.config);
    const authScheme = context.endpointV2?.properties?.authSchemes?.[0];
    const signerFunction = throwSigningPropertyError("signer", config4.signer);
    const signer = await signerFunction(authScheme);
    const signingRegion = signingProperties?.signingRegion;
    const signingRegionSet = signingProperties?.signingRegionSet;
    const signingName = signingProperties?.signingName;
    return {
      config: config4,
      signer,
      signingRegion,
      signingRegionSet,
      signingName
    };
  }, "validateSigningProperties");
  var AwsSdkSigV4Signer = class {
    static {
      __name(this, "AwsSdkSigV4Signer");
    }
    async sign(httpRequest, identity2, signingProperties) {
      if (!HttpRequest.isInstance(httpRequest)) {
        throw new Error("The request is not an instance of `HttpRequest` and cannot be signed");
      }
      const validatedProps = await validateSigningProperties(signingProperties);
      const { config: config4, signer } = validatedProps;
      let { signingRegion, signingName } = validatedProps;
      const handlerExecutionContext = signingProperties.context;
      if (handlerExecutionContext?.authSchemes?.length ?? 0 > 1) {
        const [first, second] = handlerExecutionContext.authSchemes;
        if (first?.name === "sigv4a" && second?.name === "sigv4") {
          signingRegion = second?.signingRegion ?? signingRegion;
          signingName = second?.signingName ?? signingName;
        }
      }
      const signedRequest = await signer.sign(httpRequest, {
        signingDate: getSkewCorrectedDate(config4.systemClockOffset),
        signingRegion,
        signingService: signingName
      });
      return signedRequest;
    }
    errorHandler(signingProperties) {
      return (error) => {
        const serverTime = error.ServerTime ?? getDateHeader(error.$response);
        if (serverTime) {
          const config4 = throwSigningPropertyError("config", signingProperties.config);
          const initialSystemClockOffset = config4.systemClockOffset;
          config4.systemClockOffset = getUpdatedSystemClockOffset(serverTime, config4.systemClockOffset);
          const clockSkewCorrected = config4.systemClockOffset !== initialSystemClockOffset;
          if (clockSkewCorrected && error.$metadata) {
            error.$metadata.clockSkewCorrected = true;
          }
        }
        throw error;
      };
    }
    successHandler(httpResponse, signingProperties) {
      const dateHeader = getDateHeader(httpResponse);
      if (dateHeader) {
        const config4 = throwSigningPropertyError("config", signingProperties.config);
        config4.systemClockOffset = getUpdatedSystemClockOffset(dateHeader, config4.systemClockOffset);
      }
    }
  };

  // node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/aws_sdk/AwsSdkSigV4ASigner.js
  var AwsSdkSigV4ASigner = class extends AwsSdkSigV4Signer {
    static {
      __name(this, "AwsSdkSigV4ASigner");
    }
    async sign(httpRequest, identity2, signingProperties) {
      if (!HttpRequest.isInstance(httpRequest)) {
        throw new Error("The request is not an instance of `HttpRequest` and cannot be signed");
      }
      const { config: config4, signer, signingRegion, signingRegionSet, signingName } = await validateSigningProperties(signingProperties);
      const configResolvedSigningRegionSet = await config4.sigv4aSigningRegionSet?.();
      const multiRegionOverride = (configResolvedSigningRegionSet ?? signingRegionSet ?? [signingRegion]).join(",");
      const signedRequest = await signer.sign(httpRequest, {
        signingDate: getSkewCorrectedDate(config4.systemClockOffset),
        signingRegion: multiRegionOverride,
        signingService: signingName
      });
      return signedRequest;
    }
  };

  // node_modules/@smithy/util-middleware/dist-es/getSmithyContext.js
  var getSmithyContext = /* @__PURE__ */ __name((context) => context[SMITHY_CONTEXT_KEY] || (context[SMITHY_CONTEXT_KEY] = {}), "getSmithyContext");

  // node_modules/@smithy/util-middleware/dist-es/normalizeProvider.js
  var normalizeProvider = /* @__PURE__ */ __name((input) => {
    if (typeof input === "function")
      return input;
    const promisified = Promise.resolve(input);
    return () => promisified;
  }, "normalizeProvider");

  // node_modules/@smithy/core/dist-es/middleware-http-auth-scheme/httpAuthSchemeMiddleware.js
  function convertHttpAuthSchemesToMap(httpAuthSchemes) {
    const map2 = /* @__PURE__ */ new Map();
    for (const scheme of httpAuthSchemes) {
      map2.set(scheme.schemeId, scheme);
    }
    return map2;
  }
  __name(convertHttpAuthSchemesToMap, "convertHttpAuthSchemesToMap");
  var httpAuthSchemeMiddleware = /* @__PURE__ */ __name((config4, mwOptions) => (next, context) => async (args) => {
    const options = config4.httpAuthSchemeProvider(await mwOptions.httpAuthSchemeParametersProvider(config4, context, args.input));
    const authSchemes = convertHttpAuthSchemesToMap(config4.httpAuthSchemes);
    const smithyContext = getSmithyContext(context);
    const failureReasons = [];
    for (const option2 of options) {
      const scheme = authSchemes.get(option2.schemeId);
      if (!scheme) {
        failureReasons.push(`HttpAuthScheme \`${option2.schemeId}\` was not enabled for this service.`);
        continue;
      }
      const identityProvider = scheme.identityProvider(await mwOptions.identityProviderConfigProvider(config4));
      if (!identityProvider) {
        failureReasons.push(`HttpAuthScheme \`${option2.schemeId}\` did not have an IdentityProvider configured.`);
        continue;
      }
      const { identityProperties = {}, signingProperties = {} } = option2.propertiesExtractor?.(config4, context) || {};
      option2.identityProperties = Object.assign(option2.identityProperties || {}, identityProperties);
      option2.signingProperties = Object.assign(option2.signingProperties || {}, signingProperties);
      smithyContext.selectedHttpAuthScheme = {
        httpAuthOption: option2,
        identity: await identityProvider(option2.identityProperties),
        signer: scheme.signer
      };
      break;
    }
    if (!smithyContext.selectedHttpAuthScheme) {
      throw new Error(failureReasons.join("\n"));
    }
    return next(args);
  }, "httpAuthSchemeMiddleware");

  // node_modules/@smithy/core/dist-es/middleware-http-auth-scheme/getHttpAuthSchemeEndpointRuleSetPlugin.js
  var httpAuthSchemeEndpointRuleSetMiddlewareOptions = {
    step: "serialize",
    tags: ["HTTP_AUTH_SCHEME"],
    name: "httpAuthSchemeMiddleware",
    override: true,
    relation: "before",
    toMiddleware: "endpointV2Middleware"
  };
  var getHttpAuthSchemeEndpointRuleSetPlugin = /* @__PURE__ */ __name((config4, { httpAuthSchemeParametersProvider, identityProviderConfigProvider }) => ({
    applyToStack: (clientStack) => {
      clientStack.addRelativeTo(httpAuthSchemeMiddleware(config4, {
        httpAuthSchemeParametersProvider,
        identityProviderConfigProvider
      }), httpAuthSchemeEndpointRuleSetMiddlewareOptions);
    }
  }), "getHttpAuthSchemeEndpointRuleSetPlugin");

  // node_modules/@smithy/middleware-serde/dist-es/deserializerMiddleware.js
  var deserializerMiddleware = /* @__PURE__ */ __name((options, deserializer) => (next, context) => async (args) => {
    const { response } = await next(args);
    try {
      const parsed = await deserializer(response, options);
      return {
        response,
        output: parsed
      };
    } catch (error) {
      Object.defineProperty(error, "$response", {
        value: response
      });
      if (!("$metadata" in error)) {
        const hint = `Deserialization error: to see the raw response, inspect the hidden field {error}.$response on this object.`;
        try {
          error.message += "\n  " + hint;
        } catch (e3) {
          if (!context.logger || context.logger?.constructor?.name === "NoOpLogger") {
            console.warn(hint);
          } else {
            context.logger?.warn?.(hint);
          }
        }
        if (typeof error.$responseBodyText !== "undefined") {
          if (error.$response) {
            error.$response.body = error.$responseBodyText;
          }
        }
      }
      throw error;
    }
  }, "deserializerMiddleware");

  // node_modules/@smithy/middleware-serde/dist-es/serializerMiddleware.js
  var serializerMiddleware = /* @__PURE__ */ __name((options, serializer) => (next, context) => async (args) => {
    const endpoint = context.endpointV2?.url && options.urlParser ? async () => options.urlParser(context.endpointV2.url) : options.endpoint;
    if (!endpoint) {
      throw new Error("No valid endpoint provider available.");
    }
    const request = await serializer(args.input, { ...options, endpoint });
    return next({
      ...args,
      request
    });
  }, "serializerMiddleware");

  // node_modules/@smithy/middleware-serde/dist-es/serdePlugin.js
  var deserializerMiddlewareOption = {
    name: "deserializerMiddleware",
    step: "deserialize",
    tags: ["DESERIALIZER"],
    override: true
  };
  var serializerMiddlewareOption = {
    name: "serializerMiddleware",
    step: "serialize",
    tags: ["SERIALIZER"],
    override: true
  };
  function getSerdePlugin(config4, serializer, deserializer) {
    return {
      applyToStack: (commandStack) => {
        commandStack.add(deserializerMiddleware(config4, deserializer), deserializerMiddlewareOption);
        commandStack.add(serializerMiddleware(config4, serializer), serializerMiddlewareOption);
      }
    };
  }
  __name(getSerdePlugin, "getSerdePlugin");

  // node_modules/@smithy/core/dist-es/middleware-http-auth-scheme/getHttpAuthSchemePlugin.js
  var httpAuthSchemeMiddlewareOptions = {
    step: "serialize",
    tags: ["HTTP_AUTH_SCHEME"],
    name: "httpAuthSchemeMiddleware",
    override: true,
    relation: "before",
    toMiddleware: serializerMiddlewareOption.name
  };

  // node_modules/@smithy/core/dist-es/middleware-http-signing/httpSigningMiddleware.js
  var defaultErrorHandler = /* @__PURE__ */ __name((signingProperties) => (error) => {
    throw error;
  }, "defaultErrorHandler");
  var defaultSuccessHandler = /* @__PURE__ */ __name((httpResponse, signingProperties) => {
  }, "defaultSuccessHandler");
  var httpSigningMiddleware = /* @__PURE__ */ __name((config4) => (next, context) => async (args) => {
    if (!HttpRequest.isInstance(args.request)) {
      return next(args);
    }
    const smithyContext = getSmithyContext(context);
    const scheme = smithyContext.selectedHttpAuthScheme;
    if (!scheme) {
      throw new Error(`No HttpAuthScheme was selected: unable to sign request`);
    }
    const { httpAuthOption: { signingProperties = {} }, identity: identity2, signer } = scheme;
    const output = await next({
      ...args,
      request: await signer.sign(args.request, identity2, signingProperties)
    }).catch((signer.errorHandler || defaultErrorHandler)(signingProperties));
    (signer.successHandler || defaultSuccessHandler)(output.response, signingProperties);
    return output;
  }, "httpSigningMiddleware");

  // node_modules/@smithy/core/dist-es/middleware-http-signing/getHttpSigningMiddleware.js
  var httpSigningMiddlewareOptions = {
    step: "finalizeRequest",
    tags: ["HTTP_SIGNING"],
    name: "httpSigningMiddleware",
    aliases: ["apiKeyMiddleware", "tokenMiddleware", "awsAuthMiddleware"],
    override: true,
    relation: "after",
    toMiddleware: "retryMiddleware"
  };
  var getHttpSigningPlugin = /* @__PURE__ */ __name((config4) => ({
    applyToStack: (clientStack) => {
      clientStack.addRelativeTo(httpSigningMiddleware(config4), httpSigningMiddlewareOptions);
    }
  }), "getHttpSigningPlugin");

  // node_modules/@smithy/core/dist-es/normalizeProvider.js
  var normalizeProvider2 = /* @__PURE__ */ __name((input) => {
    if (typeof input === "function")
      return input;
    const promisified = Promise.resolve(input);
    return () => promisified;
  }, "normalizeProvider");

  // node_modules/@smithy/util-base64/dist-es/constants.browser.js
  var alphabetByEncoding = {};
  var alphabetByValue = new Array(64);
  for (let i3 = 0, start2 = "A".charCodeAt(0), limit = "Z".charCodeAt(0); i3 + start2 <= limit; i3++) {
    const char = String.fromCharCode(i3 + start2);
    alphabetByEncoding[char] = i3;
    alphabetByValue[i3] = char;
  }
  for (let i3 = 0, start2 = "a".charCodeAt(0), limit = "z".charCodeAt(0); i3 + start2 <= limit; i3++) {
    const char = String.fromCharCode(i3 + start2);
    const index2 = i3 + 26;
    alphabetByEncoding[char] = index2;
    alphabetByValue[index2] = char;
  }
  for (let i3 = 0; i3 < 10; i3++) {
    alphabetByEncoding[i3.toString(10)] = i3 + 52;
    const char = i3.toString(10);
    const index2 = i3 + 52;
    alphabetByEncoding[char] = index2;
    alphabetByValue[index2] = char;
  }
  alphabetByEncoding["+"] = 62;
  alphabetByValue[62] = "+";
  alphabetByEncoding["/"] = 63;
  alphabetByValue[63] = "/";
  var bitsPerLetter = 6;
  var bitsPerByte = 8;
  var maxLetterValue = 63;

  // node_modules/@smithy/util-base64/dist-es/fromBase64.browser.js
  var fromBase64 = /* @__PURE__ */ __name((input) => {
    let totalByteLength = input.length / 4 * 3;
    if (input.slice(-2) === "==") {
      totalByteLength -= 2;
    } else if (input.slice(-1) === "=") {
      totalByteLength--;
    }
    const out = new ArrayBuffer(totalByteLength);
    const dataView = new DataView(out);
    for (let i3 = 0; i3 < input.length; i3 += 4) {
      let bits = 0;
      let bitLength = 0;
      for (let j3 = i3, limit = i3 + 3; j3 <= limit; j3++) {
        if (input[j3] !== "=") {
          if (!(input[j3] in alphabetByEncoding)) {
            throw new TypeError(`Invalid character ${input[j3]} in base64 string.`);
          }
          bits |= alphabetByEncoding[input[j3]] << (limit - j3) * bitsPerLetter;
          bitLength += bitsPerLetter;
        } else {
          bits >>= bitsPerLetter;
        }
      }
      const chunkOffset = i3 / 4 * 3;
      bits >>= bitLength % bitsPerByte;
      const byteLength = Math.floor(bitLength / bitsPerByte);
      for (let k3 = 0; k3 < byteLength; k3++) {
        const offset = (byteLength - k3 - 1) * bitsPerByte;
        dataView.setUint8(chunkOffset + k3, (bits & 255 << offset) >> offset);
      }
    }
    return new Uint8Array(out);
  }, "fromBase64");

  // node_modules/@smithy/util-utf8/dist-es/fromUtf8.browser.js
  var fromUtf8 = /* @__PURE__ */ __name((input) => new TextEncoder().encode(input), "fromUtf8");

  // node_modules/@smithy/util-utf8/dist-es/toUint8Array.js
  var toUint8Array = /* @__PURE__ */ __name((data) => {
    if (typeof data === "string") {
      return fromUtf8(data);
    }
    if (ArrayBuffer.isView(data)) {
      return new Uint8Array(data.buffer, data.byteOffset, data.byteLength / Uint8Array.BYTES_PER_ELEMENT);
    }
    return new Uint8Array(data);
  }, "toUint8Array");

  // node_modules/@smithy/util-utf8/dist-es/toUtf8.browser.js
  var toUtf8 = /* @__PURE__ */ __name((input) => {
    if (typeof input === "string") {
      return input;
    }
    if (typeof input !== "object" || typeof input.byteOffset !== "number" || typeof input.byteLength !== "number") {
      throw new Error("@smithy/util-utf8: toUtf8 encoder function only accepts string | Uint8Array.");
    }
    return new TextDecoder("utf-8").decode(input);
  }, "toUtf8");

  // node_modules/@smithy/util-base64/dist-es/toBase64.browser.js
  function toBase64(_input) {
    let input;
    if (typeof _input === "string") {
      input = fromUtf8(_input);
    } else {
      input = _input;
    }
    const isArrayLike2 = typeof input === "object" && typeof input.length === "number";
    const isUint8Array = typeof input === "object" && typeof input.byteOffset === "number" && typeof input.byteLength === "number";
    if (!isArrayLike2 && !isUint8Array) {
      throw new Error("@smithy/util-base64: toBase64 encoder function only accepts string | Uint8Array.");
    }
    let str = "";
    for (let i3 = 0; i3 < input.length; i3 += 3) {
      let bits = 0;
      let bitLength = 0;
      for (let j3 = i3, limit = Math.min(i3 + 3, input.length); j3 < limit; j3++) {
        bits |= input[j3] << (limit - j3 - 1) * bitsPerByte;
        bitLength += bitsPerByte;
      }
      const bitClusterCount = Math.ceil(bitLength / bitsPerLetter);
      bits <<= bitClusterCount * bitsPerLetter - bitLength;
      for (let k3 = 1; k3 <= bitClusterCount; k3++) {
        const offset = (bitClusterCount - k3) * bitsPerLetter;
        str += alphabetByValue[(bits & maxLetterValue << offset) >> offset];
      }
      str += "==".slice(0, 4 - bitClusterCount);
    }
    return str;
  }
  __name(toBase64, "toBase64");

  // node_modules/@smithy/util-stream/dist-es/blob/transforms.js
  function transformToString(payload, encoding = "utf-8") {
    if (encoding === "base64") {
      return toBase64(payload);
    }
    return toUtf8(payload);
  }
  __name(transformToString, "transformToString");
  function transformFromString(str, encoding) {
    if (encoding === "base64") {
      return Uint8ArrayBlobAdapter.mutate(fromBase64(str));
    }
    return Uint8ArrayBlobAdapter.mutate(fromUtf8(str));
  }
  __name(transformFromString, "transformFromString");

  // node_modules/@smithy/util-stream/dist-es/blob/Uint8ArrayBlobAdapter.js
  var Uint8ArrayBlobAdapter = class _Uint8ArrayBlobAdapter extends Uint8Array {
    static {
      __name(this, "Uint8ArrayBlobAdapter");
    }
    static fromString(source, encoding = "utf-8") {
      switch (typeof source) {
        case "string":
          return transformFromString(source, encoding);
        default:
          throw new Error(`Unsupported conversion from ${typeof source} to Uint8ArrayBlobAdapter.`);
      }
    }
    static mutate(source) {
      Object.setPrototypeOf(source, _Uint8ArrayBlobAdapter.prototype);
      return source;
    }
    transformToString(encoding = "utf-8") {
      return transformToString(this, encoding);
    }
  };

  // node_modules/@smithy/util-stream/dist-es/checksum/ChecksumStream.browser.js
  var ReadableStreamRef = typeof ReadableStream === "function" ? ReadableStream : function() {
  };
  var ChecksumStream = class extends ReadableStreamRef {
    static {
      __name(this, "ChecksumStream");
    }
  };

  // node_modules/@smithy/util-stream/dist-es/stream-type-check.js
  var isReadableStream = /* @__PURE__ */ __name((stream) => typeof ReadableStream === "function" && (stream?.constructor?.name === ReadableStream.name || stream instanceof ReadableStream), "isReadableStream");

  // node_modules/@smithy/util-stream/dist-es/checksum/createChecksumStream.browser.js
  var createChecksumStream = /* @__PURE__ */ __name(({ expectedChecksum, checksum, source, checksumSourceLocation, base64Encoder }) => {
    if (!isReadableStream(source)) {
      throw new Error(`@smithy/util-stream: unsupported source type ${source?.constructor?.name ?? source} in ChecksumStream.`);
    }
    const encoder = base64Encoder ?? toBase64;
    if (typeof TransformStream !== "function") {
      throw new Error("@smithy/util-stream: unable to instantiate ChecksumStream because API unavailable: ReadableStream/TransformStream.");
    }
    const transform = new TransformStream({
      start() {
      },
      async transform(chunk, controller) {
        checksum.update(chunk);
        controller.enqueue(chunk);
      },
      async flush(controller) {
        const digest = await checksum.digest();
        const received = encoder(digest);
        if (expectedChecksum !== received) {
          const error = new Error(`Checksum mismatch: expected "${expectedChecksum}" but received "${received}" in response header "${checksumSourceLocation}".`);
          controller.error(error);
        } else {
          controller.terminate();
        }
      }
    });
    source.pipeThrough(transform);
    const readable = transform.readable;
    Object.setPrototypeOf(readable, ChecksumStream.prototype);
    return readable;
  }, "createChecksumStream");

  // node_modules/@smithy/util-stream/dist-es/ByteArrayCollector.js
  var ByteArrayCollector = class {
    static {
      __name(this, "ByteArrayCollector");
    }
    constructor(allocByteArray) {
      this.allocByteArray = allocByteArray;
      this.byteLength = 0;
      this.byteArrays = [];
    }
    push(byteArray) {
      this.byteArrays.push(byteArray);
      this.byteLength += byteArray.byteLength;
    }
    flush() {
      if (this.byteArrays.length === 1) {
        const bytes = this.byteArrays[0];
        this.reset();
        return bytes;
      }
      const aggregation = this.allocByteArray(this.byteLength);
      let cursor = 0;
      for (let i3 = 0; i3 < this.byteArrays.length; ++i3) {
        const bytes = this.byteArrays[i3];
        aggregation.set(bytes, cursor);
        cursor += bytes.byteLength;
      }
      this.reset();
      return aggregation;
    }
    reset() {
      this.byteArrays = [];
      this.byteLength = 0;
    }
  };

  // node_modules/@smithy/util-stream/dist-es/createBufferedReadableStream.js
  function createBufferedReadableStream(upstream, size, logger2) {
    const reader = upstream.getReader();
    let streamBufferingLoggedWarning = false;
    let bytesSeen = 0;
    const buffers = ["", new ByteArrayCollector((size2) => new Uint8Array(size2))];
    let mode = -1;
    const pull = /* @__PURE__ */ __name(async (controller) => {
      const { value, done } = await reader.read();
      const chunk = value;
      if (done) {
        if (mode !== -1) {
          const remainder = flush(buffers, mode);
          if (sizeOf(remainder) > 0) {
            controller.enqueue(remainder);
          }
        }
        controller.close();
      } else {
        const chunkMode = modeOf(chunk);
        if (mode !== chunkMode) {
          if (mode >= 0) {
            controller.enqueue(flush(buffers, mode));
          }
          mode = chunkMode;
        }
        if (mode === -1) {
          controller.enqueue(chunk);
          return;
        }
        const chunkSize = sizeOf(chunk);
        bytesSeen += chunkSize;
        const bufferSize = sizeOf(buffers[mode]);
        if (chunkSize >= size && bufferSize === 0) {
          controller.enqueue(chunk);
        } else {
          const newSize = merge2(buffers, mode, chunk);
          if (!streamBufferingLoggedWarning && bytesSeen > size * 2) {
            streamBufferingLoggedWarning = true;
            logger2?.warn(`@smithy/util-stream - stream chunk size ${chunkSize} is below threshold of ${size}, automatically buffering.`);
          }
          if (newSize >= size) {
            controller.enqueue(flush(buffers, mode));
          } else {
            await pull(controller);
          }
        }
      }
    }, "pull");
    return new ReadableStream({
      pull
    });
  }
  __name(createBufferedReadableStream, "createBufferedReadableStream");
  var createBufferedReadable = createBufferedReadableStream;
  function merge2(buffers, mode, chunk) {
    switch (mode) {
      case 0:
        buffers[0] += chunk;
        return sizeOf(buffers[0]);
      case 1:
      case 2:
        buffers[mode].push(chunk);
        return sizeOf(buffers[mode]);
    }
  }
  __name(merge2, "merge");
  function flush(buffers, mode) {
    switch (mode) {
      case 0:
        const s3 = buffers[0];
        buffers[0] = "";
        return s3;
      case 1:
      case 2:
        return buffers[mode].flush();
    }
    throw new Error(`@smithy/util-stream - invalid index ${mode} given to flush()`);
  }
  __name(flush, "flush");
  function sizeOf(chunk) {
    return chunk?.byteLength ?? chunk?.length ?? 0;
  }
  __name(sizeOf, "sizeOf");
  function modeOf(chunk) {
    if (typeof Buffer !== "undefined" && chunk instanceof Buffer) {
      return 2;
    }
    if (chunk instanceof Uint8Array) {
      return 1;
    }
    if (typeof chunk === "string") {
      return 0;
    }
    return -1;
  }
  __name(modeOf, "modeOf");

  // node_modules/@smithy/util-stream/dist-es/getAwsChunkedEncodingStream.browser.js
  var getAwsChunkedEncodingStream = /* @__PURE__ */ __name((readableStream, options) => {
    const { base64Encoder, bodyLengthChecker, checksumAlgorithmFn, checksumLocationName, streamHasher } = options;
    const checksumRequired = base64Encoder !== void 0 && bodyLengthChecker !== void 0 && checksumAlgorithmFn !== void 0 && checksumLocationName !== void 0 && streamHasher !== void 0;
    const digest = checksumRequired ? streamHasher(checksumAlgorithmFn, readableStream) : void 0;
    const reader = readableStream.getReader();
    return new ReadableStream({
      async pull(controller) {
        const { value, done } = await reader.read();
        if (done) {
          controller.enqueue(`0\r
`);
          if (checksumRequired) {
            const checksum = base64Encoder(await digest);
            controller.enqueue(`${checksumLocationName}:${checksum}\r
`);
            controller.enqueue(`\r
`);
          }
          controller.close();
        } else {
          controller.enqueue(`${(bodyLengthChecker(value) || 0).toString(16)}\r
${value}\r
`);
        }
      }
    });
  }, "getAwsChunkedEncodingStream");

  // node_modules/@smithy/util-stream/dist-es/headStream.browser.js
  async function headStream(stream, bytes) {
    let byteLengthCounter = 0;
    const chunks = [];
    const reader = stream.getReader();
    let isDone = false;
    while (!isDone) {
      const { done, value } = await reader.read();
      if (value) {
        chunks.push(value);
        byteLengthCounter += value?.byteLength ?? 0;
      }
      if (byteLengthCounter >= bytes) {
        break;
      }
      isDone = done;
    }
    reader.releaseLock();
    const collected = new Uint8Array(Math.min(bytes, byteLengthCounter));
    let offset = 0;
    for (const chunk of chunks) {
      if (chunk.byteLength > collected.byteLength - offset) {
        collected.set(chunk.subarray(0, collected.byteLength - offset), offset);
        break;
      } else {
        collected.set(chunk, offset);
      }
      offset += chunk.length;
    }
    return collected;
  }
  __name(headStream, "headStream");

  // node_modules/@smithy/util-uri-escape/dist-es/escape-uri.js
  var escapeUri = /* @__PURE__ */ __name((uri) => encodeURIComponent(uri).replace(/[!'()*]/g, hexEncode), "escapeUri");
  var hexEncode = /* @__PURE__ */ __name((c3) => `%${c3.charCodeAt(0).toString(16).toUpperCase()}`, "hexEncode");

  // node_modules/@smithy/querystring-builder/dist-es/index.js
  function buildQueryString(query) {
    const parts = [];
    for (let key of Object.keys(query).sort()) {
      const value = query[key];
      key = escapeUri(key);
      if (Array.isArray(value)) {
        for (let i3 = 0, iLen = value.length; i3 < iLen; i3++) {
          parts.push(`${key}=${escapeUri(value[i3])}`);
        }
      } else {
        let qsEntry = key;
        if (value || typeof value === "string") {
          qsEntry += `=${escapeUri(value)}`;
        }
        parts.push(qsEntry);
      }
    }
    return parts.join("&");
  }
  __name(buildQueryString, "buildQueryString");

  // node_modules/@smithy/fetch-http-handler/dist-es/create-request.js
  function createRequest(url, requestOptions) {
    return new Request(url, requestOptions);
  }
  __name(createRequest, "createRequest");

  // node_modules/@smithy/fetch-http-handler/dist-es/request-timeout.js
  function requestTimeout(timeoutInMs = 0) {
    return new Promise((resolve, reject) => {
      if (timeoutInMs) {
        setTimeout(() => {
          const timeoutError = new Error(`Request did not complete within ${timeoutInMs} ms`);
          timeoutError.name = "TimeoutError";
          reject(timeoutError);
        }, timeoutInMs);
      }
    });
  }
  __name(requestTimeout, "requestTimeout");

  // node_modules/@smithy/fetch-http-handler/dist-es/fetch-http-handler.js
  var keepAliveSupport = {
    supported: void 0
  };
  var FetchHttpHandler = class _FetchHttpHandler {
    static {
      __name(this, "FetchHttpHandler");
    }
    static create(instanceOrOptions) {
      if (typeof instanceOrOptions?.handle === "function") {
        return instanceOrOptions;
      }
      return new _FetchHttpHandler(instanceOrOptions);
    }
    constructor(options) {
      if (typeof options === "function") {
        this.configProvider = options().then((opts) => opts || {});
      } else {
        this.config = options ?? {};
        this.configProvider = Promise.resolve(this.config);
      }
      if (keepAliveSupport.supported === void 0) {
        keepAliveSupport.supported = Boolean(typeof Request !== "undefined" && "keepalive" in createRequest("https://[::1]"));
      }
    }
    destroy() {
    }
    async handle(request, { abortSignal } = {}) {
      if (!this.config) {
        this.config = await this.configProvider;
      }
      const requestTimeoutInMs = this.config.requestTimeout;
      const keepAlive = this.config.keepAlive === true;
      const credentials = this.config.credentials;
      if (abortSignal?.aborted) {
        const abortError = new Error("Request aborted");
        abortError.name = "AbortError";
        return Promise.reject(abortError);
      }
      let path = request.path;
      const queryString = buildQueryString(request.query || {});
      if (queryString) {
        path += `?${queryString}`;
      }
      if (request.fragment) {
        path += `#${request.fragment}`;
      }
      let auth = "";
      if (request.username != null || request.password != null) {
        const username = request.username ?? "";
        const password = request.password ?? "";
        auth = `${username}:${password}@`;
      }
      const { port, method } = request;
      const url = `${request.protocol}//${auth}${request.hostname}${port ? `:${port}` : ""}${path}`;
      const body = method === "GET" || method === "HEAD" ? void 0 : request.body;
      const requestOptions = {
        body,
        headers: new Headers(request.headers),
        method,
        credentials
      };
      if (this.config?.cache) {
        requestOptions.cache = this.config.cache;
      }
      if (body) {
        requestOptions.duplex = "half";
      }
      if (typeof AbortController !== "undefined") {
        requestOptions.signal = abortSignal;
      }
      if (keepAliveSupport.supported) {
        requestOptions.keepalive = keepAlive;
      }
      if (typeof this.config.requestInit === "function") {
        Object.assign(requestOptions, this.config.requestInit(request));
      }
      let removeSignalEventListener = /* @__PURE__ */ __name(() => {
      }, "removeSignalEventListener");
      const fetchRequest = createRequest(url, requestOptions);
      const raceOfPromises = [
        fetch(fetchRequest).then((response) => {
          const fetchHeaders = response.headers;
          const transformedHeaders = {};
          for (const pair of fetchHeaders.entries()) {
            transformedHeaders[pair[0]] = pair[1];
          }
          const hasReadableStream = response.body != void 0;
          if (!hasReadableStream) {
            return response.blob().then((body2) => ({
              response: new HttpResponse({
                headers: transformedHeaders,
                reason: response.statusText,
                statusCode: response.status,
                body: body2
              })
            }));
          }
          return {
            response: new HttpResponse({
              headers: transformedHeaders,
              reason: response.statusText,
              statusCode: response.status,
              body: response.body
            })
          };
        }),
        requestTimeout(requestTimeoutInMs)
      ];
      if (abortSignal) {
        raceOfPromises.push(new Promise((resolve, reject) => {
          const onAbort = /* @__PURE__ */ __name(() => {
            const abortError = new Error("Request aborted");
            abortError.name = "AbortError";
            reject(abortError);
          }, "onAbort");
          if (typeof abortSignal.addEventListener === "function") {
            const signal = abortSignal;
            signal.addEventListener("abort", onAbort, { once: true });
            removeSignalEventListener = /* @__PURE__ */ __name(() => signal.removeEventListener("abort", onAbort), "removeSignalEventListener");
          } else {
            abortSignal.onabort = onAbort;
          }
        }));
      }
      return Promise.race(raceOfPromises).finally(removeSignalEventListener);
    }
    updateHttpClientConfig(key, value) {
      this.config = void 0;
      this.configProvider = this.configProvider.then((config4) => {
        config4[key] = value;
        return config4;
      });
    }
    httpHandlerConfigs() {
      return this.config ?? {};
    }
  };

  // node_modules/@smithy/fetch-http-handler/dist-es/stream-collector.js
  var streamCollector = /* @__PURE__ */ __name(async (stream) => {
    if (typeof Blob === "function" && stream instanceof Blob || stream.constructor?.name === "Blob") {
      if (Blob.prototype.arrayBuffer !== void 0) {
        return new Uint8Array(await stream.arrayBuffer());
      }
      return collectBlob(stream);
    }
    return collectStream(stream);
  }, "streamCollector");
  async function collectBlob(blob) {
    const base64 = await readToBase64(blob);
    const arrayBuffer = fromBase64(base64);
    return new Uint8Array(arrayBuffer);
  }
  __name(collectBlob, "collectBlob");
  async function collectStream(stream) {
    const chunks = [];
    const reader = stream.getReader();
    let isDone = false;
    let length = 0;
    while (!isDone) {
      const { done, value } = await reader.read();
      if (value) {
        chunks.push(value);
        length += value.length;
      }
      isDone = done;
    }
    const collected = new Uint8Array(length);
    let offset = 0;
    for (const chunk of chunks) {
      collected.set(chunk, offset);
      offset += chunk.length;
    }
    return collected;
  }
  __name(collectStream, "collectStream");
  function readToBase64(blob) {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onloadend = () => {
        if (reader.readyState !== 2) {
          return reject(new Error("Reader aborted too early"));
        }
        const result = reader.result ?? "";
        const commaIndex = result.indexOf(",");
        const dataOffset = commaIndex > -1 ? commaIndex + 1 : result.length;
        resolve(result.substring(dataOffset));
      };
      reader.onabort = () => reject(new Error("Read aborted"));
      reader.onerror = () => reject(reader.error);
      reader.readAsDataURL(blob);
    });
  }
  __name(readToBase64, "readToBase64");

  // node_modules/@smithy/util-hex-encoding/dist-es/index.js
  var SHORT_TO_HEX = {};
  var HEX_TO_SHORT = {};
  for (let i3 = 0; i3 < 256; i3++) {
    let encodedByte = i3.toString(16).toLowerCase();
    if (encodedByte.length === 1) {
      encodedByte = `0${encodedByte}`;
    }
    SHORT_TO_HEX[i3] = encodedByte;
    HEX_TO_SHORT[encodedByte] = i3;
  }
  function fromHex(encoded) {
    if (encoded.length % 2 !== 0) {
      throw new Error("Hex encoded strings must have an even number length");
    }
    const out = new Uint8Array(encoded.length / 2);
    for (let i3 = 0; i3 < encoded.length; i3 += 2) {
      const encodedByte = encoded.slice(i3, i3 + 2).toLowerCase();
      if (encodedByte in HEX_TO_SHORT) {
        out[i3 / 2] = HEX_TO_SHORT[encodedByte];
      } else {
        throw new Error(`Cannot decode unrecognized sequence ${encodedByte} as hexadecimal`);
      }
    }
    return out;
  }
  __name(fromHex, "fromHex");
  function toHex(bytes) {
    let out = "";
    for (let i3 = 0; i3 < bytes.byteLength; i3++) {
      out += SHORT_TO_HEX[bytes[i3]];
    }
    return out;
  }
  __name(toHex, "toHex");

  // node_modules/@smithy/util-stream/dist-es/sdk-stream-mixin.browser.js
  var ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED = "The stream has already been transformed.";
  var sdkStreamMixin = /* @__PURE__ */ __name((stream) => {
    if (!isBlobInstance(stream) && !isReadableStream(stream)) {
      const name = stream?.__proto__?.constructor?.name || stream;
      throw new Error(`Unexpected stream implementation, expect Blob or ReadableStream, got ${name}`);
    }
    let transformed = false;
    const transformToByteArray = /* @__PURE__ */ __name(async () => {
      if (transformed) {
        throw new Error(ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED);
      }
      transformed = true;
      return await streamCollector(stream);
    }, "transformToByteArray");
    const blobToWebStream = /* @__PURE__ */ __name((blob) => {
      if (typeof blob.stream !== "function") {
        throw new Error("Cannot transform payload Blob to web stream. Please make sure the Blob.stream() is polyfilled.\nIf you are using React Native, this API is not yet supported, see: https://react-native.canny.io/feature-requests/p/fetch-streaming-body");
      }
      return blob.stream();
    }, "blobToWebStream");
    return Object.assign(stream, {
      transformToByteArray,
      transformToString: async (encoding) => {
        const buf = await transformToByteArray();
        if (encoding === "base64") {
          return toBase64(buf);
        } else if (encoding === "hex") {
          return toHex(buf);
        } else if (encoding === void 0 || encoding === "utf8" || encoding === "utf-8") {
          return toUtf8(buf);
        } else if (typeof TextDecoder === "function") {
          return new TextDecoder(encoding).decode(buf);
        } else {
          throw new Error("TextDecoder is not available, please make sure polyfill is provided.");
        }
      },
      transformToWebStream: () => {
        if (transformed) {
          throw new Error(ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED);
        }
        transformed = true;
        if (isBlobInstance(stream)) {
          return blobToWebStream(stream);
        } else if (isReadableStream(stream)) {
          return stream;
        } else {
          throw new Error(`Cannot transform payload to web stream, got ${stream}`);
        }
      }
    });
  }, "sdkStreamMixin");
  var isBlobInstance = /* @__PURE__ */ __name((stream) => typeof Blob === "function" && stream instanceof Blob, "isBlobInstance");

  // node_modules/@smithy/util-stream/dist-es/splitStream.browser.js
  async function splitStream(stream) {
    if (typeof stream.stream === "function") {
      stream = stream.stream();
    }
    const readableStream = stream;
    return readableStream.tee();
  }
  __name(splitStream, "splitStream");

  // node_modules/@smithy/core/dist-es/submodules/protocols/collect-stream-body.js
  var collectBody = /* @__PURE__ */ __name(async (streamBody = new Uint8Array(), context) => {
    if (streamBody instanceof Uint8Array) {
      return Uint8ArrayBlobAdapter.mutate(streamBody);
    }
    if (!streamBody) {
      return Uint8ArrayBlobAdapter.mutate(new Uint8Array());
    }
    const fromContext = context.streamCollector(streamBody);
    return Uint8ArrayBlobAdapter.mutate(await fromContext);
  }, "collectBody");

  // node_modules/@smithy/core/dist-es/submodules/protocols/extended-encode-uri-component.js
  function extendedEncodeURIComponent(str) {
    return encodeURIComponent(str).replace(/[!'()*]/g, function(c3) {
      return "%" + c3.charCodeAt(0).toString(16).toUpperCase();
    });
  }
  __name(extendedEncodeURIComponent, "extendedEncodeURIComponent");

  // node_modules/@smithy/core/dist-es/submodules/protocols/resolve-path.js
  var resolvedPath = /* @__PURE__ */ __name((resolvedPath2, input, memberName, labelValueProvider, uriLabel, isGreedyLabel) => {
    if (input != null && input[memberName] !== void 0) {
      const labelValue = labelValueProvider();
      if (labelValue.length <= 0) {
        throw new Error("Empty value provided for input HTTP label: " + memberName + ".");
      }
      resolvedPath2 = resolvedPath2.replace(uriLabel, isGreedyLabel ? labelValue.split("/").map((segment) => extendedEncodeURIComponent(segment)).join("/") : extendedEncodeURIComponent(labelValue));
    } else {
      throw new Error("No value provided for input HTTP label: " + memberName + ".");
    }
    return resolvedPath2;
  }, "resolvedPath");

  // node_modules/@smithy/core/dist-es/submodules/protocols/requestBuilder.js
  function requestBuilder(input, context) {
    return new RequestBuilder(input, context);
  }
  __name(requestBuilder, "requestBuilder");
  var RequestBuilder = class {
    static {
      __name(this, "RequestBuilder");
    }
    constructor(input, context) {
      this.input = input;
      this.context = context;
      this.query = {};
      this.method = "";
      this.headers = {};
      this.path = "";
      this.body = null;
      this.hostname = "";
      this.resolvePathStack = [];
    }
    async build() {
      const { hostname, protocol = "https", port, path: basePath } = await this.context.endpoint();
      this.path = basePath;
      for (const resolvePath of this.resolvePathStack) {
        resolvePath(this.path);
      }
      return new HttpRequest({
        protocol,
        hostname: this.hostname || hostname,
        port,
        method: this.method,
        path: this.path,
        query: this.query,
        body: this.body,
        headers: this.headers
      });
    }
    hn(hostname) {
      this.hostname = hostname;
      return this;
    }
    bp(uriLabel) {
      this.resolvePathStack.push((basePath) => {
        this.path = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + uriLabel;
      });
      return this;
    }
    p(memberName, labelValueProvider, uriLabel, isGreedyLabel) {
      this.resolvePathStack.push((path) => {
        this.path = resolvedPath(path, this.input, memberName, labelValueProvider, uriLabel, isGreedyLabel);
      });
      return this;
    }
    h(headers) {
      this.headers = headers;
      return this;
    }
    q(query) {
      this.query = query;
      return this;
    }
    b(body) {
      this.body = body;
      return this;
    }
    m(method) {
      this.method = method;
      return this;
    }
  };

  // node_modules/@smithy/core/dist-es/setFeature.js
  function setFeature2(context, feature, value) {
    if (!context.__smithy_context) {
      context.__smithy_context = {
        features: {}
      };
    } else if (!context.__smithy_context.features) {
      context.__smithy_context.features = {};
    }
    context.__smithy_context.features[feature] = value;
  }
  __name(setFeature2, "setFeature");

  // node_modules/@smithy/core/dist-es/util-identity-and-auth/DefaultIdentityProviderConfig.js
  var DefaultIdentityProviderConfig = class {
    static {
      __name(this, "DefaultIdentityProviderConfig");
    }
    constructor(config4) {
      this.authSchemes = /* @__PURE__ */ new Map();
      for (const [key, value] of Object.entries(config4)) {
        if (value !== void 0) {
          this.authSchemes.set(key, value);
        }
      }
    }
    getIdentityProvider(schemeId) {
      return this.authSchemes.get(schemeId);
    }
  };

  // node_modules/@smithy/core/dist-es/util-identity-and-auth/memoizeIdentityProvider.js
  var createIsIdentityExpiredFunction = /* @__PURE__ */ __name((expirationMs) => (identity2) => doesIdentityRequireRefresh(identity2) && identity2.expiration.getTime() - Date.now() < expirationMs, "createIsIdentityExpiredFunction");
  var EXPIRATION_MS = 3e5;
  var isIdentityExpired = createIsIdentityExpiredFunction(EXPIRATION_MS);
  var doesIdentityRequireRefresh = /* @__PURE__ */ __name((identity2) => identity2.expiration !== void 0, "doesIdentityRequireRefresh");
  var memoizeIdentityProvider = /* @__PURE__ */ __name((provider, isExpired, requiresRefresh) => {
    if (provider === void 0) {
      return void 0;
    }
    const normalizedProvider = typeof provider !== "function" ? async () => Promise.resolve(provider) : provider;
    let resolved;
    let pending;
    let hasResult;
    let isConstant = false;
    const coalesceProvider = /* @__PURE__ */ __name(async (options) => {
      if (!pending) {
        pending = normalizedProvider(options);
      }
      try {
        resolved = await pending;
        hasResult = true;
        isConstant = false;
      } finally {
        pending = void 0;
      }
      return resolved;
    }, "coalesceProvider");
    if (isExpired === void 0) {
      return async (options) => {
        if (!hasResult || options?.forceRefresh) {
          resolved = await coalesceProvider(options);
        }
        return resolved;
      };
    }
    return async (options) => {
      if (!hasResult || options?.forceRefresh) {
        resolved = await coalesceProvider(options);
      }
      if (isConstant) {
        return resolved;
      }
      if (!requiresRefresh(resolved)) {
        isConstant = true;
        return resolved;
      }
      if (isExpired(resolved)) {
        await coalesceProvider(options);
        return resolved;
      }
      return resolved;
    };
  }, "memoizeIdentityProvider");

  // node_modules/@smithy/property-provider/dist-es/memoize.js
  var memoize = /* @__PURE__ */ __name((provider, isExpired, requiresRefresh) => {
    let resolved;
    let pending;
    let hasResult;
    let isConstant = false;
    const coalesceProvider = /* @__PURE__ */ __name(async () => {
      if (!pending) {
        pending = provider();
      }
      try {
        resolved = await pending;
        hasResult = true;
        isConstant = false;
      } finally {
        pending = void 0;
      }
      return resolved;
    }, "coalesceProvider");
    if (isExpired === void 0) {
      return async (options) => {
        if (!hasResult || options?.forceRefresh) {
          resolved = await coalesceProvider();
        }
        return resolved;
      };
    }
    return async (options) => {
      if (!hasResult || options?.forceRefresh) {
        resolved = await coalesceProvider();
      }
      if (isConstant) {
        return resolved;
      }
      if (requiresRefresh && !requiresRefresh(resolved)) {
        isConstant = true;
        return resolved;
      }
      if (isExpired(resolved)) {
        await coalesceProvider();
        return resolved;
      }
      return resolved;
    };
  }, "memoize");

  // node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/aws_sdk/resolveAwsSdkSigV4AConfig.js
  var resolveAwsSdkSigV4AConfig = /* @__PURE__ */ __name((config4) => {
    config4.sigv4aSigningRegionSet = normalizeProvider2(config4.sigv4aSigningRegionSet);
    return config4;
  }, "resolveAwsSdkSigV4AConfig");

  // node_modules/@smithy/signature-v4/dist-es/constants.js
  var ALGORITHM_QUERY_PARAM = "X-Amz-Algorithm";
  var CREDENTIAL_QUERY_PARAM = "X-Amz-Credential";
  var AMZ_DATE_QUERY_PARAM = "X-Amz-Date";
  var SIGNED_HEADERS_QUERY_PARAM = "X-Amz-SignedHeaders";
  var EXPIRES_QUERY_PARAM = "X-Amz-Expires";
  var SIGNATURE_QUERY_PARAM = "X-Amz-Signature";
  var TOKEN_QUERY_PARAM = "X-Amz-Security-Token";
  var AUTH_HEADER = "authorization";
  var AMZ_DATE_HEADER = AMZ_DATE_QUERY_PARAM.toLowerCase();
  var DATE_HEADER = "date";
  var GENERATED_HEADERS = [AUTH_HEADER, AMZ_DATE_HEADER, DATE_HEADER];
  var SIGNATURE_HEADER = SIGNATURE_QUERY_PARAM.toLowerCase();
  var SHA256_HEADER = "x-amz-content-sha256";
  var TOKEN_HEADER = TOKEN_QUERY_PARAM.toLowerCase();
  var ALWAYS_UNSIGNABLE_HEADERS = {
    authorization: true,
    "cache-control": true,
    connection: true,
    expect: true,
    from: true,
    "keep-alive": true,
    "max-forwards": true,
    pragma: true,
    referer: true,
    te: true,
    trailer: true,
    "transfer-encoding": true,
    upgrade: true,
    "user-agent": true,
    "x-amzn-trace-id": true
  };
  var PROXY_HEADER_PATTERN = /^proxy-/;
  var SEC_HEADER_PATTERN = /^sec-/;
  var ALGORITHM_IDENTIFIER = "AWS4-HMAC-SHA256";
  var EVENT_ALGORITHM_IDENTIFIER = "AWS4-HMAC-SHA256-PAYLOAD";
  var UNSIGNED_PAYLOAD = "UNSIGNED-PAYLOAD";
  var MAX_CACHE_SIZE = 50;
  var KEY_TYPE_IDENTIFIER = "aws4_request";
  var MAX_PRESIGNED_TTL = 60 * 60 * 24 * 7;

  // node_modules/@smithy/signature-v4/dist-es/credentialDerivation.js
  var signingKeyCache = {};
  var cacheQueue = [];
  var createScope = /* @__PURE__ */ __name((shortDate, region, service) => `${shortDate}/${region}/${service}/${KEY_TYPE_IDENTIFIER}`, "createScope");
  var getSigningKey = /* @__PURE__ */ __name(async (sha256Constructor, credentials, shortDate, region, service) => {
    const credsHash = await hmac(sha256Constructor, credentials.secretAccessKey, credentials.accessKeyId);
    const cacheKey = `${shortDate}:${region}:${service}:${toHex(credsHash)}:${credentials.sessionToken}`;
    if (cacheKey in signingKeyCache) {
      return signingKeyCache[cacheKey];
    }
    cacheQueue.push(cacheKey);
    while (cacheQueue.length > MAX_CACHE_SIZE) {
      delete signingKeyCache[cacheQueue.shift()];
    }
    let key = `AWS4${credentials.secretAccessKey}`;
    for (const signable of [shortDate, region, service, KEY_TYPE_IDENTIFIER]) {
      key = await hmac(sha256Constructor, key, signable);
    }
    return signingKeyCache[cacheKey] = key;
  }, "getSigningKey");
  var hmac = /* @__PURE__ */ __name((ctor, secret, data) => {
    const hash = new ctor(secret);
    hash.update(toUint8Array(data));
    return hash.digest();
  }, "hmac");

  // node_modules/@smithy/signature-v4/dist-es/getCanonicalHeaders.js
  var getCanonicalHeaders = /* @__PURE__ */ __name(({ headers }, unsignableHeaders, signableHeaders) => {
    const canonical = {};
    for (const headerName of Object.keys(headers).sort()) {
      if (headers[headerName] == void 0) {
        continue;
      }
      const canonicalHeaderName = headerName.toLowerCase();
      if (canonicalHeaderName in ALWAYS_UNSIGNABLE_HEADERS || unsignableHeaders?.has(canonicalHeaderName) || PROXY_HEADER_PATTERN.test(canonicalHeaderName) || SEC_HEADER_PATTERN.test(canonicalHeaderName)) {
        if (!signableHeaders || signableHeaders && !signableHeaders.has(canonicalHeaderName)) {
          continue;
        }
      }
      canonical[canonicalHeaderName] = headers[headerName].trim().replace(/\s+/g, " ");
    }
    return canonical;
  }, "getCanonicalHeaders");

  // node_modules/@smithy/signature-v4/dist-es/getCanonicalQuery.js
  var getCanonicalQuery = /* @__PURE__ */ __name(({ query = {} }) => {
    const keys2 = [];
    const serialized = {};
    for (const key of Object.keys(query)) {
      if (key.toLowerCase() === SIGNATURE_HEADER) {
        continue;
      }
      const encodedKey = escapeUri(key);
      keys2.push(encodedKey);
      const value = query[key];
      if (typeof value === "string") {
        serialized[encodedKey] = `${encodedKey}=${escapeUri(value)}`;
      } else if (Array.isArray(value)) {
        serialized[encodedKey] = value.slice(0).reduce((encoded, value2) => encoded.concat([`${encodedKey}=${escapeUri(value2)}`]), []).sort().join("&");
      }
    }
    return keys2.sort().map((key) => serialized[key]).filter((serialized2) => serialized2).join("&");
  }, "getCanonicalQuery");

  // node_modules/@smithy/is-array-buffer/dist-es/index.js
  var isArrayBuffer = /* @__PURE__ */ __name((arg) => typeof ArrayBuffer === "function" && arg instanceof ArrayBuffer || Object.prototype.toString.call(arg) === "[object ArrayBuffer]", "isArrayBuffer");

  // node_modules/@smithy/signature-v4/dist-es/getPayloadHash.js
  var getPayloadHash = /* @__PURE__ */ __name(async ({ headers, body }, hashConstructor) => {
    for (const headerName of Object.keys(headers)) {
      if (headerName.toLowerCase() === SHA256_HEADER) {
        return headers[headerName];
      }
    }
    if (body == void 0) {
      return "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855";
    } else if (typeof body === "string" || ArrayBuffer.isView(body) || isArrayBuffer(body)) {
      const hashCtor = new hashConstructor();
      hashCtor.update(toUint8Array(body));
      return toHex(await hashCtor.digest());
    }
    return UNSIGNED_PAYLOAD;
  }, "getPayloadHash");

  // node_modules/@smithy/signature-v4/dist-es/HeaderFormatter.js
  var HeaderFormatter = class {
    static {
      __name(this, "HeaderFormatter");
    }
    format(headers) {
      const chunks = [];
      for (const headerName of Object.keys(headers)) {
        const bytes = fromUtf8(headerName);
        chunks.push(Uint8Array.from([bytes.byteLength]), bytes, this.formatHeaderValue(headers[headerName]));
      }
      const out = new Uint8Array(chunks.reduce((carry, bytes) => carry + bytes.byteLength, 0));
      let position = 0;
      for (const chunk of chunks) {
        out.set(chunk, position);
        position += chunk.byteLength;
      }
      return out;
    }
    formatHeaderValue(header) {
      switch (header.type) {
        case "boolean":
          return Uint8Array.from([header.value ? 0 : 1]);
        case "byte":
          return Uint8Array.from([2, header.value]);
        case "short":
          const shortView = new DataView(new ArrayBuffer(3));
          shortView.setUint8(0, 3);
          shortView.setInt16(1, header.value, false);
          return new Uint8Array(shortView.buffer);
        case "integer":
          const intView = new DataView(new ArrayBuffer(5));
          intView.setUint8(0, 4);
          intView.setInt32(1, header.value, false);
          return new Uint8Array(intView.buffer);
        case "long":
          const longBytes = new Uint8Array(9);
          longBytes[0] = 5;
          longBytes.set(header.value.bytes, 1);
          return longBytes;
        case "binary":
          const binView = new DataView(new ArrayBuffer(3 + header.value.byteLength));
          binView.setUint8(0, 6);
          binView.setUint16(1, header.value.byteLength, false);
          const binBytes = new Uint8Array(binView.buffer);
          binBytes.set(header.value, 3);
          return binBytes;
        case "string":
          const utf8Bytes = fromUtf8(header.value);
          const strView = new DataView(new ArrayBuffer(3 + utf8Bytes.byteLength));
          strView.setUint8(0, 7);
          strView.setUint16(1, utf8Bytes.byteLength, false);
          const strBytes = new Uint8Array(strView.buffer);
          strBytes.set(utf8Bytes, 3);
          return strBytes;
        case "timestamp":
          const tsBytes = new Uint8Array(9);
          tsBytes[0] = 8;
          tsBytes.set(Int64.fromNumber(header.value.valueOf()).bytes, 1);
          return tsBytes;
        case "uuid":
          if (!UUID_PATTERN.test(header.value)) {
            throw new Error(`Invalid UUID received: ${header.value}`);
          }
          const uuidBytes = new Uint8Array(17);
          uuidBytes[0] = 9;
          uuidBytes.set(fromHex(header.value.replace(/\-/g, "")), 1);
          return uuidBytes;
      }
    }
  };
  var HEADER_VALUE_TYPE;
  (function(HEADER_VALUE_TYPE3) {
    HEADER_VALUE_TYPE3[HEADER_VALUE_TYPE3["boolTrue"] = 0] = "boolTrue";
    HEADER_VALUE_TYPE3[HEADER_VALUE_TYPE3["boolFalse"] = 1] = "boolFalse";
    HEADER_VALUE_TYPE3[HEADER_VALUE_TYPE3["byte"] = 2] = "byte";
    HEADER_VALUE_TYPE3[HEADER_VALUE_TYPE3["short"] = 3] = "short";
    HEADER_VALUE_TYPE3[HEADER_VALUE_TYPE3["integer"] = 4] = "integer";
    HEADER_VALUE_TYPE3[HEADER_VALUE_TYPE3["long"] = 5] = "long";
    HEADER_VALUE_TYPE3[HEADER_VALUE_TYPE3["byteArray"] = 6] = "byteArray";
    HEADER_VALUE_TYPE3[HEADER_VALUE_TYPE3["string"] = 7] = "string";
    HEADER_VALUE_TYPE3[HEADER_VALUE_TYPE3["timestamp"] = 8] = "timestamp";
    HEADER_VALUE_TYPE3[HEADER_VALUE_TYPE3["uuid"] = 9] = "uuid";
  })(HEADER_VALUE_TYPE || (HEADER_VALUE_TYPE = {}));
  var UUID_PATTERN = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/;
  var Int64 = class _Int64 {
    static {
      __name(this, "Int64");
    }
    constructor(bytes) {
      this.bytes = bytes;
      if (bytes.byteLength !== 8) {
        throw new Error("Int64 buffers must be exactly 8 bytes");
      }
    }
    static fromNumber(number) {
      if (number > 9223372036854776e3 || number < -9223372036854776e3) {
        throw new Error(`${number} is too large (or, if negative, too small) to represent as an Int64`);
      }
      const bytes = new Uint8Array(8);
      for (let i3 = 7, remaining = Math.abs(Math.round(number)); i3 > -1 && remaining > 0; i3--, remaining /= 256) {
        bytes[i3] = remaining;
      }
      if (number < 0) {
        negate(bytes);
      }
      return new _Int64(bytes);
    }
    valueOf() {
      const bytes = this.bytes.slice(0);
      const negative = bytes[0] & 128;
      if (negative) {
        negate(bytes);
      }
      return parseInt(toHex(bytes), 16) * (negative ? -1 : 1);
    }
    toString() {
      return String(this.valueOf());
    }
  };
  function negate(bytes) {
    for (let i3 = 0; i3 < 8; i3++) {
      bytes[i3] ^= 255;
    }
    for (let i3 = 7; i3 > -1; i3--) {
      bytes[i3]++;
      if (bytes[i3] !== 0)
        break;
    }
  }
  __name(negate, "negate");

  // node_modules/@smithy/signature-v4/dist-es/headerUtil.js
  var hasHeader = /* @__PURE__ */ __name((soughtHeader, headers) => {
    soughtHeader = soughtHeader.toLowerCase();
    for (const headerName of Object.keys(headers)) {
      if (soughtHeader === headerName.toLowerCase()) {
        return true;
      }
    }
    return false;
  }, "hasHeader");

  // node_modules/@smithy/signature-v4/dist-es/moveHeadersToQuery.js
  var moveHeadersToQuery = /* @__PURE__ */ __name((request, options = {}) => {
    const { headers, query = {} } = HttpRequest.clone(request);
    for (const name of Object.keys(headers)) {
      const lname = name.toLowerCase();
      if (lname.slice(0, 6) === "x-amz-" && !options.unhoistableHeaders?.has(lname) || options.hoistableHeaders?.has(lname)) {
        query[name] = headers[name];
        delete headers[name];
      }
    }
    return {
      ...request,
      headers,
      query
    };
  }, "moveHeadersToQuery");

  // node_modules/@smithy/signature-v4/dist-es/prepareRequest.js
  var prepareRequest = /* @__PURE__ */ __name((request) => {
    request = HttpRequest.clone(request);
    for (const headerName of Object.keys(request.headers)) {
      if (GENERATED_HEADERS.indexOf(headerName.toLowerCase()) > -1) {
        delete request.headers[headerName];
      }
    }
    return request;
  }, "prepareRequest");

  // node_modules/@smithy/signature-v4/dist-es/utilDate.js
  var iso8601 = /* @__PURE__ */ __name((time) => toDate(time).toISOString().replace(/\.\d{3}Z$/, "Z"), "iso8601");
  var toDate = /* @__PURE__ */ __name((time) => {
    if (typeof time === "number") {
      return new Date(time * 1e3);
    }
    if (typeof time === "string") {
      if (Number(time)) {
        return new Date(Number(time) * 1e3);
      }
      return new Date(time);
    }
    return time;
  }, "toDate");

  // node_modules/@smithy/signature-v4/dist-es/SignatureV4.js
  var SignatureV4 = class {
    static {
      __name(this, "SignatureV4");
    }
    constructor({ applyChecksum, credentials, region, service, sha256, uriEscapePath = true }) {
      this.headerFormatter = new HeaderFormatter();
      this.service = service;
      this.sha256 = sha256;
      this.uriEscapePath = uriEscapePath;
      this.applyChecksum = typeof applyChecksum === "boolean" ? applyChecksum : true;
      this.regionProvider = normalizeProvider(region);
      this.credentialProvider = normalizeProvider(credentials);
    }
    async presign(originalRequest, options = {}) {
      const { signingDate = /* @__PURE__ */ new Date(), expiresIn = 3600, unsignableHeaders, unhoistableHeaders, signableHeaders, hoistableHeaders, signingRegion, signingService } = options;
      const credentials = await this.credentialProvider();
      this.validateResolvedCredentials(credentials);
      const region = signingRegion ?? await this.regionProvider();
      const { longDate, shortDate } = formatDate(signingDate);
      if (expiresIn > MAX_PRESIGNED_TTL) {
        return Promise.reject("Signature version 4 presigned URLs must have an expiration date less than one week in the future");
      }
      const scope = createScope(shortDate, region, signingService ?? this.service);
      const request = moveHeadersToQuery(prepareRequest(originalRequest), { unhoistableHeaders, hoistableHeaders });
      if (credentials.sessionToken) {
        request.query[TOKEN_QUERY_PARAM] = credentials.sessionToken;
      }
      request.query[ALGORITHM_QUERY_PARAM] = ALGORITHM_IDENTIFIER;
      request.query[CREDENTIAL_QUERY_PARAM] = `${credentials.accessKeyId}/${scope}`;
      request.query[AMZ_DATE_QUERY_PARAM] = longDate;
      request.query[EXPIRES_QUERY_PARAM] = expiresIn.toString(10);
      const canonicalHeaders = getCanonicalHeaders(request, unsignableHeaders, signableHeaders);
      request.query[SIGNED_HEADERS_QUERY_PARAM] = getCanonicalHeaderList(canonicalHeaders);
      request.query[SIGNATURE_QUERY_PARAM] = await this.getSignature(longDate, scope, this.getSigningKey(credentials, region, shortDate, signingService), this.createCanonicalRequest(request, canonicalHeaders, await getPayloadHash(originalRequest, this.sha256)));
      return request;
    }
    async sign(toSign, options) {
      if (typeof toSign === "string") {
        return this.signString(toSign, options);
      } else if (toSign.headers && toSign.payload) {
        return this.signEvent(toSign, options);
      } else if (toSign.message) {
        return this.signMessage(toSign, options);
      } else {
        return this.signRequest(toSign, options);
      }
    }
    async signEvent({ headers, payload }, { signingDate = /* @__PURE__ */ new Date(), priorSignature, signingRegion, signingService }) {
      const region = signingRegion ?? await this.regionProvider();
      const { shortDate, longDate } = formatDate(signingDate);
      const scope = createScope(shortDate, region, signingService ?? this.service);
      const hashedPayload = await getPayloadHash({ headers: {}, body: payload }, this.sha256);
      const hash = new this.sha256();
      hash.update(headers);
      const hashedHeaders = toHex(await hash.digest());
      const stringToSign = [
        EVENT_ALGORITHM_IDENTIFIER,
        longDate,
        scope,
        priorSignature,
        hashedHeaders,
        hashedPayload
      ].join("\n");
      return this.signString(stringToSign, { signingDate, signingRegion: region, signingService });
    }
    async signMessage(signableMessage, { signingDate = /* @__PURE__ */ new Date(), signingRegion, signingService }) {
      const promise = this.signEvent({
        headers: this.headerFormatter.format(signableMessage.message.headers),
        payload: signableMessage.message.body
      }, {
        signingDate,
        signingRegion,
        signingService,
        priorSignature: signableMessage.priorSignature
      });
      return promise.then((signature) => {
        return { message: signableMessage.message, signature };
      });
    }
    async signString(stringToSign, { signingDate = /* @__PURE__ */ new Date(), signingRegion, signingService } = {}) {
      const credentials = await this.credentialProvider();
      this.validateResolvedCredentials(credentials);
      const region = signingRegion ?? await this.regionProvider();
      const { shortDate } = formatDate(signingDate);
      const hash = new this.sha256(await this.getSigningKey(credentials, region, shortDate, signingService));
      hash.update(toUint8Array(stringToSign));
      return toHex(await hash.digest());
    }
    async signRequest(requestToSign, { signingDate = /* @__PURE__ */ new Date(), signableHeaders, unsignableHeaders, signingRegion, signingService } = {}) {
      const credentials = await this.credentialProvider();
      this.validateResolvedCredentials(credentials);
      const region = signingRegion ?? await this.regionProvider();
      const request = prepareRequest(requestToSign);
      const { longDate, shortDate } = formatDate(signingDate);
      const scope = createScope(shortDate, region, signingService ?? this.service);
      request.headers[AMZ_DATE_HEADER] = longDate;
      if (credentials.sessionToken) {
        request.headers[TOKEN_HEADER] = credentials.sessionToken;
      }
      const payloadHash = await getPayloadHash(request, this.sha256);
      if (!hasHeader(SHA256_HEADER, request.headers) && this.applyChecksum) {
        request.headers[SHA256_HEADER] = payloadHash;
      }
      const canonicalHeaders = getCanonicalHeaders(request, unsignableHeaders, signableHeaders);
      const signature = await this.getSignature(longDate, scope, this.getSigningKey(credentials, region, shortDate, signingService), this.createCanonicalRequest(request, canonicalHeaders, payloadHash));
      request.headers[AUTH_HEADER] = `${ALGORITHM_IDENTIFIER} Credential=${credentials.accessKeyId}/${scope}, SignedHeaders=${getCanonicalHeaderList(canonicalHeaders)}, Signature=${signature}`;
      return request;
    }
    createCanonicalRequest(request, canonicalHeaders, payloadHash) {
      const sortedHeaders = Object.keys(canonicalHeaders).sort();
      return `${request.method}
${this.getCanonicalPath(request)}
${getCanonicalQuery(request)}
${sortedHeaders.map((name) => `${name}:${canonicalHeaders[name]}`).join("\n")}

${sortedHeaders.join(";")}
${payloadHash}`;
    }
    async createStringToSign(longDate, credentialScope, canonicalRequest) {
      const hash = new this.sha256();
      hash.update(toUint8Array(canonicalRequest));
      const hashedRequest = await hash.digest();
      return `${ALGORITHM_IDENTIFIER}
${longDate}
${credentialScope}
${toHex(hashedRequest)}`;
    }
    getCanonicalPath({ path }) {
      if (this.uriEscapePath) {
        const normalizedPathSegments = [];
        for (const pathSegment of path.split("/")) {
          if (pathSegment?.length === 0)
            continue;
          if (pathSegment === ".")
            continue;
          if (pathSegment === "..") {
            normalizedPathSegments.pop();
          } else {
            normalizedPathSegments.push(pathSegment);
          }
        }
        const normalizedPath = `${path?.startsWith("/") ? "/" : ""}${normalizedPathSegments.join("/")}${normalizedPathSegments.length > 0 && path?.endsWith("/") ? "/" : ""}`;
        const doubleEncoded = escapeUri(normalizedPath);
        return doubleEncoded.replace(/%2F/g, "/");
      }
      return path;
    }
    async getSignature(longDate, credentialScope, keyPromise, canonicalRequest) {
      const stringToSign = await this.createStringToSign(longDate, credentialScope, canonicalRequest);
      const hash = new this.sha256(await keyPromise);
      hash.update(toUint8Array(stringToSign));
      return toHex(await hash.digest());
    }
    getSigningKey(credentials, region, shortDate, service) {
      return getSigningKey(this.sha256, credentials, shortDate, region, service || this.service);
    }
    validateResolvedCredentials(credentials) {
      if (typeof credentials !== "object" || typeof credentials.accessKeyId !== "string" || typeof credentials.secretAccessKey !== "string") {
        throw new Error("Resolved credential object is not valid");
      }
    }
  };
  var formatDate = /* @__PURE__ */ __name((now2) => {
    const longDate = iso8601(now2).replace(/[\-:]/g, "");
    return {
      longDate,
      shortDate: longDate.slice(0, 8)
    };
  }, "formatDate");
  var getCanonicalHeaderList = /* @__PURE__ */ __name((headers) => Object.keys(headers).sort().join(";"), "getCanonicalHeaderList");

  // node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/aws_sdk/resolveAwsSdkSigV4Config.js
  var resolveAwsSdkSigV4Config = /* @__PURE__ */ __name((config4) => {
    let isUserSupplied = false;
    let credentialsProvider;
    if (config4.credentials) {
      isUserSupplied = true;
      credentialsProvider = memoizeIdentityProvider(config4.credentials, isIdentityExpired, doesIdentityRequireRefresh);
    }
    if (!credentialsProvider) {
      if (config4.credentialDefaultProvider) {
        credentialsProvider = normalizeProvider2(config4.credentialDefaultProvider(Object.assign({}, config4, {
          parentClientConfig: config4
        })));
      } else {
        credentialsProvider = /* @__PURE__ */ __name(async () => {
          throw new Error("`credentials` is missing");
        }, "credentialsProvider");
      }
    }
    const boundCredentialsProvider = /* @__PURE__ */ __name(async () => credentialsProvider({ callerClientConfig: config4 }), "boundCredentialsProvider");
    const { signingEscapePath = true, systemClockOffset = config4.systemClockOffset || 0, sha256 } = config4;
    let signer;
    if (config4.signer) {
      signer = normalizeProvider2(config4.signer);
    } else if (config4.regionInfoProvider) {
      signer = /* @__PURE__ */ __name(() => normalizeProvider2(config4.region)().then(async (region) => [
        await config4.regionInfoProvider(region, {
          useFipsEndpoint: await config4.useFipsEndpoint(),
          useDualstackEndpoint: await config4.useDualstackEndpoint()
        }) || {},
        region
      ]).then(([regionInfo, region]) => {
        const { signingRegion, signingService } = regionInfo;
        config4.signingRegion = config4.signingRegion || signingRegion || region;
        config4.signingName = config4.signingName || signingService || config4.serviceId;
        const params = {
          ...config4,
          credentials: boundCredentialsProvider,
          region: config4.signingRegion,
          service: config4.signingName,
          sha256,
          uriEscapePath: signingEscapePath
        };
        const SignerCtor = config4.signerConstructor || SignatureV4;
        return new SignerCtor(params);
      }), "signer");
    } else {
      signer = /* @__PURE__ */ __name(async (authScheme) => {
        authScheme = Object.assign({}, {
          name: "sigv4",
          signingName: config4.signingName || config4.defaultSigningName,
          signingRegion: await normalizeProvider2(config4.region)(),
          properties: {}
        }, authScheme);
        const signingRegion = authScheme.signingRegion;
        const signingService = authScheme.signingName;
        config4.signingRegion = config4.signingRegion || signingRegion;
        config4.signingName = config4.signingName || signingService || config4.serviceId;
        const params = {
          ...config4,
          credentials: boundCredentialsProvider,
          region: config4.signingRegion,
          service: config4.signingName,
          sha256,
          uriEscapePath: signingEscapePath
        };
        const SignerCtor = config4.signerConstructor || SignatureV4;
        return new SignerCtor(params);
      }, "signer");
    }
    return {
      ...config4,
      systemClockOffset,
      signingEscapePath,
      credentials: isUserSupplied ? async () => boundCredentialsProvider().then((creds) => setCredentialFeature(creds, "CREDENTIALS_CODE", "e")) : boundCredentialsProvider,
      signer
    };
  }, "resolveAwsSdkSigV4Config");

  // node_modules/@smithy/middleware-stack/dist-es/MiddlewareStack.js
  var getAllAliases = /* @__PURE__ */ __name((name, aliases) => {
    const _aliases = [];
    if (name) {
      _aliases.push(name);
    }
    if (aliases) {
      for (const alias of aliases) {
        _aliases.push(alias);
      }
    }
    return _aliases;
  }, "getAllAliases");
  var getMiddlewareNameWithAliases = /* @__PURE__ */ __name((name, aliases) => {
    return `${name || "anonymous"}${aliases && aliases.length > 0 ? ` (a.k.a. ${aliases.join(",")})` : ""}`;
  }, "getMiddlewareNameWithAliases");
  var constructStack = /* @__PURE__ */ __name(() => {
    let absoluteEntries = [];
    let relativeEntries = [];
    let identifyOnResolve = false;
    const entriesNameSet = /* @__PURE__ */ new Set();
    const sort2 = /* @__PURE__ */ __name((entries) => entries.sort((a3, b3) => stepWeights[b3.step] - stepWeights[a3.step] || priorityWeights[b3.priority || "normal"] - priorityWeights[a3.priority || "normal"]), "sort");
    const removeByName = /* @__PURE__ */ __name((toRemove) => {
      let isRemoved = false;
      const filterCb = /* @__PURE__ */ __name((entry) => {
        const aliases = getAllAliases(entry.name, entry.aliases);
        if (aliases.includes(toRemove)) {
          isRemoved = true;
          for (const alias of aliases) {
            entriesNameSet.delete(alias);
          }
          return false;
        }
        return true;
      }, "filterCb");
      absoluteEntries = absoluteEntries.filter(filterCb);
      relativeEntries = relativeEntries.filter(filterCb);
      return isRemoved;
    }, "removeByName");
    const removeByReference = /* @__PURE__ */ __name((toRemove) => {
      let isRemoved = false;
      const filterCb = /* @__PURE__ */ __name((entry) => {
        if (entry.middleware === toRemove) {
          isRemoved = true;
          for (const alias of getAllAliases(entry.name, entry.aliases)) {
            entriesNameSet.delete(alias);
          }
          return false;
        }
        return true;
      }, "filterCb");
      absoluteEntries = absoluteEntries.filter(filterCb);
      relativeEntries = relativeEntries.filter(filterCb);
      return isRemoved;
    }, "removeByReference");
    const cloneTo = /* @__PURE__ */ __name((toStack) => {
      absoluteEntries.forEach((entry) => {
        toStack.add(entry.middleware, { ...entry });
      });
      relativeEntries.forEach((entry) => {
        toStack.addRelativeTo(entry.middleware, { ...entry });
      });
      toStack.identifyOnResolve?.(stack.identifyOnResolve());
      return toStack;
    }, "cloneTo");
    const expandRelativeMiddlewareList = /* @__PURE__ */ __name((from) => {
      const expandedMiddlewareList = [];
      from.before.forEach((entry) => {
        if (entry.before.length === 0 && entry.after.length === 0) {
          expandedMiddlewareList.push(entry);
        } else {
          expandedMiddlewareList.push(...expandRelativeMiddlewareList(entry));
        }
      });
      expandedMiddlewareList.push(from);
      from.after.reverse().forEach((entry) => {
        if (entry.before.length === 0 && entry.after.length === 0) {
          expandedMiddlewareList.push(entry);
        } else {
          expandedMiddlewareList.push(...expandRelativeMiddlewareList(entry));
        }
      });
      return expandedMiddlewareList;
    }, "expandRelativeMiddlewareList");
    const getMiddlewareList = /* @__PURE__ */ __name((debug8 = false) => {
      const normalizedAbsoluteEntries = [];
      const normalizedRelativeEntries = [];
      const normalizedEntriesNameMap = {};
      absoluteEntries.forEach((entry) => {
        const normalizedEntry = {
          ...entry,
          before: [],
          after: []
        };
        for (const alias of getAllAliases(normalizedEntry.name, normalizedEntry.aliases)) {
          normalizedEntriesNameMap[alias] = normalizedEntry;
        }
        normalizedAbsoluteEntries.push(normalizedEntry);
      });
      relativeEntries.forEach((entry) => {
        const normalizedEntry = {
          ...entry,
          before: [],
          after: []
        };
        for (const alias of getAllAliases(normalizedEntry.name, normalizedEntry.aliases)) {
          normalizedEntriesNameMap[alias] = normalizedEntry;
        }
        normalizedRelativeEntries.push(normalizedEntry);
      });
      normalizedRelativeEntries.forEach((entry) => {
        if (entry.toMiddleware) {
          const toMiddleware = normalizedEntriesNameMap[entry.toMiddleware];
          if (toMiddleware === void 0) {
            if (debug8) {
              return;
            }
            throw new Error(`${entry.toMiddleware} is not found when adding ${getMiddlewareNameWithAliases(entry.name, entry.aliases)} middleware ${entry.relation} ${entry.toMiddleware}`);
          }
          if (entry.relation === "after") {
            toMiddleware.after.push(entry);
          }
          if (entry.relation === "before") {
            toMiddleware.before.push(entry);
          }
        }
      });
      const mainChain = sort2(normalizedAbsoluteEntries).map(expandRelativeMiddlewareList).reduce((wholeList, expandedMiddlewareList) => {
        wholeList.push(...expandedMiddlewareList);
        return wholeList;
      }, []);
      return mainChain;
    }, "getMiddlewareList");
    const stack = {
      add: (middleware, options = {}) => {
        const { name, override, aliases: _aliases } = options;
        const entry = {
          step: "initialize",
          priority: "normal",
          middleware,
          ...options
        };
        const aliases = getAllAliases(name, _aliases);
        if (aliases.length > 0) {
          if (aliases.some((alias) => entriesNameSet.has(alias))) {
            if (!override)
              throw new Error(`Duplicate middleware name '${getMiddlewareNameWithAliases(name, _aliases)}'`);
            for (const alias of aliases) {
              const toOverrideIndex = absoluteEntries.findIndex((entry2) => entry2.name === alias || entry2.aliases?.some((a3) => a3 === alias));
              if (toOverrideIndex === -1) {
                continue;
              }
              const toOverride = absoluteEntries[toOverrideIndex];
              if (toOverride.step !== entry.step || entry.priority !== toOverride.priority) {
                throw new Error(`"${getMiddlewareNameWithAliases(toOverride.name, toOverride.aliases)}" middleware with ${toOverride.priority} priority in ${toOverride.step} step cannot be overridden by "${getMiddlewareNameWithAliases(name, _aliases)}" middleware with ${entry.priority} priority in ${entry.step} step.`);
              }
              absoluteEntries.splice(toOverrideIndex, 1);
            }
          }
          for (const alias of aliases) {
            entriesNameSet.add(alias);
          }
        }
        absoluteEntries.push(entry);
      },
      addRelativeTo: (middleware, options) => {
        const { name, override, aliases: _aliases } = options;
        const entry = {
          middleware,
          ...options
        };
        const aliases = getAllAliases(name, _aliases);
        if (aliases.length > 0) {
          if (aliases.some((alias) => entriesNameSet.has(alias))) {
            if (!override)
              throw new Error(`Duplicate middleware name '${getMiddlewareNameWithAliases(name, _aliases)}'`);
            for (const alias of aliases) {
              const toOverrideIndex = relativeEntries.findIndex((entry2) => entry2.name === alias || entry2.aliases?.some((a3) => a3 === alias));
              if (toOverrideIndex === -1) {
                continue;
              }
              const toOverride = relativeEntries[toOverrideIndex];
              if (toOverride.toMiddleware !== entry.toMiddleware || toOverride.relation !== entry.relation) {
                throw new Error(`"${getMiddlewareNameWithAliases(toOverride.name, toOverride.aliases)}" middleware ${toOverride.relation} "${toOverride.toMiddleware}" middleware cannot be overridden by "${getMiddlewareNameWithAliases(name, _aliases)}" middleware ${entry.relation} "${entry.toMiddleware}" middleware.`);
              }
              relativeEntries.splice(toOverrideIndex, 1);
            }
          }
          for (const alias of aliases) {
            entriesNameSet.add(alias);
          }
        }
        relativeEntries.push(entry);
      },
      clone: () => cloneTo(constructStack()),
      use: (plugin) => {
        plugin.applyToStack(stack);
      },
      remove: (toRemove) => {
        if (typeof toRemove === "string")
          return removeByName(toRemove);
        else
          return removeByReference(toRemove);
      },
      removeByTag: (toRemove) => {
        let isRemoved = false;
        const filterCb = /* @__PURE__ */ __name((entry) => {
          const { tags, name, aliases: _aliases } = entry;
          if (tags && tags.includes(toRemove)) {
            const aliases = getAllAliases(name, _aliases);
            for (const alias of aliases) {
              entriesNameSet.delete(alias);
            }
            isRemoved = true;
            return false;
          }
          return true;
        }, "filterCb");
        absoluteEntries = absoluteEntries.filter(filterCb);
        relativeEntries = relativeEntries.filter(filterCb);
        return isRemoved;
      },
      concat: (from) => {
        const cloned = cloneTo(constructStack());
        cloned.use(from);
        cloned.identifyOnResolve(identifyOnResolve || cloned.identifyOnResolve() || (from.identifyOnResolve?.() ?? false));
        return cloned;
      },
      applyToStack: cloneTo,
      identify: () => {
        return getMiddlewareList(true).map((mw) => {
          const step = mw.step ?? mw.relation + " " + mw.toMiddleware;
          return getMiddlewareNameWithAliases(mw.name, mw.aliases) + " - " + step;
        });
      },
      identifyOnResolve(toggle) {
        if (typeof toggle === "boolean")
          identifyOnResolve = toggle;
        return identifyOnResolve;
      },
      resolve: (handler, context) => {
        for (const middleware of getMiddlewareList().map((entry) => entry.middleware).reverse()) {
          handler = middleware(handler, context);
        }
        if (identifyOnResolve) {
          console.log(stack.identify());
        }
        return handler;
      }
    };
    return stack;
  }, "constructStack");
  var stepWeights = {
    initialize: 5,
    serialize: 4,
    build: 3,
    finalizeRequest: 2,
    deserialize: 1
  };
  var priorityWeights = {
    high: 3,
    normal: 2,
    low: 1
  };

  // node_modules/@smithy/smithy-client/dist-es/client.js
  var Client = class {
    static {
      __name(this, "Client");
    }
    constructor(config4) {
      this.config = config4;
      this.middlewareStack = constructStack();
    }
    send(command, optionsOrCb, cb2) {
      const options = typeof optionsOrCb !== "function" ? optionsOrCb : void 0;
      const callback = typeof optionsOrCb === "function" ? optionsOrCb : cb2;
      const useHandlerCache = options === void 0 && this.config.cacheMiddleware === true;
      let handler;
      if (useHandlerCache) {
        if (!this.handlers) {
          this.handlers = /* @__PURE__ */ new WeakMap();
        }
        const handlers = this.handlers;
        if (handlers.has(command.constructor)) {
          handler = handlers.get(command.constructor);
        } else {
          handler = command.resolveMiddleware(this.middlewareStack, this.config, options);
          handlers.set(command.constructor, handler);
        }
      } else {
        delete this.handlers;
        handler = command.resolveMiddleware(this.middlewareStack, this.config, options);
      }
      if (callback) {
        handler(command).then((result) => callback(null, result.output), (err) => callback(err)).catch(() => {
        });
      } else {
        return handler(command).then((result) => result.output);
      }
    }
    destroy() {
      this.config?.requestHandler?.destroy?.();
      delete this.handlers;
    }
  };

  // node_modules/@smithy/smithy-client/dist-es/command.js
  var Command = class {
    static {
      __name(this, "Command");
    }
    constructor() {
      this.middlewareStack = constructStack();
    }
    static classBuilder() {
      return new ClassBuilder();
    }
    resolveMiddlewareWithContext(clientStack, configuration, options, { middlewareFn, clientName, commandName, inputFilterSensitiveLog, outputFilterSensitiveLog, smithyContext, additionalContext, CommandCtor }) {
      for (const mw of middlewareFn.bind(this)(CommandCtor, clientStack, configuration, options)) {
        this.middlewareStack.use(mw);
      }
      const stack = clientStack.concat(this.middlewareStack);
      const { logger: logger2 } = configuration;
      const handlerExecutionContext = {
        logger: logger2,
        clientName,
        commandName,
        inputFilterSensitiveLog,
        outputFilterSensitiveLog,
        [SMITHY_CONTEXT_KEY]: {
          commandInstance: this,
          ...smithyContext
        },
        ...additionalContext
      };
      const { requestHandler } = configuration;
      return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
  };
  var ClassBuilder = class {
    static {
      __name(this, "ClassBuilder");
    }
    constructor() {
      this._init = () => {
      };
      this._ep = {};
      this._middlewareFn = () => [];
      this._commandName = "";
      this._clientName = "";
      this._additionalContext = {};
      this._smithyContext = {};
      this._inputFilterSensitiveLog = (_2) => _2;
      this._outputFilterSensitiveLog = (_2) => _2;
      this._serializer = null;
      this._deserializer = null;
    }
    init(cb2) {
      this._init = cb2;
    }
    ep(endpointParameterInstructions) {
      this._ep = endpointParameterInstructions;
      return this;
    }
    m(middlewareSupplier) {
      this._middlewareFn = middlewareSupplier;
      return this;
    }
    s(service, operation, smithyContext = {}) {
      this._smithyContext = {
        service,
        operation,
        ...smithyContext
      };
      return this;
    }
    c(additionalContext = {}) {
      this._additionalContext = additionalContext;
      return this;
    }
    n(clientName, commandName) {
      this._clientName = clientName;
      this._commandName = commandName;
      return this;
    }
    f(inputFilter = (_2) => _2, outputFilter = (_2) => _2) {
      this._inputFilterSensitiveLog = inputFilter;
      this._outputFilterSensitiveLog = outputFilter;
      return this;
    }
    ser(serializer) {
      this._serializer = serializer;
      return this;
    }
    de(deserializer) {
      this._deserializer = deserializer;
      return this;
    }
    build() {
      const closure = this;
      let CommandRef;
      return CommandRef = class extends Command {
        static {
          __name(this, "CommandRef");
        }
        static getEndpointParameterInstructions() {
          return closure._ep;
        }
        constructor(...[input]) {
          super();
          this.serialize = closure._serializer;
          this.deserialize = closure._deserializer;
          this.input = input ?? {};
          closure._init(this);
        }
        resolveMiddleware(stack, configuration, options) {
          return this.resolveMiddlewareWithContext(stack, configuration, options, {
            CommandCtor: CommandRef,
            middlewareFn: closure._middlewareFn,
            clientName: closure._clientName,
            commandName: closure._commandName,
            inputFilterSensitiveLog: closure._inputFilterSensitiveLog,
            outputFilterSensitiveLog: closure._outputFilterSensitiveLog,
            smithyContext: closure._smithyContext,
            additionalContext: closure._additionalContext
          });
        }
      };
    }
  };

  // node_modules/@smithy/smithy-client/dist-es/constants.js
  var SENSITIVE_STRING = "***SensitiveInformation***";

  // node_modules/@smithy/smithy-client/dist-es/parse-utils.js
  var parseBoolean = /* @__PURE__ */ __name((value) => {
    switch (value) {
      case "true":
        return true;
      case "false":
        return false;
      default:
        throw new Error(`Unable to parse boolean value "${value}"`);
    }
  }, "parseBoolean");
  var expectNumber = /* @__PURE__ */ __name((value) => {
    if (value === null || value === void 0) {
      return void 0;
    }
    if (typeof value === "string") {
      const parsed = parseFloat(value);
      if (!Number.isNaN(parsed)) {
        if (String(parsed) !== String(value)) {
          logger.warn(stackTraceWarning(`Expected number but observed string: ${value}`));
        }
        return parsed;
      }
    }
    if (typeof value === "number") {
      return value;
    }
    throw new TypeError(`Expected number, got ${typeof value}: ${value}`);
  }, "expectNumber");
  var MAX_FLOAT = Math.ceil(2 ** 127 * (2 - 2 ** -23));
  var expectFloat32 = /* @__PURE__ */ __name((value) => {
    const expected = expectNumber(value);
    if (expected !== void 0 && !Number.isNaN(expected) && expected !== Infinity && expected !== -Infinity) {
      if (Math.abs(expected) > MAX_FLOAT) {
        throw new TypeError(`Expected 32-bit float, got ${value}`);
      }
    }
    return expected;
  }, "expectFloat32");
  var expectLong = /* @__PURE__ */ __name((value) => {
    if (value === null || value === void 0) {
      return void 0;
    }
    if (Number.isInteger(value) && !Number.isNaN(value)) {
      return value;
    }
    throw new TypeError(`Expected integer, got ${typeof value}: ${value}`);
  }, "expectLong");
  var expectShort = /* @__PURE__ */ __name((value) => expectSizedInt(value, 16), "expectShort");
  var expectByte = /* @__PURE__ */ __name((value) => expectSizedInt(value, 8), "expectByte");
  var expectSizedInt = /* @__PURE__ */ __name((value, size) => {
    const expected = expectLong(value);
    if (expected !== void 0 && castInt(expected, size) !== expected) {
      throw new TypeError(`Expected ${size}-bit integer, got ${value}`);
    }
    return expected;
  }, "expectSizedInt");
  var castInt = /* @__PURE__ */ __name((value, size) => {
    switch (size) {
      case 32:
        return Int32Array.of(value)[0];
      case 16:
        return Int16Array.of(value)[0];
      case 8:
        return Int8Array.of(value)[0];
    }
  }, "castInt");
  var expectNonNull = /* @__PURE__ */ __name((value, location2) => {
    if (value === null || value === void 0) {
      if (location2) {
        throw new TypeError(`Expected a non-null value for ${location2}`);
      }
      throw new TypeError("Expected a non-null value");
    }
    return value;
  }, "expectNonNull");
  var expectObject = /* @__PURE__ */ __name((value) => {
    if (value === null || value === void 0) {
      return void 0;
    }
    if (typeof value === "object" && !Array.isArray(value)) {
      return value;
    }
    const receivedType = Array.isArray(value) ? "array" : typeof value;
    throw new TypeError(`Expected object, got ${receivedType}: ${value}`);
  }, "expectObject");
  var expectString = /* @__PURE__ */ __name((value) => {
    if (value === null || value === void 0) {
      return void 0;
    }
    if (typeof value === "string") {
      return value;
    }
    if (["boolean", "number", "bigint"].includes(typeof value)) {
      logger.warn(stackTraceWarning(`Expected string, got ${typeof value}: ${value}`));
      return String(value);
    }
    throw new TypeError(`Expected string, got ${typeof value}: ${value}`);
  }, "expectString");
  var strictParseFloat32 = /* @__PURE__ */ __name((value) => {
    if (typeof value == "string") {
      return expectFloat32(parseNumber(value));
    }
    return expectFloat32(value);
  }, "strictParseFloat32");
  var NUMBER_REGEX = /(-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?)|(-?Infinity)|(NaN)/g;
  var parseNumber = /* @__PURE__ */ __name((value) => {
    const matches2 = value.match(NUMBER_REGEX);
    if (matches2 === null || matches2[0].length !== value.length) {
      throw new TypeError(`Expected real number, got implicit NaN`);
    }
    return parseFloat(value);
  }, "parseNumber");
  var strictParseLong = /* @__PURE__ */ __name((value) => {
    if (typeof value === "string") {
      return expectLong(parseNumber(value));
    }
    return expectLong(value);
  }, "strictParseLong");
  var strictParseShort = /* @__PURE__ */ __name((value) => {
    if (typeof value === "string") {
      return expectShort(parseNumber(value));
    }
    return expectShort(value);
  }, "strictParseShort");
  var strictParseByte = /* @__PURE__ */ __name((value) => {
    if (typeof value === "string") {
      return expectByte(parseNumber(value));
    }
    return expectByte(value);
  }, "strictParseByte");
  var stackTraceWarning = /* @__PURE__ */ __name((message) => {
    return String(new TypeError(message).stack || message).split("\n").slice(0, 5).filter((s3) => !s3.includes("stackTraceWarning")).join("\n");
  }, "stackTraceWarning");
  var logger = {
    warn: console.warn
  };

  // node_modules/@smithy/smithy-client/dist-es/date-utils.js
  var DAYS = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
  var MONTHS = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
  function dateToUtcString(date) {
    const year = date.getUTCFullYear();
    const month = date.getUTCMonth();
    const dayOfWeek = date.getUTCDay();
    const dayOfMonthInt = date.getUTCDate();
    const hoursInt = date.getUTCHours();
    const minutesInt = date.getUTCMinutes();
    const secondsInt = date.getUTCSeconds();
    const dayOfMonthString = dayOfMonthInt < 10 ? `0${dayOfMonthInt}` : `${dayOfMonthInt}`;
    const hoursString = hoursInt < 10 ? `0${hoursInt}` : `${hoursInt}`;
    const minutesString = minutesInt < 10 ? `0${minutesInt}` : `${minutesInt}`;
    const secondsString = secondsInt < 10 ? `0${secondsInt}` : `${secondsInt}`;
    return `${DAYS[dayOfWeek]}, ${dayOfMonthString} ${MONTHS[month]} ${year} ${hoursString}:${minutesString}:${secondsString} GMT`;
  }
  __name(dateToUtcString, "dateToUtcString");
  var RFC3339 = new RegExp(/^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?[zZ]$/);
  var RFC3339_WITH_OFFSET = new RegExp(/^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?(([-+]\d{2}\:\d{2})|[zZ])$/);
  var parseRfc3339DateTimeWithOffset = /* @__PURE__ */ __name((value) => {
    if (value === null || value === void 0) {
      return void 0;
    }
    if (typeof value !== "string") {
      throw new TypeError("RFC-3339 date-times must be expressed as strings");
    }
    const match2 = RFC3339_WITH_OFFSET.exec(value);
    if (!match2) {
      throw new TypeError("Invalid RFC-3339 date-time value");
    }
    const [_2, yearStr, monthStr, dayStr, hours, minutes, seconds, fractionalMilliseconds, offsetStr] = match2;
    const year = strictParseShort(stripLeadingZeroes(yearStr));
    const month = parseDateValue(monthStr, "month", 1, 12);
    const day = parseDateValue(dayStr, "day", 1, 31);
    const date = buildDate(year, month, day, { hours, minutes, seconds, fractionalMilliseconds });
    if (offsetStr.toUpperCase() != "Z") {
      date.setTime(date.getTime() - parseOffsetToMilliseconds(offsetStr));
    }
    return date;
  }, "parseRfc3339DateTimeWithOffset");
  var IMF_FIXDATE = new RegExp(/^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d{2}) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? GMT$/);
  var RFC_850_DATE = new RegExp(/^(?:Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d{2})-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d{2}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? GMT$/);
  var ASC_TIME = new RegExp(/^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( [1-9]|\d{2}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? (\d{4})$/);
  var buildDate = /* @__PURE__ */ __name((year, month, day, time) => {
    const adjustedMonth = month - 1;
    validateDayOfMonth(year, adjustedMonth, day);
    return new Date(Date.UTC(year, adjustedMonth, day, parseDateValue(time.hours, "hour", 0, 23), parseDateValue(time.minutes, "minute", 0, 59), parseDateValue(time.seconds, "seconds", 0, 60), parseMilliseconds(time.fractionalMilliseconds)));
  }, "buildDate");
  var FIFTY_YEARS_IN_MILLIS = 50 * 365 * 24 * 60 * 60 * 1e3;
  var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  var validateDayOfMonth = /* @__PURE__ */ __name((year, month, day) => {
    let maxDays = DAYS_IN_MONTH[month];
    if (month === 1 && isLeapYear(year)) {
      maxDays = 29;
    }
    if (day > maxDays) {
      throw new TypeError(`Invalid day for ${MONTHS[month]} in ${year}: ${day}`);
    }
  }, "validateDayOfMonth");
  var isLeapYear = /* @__PURE__ */ __name((year) => {
    return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
  }, "isLeapYear");
  var parseDateValue = /* @__PURE__ */ __name((value, type, lower, upper) => {
    const dateVal = strictParseByte(stripLeadingZeroes(value));
    if (dateVal < lower || dateVal > upper) {
      throw new TypeError(`${type} must be between ${lower} and ${upper}, inclusive`);
    }
    return dateVal;
  }, "parseDateValue");
  var parseMilliseconds = /* @__PURE__ */ __name((value) => {
    if (value === null || value === void 0) {
      return 0;
    }
    return strictParseFloat32("0." + value) * 1e3;
  }, "parseMilliseconds");
  var parseOffsetToMilliseconds = /* @__PURE__ */ __name((value) => {
    const directionStr = value[0];
    let direction = 1;
    if (directionStr == "+") {
      direction = 1;
    } else if (directionStr == "-") {
      direction = -1;
    } else {
      throw new TypeError(`Offset direction, ${directionStr}, must be "+" or "-"`);
    }
    const hour = Number(value.substring(1, 3));
    const minute = Number(value.substring(4, 6));
    return direction * (hour * 60 + minute) * 60 * 1e3;
  }, "parseOffsetToMilliseconds");
  var stripLeadingZeroes = /* @__PURE__ */ __name((value) => {
    let idx = 0;
    while (idx < value.length - 1 && value.charAt(idx) === "0") {
      idx++;
    }
    if (idx === 0) {
      return value;
    }
    return value.slice(idx);
  }, "stripLeadingZeroes");

  // node_modules/@smithy/smithy-client/dist-es/exceptions.js
  var ServiceException = class _ServiceException extends Error {
    static {
      __name(this, "ServiceException");
    }
    constructor(options) {
      super(options.message);
      Object.setPrototypeOf(this, Object.getPrototypeOf(this).constructor.prototype);
      this.name = options.name;
      this.$fault = options.$fault;
      this.$metadata = options.$metadata;
    }
    static isInstance(value) {
      if (!value)
        return false;
      const candidate = value;
      return _ServiceException.prototype.isPrototypeOf(candidate) || Boolean(candidate.$fault) && Boolean(candidate.$metadata) && (candidate.$fault === "client" || candidate.$fault === "server");
    }
    static [Symbol.hasInstance](instance) {
      if (!instance)
        return false;
      const candidate = instance;
      if (this === _ServiceException) {
        return _ServiceException.isInstance(instance);
      }
      if (_ServiceException.isInstance(instance)) {
        if (candidate.name && this.name) {
          return this.prototype.isPrototypeOf(instance) || candidate.name === this.name;
        }
        return this.prototype.isPrototypeOf(instance);
      }
      return false;
    }
  };
  var decorateServiceException = /* @__PURE__ */ __name((exception, additions = {}) => {
    Object.entries(additions).filter(([, v3]) => v3 !== void 0).forEach(([k3, v3]) => {
      if (exception[k3] == void 0 || exception[k3] === "") {
        exception[k3] = v3;
      }
    });
    const message = exception.message || exception.Message || "UnknownError";
    exception.message = message;
    delete exception.Message;
    return exception;
  }, "decorateServiceException");

  // node_modules/@smithy/smithy-client/dist-es/default-error-handler.js
  var throwDefaultError = /* @__PURE__ */ __name(({ output, parsedBody, exceptionCtor, errorCode }) => {
    const $metadata = deserializeMetadata(output);
    const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : void 0;
    const response = new exceptionCtor({
      name: parsedBody?.code || parsedBody?.Code || errorCode || statusCode || "UnknownError",
      $fault: "client",
      $metadata
    });
    throw decorateServiceException(response, parsedBody);
  }, "throwDefaultError");
  var withBaseException = /* @__PURE__ */ __name((ExceptionCtor) => {
    return ({ output, parsedBody, errorCode }) => {
      throwDefaultError({ output, parsedBody, exceptionCtor: ExceptionCtor, errorCode });
    };
  }, "withBaseException");
  var deserializeMetadata = /* @__PURE__ */ __name((output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"]
  }), "deserializeMetadata");

  // node_modules/@smithy/smithy-client/dist-es/defaults-mode.js
  var loadConfigsForDefaultMode = /* @__PURE__ */ __name((mode) => {
    switch (mode) {
      case "standard":
        return {
          retryMode: "standard",
          connectionTimeout: 3100
        };
      case "in-region":
        return {
          retryMode: "standard",
          connectionTimeout: 1100
        };
      case "cross-region":
        return {
          retryMode: "standard",
          connectionTimeout: 3100
        };
      case "mobile":
        return {
          retryMode: "standard",
          connectionTimeout: 3e4
        };
      default:
        return {};
    }
  }, "loadConfigsForDefaultMode");

  // node_modules/@smithy/smithy-client/dist-es/extensions/checksum.js
  var getChecksumConfiguration2 = /* @__PURE__ */ __name((runtimeConfig) => {
    const checksumAlgorithms = [];
    for (const id in AlgorithmId) {
      const algorithmId = AlgorithmId[id];
      if (runtimeConfig[algorithmId] === void 0) {
        continue;
      }
      checksumAlgorithms.push({
        algorithmId: () => algorithmId,
        checksumConstructor: () => runtimeConfig[algorithmId]
      });
    }
    return {
      _checksumAlgorithms: checksumAlgorithms,
      addChecksumAlgorithm(algo) {
        this._checksumAlgorithms.push(algo);
      },
      checksumAlgorithms() {
        return this._checksumAlgorithms;
      }
    };
  }, "getChecksumConfiguration");
  var resolveChecksumRuntimeConfig2 = /* @__PURE__ */ __name((clientConfig) => {
    const runtimeConfig = {};
    clientConfig.checksumAlgorithms().forEach((checksumAlgorithm) => {
      runtimeConfig[checksumAlgorithm.algorithmId()] = checksumAlgorithm.checksumConstructor();
    });
    return runtimeConfig;
  }, "resolveChecksumRuntimeConfig");

  // node_modules/@smithy/smithy-client/dist-es/extensions/retry.js
  var getRetryConfiguration = /* @__PURE__ */ __name((runtimeConfig) => {
    let _retryStrategy = runtimeConfig.retryStrategy;
    return {
      setRetryStrategy(retryStrategy) {
        _retryStrategy = retryStrategy;
      },
      retryStrategy() {
        return _retryStrategy;
      }
    };
  }, "getRetryConfiguration");
  var resolveRetryRuntimeConfig = /* @__PURE__ */ __name((retryStrategyConfiguration) => {
    const runtimeConfig = {};
    runtimeConfig.retryStrategy = retryStrategyConfiguration.retryStrategy();
    return runtimeConfig;
  }, "resolveRetryRuntimeConfig");

  // node_modules/@smithy/smithy-client/dist-es/extensions/defaultExtensionConfiguration.js
  var getDefaultExtensionConfiguration = /* @__PURE__ */ __name((runtimeConfig) => {
    return {
      ...getChecksumConfiguration2(runtimeConfig),
      ...getRetryConfiguration(runtimeConfig)
    };
  }, "getDefaultExtensionConfiguration");
  var resolveDefaultRuntimeConfig = /* @__PURE__ */ __name((config4) => {
    return {
      ...resolveChecksumRuntimeConfig2(config4),
      ...resolveRetryRuntimeConfig(config4)
    };
  }, "resolveDefaultRuntimeConfig");

  // node_modules/@smithy/smithy-client/dist-es/get-value-from-text-node.js
  var getValueFromTextNode = /* @__PURE__ */ __name((obj) => {
    const textNodeName = "#text";
    for (const key in obj) {
      if (obj.hasOwnProperty(key) && obj[key][textNodeName] !== void 0) {
        obj[key] = obj[key][textNodeName];
      } else if (typeof obj[key] === "object" && obj[key] !== null) {
        obj[key] = getValueFromTextNode(obj[key]);
      }
    }
    return obj;
  }, "getValueFromTextNode");

  // node_modules/@smithy/smithy-client/dist-es/is-serializable-header-value.js
  var isSerializableHeaderValue = /* @__PURE__ */ __name((value) => {
    return value != null;
  }, "isSerializableHeaderValue");

  // node_modules/@smithy/smithy-client/dist-es/lazy-json.js
  var LazyJsonString = /* @__PURE__ */ __name(function LazyJsonString2(val2) {
    const str = Object.assign(new String(val2), {
      deserializeJSON() {
        return JSON.parse(String(val2));
      },
      toString() {
        return String(val2);
      },
      toJSON() {
        return String(val2);
      }
    });
    return str;
  }, "LazyJsonString");
  LazyJsonString.from = (object) => {
    if (object && typeof object === "object" && (object instanceof LazyJsonString || "deserializeJSON" in object)) {
      return object;
    } else if (typeof object === "string" || Object.getPrototypeOf(object) === String.prototype) {
      return LazyJsonString(String(object));
    }
    return LazyJsonString(JSON.stringify(object));
  };
  LazyJsonString.fromObject = LazyJsonString.from;

  // node_modules/@smithy/smithy-client/dist-es/NoOpLogger.js
  var NoOpLogger = class {
    static {
      __name(this, "NoOpLogger");
    }
    trace() {
    }
    debug() {
    }
    info() {
    }
    warn() {
    }
    error() {
    }
  };

  // node_modules/@smithy/smithy-client/dist-es/object-mapping.js
  function map(arg0, arg1, arg2) {
    let target;
    let filter;
    let instructions;
    if (typeof arg1 === "undefined" && typeof arg2 === "undefined") {
      target = {};
      instructions = arg0;
    } else {
      target = arg0;
      if (typeof arg1 === "function") {
        filter = arg1;
        instructions = arg2;
        return mapWithFilter(target, filter, instructions);
      } else {
        instructions = arg1;
      }
    }
    for (const key of Object.keys(instructions)) {
      if (!Array.isArray(instructions[key])) {
        target[key] = instructions[key];
        continue;
      }
      applyInstruction(target, null, instructions, key);
    }
    return target;
  }
  __name(map, "map");
  var mapWithFilter = /* @__PURE__ */ __name((target, filter, instructions) => {
    return map(target, Object.entries(instructions).reduce((_instructions, [key, value]) => {
      if (Array.isArray(value)) {
        _instructions[key] = value;
      } else {
        if (typeof value === "function") {
          _instructions[key] = [filter, value()];
        } else {
          _instructions[key] = [filter, value];
        }
      }
      return _instructions;
    }, {}));
  }, "mapWithFilter");
  var applyInstruction = /* @__PURE__ */ __name((target, source, instructions, targetKey) => {
    if (source !== null) {
      let instruction = instructions[targetKey];
      if (typeof instruction === "function") {
        instruction = [, instruction];
      }
      const [filter2 = nonNullish, valueFn = pass, sourceKey = targetKey] = instruction;
      if (typeof filter2 === "function" && filter2(source[sourceKey]) || typeof filter2 !== "function" && !!filter2) {
        target[targetKey] = valueFn(source[sourceKey]);
      }
      return;
    }
    let [filter, value] = instructions[targetKey];
    if (typeof value === "function") {
      let _value;
      const defaultFilterPassed = filter === void 0 && (_value = value()) != null;
      const customFilterPassed = typeof filter === "function" && !!filter(void 0) || typeof filter !== "function" && !!filter;
      if (defaultFilterPassed) {
        target[targetKey] = _value;
      } else if (customFilterPassed) {
        target[targetKey] = value();
      }
    } else {
      const defaultFilterPassed = filter === void 0 && value != null;
      const customFilterPassed = typeof filter === "function" && !!filter(value) || typeof filter !== "function" && !!filter;
      if (defaultFilterPassed || customFilterPassed) {
        target[targetKey] = value;
      }
    }
  }, "applyInstruction");
  var nonNullish = /* @__PURE__ */ __name((_2) => _2 != null, "nonNullish");
  var pass = /* @__PURE__ */ __name((_2) => _2, "pass");

  // node_modules/@smithy/smithy-client/dist-es/ser-utils.js
  var serializeDateTime = /* @__PURE__ */ __name((date) => date.toISOString().replace(".000Z", "Z"), "serializeDateTime");

  // node_modules/@aws-sdk/core/dist-es/submodules/protocols/common.js
  var collectBodyString = /* @__PURE__ */ __name((streamBody, context) => collectBody(streamBody, context).then((body) => context.utf8Encoder(body)), "collectBodyString");

  // node_modules/@aws-sdk/core/dist-es/submodules/protocols/xml/parseXmlBody.js
  var import_fast_xml_parser = __toESM(require_fxp());
  var parseXmlBody = /* @__PURE__ */ __name((streamBody, context) => collectBodyString(streamBody, context).then((encoded) => {
    if (encoded.length) {
      const parser = new import_fast_xml_parser.XMLParser({
        attributeNamePrefix: "",
        htmlEntities: true,
        ignoreAttributes: false,
        ignoreDeclaration: true,
        parseTagValue: false,
        trimValues: false,
        tagValueProcessor: (_2, val2) => val2.trim() === "" && val2.includes("\n") ? "" : void 0
      });
      parser.addEntity("#xD", "\r");
      parser.addEntity("#10", "\n");
      let parsedObj;
      try {
        parsedObj = parser.parse(encoded, true);
      } catch (e3) {
        if (e3 && typeof e3 === "object") {
          Object.defineProperty(e3, "$responseBodyText", {
            value: encoded
          });
        }
        throw e3;
      }
      const textNodeName = "#text";
      const key = Object.keys(parsedObj)[0];
      const parsedObjToReturn = parsedObj[key];
      if (parsedObjToReturn[textNodeName]) {
        parsedObjToReturn[key] = parsedObjToReturn[textNodeName];
        delete parsedObjToReturn[textNodeName];
      }
      return getValueFromTextNode(parsedObjToReturn);
    }
    return {};
  }), "parseXmlBody");
  var parseXmlErrorBody = /* @__PURE__ */ __name(async (errorBody, context) => {
    const value = await parseXmlBody(errorBody, context);
    if (value.Error) {
      value.Error.message = value.Error.message ?? value.Error.Message;
    }
    return value;
  }, "parseXmlErrorBody");
  var loadRestXmlErrorCode = /* @__PURE__ */ __name((output, data) => {
    if (data?.Error?.Code !== void 0) {
      return data.Error.Code;
    }
    if (data?.Code !== void 0) {
      return data.Code;
    }
    if (output.statusCode == 404) {
      return "NotFound";
    }
  }, "loadRestXmlErrorCode");

  // node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/types.js
  var CLIENT_SUPPORTED_ALGORITHMS = [
    ChecksumAlgorithm.CRC32,
    ChecksumAlgorithm.CRC32C,
    ChecksumAlgorithm.CRC64NVME,
    ChecksumAlgorithm.SHA1,
    ChecksumAlgorithm.SHA256
  ];
  var PRIORITY_ORDER_ALGORITHMS = [
    ChecksumAlgorithm.SHA256,
    ChecksumAlgorithm.SHA1,
    ChecksumAlgorithm.CRC32,
    ChecksumAlgorithm.CRC32C,
    ChecksumAlgorithm.CRC64NVME
  ];

  // node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/getChecksumAlgorithmForRequest.js
  var getChecksumAlgorithmForRequest = /* @__PURE__ */ __name((input, { requestChecksumRequired, requestAlgorithmMember, requestChecksumCalculation }) => {
    if (!requestAlgorithmMember) {
      return requestChecksumCalculation === RequestChecksumCalculation.WHEN_SUPPORTED || requestChecksumRequired ? DEFAULT_CHECKSUM_ALGORITHM : void 0;
    }
    if (!input[requestAlgorithmMember]) {
      return void 0;
    }
    const checksumAlgorithm = input[requestAlgorithmMember];
    if (!CLIENT_SUPPORTED_ALGORITHMS.includes(checksumAlgorithm)) {
      throw new Error(`The checksum algorithm "${checksumAlgorithm}" is not supported by the client. Select one of ${CLIENT_SUPPORTED_ALGORITHMS}.`);
    }
    return checksumAlgorithm;
  }, "getChecksumAlgorithmForRequest");

  // node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/getChecksumLocationName.js
  var getChecksumLocationName = /* @__PURE__ */ __name((algorithm) => algorithm === ChecksumAlgorithm.MD5 ? "content-md5" : `x-amz-checksum-${algorithm.toLowerCase()}`, "getChecksumLocationName");

  // node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/hasHeader.js
  var hasHeader2 = /* @__PURE__ */ __name((header, headers) => {
    const soughtHeader = header.toLowerCase();
    for (const headerName of Object.keys(headers)) {
      if (soughtHeader === headerName.toLowerCase()) {
        return true;
      }
    }
    return false;
  }, "hasHeader");

  // node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/hasHeaderWithPrefix.js
  var hasHeaderWithPrefix = /* @__PURE__ */ __name((headerPrefix, headers) => {
    const soughtHeaderPrefix = headerPrefix.toLowerCase();
    for (const headerName of Object.keys(headers)) {
      if (headerName.toLowerCase().startsWith(soughtHeaderPrefix)) {
        return true;
      }
    }
    return false;
  }, "hasHeaderWithPrefix");

  // node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/isStreaming.js
  var isStreaming = /* @__PURE__ */ __name((body) => body !== void 0 && typeof body !== "string" && !ArrayBuffer.isView(body) && !isArrayBuffer(body), "isStreaming");

  // node_modules/tslib/tslib.es6.mjs
  function __awaiter(thisArg, _arguments, P3, generator) {
    function adopt(value) {
      return value instanceof P3 ? value : new P3(function(resolve) {
        resolve(value);
      });
    }
    __name(adopt, "adopt");
    return new (P3 || (P3 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e3) {
          reject(e3);
        }
      }
      __name(fulfilled, "fulfilled");
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e3) {
          reject(e3);
        }
      }
      __name(rejected, "rejected");
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      __name(step, "step");
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  }
  __name(__awaiter, "__awaiter");
  function __generator(thisArg, body) {
    var _2 = { label: 0, sent: function() {
      if (t3[0] & 1)
        throw t3[1];
      return t3[1];
    }, trys: [], ops: [] }, f3, y3, t3, g3;
    return g3 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g3[Symbol.iterator] = function() {
      return this;
    }), g3;
    function verb(n3) {
      return function(v3) {
        return step([n3, v3]);
      };
    }
    __name(verb, "verb");
    function step(op) {
      if (f3)
        throw new TypeError("Generator is already executing.");
      while (g3 && (g3 = 0, op[0] && (_2 = 0)), _2)
        try {
          if (f3 = 1, y3 && (t3 = op[0] & 2 ? y3["return"] : op[0] ? y3["throw"] || ((t3 = y3["return"]) && t3.call(y3), 0) : y3.next) && !(t3 = t3.call(y3, op[1])).done)
            return t3;
          if (y3 = 0, t3)
            op = [op[0] & 2, t3.value];
          switch (op[0]) {
            case 0:
            case 1:
              t3 = op;
              break;
            case 4:
              _2.label++;
              return { value: op[1], done: false };
            case 5:
              _2.label++;
              y3 = op[1];
              op = [0];
              continue;
            case 7:
              op = _2.ops.pop();
              _2.trys.pop();
              continue;
            default:
              if (!(t3 = _2.trys, t3 = t3.length > 0 && t3[t3.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _2 = 0;
                continue;
              }
              if (op[0] === 3 && (!t3 || op[1] > t3[0] && op[1] < t3[3])) {
                _2.label = op[1];
                break;
              }
              if (op[0] === 6 && _2.label < t3[1]) {
                _2.label = t3[1];
                t3 = op;
                break;
              }
              if (t3 && _2.label < t3[2]) {
                _2.label = t3[2];
                _2.ops.push(op);
                break;
              }
              if (t3[2])
                _2.ops.pop();
              _2.trys.pop();
              continue;
          }
          op = body.call(thisArg, _2);
        } catch (e3) {
          op = [6, e3];
          y3 = 0;
        } finally {
          f3 = t3 = 0;
        }
      if (op[0] & 5)
        throw op[1];
      return { value: op[0] ? op[1] : void 0, done: true };
    }
    __name(step, "step");
  }
  __name(__generator, "__generator");
  function __values(o3) {
    var s3 = typeof Symbol === "function" && Symbol.iterator, m3 = s3 && o3[s3], i3 = 0;
    if (m3)
      return m3.call(o3);
    if (o3 && typeof o3.length === "number")
      return {
        next: function() {
          if (o3 && i3 >= o3.length)
            o3 = void 0;
          return { value: o3 && o3[i3++], done: !o3 };
        }
      };
    throw new TypeError(s3 ? "Object is not iterable." : "Symbol.iterator is not defined.");
  }
  __name(__values, "__values");

  // node_modules/@aws-crypto/util/node_modules/@smithy/util-utf8/dist-es/fromUtf8.browser.js
  var fromUtf82 = /* @__PURE__ */ __name((input) => new TextEncoder().encode(input), "fromUtf8");

  // node_modules/@aws-crypto/util/build/module/convertToBuffer.js
  var fromUtf83 = typeof Buffer !== "undefined" && Buffer.from ? function(input) {
    return Buffer.from(input, "utf8");
  } : fromUtf82;
  function convertToBuffer(data) {
    if (data instanceof Uint8Array)
      return data;
    if (typeof data === "string") {
      return fromUtf83(data);
    }
    if (ArrayBuffer.isView(data)) {
      return new Uint8Array(data.buffer, data.byteOffset, data.byteLength / Uint8Array.BYTES_PER_ELEMENT);
    }
    return new Uint8Array(data);
  }
  __name(convertToBuffer, "convertToBuffer");

  // node_modules/@aws-crypto/util/build/module/isEmptyData.js
  function isEmptyData(data) {
    if (typeof data === "string") {
      return data.length === 0;
    }
    return data.byteLength === 0;
  }
  __name(isEmptyData, "isEmptyData");

  // node_modules/@aws-crypto/util/build/module/numToUint8.js
  function numToUint8(num) {
    return new Uint8Array([
      (num & 4278190080) >> 24,
      (num & 16711680) >> 16,
      (num & 65280) >> 8,
      num & 255
    ]);
  }
  __name(numToUint8, "numToUint8");

  // node_modules/@aws-crypto/util/build/module/uint32ArrayFrom.js
  function uint32ArrayFrom(a_lookUpTable2) {
    if (!Uint32Array.from) {
      var return_array = new Uint32Array(a_lookUpTable2.length);
      var a_index = 0;
      while (a_index < a_lookUpTable2.length) {
        return_array[a_index] = a_lookUpTable2[a_index];
        a_index += 1;
      }
      return return_array;
    }
    return Uint32Array.from(a_lookUpTable2);
  }
  __name(uint32ArrayFrom, "uint32ArrayFrom");

  // node_modules/@aws-crypto/crc32c/build/module/aws_crc32c.js
  var AwsCrc32c = (
    /** @class */
    function() {
      function AwsCrc32c2() {
        this.crc32c = new Crc32c();
      }
      __name(AwsCrc32c2, "AwsCrc32c");
      AwsCrc32c2.prototype.update = function(toHash) {
        if (isEmptyData(toHash))
          return;
        this.crc32c.update(convertToBuffer(toHash));
      };
      AwsCrc32c2.prototype.digest = function() {
        return __awaiter(this, void 0, void 0, function() {
          return __generator(this, function(_a) {
            return [2, numToUint8(this.crc32c.digest())];
          });
        });
      };
      AwsCrc32c2.prototype.reset = function() {
        this.crc32c = new Crc32c();
      };
      return AwsCrc32c2;
    }()
  );

  // node_modules/@aws-crypto/crc32c/build/module/index.js
  var Crc32c = (
    /** @class */
    function() {
      function Crc32c2() {
        this.checksum = 4294967295;
      }
      __name(Crc32c2, "Crc32c");
      Crc32c2.prototype.update = function(data) {
        var e_1, _a;
        try {
          for (var data_1 = __values(data), data_1_1 = data_1.next(); !data_1_1.done; data_1_1 = data_1.next()) {
            var byte = data_1_1.value;
            this.checksum = this.checksum >>> 8 ^ lookupTable[(this.checksum ^ byte) & 255];
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (data_1_1 && !data_1_1.done && (_a = data_1.return))
              _a.call(data_1);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
        return this;
      };
      Crc32c2.prototype.digest = function() {
        return (this.checksum ^ 4294967295) >>> 0;
      };
      return Crc32c2;
    }()
  );
  var a_lookupTable = [
    0,
    4067132163,
    3778769143,
    324072436,
    3348797215,
    904991772,
    648144872,
    3570033899,
    2329499855,
    2024987596,
    1809983544,
    2575936315,
    1296289744,
    3207089363,
    2893594407,
    1578318884,
    274646895,
    3795141740,
    4049975192,
    51262619,
    3619967088,
    632279923,
    922689671,
    3298075524,
    2592579488,
    1760304291,
    2075979607,
    2312596564,
    1562183871,
    2943781820,
    3156637768,
    1313733451,
    549293790,
    3537243613,
    3246849577,
    871202090,
    3878099393,
    357341890,
    102525238,
    4101499445,
    2858735121,
    1477399826,
    1264559846,
    3107202533,
    1845379342,
    2677391885,
    2361733625,
    2125378298,
    820201905,
    3263744690,
    3520608582,
    598981189,
    4151959214,
    85089709,
    373468761,
    3827903834,
    3124367742,
    1213305469,
    1526817161,
    2842354314,
    2107672161,
    2412447074,
    2627466902,
    1861252501,
    1098587580,
    3004210879,
    2688576843,
    1378610760,
    2262928035,
    1955203488,
    1742404180,
    2511436119,
    3416409459,
    969524848,
    714683780,
    3639785095,
    205050476,
    4266873199,
    3976438427,
    526918040,
    1361435347,
    2739821008,
    2954799652,
    1114974503,
    2529119692,
    1691668175,
    2005155131,
    2247081528,
    3690758684,
    697762079,
    986182379,
    3366744552,
    476452099,
    3993867776,
    4250756596,
    255256311,
    1640403810,
    2477592673,
    2164122517,
    1922457750,
    2791048317,
    1412925310,
    1197962378,
    3037525897,
    3944729517,
    427051182,
    170179418,
    4165941337,
    746937522,
    3740196785,
    3451792453,
    1070968646,
    1905808397,
    2213795598,
    2426610938,
    1657317369,
    3053634322,
    1147748369,
    1463399397,
    2773627110,
    4215344322,
    153784257,
    444234805,
    3893493558,
    1021025245,
    3467647198,
    3722505002,
    797665321,
    2197175160,
    1889384571,
    1674398607,
    2443626636,
    1164749927,
    3070701412,
    2757221520,
    1446797203,
    137323447,
    4198817972,
    3910406976,
    461344835,
    3484808360,
    1037989803,
    781091935,
    3705997148,
    2460548119,
    1623424788,
    1939049696,
    2180517859,
    1429367560,
    2807687179,
    3020495871,
    1180866812,
    410100952,
    3927582683,
    4182430767,
    186734380,
    3756733383,
    763408580,
    1053836080,
    3434856499,
    2722870694,
    1344288421,
    1131464017,
    2971354706,
    1708204729,
    2545590714,
    2229949006,
    1988219213,
    680717673,
    3673779818,
    3383336350,
    1002577565,
    4010310262,
    493091189,
    238226049,
    4233660802,
    2987750089,
    1082061258,
    1395524158,
    2705686845,
    1972364758,
    2279892693,
    2494862625,
    1725896226,
    952904198,
    3399985413,
    3656866545,
    731699698,
    4283874585,
    222117402,
    510512622,
    3959836397,
    3280807620,
    837199303,
    582374963,
    3504198960,
    68661723,
    4135334616,
    3844915500,
    390545967,
    1230274059,
    3141532936,
    2825850620,
    1510247935,
    2395924756,
    2091215383,
    1878366691,
    2644384480,
    3553878443,
    565732008,
    854102364,
    3229815391,
    340358836,
    3861050807,
    4117890627,
    119113024,
    1493875044,
    2875275879,
    3090270611,
    1247431312,
    2660249211,
    1828433272,
    2141937292,
    2378227087,
    3811616794,
    291187481,
    34330861,
    4032846830,
    615137029,
    3603020806,
    3314634738,
    939183345,
    1776939221,
    2609017814,
    2295496738,
    2058945313,
    2926798794,
    1545135305,
    1330124605,
    3173225534,
    4084100981,
    17165430,
    307568514,
    3762199681,
    888469610,
    3332340585,
    3587147933,
    665062302,
    2042050490,
    2346497209,
    2559330125,
    1793573966,
    3190661285,
    1279665062,
    1595330642,
    2910671697
  ];
  var lookupTable = uint32ArrayFrom(a_lookupTable);

  // node_modules/@aws-crypto/crc32/build/module/aws_crc32.js
  var AwsCrc32 = (
    /** @class */
    function() {
      function AwsCrc322() {
        this.crc32 = new Crc32();
      }
      __name(AwsCrc322, "AwsCrc32");
      AwsCrc322.prototype.update = function(toHash) {
        if (isEmptyData(toHash))
          return;
        this.crc32.update(convertToBuffer(toHash));
      };
      AwsCrc322.prototype.digest = function() {
        return __awaiter(this, void 0, void 0, function() {
          return __generator(this, function(_a) {
            return [2, numToUint8(this.crc32.digest())];
          });
        });
      };
      AwsCrc322.prototype.reset = function() {
        this.crc32 = new Crc32();
      };
      return AwsCrc322;
    }()
  );

  // node_modules/@aws-crypto/crc32/build/module/index.js
  var Crc32 = (
    /** @class */
    function() {
      function Crc322() {
        this.checksum = 4294967295;
      }
      __name(Crc322, "Crc32");
      Crc322.prototype.update = function(data) {
        var e_1, _a;
        try {
          for (var data_1 = __values(data), data_1_1 = data_1.next(); !data_1_1.done; data_1_1 = data_1.next()) {
            var byte = data_1_1.value;
            this.checksum = this.checksum >>> 8 ^ lookupTable2[(this.checksum ^ byte) & 255];
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (data_1_1 && !data_1_1.done && (_a = data_1.return))
              _a.call(data_1);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
        return this;
      };
      Crc322.prototype.digest = function() {
        return (this.checksum ^ 4294967295) >>> 0;
      };
      return Crc322;
    }()
  );
  var a_lookUpTable = [
    0,
    1996959894,
    3993919788,
    2567524794,
    124634137,
    1886057615,
    3915621685,
    2657392035,
    249268274,
    2044508324,
    3772115230,
    2547177864,
    162941995,
    2125561021,
    3887607047,
    2428444049,
    498536548,
    1789927666,
    4089016648,
    2227061214,
    450548861,
    1843258603,
    4107580753,
    2211677639,
    325883990,
    1684777152,
    4251122042,
    2321926636,
    335633487,
    1661365465,
    4195302755,
    2366115317,
    997073096,
    1281953886,
    3579855332,
    2724688242,
    1006888145,
    1258607687,
    3524101629,
    2768942443,
    901097722,
    1119000684,
    3686517206,
    2898065728,
    853044451,
    1172266101,
    3705015759,
    2882616665,
    651767980,
    1373503546,
    3369554304,
    3218104598,
    565507253,
    1454621731,
    3485111705,
    3099436303,
    671266974,
    1594198024,
    3322730930,
    2970347812,
    795835527,
    1483230225,
    3244367275,
    3060149565,
    1994146192,
    31158534,
    2563907772,
    4023717930,
    1907459465,
    112637215,
    2680153253,
    3904427059,
    2013776290,
    251722036,
    2517215374,
    3775830040,
    2137656763,
    141376813,
    2439277719,
    3865271297,
    1802195444,
    476864866,
    2238001368,
    4066508878,
    1812370925,
    453092731,
    2181625025,
    4111451223,
    1706088902,
    314042704,
    2344532202,
    4240017532,
    1658658271,
    366619977,
    2362670323,
    4224994405,
    1303535960,
    984961486,
    2747007092,
    3569037538,
    1256170817,
    1037604311,
    2765210733,
    3554079995,
    1131014506,
    879679996,
    2909243462,
    3663771856,
    1141124467,
    855842277,
    2852801631,
    3708648649,
    1342533948,
    654459306,
    3188396048,
    3373015174,
    1466479909,
    544179635,
    3110523913,
    3462522015,
    1591671054,
    702138776,
    2966460450,
    3352799412,
    1504918807,
    783551873,
    3082640443,
    3233442989,
    3988292384,
    2596254646,
    62317068,
    1957810842,
    3939845945,
    2647816111,
    81470997,
    1943803523,
    3814918930,
    2489596804,
    225274430,
    2053790376,
    3826175755,
    2466906013,
    167816743,
    2097651377,
    4027552580,
    2265490386,
    503444072,
    1762050814,
    4150417245,
    2154129355,
    426522225,
    1852507879,
    4275313526,
    2312317920,
    282753626,
    1742555852,
    4189708143,
    2394877945,
    397917763,
    1622183637,
    3604390888,
    2714866558,
    953729732,
    1340076626,
    3518719985,
    2797360999,
    1068828381,
    1219638859,
    3624741850,
    2936675148,
    906185462,
    1090812512,
    3747672003,
    2825379669,
    829329135,
    1181335161,
    3412177804,
    3160834842,
    628085408,
    1382605366,
    3423369109,
    3138078467,
    570562233,
    1426400815,
    3317316542,
    2998733608,
    733239954,
    1555261956,
    3268935591,
    3050360625,
    752459403,
    1541320221,
    2607071920,
    3965973030,
    1969922972,
    40735498,
    2617837225,
    3943577151,
    1913087877,
    83908371,
    2512341634,
    3803740692,
    2075208622,
    213261112,
    2463272603,
    3855990285,
    2094854071,
    198958881,
    2262029012,
    4057260610,
    1759359992,
    534414190,
    2176718541,
    4139329115,
    1873836001,
    414664567,
    2282248934,
    4279200368,
    1711684554,
    285281116,
    2405801727,
    4167216745,
    1634467795,
    376229701,
    2685067896,
    3608007406,
    1308918612,
    956543938,
    2808555105,
    3495958263,
    1231636301,
    1047427035,
    2932959818,
    3654703836,
    1088359270,
    936918e3,
    2847714899,
    3736837829,
    1202900863,
    817233897,
    3183342108,
    3401237130,
    1404277552,
    615818150,
    3134207493,
    3453421203,
    1423857449,
    601450431,
    3009837614,
    3294710456,
    1567103746,
    711928724,
    3020668471,
    3272380065,
    1510334235,
    755167117
  ];
  var lookupTable2 = uint32ArrayFrom(a_lookUpTable);

  // node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/getCrc32ChecksumAlgorithmFunction.browser.js
  var getCrc32ChecksumAlgorithmFunction = /* @__PURE__ */ __name(() => AwsCrc32, "getCrc32ChecksumAlgorithmFunction");

  // node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/selectChecksumAlgorithmFunction.js
  var selectChecksumAlgorithmFunction = /* @__PURE__ */ __name((checksumAlgorithm, config4) => {
    switch (checksumAlgorithm) {
      case ChecksumAlgorithm.MD5:
        return config4.md5;
      case ChecksumAlgorithm.CRC32:
        return getCrc32ChecksumAlgorithmFunction();
      case ChecksumAlgorithm.CRC32C:
        return AwsCrc32c;
      case ChecksumAlgorithm.CRC64NVME:
        if (typeof crc64NvmeCrtContainer.CrtCrc64Nvme !== "function") {
          throw new Error(`Please check whether you have installed the "@aws-sdk/crc64-nvme-crt" package explicitly. 
You must also register the package by calling [require("@aws-sdk/crc64-nvme-crt");] or an ESM equivalent such as [import "@aws-sdk/crc64-nvme-crt";]. 
For more information please go to https://github.com/aws/aws-sdk-js-v3#functionality-requiring-aws-common-runtime-crt`);
        }
        return crc64NvmeCrtContainer.CrtCrc64Nvme;
      case ChecksumAlgorithm.SHA1:
        return config4.sha1;
      case ChecksumAlgorithm.SHA256:
        return config4.sha256;
      default:
        throw new Error(`Unsupported checksum algorithm: ${checksumAlgorithm}`);
    }
  }, "selectChecksumAlgorithmFunction");

  // node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/stringHasher.js
  var stringHasher = /* @__PURE__ */ __name((checksumAlgorithmFn, body) => {
    const hash = new checksumAlgorithmFn();
    hash.update(toUint8Array(body || ""));
    return hash.digest();
  }, "stringHasher");

  // node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/flexibleChecksumsMiddleware.js
  var flexibleChecksumsMiddlewareOptions = {
    name: "flexibleChecksumsMiddleware",
    step: "build",
    tags: ["BODY_CHECKSUM"],
    override: true
  };
  var flexibleChecksumsMiddleware = /* @__PURE__ */ __name((config4, middlewareConfig) => (next, context) => async (args) => {
    if (!HttpRequest.isInstance(args.request)) {
      return next(args);
    }
    if (hasHeaderWithPrefix("x-amz-checksum-", args.request.headers)) {
      return next(args);
    }
    const { request, input } = args;
    const { body: requestBody, headers } = request;
    const { base64Encoder, streamHasher } = config4;
    const { requestChecksumRequired, requestAlgorithmMember } = middlewareConfig;
    const requestChecksumCalculation = await config4.requestChecksumCalculation();
    const requestAlgorithmMemberName = requestAlgorithmMember?.name;
    const requestAlgorithmMemberHttpHeader = requestAlgorithmMember?.httpHeader;
    if (requestAlgorithmMemberName && !input[requestAlgorithmMemberName]) {
      if (requestChecksumCalculation === RequestChecksumCalculation.WHEN_SUPPORTED || requestChecksumRequired) {
        input[requestAlgorithmMemberName] = DEFAULT_CHECKSUM_ALGORITHM;
        if (requestAlgorithmMemberHttpHeader) {
          headers[requestAlgorithmMemberHttpHeader] = DEFAULT_CHECKSUM_ALGORITHM;
        }
      }
    }
    const checksumAlgorithm = getChecksumAlgorithmForRequest(input, {
      requestChecksumRequired,
      requestAlgorithmMember: requestAlgorithmMember?.name,
      requestChecksumCalculation
    });
    let updatedBody = requestBody;
    let updatedHeaders = headers;
    if (checksumAlgorithm) {
      switch (checksumAlgorithm) {
        case ChecksumAlgorithm.CRC32:
          setFeature(context, "FLEXIBLE_CHECKSUMS_REQ_CRC32", "U");
          break;
        case ChecksumAlgorithm.CRC32C:
          setFeature(context, "FLEXIBLE_CHECKSUMS_REQ_CRC32C", "V");
          break;
        case ChecksumAlgorithm.CRC64NVME:
          setFeature(context, "FLEXIBLE_CHECKSUMS_REQ_CRC64", "W");
          break;
        case ChecksumAlgorithm.SHA1:
          setFeature(context, "FLEXIBLE_CHECKSUMS_REQ_SHA1", "X");
          break;
        case ChecksumAlgorithm.SHA256:
          setFeature(context, "FLEXIBLE_CHECKSUMS_REQ_SHA256", "Y");
          break;
      }
      const checksumLocationName = getChecksumLocationName(checksumAlgorithm);
      const checksumAlgorithmFn = selectChecksumAlgorithmFunction(checksumAlgorithm, config4);
      if (isStreaming(requestBody)) {
        const { getAwsChunkedEncodingStream: getAwsChunkedEncodingStream2, bodyLengthChecker } = config4;
        updatedBody = getAwsChunkedEncodingStream2(typeof config4.requestStreamBufferSize === "number" && config4.requestStreamBufferSize >= 8 * 1024 ? createBufferedReadable(requestBody, config4.requestStreamBufferSize, context.logger) : requestBody, {
          base64Encoder,
          bodyLengthChecker,
          checksumLocationName,
          checksumAlgorithmFn,
          streamHasher
        });
        updatedHeaders = {
          ...headers,
          "content-encoding": headers["content-encoding"] ? `${headers["content-encoding"]},aws-chunked` : "aws-chunked",
          "transfer-encoding": "chunked",
          "x-amz-decoded-content-length": headers["content-length"],
          "x-amz-content-sha256": "STREAMING-UNSIGNED-PAYLOAD-TRAILER",
          "x-amz-trailer": checksumLocationName
        };
        delete updatedHeaders["content-length"];
      } else if (!hasHeader2(checksumLocationName, headers)) {
        const rawChecksum = await stringHasher(checksumAlgorithmFn, requestBody);
        updatedHeaders = {
          ...headers,
          [checksumLocationName]: base64Encoder(rawChecksum)
        };
      }
    }
    const result = await next({
      ...args,
      request: {
        ...request,
        headers: updatedHeaders,
        body: updatedBody
      }
    });
    return result;
  }, "flexibleChecksumsMiddleware");

  // node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/flexibleChecksumsInputMiddleware.js
  var flexibleChecksumsInputMiddlewareOptions = {
    name: "flexibleChecksumsInputMiddleware",
    toMiddleware: "serializerMiddleware",
    relation: "before",
    tags: ["BODY_CHECKSUM"],
    override: true
  };
  var flexibleChecksumsInputMiddleware = /* @__PURE__ */ __name((config4, middlewareConfig) => (next, context) => async (args) => {
    const input = args.input;
    const { requestValidationModeMember } = middlewareConfig;
    const requestChecksumCalculation = await config4.requestChecksumCalculation();
    const responseChecksumValidation = await config4.responseChecksumValidation();
    switch (requestChecksumCalculation) {
      case RequestChecksumCalculation.WHEN_REQUIRED:
        setFeature(context, "FLEXIBLE_CHECKSUMS_REQ_WHEN_REQUIRED", "a");
        break;
      case RequestChecksumCalculation.WHEN_SUPPORTED:
        setFeature(context, "FLEXIBLE_CHECKSUMS_REQ_WHEN_SUPPORTED", "Z");
        break;
    }
    switch (responseChecksumValidation) {
      case ResponseChecksumValidation.WHEN_REQUIRED:
        setFeature(context, "FLEXIBLE_CHECKSUMS_RES_WHEN_REQUIRED", "c");
        break;
      case ResponseChecksumValidation.WHEN_SUPPORTED:
        setFeature(context, "FLEXIBLE_CHECKSUMS_RES_WHEN_SUPPORTED", "b");
        break;
    }
    if (requestValidationModeMember && !input[requestValidationModeMember]) {
      if (responseChecksumValidation === ResponseChecksumValidation.WHEN_SUPPORTED) {
        input[requestValidationModeMember] = "ENABLED";
      }
    }
    return next(args);
  }, "flexibleChecksumsInputMiddleware");

  // node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/getChecksumAlgorithmListForResponse.js
  var getChecksumAlgorithmListForResponse = /* @__PURE__ */ __name((responseAlgorithms = []) => {
    const validChecksumAlgorithms = [];
    for (const algorithm of PRIORITY_ORDER_ALGORITHMS) {
      if (!responseAlgorithms.includes(algorithm) || !CLIENT_SUPPORTED_ALGORITHMS.includes(algorithm)) {
        continue;
      }
      validChecksumAlgorithms.push(algorithm);
    }
    return validChecksumAlgorithms;
  }, "getChecksumAlgorithmListForResponse");

  // node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/isChecksumWithPartNumber.js
  var isChecksumWithPartNumber = /* @__PURE__ */ __name((checksum) => {
    const lastHyphenIndex = checksum.lastIndexOf("-");
    if (lastHyphenIndex !== -1) {
      const numberPart = checksum.slice(lastHyphenIndex + 1);
      if (!numberPart.startsWith("0")) {
        const number = parseInt(numberPart, 10);
        if (!isNaN(number) && number >= 1 && number <= 1e4) {
          return true;
        }
      }
    }
    return false;
  }, "isChecksumWithPartNumber");

  // node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/getChecksum.js
  var getChecksum = /* @__PURE__ */ __name(async (body, { checksumAlgorithmFn, base64Encoder }) => base64Encoder(await stringHasher(checksumAlgorithmFn, body)), "getChecksum");

  // node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/validateChecksumFromResponse.js
  var validateChecksumFromResponse = /* @__PURE__ */ __name(async (response, { config: config4, responseAlgorithms, logger: logger2 }) => {
    const checksumAlgorithms = getChecksumAlgorithmListForResponse(responseAlgorithms);
    const { body: responseBody, headers: responseHeaders } = response;
    for (const algorithm of checksumAlgorithms) {
      const responseHeader = getChecksumLocationName(algorithm);
      const checksumFromResponse = responseHeaders[responseHeader];
      if (checksumFromResponse) {
        let checksumAlgorithmFn;
        try {
          checksumAlgorithmFn = selectChecksumAlgorithmFunction(algorithm, config4);
        } catch (error) {
          if (algorithm === ChecksumAlgorithm.CRC64NVME) {
            logger2?.warn(`Skipping ${ChecksumAlgorithm.CRC64NVME} checksum validation: ${error.message}`);
            continue;
          }
          throw error;
        }
        const { base64Encoder } = config4;
        if (isStreaming(responseBody)) {
          response.body = createChecksumStream({
            expectedChecksum: checksumFromResponse,
            checksumSourceLocation: responseHeader,
            checksum: new checksumAlgorithmFn(),
            source: responseBody,
            base64Encoder
          });
          return;
        }
        const checksum = await getChecksum(responseBody, { checksumAlgorithmFn, base64Encoder });
        if (checksum === checksumFromResponse) {
          break;
        }
        throw new Error(`Checksum mismatch: expected "${checksum}" but received "${checksumFromResponse}" in response header "${responseHeader}".`);
      }
    }
  }, "validateChecksumFromResponse");

  // node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/flexibleChecksumsResponseMiddleware.js
  var flexibleChecksumsResponseMiddlewareOptions = {
    name: "flexibleChecksumsResponseMiddleware",
    toMiddleware: "deserializerMiddleware",
    relation: "after",
    tags: ["BODY_CHECKSUM"],
    override: true
  };
  var flexibleChecksumsResponseMiddleware = /* @__PURE__ */ __name((config4, middlewareConfig) => (next, context) => async (args) => {
    if (!HttpRequest.isInstance(args.request)) {
      return next(args);
    }
    const input = args.input;
    const result = await next(args);
    const response = result.response;
    const { requestValidationModeMember, responseAlgorithms } = middlewareConfig;
    if (requestValidationModeMember && input[requestValidationModeMember] === "ENABLED") {
      const { clientName, commandName } = context;
      const isS3WholeObjectMultipartGetResponseChecksum = clientName === "S3Client" && commandName === "GetObjectCommand" && getChecksumAlgorithmListForResponse(responseAlgorithms).every((algorithm) => {
        const responseHeader = getChecksumLocationName(algorithm);
        const checksumFromResponse = response.headers[responseHeader];
        return !checksumFromResponse || isChecksumWithPartNumber(checksumFromResponse);
      });
      if (isS3WholeObjectMultipartGetResponseChecksum) {
        return result;
      }
      await validateChecksumFromResponse(response, {
        config: config4,
        responseAlgorithms,
        logger: context.logger
      });
    }
    return result;
  }, "flexibleChecksumsResponseMiddleware");

  // node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/getFlexibleChecksumsPlugin.js
  var getFlexibleChecksumsPlugin = /* @__PURE__ */ __name((config4, middlewareConfig) => ({
    applyToStack: (clientStack) => {
      clientStack.add(flexibleChecksumsMiddleware(config4, middlewareConfig), flexibleChecksumsMiddlewareOptions);
      clientStack.addRelativeTo(flexibleChecksumsInputMiddleware(config4, middlewareConfig), flexibleChecksumsInputMiddlewareOptions);
      clientStack.addRelativeTo(flexibleChecksumsResponseMiddleware(config4, middlewareConfig), flexibleChecksumsResponseMiddlewareOptions);
    }
  }), "getFlexibleChecksumsPlugin");

  // node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/resolveFlexibleChecksumsConfig.js
  var resolveFlexibleChecksumsConfig = /* @__PURE__ */ __name((input) => ({
    ...input,
    requestChecksumCalculation: normalizeProvider(input.requestChecksumCalculation ?? DEFAULT_REQUEST_CHECKSUM_CALCULATION),
    responseChecksumValidation: normalizeProvider(input.responseChecksumValidation ?? DEFAULT_RESPONSE_CHECKSUM_VALIDATION),
    requestStreamBufferSize: Number(input.requestStreamBufferSize ?? 0)
  }), "resolveFlexibleChecksumsConfig");

  // node_modules/@aws-sdk/middleware-host-header/dist-es/index.js
  function resolveHostHeaderConfig(input) {
    return input;
  }
  __name(resolveHostHeaderConfig, "resolveHostHeaderConfig");
  var hostHeaderMiddleware = /* @__PURE__ */ __name((options) => (next) => async (args) => {
    if (!HttpRequest.isInstance(args.request))
      return next(args);
    const { request } = args;
    const { handlerProtocol = "" } = options.requestHandler.metadata || {};
    if (handlerProtocol.indexOf("h2") >= 0 && !request.headers[":authority"]) {
      delete request.headers["host"];
      request.headers[":authority"] = request.hostname + (request.port ? ":" + request.port : "");
    } else if (!request.headers["host"]) {
      let host = request.hostname;
      if (request.port != null)
        host += `:${request.port}`;
      request.headers["host"] = host;
    }
    return next(args);
  }, "hostHeaderMiddleware");
  var hostHeaderMiddlewareOptions = {
    name: "hostHeaderMiddleware",
    step: "build",
    priority: "low",
    tags: ["HOST"],
    override: true
  };
  var getHostHeaderPlugin = /* @__PURE__ */ __name((options) => ({
    applyToStack: (clientStack) => {
      clientStack.add(hostHeaderMiddleware(options), hostHeaderMiddlewareOptions);
    }
  }), "getHostHeaderPlugin");

  // node_modules/@aws-sdk/middleware-logger/dist-es/loggerMiddleware.js
  var loggerMiddleware = /* @__PURE__ */ __name(() => (next, context) => async (args) => {
    try {
      const response = await next(args);
      const { clientName, commandName, logger: logger2, dynamoDbDocumentClientOptions = {} } = context;
      const { overrideInputFilterSensitiveLog, overrideOutputFilterSensitiveLog } = dynamoDbDocumentClientOptions;
      const inputFilterSensitiveLog = overrideInputFilterSensitiveLog ?? context.inputFilterSensitiveLog;
      const outputFilterSensitiveLog = overrideOutputFilterSensitiveLog ?? context.outputFilterSensitiveLog;
      const { $metadata, ...outputWithoutMetadata } = response.output;
      logger2?.info?.({
        clientName,
        commandName,
        input: inputFilterSensitiveLog(args.input),
        output: outputFilterSensitiveLog(outputWithoutMetadata),
        metadata: $metadata
      });
      return response;
    } catch (error) {
      const { clientName, commandName, logger: logger2, dynamoDbDocumentClientOptions = {} } = context;
      const { overrideInputFilterSensitiveLog } = dynamoDbDocumentClientOptions;
      const inputFilterSensitiveLog = overrideInputFilterSensitiveLog ?? context.inputFilterSensitiveLog;
      logger2?.error?.({
        clientName,
        commandName,
        input: inputFilterSensitiveLog(args.input),
        error,
        metadata: error.$metadata
      });
      throw error;
    }
  }, "loggerMiddleware");
  var loggerMiddlewareOptions = {
    name: "loggerMiddleware",
    tags: ["LOGGER"],
    step: "initialize",
    override: true
  };
  var getLoggerPlugin = /* @__PURE__ */ __name((options) => ({
    applyToStack: (clientStack) => {
      clientStack.add(loggerMiddleware(), loggerMiddlewareOptions);
    }
  }), "getLoggerPlugin");

  // node_modules/@aws-sdk/middleware-recursion-detection/dist-es/index.js
  var TRACE_ID_HEADER_NAME = "X-Amzn-Trace-Id";
  var ENV_LAMBDA_FUNCTION_NAME = "AWS_LAMBDA_FUNCTION_NAME";
  var ENV_TRACE_ID = "_X_AMZN_TRACE_ID";
  var recursionDetectionMiddleware = /* @__PURE__ */ __name((options) => (next) => async (args) => {
    const { request } = args;
    if (!HttpRequest.isInstance(request) || options.runtime !== "node" || request.headers.hasOwnProperty(TRACE_ID_HEADER_NAME)) {
      return next(args);
    }
    const functionName = process.env[ENV_LAMBDA_FUNCTION_NAME];
    const traceId = process.env[ENV_TRACE_ID];
    const nonEmptyString = /* @__PURE__ */ __name((str) => typeof str === "string" && str.length > 0, "nonEmptyString");
    if (nonEmptyString(functionName) && nonEmptyString(traceId)) {
      request.headers[TRACE_ID_HEADER_NAME] = traceId;
    }
    return next({
      ...args,
      request
    });
  }, "recursionDetectionMiddleware");
  var addRecursionDetectionMiddlewareOptions = {
    step: "build",
    tags: ["RECURSION_DETECTION"],
    name: "recursionDetectionMiddleware",
    override: true,
    priority: "low"
  };
  var getRecursionDetectionPlugin = /* @__PURE__ */ __name((options) => ({
    applyToStack: (clientStack) => {
      clientStack.add(recursionDetectionMiddleware(options), addRecursionDetectionMiddlewareOptions);
    }
  }), "getRecursionDetectionPlugin");

  // node_modules/@aws-sdk/middleware-sdk-s3/dist-es/check-content-length-header.js
  var CONTENT_LENGTH_HEADER = "content-length";
  var DECODED_CONTENT_LENGTH_HEADER = "x-amz-decoded-content-length";
  function checkContentLengthHeader() {
    return (next, context) => async (args) => {
      const { request } = args;
      if (HttpRequest.isInstance(request)) {
        if (!(CONTENT_LENGTH_HEADER in request.headers) && !(DECODED_CONTENT_LENGTH_HEADER in request.headers)) {
          const message = `Are you using a Stream of unknown length as the Body of a PutObject request? Consider using Upload instead from @aws-sdk/lib-storage.`;
          if (typeof context?.logger?.warn === "function" && !(context.logger instanceof NoOpLogger)) {
            context.logger.warn(message);
          } else {
            console.warn(message);
          }
        }
      }
      return next({ ...args });
    };
  }
  __name(checkContentLengthHeader, "checkContentLengthHeader");
  var checkContentLengthHeaderMiddlewareOptions = {
    step: "finalizeRequest",
    tags: ["CHECK_CONTENT_LENGTH_HEADER"],
    name: "getCheckContentLengthHeaderPlugin",
    override: true
  };
  var getCheckContentLengthHeaderPlugin = /* @__PURE__ */ __name((unused) => ({
    applyToStack: (clientStack) => {
      clientStack.add(checkContentLengthHeader(), checkContentLengthHeaderMiddlewareOptions);
    }
  }), "getCheckContentLengthHeaderPlugin");

  // node_modules/@aws-sdk/middleware-sdk-s3/dist-es/region-redirect-endpoint-middleware.js
  var regionRedirectEndpointMiddleware = /* @__PURE__ */ __name((config4) => {
    return (next, context) => async (args) => {
      const originalRegion = await config4.region();
      const regionProviderRef = config4.region;
      let unlock = /* @__PURE__ */ __name(() => {
      }, "unlock");
      if (context.__s3RegionRedirect) {
        Object.defineProperty(config4, "region", {
          writable: false,
          value: async () => {
            return context.__s3RegionRedirect;
          }
        });
        unlock = /* @__PURE__ */ __name(() => Object.defineProperty(config4, "region", {
          writable: true,
          value: regionProviderRef
        }), "unlock");
      }
      try {
        const result = await next(args);
        if (context.__s3RegionRedirect) {
          unlock();
          const region = await config4.region();
          if (originalRegion !== region) {
            throw new Error("Region was not restored following S3 region redirect.");
          }
        }
        return result;
      } catch (e3) {
        unlock();
        throw e3;
      }
    };
  }, "regionRedirectEndpointMiddleware");
  var regionRedirectEndpointMiddlewareOptions = {
    tags: ["REGION_REDIRECT", "S3"],
    name: "regionRedirectEndpointMiddleware",
    override: true,
    relation: "before",
    toMiddleware: "endpointV2Middleware"
  };

  // node_modules/@aws-sdk/middleware-sdk-s3/dist-es/region-redirect-middleware.js
  function regionRedirectMiddleware(clientConfig) {
    return (next, context) => async (args) => {
      try {
        return await next(args);
      } catch (err) {
        if (clientConfig.followRegionRedirects) {
          if (err?.$metadata?.httpStatusCode === 301 || err?.$metadata?.httpStatusCode === 400 && err?.name === "IllegalLocationConstraintException") {
            try {
              const actualRegion = err.$response.headers["x-amz-bucket-region"];
              context.logger?.debug(`Redirecting from ${await clientConfig.region()} to ${actualRegion}`);
              context.__s3RegionRedirect = actualRegion;
            } catch (e3) {
              throw new Error("Region redirect failed: " + e3);
            }
            return next(args);
          }
        }
        throw err;
      }
    };
  }
  __name(regionRedirectMiddleware, "regionRedirectMiddleware");
  var regionRedirectMiddlewareOptions = {
    step: "initialize",
    tags: ["REGION_REDIRECT", "S3"],
    name: "regionRedirectMiddleware",
    override: true
  };
  var getRegionRedirectMiddlewarePlugin = /* @__PURE__ */ __name((clientConfig) => ({
    applyToStack: (clientStack) => {
      clientStack.add(regionRedirectMiddleware(clientConfig), regionRedirectMiddlewareOptions);
      clientStack.addRelativeTo(regionRedirectEndpointMiddleware(clientConfig), regionRedirectEndpointMiddlewareOptions);
    }
  }), "getRegionRedirectMiddlewarePlugin");

  // node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3-express/classes/S3ExpressIdentityCache.js
  var S3ExpressIdentityCache = class _S3ExpressIdentityCache {
    static {
      __name(this, "S3ExpressIdentityCache");
    }
    data;
    lastPurgeTime = Date.now();
    static EXPIRED_CREDENTIAL_PURGE_INTERVAL_MS = 3e4;
    constructor(data = {}) {
      this.data = data;
    }
    get(key) {
      const entry = this.data[key];
      if (!entry) {
        return;
      }
      return entry;
    }
    set(key, entry) {
      this.data[key] = entry;
      return entry;
    }
    delete(key) {
      delete this.data[key];
    }
    async purgeExpired() {
      const now2 = Date.now();
      if (this.lastPurgeTime + _S3ExpressIdentityCache.EXPIRED_CREDENTIAL_PURGE_INTERVAL_MS > now2) {
        return;
      }
      for (const key in this.data) {
        const entry = this.data[key];
        if (!entry.isRefreshing) {
          const credential = await entry.identity;
          if (credential.expiration) {
            if (credential.expiration.getTime() < now2) {
              delete this.data[key];
            }
          }
        }
      }
    }
  };

  // node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3-express/classes/S3ExpressIdentityCacheEntry.js
  var S3ExpressIdentityCacheEntry = class {
    static {
      __name(this, "S3ExpressIdentityCacheEntry");
    }
    _identity;
    isRefreshing;
    accessed;
    constructor(_identity, isRefreshing = false, accessed = Date.now()) {
      this._identity = _identity;
      this.isRefreshing = isRefreshing;
      this.accessed = accessed;
    }
    get identity() {
      this.accessed = Date.now();
      return this._identity;
    }
  };

  // node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3-express/classes/S3ExpressIdentityProviderImpl.js
  var S3ExpressIdentityProviderImpl = class _S3ExpressIdentityProviderImpl {
    static {
      __name(this, "S3ExpressIdentityProviderImpl");
    }
    createSessionFn;
    cache;
    static REFRESH_WINDOW_MS = 6e4;
    constructor(createSessionFn, cache3 = new S3ExpressIdentityCache()) {
      this.createSessionFn = createSessionFn;
      this.cache = cache3;
    }
    async getS3ExpressIdentity(awsIdentity, identityProperties) {
      const key = identityProperties.Bucket;
      const { cache: cache3 } = this;
      const entry = cache3.get(key);
      if (entry) {
        return entry.identity.then((identity2) => {
          const isExpired = (identity2.expiration?.getTime() ?? 0) < Date.now();
          if (isExpired) {
            return cache3.set(key, new S3ExpressIdentityCacheEntry(this.getIdentity(key))).identity;
          }
          const isExpiringSoon = (identity2.expiration?.getTime() ?? 0) < Date.now() + _S3ExpressIdentityProviderImpl.REFRESH_WINDOW_MS;
          if (isExpiringSoon && !entry.isRefreshing) {
            entry.isRefreshing = true;
            this.getIdentity(key).then((id) => {
              cache3.set(key, new S3ExpressIdentityCacheEntry(Promise.resolve(id)));
            });
          }
          return identity2;
        });
      }
      return cache3.set(key, new S3ExpressIdentityCacheEntry(this.getIdentity(key))).identity;
    }
    async getIdentity(key) {
      await this.cache.purgeExpired().catch((error) => {
        console.warn("Error while clearing expired entries in S3ExpressIdentityCache: \n" + error);
      });
      const session2 = await this.createSessionFn(key);
      if (!session2.Credentials?.AccessKeyId || !session2.Credentials?.SecretAccessKey) {
        throw new Error("s3#createSession response credential missing AccessKeyId or SecretAccessKey.");
      }
      const identity2 = {
        accessKeyId: session2.Credentials.AccessKeyId,
        secretAccessKey: session2.Credentials.SecretAccessKey,
        sessionToken: session2.Credentials.SessionToken,
        expiration: session2.Credentials.Expiration ? new Date(session2.Credentials.Expiration) : void 0
      };
      return identity2;
    }
  };

  // node_modules/@smithy/util-config-provider/dist-es/types.js
  var SelectorType2;
  (function(SelectorType3) {
    SelectorType3["ENV"] = "env";
    SelectorType3["CONFIG"] = "shared config entry";
  })(SelectorType2 || (SelectorType2 = {}));

  // node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3-express/constants.js
  var S3_EXPRESS_BUCKET_TYPE = "Directory";
  var S3_EXPRESS_BACKEND = "S3Express";
  var S3_EXPRESS_AUTH_SCHEME = "sigv4-s3express";
  var SESSION_TOKEN_QUERY_PARAM = "X-Amz-S3session-Token";
  var SESSION_TOKEN_HEADER = SESSION_TOKEN_QUERY_PARAM.toLowerCase();

  // node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3-express/classes/SignatureV4S3Express.js
  var SignatureV4S3Express = class extends SignatureV4 {
    static {
      __name(this, "SignatureV4S3Express");
    }
    async signWithCredentials(requestToSign, credentials, options) {
      const credentialsWithoutSessionToken = getCredentialsWithoutSessionToken(credentials);
      requestToSign.headers[SESSION_TOKEN_HEADER] = credentials.sessionToken;
      const privateAccess = this;
      setSingleOverride(privateAccess, credentialsWithoutSessionToken);
      return privateAccess.signRequest(requestToSign, options ?? {});
    }
    async presignWithCredentials(requestToSign, credentials, options) {
      const credentialsWithoutSessionToken = getCredentialsWithoutSessionToken(credentials);
      delete requestToSign.headers[SESSION_TOKEN_HEADER];
      requestToSign.headers[SESSION_TOKEN_QUERY_PARAM] = credentials.sessionToken;
      requestToSign.query = requestToSign.query ?? {};
      requestToSign.query[SESSION_TOKEN_QUERY_PARAM] = credentials.sessionToken;
      const privateAccess = this;
      setSingleOverride(privateAccess, credentialsWithoutSessionToken);
      return this.presign(requestToSign, options);
    }
  };
  function getCredentialsWithoutSessionToken(credentials) {
    const credentialsWithoutSessionToken = {
      accessKeyId: credentials.accessKeyId,
      secretAccessKey: credentials.secretAccessKey,
      expiration: credentials.expiration
    };
    return credentialsWithoutSessionToken;
  }
  __name(getCredentialsWithoutSessionToken, "getCredentialsWithoutSessionToken");
  function setSingleOverride(privateAccess, credentialsWithoutSessionToken) {
    const id = setTimeout(() => {
      throw new Error("SignatureV4S3Express credential override was created but not called.");
    }, 10);
    const currentCredentialProvider = privateAccess.credentialProvider;
    const overrideCredentialsProviderOnce = /* @__PURE__ */ __name(() => {
      clearTimeout(id);
      privateAccess.credentialProvider = currentCredentialProvider;
      return Promise.resolve(credentialsWithoutSessionToken);
    }, "overrideCredentialsProviderOnce");
    privateAccess.credentialProvider = overrideCredentialsProviderOnce;
  }
  __name(setSingleOverride, "setSingleOverride");

  // node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3-express/functions/s3ExpressMiddleware.js
  var s3ExpressMiddleware = /* @__PURE__ */ __name((options) => {
    return (next, context) => async (args) => {
      if (context.endpointV2) {
        const endpoint = context.endpointV2;
        const isS3ExpressAuth = endpoint.properties?.authSchemes?.[0]?.name === S3_EXPRESS_AUTH_SCHEME;
        const isS3ExpressBucket = endpoint.properties?.backend === S3_EXPRESS_BACKEND || endpoint.properties?.bucketType === S3_EXPRESS_BUCKET_TYPE;
        if (isS3ExpressBucket) {
          setFeature(context, "S3_EXPRESS_BUCKET", "J");
          context.isS3ExpressBucket = true;
        }
        if (isS3ExpressAuth) {
          const requestBucket = args.input.Bucket;
          if (requestBucket) {
            const s3ExpressIdentity = await options.s3ExpressIdentityProvider.getS3ExpressIdentity(await options.credentials(), {
              Bucket: requestBucket
            });
            context.s3ExpressIdentity = s3ExpressIdentity;
            if (HttpRequest.isInstance(args.request) && s3ExpressIdentity.sessionToken) {
              args.request.headers[SESSION_TOKEN_HEADER] = s3ExpressIdentity.sessionToken;
            }
          }
        }
      }
      return next(args);
    };
  }, "s3ExpressMiddleware");
  var s3ExpressMiddlewareOptions = {
    name: "s3ExpressMiddleware",
    step: "build",
    tags: ["S3", "S3_EXPRESS"],
    override: true
  };
  var getS3ExpressPlugin = /* @__PURE__ */ __name((options) => ({
    applyToStack: (clientStack) => {
      clientStack.add(s3ExpressMiddleware(options), s3ExpressMiddlewareOptions);
    }
  }), "getS3ExpressPlugin");

  // node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3-express/functions/signS3Express.js
  var signS3Express = /* @__PURE__ */ __name(async (s3ExpressIdentity, signingOptions, request, sigV4MultiRegionSigner) => {
    const signedRequest = await sigV4MultiRegionSigner.signWithCredentials(request, s3ExpressIdentity, {});
    if (signedRequest.headers["X-Amz-Security-Token"] || signedRequest.headers["x-amz-security-token"]) {
      throw new Error("X-Amz-Security-Token must not be set for s3-express requests.");
    }
    return signedRequest;
  }, "signS3Express");

  // node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3-express/functions/s3ExpressHttpSigningMiddleware.js
  var defaultErrorHandler2 = /* @__PURE__ */ __name((signingProperties) => (error) => {
    throw error;
  }, "defaultErrorHandler");
  var defaultSuccessHandler2 = /* @__PURE__ */ __name((httpResponse, signingProperties) => {
  }, "defaultSuccessHandler");
  var s3ExpressHttpSigningMiddleware = /* @__PURE__ */ __name((config4) => (next, context) => async (args) => {
    if (!HttpRequest.isInstance(args.request)) {
      return next(args);
    }
    const smithyContext = getSmithyContext(context);
    const scheme = smithyContext.selectedHttpAuthScheme;
    if (!scheme) {
      throw new Error(`No HttpAuthScheme was selected: unable to sign request`);
    }
    const { httpAuthOption: { signingProperties = {} }, identity: identity2, signer } = scheme;
    let request;
    if (context.s3ExpressIdentity) {
      request = await signS3Express(context.s3ExpressIdentity, signingProperties, args.request, await config4.signer());
    } else {
      request = await signer.sign(args.request, identity2, signingProperties);
    }
    const output = await next({
      ...args,
      request
    }).catch((signer.errorHandler || defaultErrorHandler2)(signingProperties));
    (signer.successHandler || defaultSuccessHandler2)(output.response, signingProperties);
    return output;
  }, "s3ExpressHttpSigningMiddleware");
  var getS3ExpressHttpSigningPlugin = /* @__PURE__ */ __name((config4) => ({
    applyToStack: (clientStack) => {
      clientStack.addRelativeTo(s3ExpressHttpSigningMiddleware(config4), httpSigningMiddlewareOptions);
    }
  }), "getS3ExpressHttpSigningPlugin");

  // node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3Configuration.js
  var resolveS3Config = /* @__PURE__ */ __name((input, { session: session2 }) => {
    const [s3ClientProvider, CreateSessionCommandCtor] = session2;
    return {
      ...input,
      forcePathStyle: input.forcePathStyle ?? false,
      useAccelerateEndpoint: input.useAccelerateEndpoint ?? false,
      disableMultiregionAccessPoints: input.disableMultiregionAccessPoints ?? false,
      followRegionRedirects: input.followRegionRedirects ?? false,
      s3ExpressIdentityProvider: input.s3ExpressIdentityProvider ?? new S3ExpressIdentityProviderImpl(async (key) => s3ClientProvider().send(new CreateSessionCommandCtor({
        Bucket: key
      }))),
      bucketEndpoint: input.bucketEndpoint ?? false
    };
  }, "resolveS3Config");

  // node_modules/@aws-sdk/middleware-sdk-s3/dist-es/throw-200-exceptions.js
  var THROW_IF_EMPTY_BODY = {
    CopyObjectCommand: true,
    UploadPartCopyCommand: true,
    CompleteMultipartUploadCommand: true
  };
  var MAX_BYTES_TO_INSPECT = 3e3;
  var throw200ExceptionsMiddleware = /* @__PURE__ */ __name((config4) => (next, context) => async (args) => {
    const result = await next(args);
    const { response } = result;
    if (!HttpResponse.isInstance(response)) {
      return result;
    }
    const { statusCode, body: sourceBody } = response;
    if (statusCode < 200 || statusCode >= 300) {
      return result;
    }
    const isSplittableStream = typeof sourceBody?.stream === "function" || typeof sourceBody?.pipe === "function" || typeof sourceBody?.tee === "function";
    if (!isSplittableStream) {
      return result;
    }
    let bodyCopy = sourceBody;
    let body = sourceBody;
    if (sourceBody && typeof sourceBody === "object" && !(sourceBody instanceof Uint8Array)) {
      [bodyCopy, body] = await splitStream(sourceBody);
    }
    response.body = body;
    const bodyBytes = await collectBody2(bodyCopy, {
      streamCollector: async (stream) => {
        return headStream(stream, MAX_BYTES_TO_INSPECT);
      }
    });
    if (typeof bodyCopy?.destroy === "function") {
      bodyCopy.destroy();
    }
    const bodyStringTail = config4.utf8Encoder(bodyBytes.subarray(bodyBytes.length - 16));
    if (bodyBytes.length === 0 && THROW_IF_EMPTY_BODY[context.commandName]) {
      const err = new Error("S3 aborted request");
      err.name = "InternalError";
      throw err;
    }
    if (bodyStringTail && bodyStringTail.endsWith("</Error>")) {
      response.statusCode = 400;
    }
    return result;
  }, "throw200ExceptionsMiddleware");
  var collectBody2 = /* @__PURE__ */ __name((streamBody = new Uint8Array(), context) => {
    if (streamBody instanceof Uint8Array) {
      return Promise.resolve(streamBody);
    }
    return context.streamCollector(streamBody) || Promise.resolve(new Uint8Array());
  }, "collectBody");
  var throw200ExceptionsMiddlewareOptions = {
    relation: "after",
    toMiddleware: "deserializerMiddleware",
    tags: ["THROW_200_EXCEPTIONS", "S3"],
    name: "throw200ExceptionsMiddleware",
    override: true
  };
  var getThrow200ExceptionsPlugin = /* @__PURE__ */ __name((config4) => ({
    applyToStack: (clientStack) => {
      clientStack.addRelativeTo(throw200ExceptionsMiddleware(config4), throw200ExceptionsMiddlewareOptions);
    }
  }), "getThrow200ExceptionsPlugin");

  // node_modules/@aws-sdk/util-arn-parser/dist-es/index.js
  var validate = /* @__PURE__ */ __name((str) => typeof str === "string" && str.indexOf("arn:") === 0 && str.split(":").length >= 6, "validate");

  // node_modules/@aws-sdk/middleware-sdk-s3/dist-es/bucket-endpoint-middleware.js
  function bucketEndpointMiddleware(options) {
    return (next, context) => async (args) => {
      if (options.bucketEndpoint) {
        const endpoint = context.endpointV2;
        if (endpoint) {
          const bucket = args.input.Bucket;
          if (typeof bucket === "string") {
            try {
              const bucketEndpointUrl = new URL(bucket);
              context.endpointV2 = {
                ...endpoint,
                url: bucketEndpointUrl
              };
            } catch (e3) {
              const warning = `@aws-sdk/middleware-sdk-s3: bucketEndpoint=true was set but Bucket=${bucket} could not be parsed as URL.`;
              if (context.logger?.constructor?.name === "NoOpLogger") {
                console.warn(warning);
              } else {
                context.logger?.warn?.(warning);
              }
              throw e3;
            }
          }
        }
      }
      return next(args);
    };
  }
  __name(bucketEndpointMiddleware, "bucketEndpointMiddleware");
  var bucketEndpointMiddlewareOptions = {
    name: "bucketEndpointMiddleware",
    override: true,
    relation: "after",
    toMiddleware: "endpointV2Middleware"
  };

  // node_modules/@aws-sdk/middleware-sdk-s3/dist-es/validate-bucket-name.js
  function validateBucketNameMiddleware({ bucketEndpoint }) {
    return (next) => async (args) => {
      const { input: { Bucket } } = args;
      if (!bucketEndpoint && typeof Bucket === "string" && !validate(Bucket) && Bucket.indexOf("/") >= 0) {
        const err = new Error(`Bucket name shouldn't contain '/', received '${Bucket}'`);
        err.name = "InvalidBucketName";
        throw err;
      }
      return next({ ...args });
    };
  }
  __name(validateBucketNameMiddleware, "validateBucketNameMiddleware");
  var validateBucketNameMiddlewareOptions = {
    step: "initialize",
    tags: ["VALIDATE_BUCKET_NAME"],
    name: "validateBucketNameMiddleware",
    override: true
  };
  var getValidateBucketNamePlugin = /* @__PURE__ */ __name((options) => ({
    applyToStack: (clientStack) => {
      clientStack.add(validateBucketNameMiddleware(options), validateBucketNameMiddlewareOptions);
      clientStack.addRelativeTo(bucketEndpointMiddleware(options), bucketEndpointMiddlewareOptions);
    }
  }), "getValidateBucketNamePlugin");

  // node_modules/@aws-sdk/middleware-user-agent/dist-es/configurations.js
  var DEFAULT_UA_APP_ID = void 0;
  function isValidUserAgentAppId(appId) {
    if (appId === void 0) {
      return true;
    }
    return typeof appId === "string" && appId.length <= 50;
  }
  __name(isValidUserAgentAppId, "isValidUserAgentAppId");
  function resolveUserAgentConfig(input) {
    const normalizedAppIdProvider = normalizeProvider2(input.userAgentAppId ?? DEFAULT_UA_APP_ID);
    return {
      ...input,
      customUserAgent: typeof input.customUserAgent === "string" ? [[input.customUserAgent]] : input.customUserAgent,
      userAgentAppId: async () => {
        const appId = await normalizedAppIdProvider();
        if (!isValidUserAgentAppId(appId)) {
          const logger2 = input.logger?.constructor?.name === "NoOpLogger" || !input.logger ? console : input.logger;
          if (typeof appId !== "string") {
            logger2?.warn("userAgentAppId must be a string or undefined.");
          } else if (appId.length > 50) {
            logger2?.warn("The provided userAgentAppId exceeds the maximum length of 50 characters.");
          }
        }
        return appId;
      }
    };
  }
  __name(resolveUserAgentConfig, "resolveUserAgentConfig");

  // node_modules/@smithy/util-endpoints/dist-es/cache/EndpointCache.js
  var EndpointCache = class {
    static {
      __name(this, "EndpointCache");
    }
    constructor({ size, params }) {
      this.data = /* @__PURE__ */ new Map();
      this.parameters = [];
      this.capacity = size ?? 50;
      if (params) {
        this.parameters = params;
      }
    }
    get(endpointParams, resolver) {
      const key = this.hash(endpointParams);
      if (key === false) {
        return resolver();
      }
      if (!this.data.has(key)) {
        if (this.data.size > this.capacity + 10) {
          const keys2 = this.data.keys();
          let i3 = 0;
          while (true) {
            const { value, done } = keys2.next();
            this.data.delete(value);
            if (done || ++i3 > 10) {
              break;
            }
          }
        }
        this.data.set(key, resolver());
      }
      return this.data.get(key);
    }
    size() {
      return this.data.size;
    }
    hash(endpointParams) {
      let buffer = "";
      const { parameters } = this;
      if (parameters.length === 0) {
        return false;
      }
      for (const param of parameters) {
        const val2 = String(endpointParams[param] ?? "");
        if (val2.includes("|;")) {
          return false;
        }
        buffer += val2 + "|;";
      }
      return buffer;
    }
  };

  // node_modules/@smithy/util-endpoints/dist-es/lib/isIpAddress.js
  var IP_V4_REGEX = new RegExp(`^(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}$`);
  var isIpAddress = /* @__PURE__ */ __name((value) => IP_V4_REGEX.test(value) || value.startsWith("[") && value.endsWith("]"), "isIpAddress");

  // node_modules/@smithy/util-endpoints/dist-es/lib/isValidHostLabel.js
  var VALID_HOST_LABEL_REGEX = new RegExp(`^(?!.*-$)(?!-)[a-zA-Z0-9-]{1,63}$`);
  var isValidHostLabel = /* @__PURE__ */ __name((value, allowSubDomains = false) => {
    if (!allowSubDomains) {
      return VALID_HOST_LABEL_REGEX.test(value);
    }
    const labels = value.split(".");
    for (const label of labels) {
      if (!isValidHostLabel(label)) {
        return false;
      }
    }
    return true;
  }, "isValidHostLabel");

  // node_modules/@smithy/util-endpoints/dist-es/utils/customEndpointFunctions.js
  var customEndpointFunctions = {};

  // node_modules/@smithy/util-endpoints/dist-es/debug/debugId.js
  var debugId = "endpoints";

  // node_modules/@smithy/util-endpoints/dist-es/debug/toDebugString.js
  function toDebugString(input) {
    if (typeof input !== "object" || input == null) {
      return input;
    }
    if ("ref" in input) {
      return `$${toDebugString(input.ref)}`;
    }
    if ("fn" in input) {
      return `${input.fn}(${(input.argv || []).map(toDebugString).join(", ")})`;
    }
    return JSON.stringify(input, null, 2);
  }
  __name(toDebugString, "toDebugString");

  // node_modules/@smithy/util-endpoints/dist-es/types/EndpointError.js
  var EndpointError = class extends Error {
    static {
      __name(this, "EndpointError");
    }
    constructor(message) {
      super(message);
      this.name = "EndpointError";
    }
  };

  // node_modules/@smithy/util-endpoints/dist-es/lib/booleanEquals.js
  var booleanEquals = /* @__PURE__ */ __name((value1, value2) => value1 === value2, "booleanEquals");

  // node_modules/@smithy/util-endpoints/dist-es/lib/getAttrPathList.js
  var getAttrPathList = /* @__PURE__ */ __name((path) => {
    const parts = path.split(".");
    const pathList = [];
    for (const part of parts) {
      const squareBracketIndex = part.indexOf("[");
      if (squareBracketIndex !== -1) {
        if (part.indexOf("]") !== part.length - 1) {
          throw new EndpointError(`Path: '${path}' does not end with ']'`);
        }
        const arrayIndex = part.slice(squareBracketIndex + 1, -1);
        if (Number.isNaN(parseInt(arrayIndex))) {
          throw new EndpointError(`Invalid array index: '${arrayIndex}' in path: '${path}'`);
        }
        if (squareBracketIndex !== 0) {
          pathList.push(part.slice(0, squareBracketIndex));
        }
        pathList.push(arrayIndex);
      } else {
        pathList.push(part);
      }
    }
    return pathList;
  }, "getAttrPathList");

  // node_modules/@smithy/util-endpoints/dist-es/lib/getAttr.js
  var getAttr = /* @__PURE__ */ __name((value, path) => getAttrPathList(path).reduce((acc, index2) => {
    if (typeof acc !== "object") {
      throw new EndpointError(`Index '${index2}' in '${path}' not found in '${JSON.stringify(value)}'`);
    } else if (Array.isArray(acc)) {
      return acc[parseInt(index2)];
    }
    return acc[index2];
  }, value), "getAttr");

  // node_modules/@smithy/util-endpoints/dist-es/lib/isSet.js
  var isSet2 = /* @__PURE__ */ __name((value) => value != null, "isSet");

  // node_modules/@smithy/util-endpoints/dist-es/lib/not.js
  var not = /* @__PURE__ */ __name((value) => !value, "not");

  // node_modules/@smithy/util-endpoints/dist-es/lib/parseURL.js
  var DEFAULT_PORTS = {
    [EndpointURLScheme.HTTP]: 80,
    [EndpointURLScheme.HTTPS]: 443
  };
  var parseURL = /* @__PURE__ */ __name((value) => {
    const whatwgURL = (() => {
      try {
        if (value instanceof URL) {
          return value;
        }
        if (typeof value === "object" && "hostname" in value) {
          const { hostname: hostname2, port, protocol: protocol2 = "", path = "", query = {} } = value;
          const url = new URL(`${protocol2}//${hostname2}${port ? `:${port}` : ""}${path}`);
          url.search = Object.entries(query).map(([k3, v3]) => `${k3}=${v3}`).join("&");
          return url;
        }
        return new URL(value);
      } catch (error) {
        return null;
      }
    })();
    if (!whatwgURL) {
      console.error(`Unable to parse ${JSON.stringify(value)} as a whatwg URL.`);
      return null;
    }
    const urlString = whatwgURL.href;
    const { host, hostname, pathname, protocol, search } = whatwgURL;
    if (search) {
      return null;
    }
    const scheme = protocol.slice(0, -1);
    if (!Object.values(EndpointURLScheme).includes(scheme)) {
      return null;
    }
    const isIp = isIpAddress(hostname);
    const inputContainsDefaultPort = urlString.includes(`${host}:${DEFAULT_PORTS[scheme]}`) || typeof value === "string" && value.includes(`${host}:${DEFAULT_PORTS[scheme]}`);
    const authority = `${host}${inputContainsDefaultPort ? `:${DEFAULT_PORTS[scheme]}` : ``}`;
    return {
      scheme,
      authority,
      path: pathname,
      normalizedPath: pathname.endsWith("/") ? pathname : `${pathname}/`,
      isIp
    };
  }, "parseURL");

  // node_modules/@smithy/util-endpoints/dist-es/lib/stringEquals.js
  var stringEquals = /* @__PURE__ */ __name((value1, value2) => value1 === value2, "stringEquals");

  // node_modules/@smithy/util-endpoints/dist-es/lib/substring.js
  var substring = /* @__PURE__ */ __name((input, start2, stop, reverse) => {
    if (start2 >= stop || input.length < stop) {
      return null;
    }
    if (!reverse) {
      return input.substring(start2, stop);
    }
    return input.substring(input.length - stop, input.length - start2);
  }, "substring");

  // node_modules/@smithy/util-endpoints/dist-es/lib/uriEncode.js
  var uriEncode = /* @__PURE__ */ __name((value) => encodeURIComponent(value).replace(/[!*'()]/g, (c3) => `%${c3.charCodeAt(0).toString(16).toUpperCase()}`), "uriEncode");

  // node_modules/@smithy/util-endpoints/dist-es/utils/endpointFunctions.js
  var endpointFunctions = {
    booleanEquals,
    getAttr,
    isSet: isSet2,
    isValidHostLabel,
    not,
    parseURL,
    stringEquals,
    substring,
    uriEncode
  };

  // node_modules/@smithy/util-endpoints/dist-es/utils/evaluateTemplate.js
  var evaluateTemplate = /* @__PURE__ */ __name((template, options) => {
    const evaluatedTemplateArr = [];
    const templateContext = {
      ...options.endpointParams,
      ...options.referenceRecord
    };
    let currentIndex = 0;
    while (currentIndex < template.length) {
      const openingBraceIndex = template.indexOf("{", currentIndex);
      if (openingBraceIndex === -1) {
        evaluatedTemplateArr.push(template.slice(currentIndex));
        break;
      }
      evaluatedTemplateArr.push(template.slice(currentIndex, openingBraceIndex));
      const closingBraceIndex = template.indexOf("}", openingBraceIndex);
      if (closingBraceIndex === -1) {
        evaluatedTemplateArr.push(template.slice(openingBraceIndex));
        break;
      }
      if (template[openingBraceIndex + 1] === "{" && template[closingBraceIndex + 1] === "}") {
        evaluatedTemplateArr.push(template.slice(openingBraceIndex + 1, closingBraceIndex));
        currentIndex = closingBraceIndex + 2;
      }
      const parameterName = template.substring(openingBraceIndex + 1, closingBraceIndex);
      if (parameterName.includes("#")) {
        const [refName, attrName] = parameterName.split("#");
        evaluatedTemplateArr.push(getAttr(templateContext[refName], attrName));
      } else {
        evaluatedTemplateArr.push(templateContext[parameterName]);
      }
      currentIndex = closingBraceIndex + 1;
    }
    return evaluatedTemplateArr.join("");
  }, "evaluateTemplate");

  // node_modules/@smithy/util-endpoints/dist-es/utils/getReferenceValue.js
  var getReferenceValue = /* @__PURE__ */ __name(({ ref }, options) => {
    const referenceRecord = {
      ...options.endpointParams,
      ...options.referenceRecord
    };
    return referenceRecord[ref];
  }, "getReferenceValue");

  // node_modules/@smithy/util-endpoints/dist-es/utils/evaluateExpression.js
  var evaluateExpression = /* @__PURE__ */ __name((obj, keyName, options) => {
    if (typeof obj === "string") {
      return evaluateTemplate(obj, options);
    } else if (obj["fn"]) {
      return callFunction(obj, options);
    } else if (obj["ref"]) {
      return getReferenceValue(obj, options);
    }
    throw new EndpointError(`'${keyName}': ${String(obj)} is not a string, function or reference.`);
  }, "evaluateExpression");

  // node_modules/@smithy/util-endpoints/dist-es/utils/callFunction.js
  var callFunction = /* @__PURE__ */ __name(({ fn, argv }, options) => {
    const evaluatedArgs = argv.map((arg) => ["boolean", "number"].includes(typeof arg) ? arg : evaluateExpression(arg, "arg", options));
    const fnSegments = fn.split(".");
    if (fnSegments[0] in customEndpointFunctions && fnSegments[1] != null) {
      return customEndpointFunctions[fnSegments[0]][fnSegments[1]](...evaluatedArgs);
    }
    return endpointFunctions[fn](...evaluatedArgs);
  }, "callFunction");

  // node_modules/@smithy/util-endpoints/dist-es/utils/evaluateCondition.js
  var evaluateCondition = /* @__PURE__ */ __name(({ assign: assign2, ...fnArgs }, options) => {
    if (assign2 && assign2 in options.referenceRecord) {
      throw new EndpointError(`'${assign2}' is already defined in Reference Record.`);
    }
    const value = callFunction(fnArgs, options);
    options.logger?.debug?.(`${debugId} evaluateCondition: ${toDebugString(fnArgs)} = ${toDebugString(value)}`);
    return {
      result: value === "" ? true : !!value,
      ...assign2 != null && { toAssign: { name: assign2, value } }
    };
  }, "evaluateCondition");

  // node_modules/@smithy/util-endpoints/dist-es/utils/evaluateConditions.js
  var evaluateConditions = /* @__PURE__ */ __name((conditions = [], options) => {
    const conditionsReferenceRecord = {};
    for (const condition of conditions) {
      const { result, toAssign } = evaluateCondition(condition, {
        ...options,
        referenceRecord: {
          ...options.referenceRecord,
          ...conditionsReferenceRecord
        }
      });
      if (!result) {
        return { result };
      }
      if (toAssign) {
        conditionsReferenceRecord[toAssign.name] = toAssign.value;
        options.logger?.debug?.(`${debugId} assign: ${toAssign.name} := ${toDebugString(toAssign.value)}`);
      }
    }
    return { result: true, referenceRecord: conditionsReferenceRecord };
  }, "evaluateConditions");

  // node_modules/@smithy/util-endpoints/dist-es/utils/getEndpointHeaders.js
  var getEndpointHeaders = /* @__PURE__ */ __name((headers, options) => Object.entries(headers).reduce((acc, [headerKey, headerVal]) => ({
    ...acc,
    [headerKey]: headerVal.map((headerValEntry) => {
      const processedExpr = evaluateExpression(headerValEntry, "Header value entry", options);
      if (typeof processedExpr !== "string") {
        throw new EndpointError(`Header '${headerKey}' value '${processedExpr}' is not a string`);
      }
      return processedExpr;
    })
  }), {}), "getEndpointHeaders");

  // node_modules/@smithy/util-endpoints/dist-es/utils/getEndpointProperty.js
  var getEndpointProperty = /* @__PURE__ */ __name((property, options) => {
    if (Array.isArray(property)) {
      return property.map((propertyEntry) => getEndpointProperty(propertyEntry, options));
    }
    switch (typeof property) {
      case "string":
        return evaluateTemplate(property, options);
      case "object":
        if (property === null) {
          throw new EndpointError(`Unexpected endpoint property: ${property}`);
        }
        return getEndpointProperties(property, options);
      case "boolean":
        return property;
      default:
        throw new EndpointError(`Unexpected endpoint property type: ${typeof property}`);
    }
  }, "getEndpointProperty");

  // node_modules/@smithy/util-endpoints/dist-es/utils/getEndpointProperties.js
  var getEndpointProperties = /* @__PURE__ */ __name((properties, options) => Object.entries(properties).reduce((acc, [propertyKey, propertyVal]) => ({
    ...acc,
    [propertyKey]: getEndpointProperty(propertyVal, options)
  }), {}), "getEndpointProperties");

  // node_modules/@smithy/util-endpoints/dist-es/utils/getEndpointUrl.js
  var getEndpointUrl = /* @__PURE__ */ __name((endpointUrl, options) => {
    const expression = evaluateExpression(endpointUrl, "Endpoint URL", options);
    if (typeof expression === "string") {
      try {
        return new URL(expression);
      } catch (error) {
        console.error(`Failed to construct URL with ${expression}`, error);
        throw error;
      }
    }
    throw new EndpointError(`Endpoint URL must be a string, got ${typeof expression}`);
  }, "getEndpointUrl");

  // node_modules/@smithy/util-endpoints/dist-es/utils/evaluateEndpointRule.js
  var evaluateEndpointRule = /* @__PURE__ */ __name((endpointRule, options) => {
    const { conditions, endpoint } = endpointRule;
    const { result, referenceRecord } = evaluateConditions(conditions, options);
    if (!result) {
      return;
    }
    const endpointRuleOptions = {
      ...options,
      referenceRecord: { ...options.referenceRecord, ...referenceRecord }
    };
    const { url, properties, headers } = endpoint;
    options.logger?.debug?.(`${debugId} Resolving endpoint from template: ${toDebugString(endpoint)}`);
    return {
      ...headers != void 0 && {
        headers: getEndpointHeaders(headers, endpointRuleOptions)
      },
      ...properties != void 0 && {
        properties: getEndpointProperties(properties, endpointRuleOptions)
      },
      url: getEndpointUrl(url, endpointRuleOptions)
    };
  }, "evaluateEndpointRule");

  // node_modules/@smithy/util-endpoints/dist-es/utils/evaluateErrorRule.js
  var evaluateErrorRule = /* @__PURE__ */ __name((errorRule, options) => {
    const { conditions, error } = errorRule;
    const { result, referenceRecord } = evaluateConditions(conditions, options);
    if (!result) {
      return;
    }
    throw new EndpointError(evaluateExpression(error, "Error", {
      ...options,
      referenceRecord: { ...options.referenceRecord, ...referenceRecord }
    }));
  }, "evaluateErrorRule");

  // node_modules/@smithy/util-endpoints/dist-es/utils/evaluateTreeRule.js
  var evaluateTreeRule = /* @__PURE__ */ __name((treeRule, options) => {
    const { conditions, rules } = treeRule;
    const { result, referenceRecord } = evaluateConditions(conditions, options);
    if (!result) {
      return;
    }
    return evaluateRules(rules, {
      ...options,
      referenceRecord: { ...options.referenceRecord, ...referenceRecord }
    });
  }, "evaluateTreeRule");

  // node_modules/@smithy/util-endpoints/dist-es/utils/evaluateRules.js
  var evaluateRules = /* @__PURE__ */ __name((rules, options) => {
    for (const rule of rules) {
      if (rule.type === "endpoint") {
        const endpointOrUndefined = evaluateEndpointRule(rule, options);
        if (endpointOrUndefined) {
          return endpointOrUndefined;
        }
      } else if (rule.type === "error") {
        evaluateErrorRule(rule, options);
      } else if (rule.type === "tree") {
        const endpointOrUndefined = evaluateTreeRule(rule, options);
        if (endpointOrUndefined) {
          return endpointOrUndefined;
        }
      } else {
        throw new EndpointError(`Unknown endpoint rule: ${rule}`);
      }
    }
    throw new EndpointError(`Rules evaluation failed`);
  }, "evaluateRules");

  // node_modules/@smithy/util-endpoints/dist-es/resolveEndpoint.js
  var resolveEndpoint = /* @__PURE__ */ __name((ruleSetObject, options) => {
    const { endpointParams, logger: logger2 } = options;
    const { parameters, rules } = ruleSetObject;
    options.logger?.debug?.(`${debugId} Initial EndpointParams: ${toDebugString(endpointParams)}`);
    const paramsWithDefault = Object.entries(parameters).filter(([, v3]) => v3.default != null).map(([k3, v3]) => [k3, v3.default]);
    if (paramsWithDefault.length > 0) {
      for (const [paramKey, paramDefaultValue] of paramsWithDefault) {
        endpointParams[paramKey] = endpointParams[paramKey] ?? paramDefaultValue;
      }
    }
    const requiredParams = Object.entries(parameters).filter(([, v3]) => v3.required).map(([k3]) => k3);
    for (const requiredParam of requiredParams) {
      if (endpointParams[requiredParam] == null) {
        throw new EndpointError(`Missing required parameter: '${requiredParam}'`);
      }
    }
    const endpoint = evaluateRules(rules, { endpointParams, logger: logger2, referenceRecord: {} });
    options.logger?.debug?.(`${debugId} Resolved endpoint: ${toDebugString(endpoint)}`);
    return endpoint;
  }, "resolveEndpoint");

  // node_modules/@aws-sdk/util-endpoints/dist-es/lib/aws/isVirtualHostableS3Bucket.js
  var isVirtualHostableS3Bucket = /* @__PURE__ */ __name((value, allowSubDomains = false) => {
    if (allowSubDomains) {
      for (const label of value.split(".")) {
        if (!isVirtualHostableS3Bucket(label)) {
          return false;
        }
      }
      return true;
    }
    if (!isValidHostLabel(value)) {
      return false;
    }
    if (value.length < 3 || value.length > 63) {
      return false;
    }
    if (value !== value.toLowerCase()) {
      return false;
    }
    if (isIpAddress(value)) {
      return false;
    }
    return true;
  }, "isVirtualHostableS3Bucket");

  // node_modules/@aws-sdk/util-endpoints/dist-es/lib/aws/parseArn.js
  var ARN_DELIMITER = ":";
  var RESOURCE_DELIMITER = "/";
  var parseArn = /* @__PURE__ */ __name((value) => {
    const segments = value.split(ARN_DELIMITER);
    if (segments.length < 6)
      return null;
    const [arn, partition2, service, region, accountId, ...resourcePath] = segments;
    if (arn !== "arn" || partition2 === "" || service === "" || resourcePath.join(ARN_DELIMITER) === "")
      return null;
    const resourceId = resourcePath.map((resource) => resource.split(RESOURCE_DELIMITER)).flat();
    return {
      partition: partition2,
      service,
      region,
      accountId,
      resourceId
    };
  }, "parseArn");

  // node_modules/@aws-sdk/util-endpoints/dist-es/lib/aws/partitions.json
  var partitions_default = {
    partitions: [{
      id: "aws",
      outputs: {
        dnsSuffix: "amazonaws.com",
        dualStackDnsSuffix: "api.aws",
        implicitGlobalRegion: "us-east-1",
        name: "aws",
        supportsDualStack: true,
        supportsFIPS: true
      },
      regionRegex: "^(us|eu|ap|sa|ca|me|af|il|mx)\\-\\w+\\-\\d+$",
      regions: {
        "af-south-1": {
          description: "Africa (Cape Town)"
        },
        "ap-east-1": {
          description: "Asia Pacific (Hong Kong)"
        },
        "ap-northeast-1": {
          description: "Asia Pacific (Tokyo)"
        },
        "ap-northeast-2": {
          description: "Asia Pacific (Seoul)"
        },
        "ap-northeast-3": {
          description: "Asia Pacific (Osaka)"
        },
        "ap-south-1": {
          description: "Asia Pacific (Mumbai)"
        },
        "ap-south-2": {
          description: "Asia Pacific (Hyderabad)"
        },
        "ap-southeast-1": {
          description: "Asia Pacific (Singapore)"
        },
        "ap-southeast-2": {
          description: "Asia Pacific (Sydney)"
        },
        "ap-southeast-3": {
          description: "Asia Pacific (Jakarta)"
        },
        "ap-southeast-4": {
          description: "Asia Pacific (Melbourne)"
        },
        "ap-southeast-5": {
          description: "Asia Pacific (Malaysia)"
        },
        "ap-southeast-7": {
          description: "Asia Pacific (Thailand)"
        },
        "aws-global": {
          description: "AWS Standard global region"
        },
        "ca-central-1": {
          description: "Canada (Central)"
        },
        "ca-west-1": {
          description: "Canada West (Calgary)"
        },
        "eu-central-1": {
          description: "Europe (Frankfurt)"
        },
        "eu-central-2": {
          description: "Europe (Zurich)"
        },
        "eu-north-1": {
          description: "Europe (Stockholm)"
        },
        "eu-south-1": {
          description: "Europe (Milan)"
        },
        "eu-south-2": {
          description: "Europe (Spain)"
        },
        "eu-west-1": {
          description: "Europe (Ireland)"
        },
        "eu-west-2": {
          description: "Europe (London)"
        },
        "eu-west-3": {
          description: "Europe (Paris)"
        },
        "il-central-1": {
          description: "Israel (Tel Aviv)"
        },
        "me-central-1": {
          description: "Middle East (UAE)"
        },
        "me-south-1": {
          description: "Middle East (Bahrain)"
        },
        "mx-central-1": {
          description: "Mexico (Central)"
        },
        "sa-east-1": {
          description: "South America (Sao Paulo)"
        },
        "us-east-1": {
          description: "US East (N. Virginia)"
        },
        "us-east-2": {
          description: "US East (Ohio)"
        },
        "us-west-1": {
          description: "US West (N. California)"
        },
        "us-west-2": {
          description: "US West (Oregon)"
        }
      }
    }, {
      id: "aws-cn",
      outputs: {
        dnsSuffix: "amazonaws.com.cn",
        dualStackDnsSuffix: "api.amazonwebservices.com.cn",
        implicitGlobalRegion: "cn-northwest-1",
        name: "aws-cn",
        supportsDualStack: true,
        supportsFIPS: true
      },
      regionRegex: "^cn\\-\\w+\\-\\d+$",
      regions: {
        "aws-cn-global": {
          description: "AWS China global region"
        },
        "cn-north-1": {
          description: "China (Beijing)"
        },
        "cn-northwest-1": {
          description: "China (Ningxia)"
        }
      }
    }, {
      id: "aws-us-gov",
      outputs: {
        dnsSuffix: "amazonaws.com",
        dualStackDnsSuffix: "api.aws",
        implicitGlobalRegion: "us-gov-west-1",
        name: "aws-us-gov",
        supportsDualStack: true,
        supportsFIPS: true
      },
      regionRegex: "^us\\-gov\\-\\w+\\-\\d+$",
      regions: {
        "aws-us-gov-global": {
          description: "AWS GovCloud (US) global region"
        },
        "us-gov-east-1": {
          description: "AWS GovCloud (US-East)"
        },
        "us-gov-west-1": {
          description: "AWS GovCloud (US-West)"
        }
      }
    }, {
      id: "aws-iso",
      outputs: {
        dnsSuffix: "c2s.ic.gov",
        dualStackDnsSuffix: "c2s.ic.gov",
        implicitGlobalRegion: "us-iso-east-1",
        name: "aws-iso",
        supportsDualStack: false,
        supportsFIPS: true
      },
      regionRegex: "^us\\-iso\\-\\w+\\-\\d+$",
      regions: {
        "aws-iso-global": {
          description: "AWS ISO (US) global region"
        },
        "us-iso-east-1": {
          description: "US ISO East"
        },
        "us-iso-west-1": {
          description: "US ISO WEST"
        }
      }
    }, {
      id: "aws-iso-b",
      outputs: {
        dnsSuffix: "sc2s.sgov.gov",
        dualStackDnsSuffix: "sc2s.sgov.gov",
        implicitGlobalRegion: "us-isob-east-1",
        name: "aws-iso-b",
        supportsDualStack: false,
        supportsFIPS: true
      },
      regionRegex: "^us\\-isob\\-\\w+\\-\\d+$",
      regions: {
        "aws-iso-b-global": {
          description: "AWS ISOB (US) global region"
        },
        "us-isob-east-1": {
          description: "US ISOB East (Ohio)"
        }
      }
    }, {
      id: "aws-iso-e",
      outputs: {
        dnsSuffix: "cloud.adc-e.uk",
        dualStackDnsSuffix: "cloud.adc-e.uk",
        implicitGlobalRegion: "eu-isoe-west-1",
        name: "aws-iso-e",
        supportsDualStack: false,
        supportsFIPS: true
      },
      regionRegex: "^eu\\-isoe\\-\\w+\\-\\d+$",
      regions: {
        "eu-isoe-west-1": {
          description: "EU ISOE West"
        }
      }
    }, {
      id: "aws-iso-f",
      outputs: {
        dnsSuffix: "csp.hci.ic.gov",
        dualStackDnsSuffix: "csp.hci.ic.gov",
        implicitGlobalRegion: "us-isof-south-1",
        name: "aws-iso-f",
        supportsDualStack: false,
        supportsFIPS: true
      },
      regionRegex: "^us\\-isof\\-\\w+\\-\\d+$",
      regions: {
        "aws-iso-f-global": {
          description: "AWS ISOF global region"
        },
        "us-isof-east-1": {
          description: "US ISOF EAST"
        },
        "us-isof-south-1": {
          description: "US ISOF SOUTH"
        }
      }
    }],
    version: "1.1"
  };

  // node_modules/@aws-sdk/util-endpoints/dist-es/lib/aws/partition.js
  var selectedPartitionsInfo = partitions_default;
  var selectedUserAgentPrefix = "";
  var partition = /* @__PURE__ */ __name((value) => {
    const { partitions } = selectedPartitionsInfo;
    for (const partition2 of partitions) {
      const { regions, outputs } = partition2;
      for (const [region, regionData] of Object.entries(regions)) {
        if (region === value) {
          return {
            ...outputs,
            ...regionData
          };
        }
      }
    }
    for (const partition2 of partitions) {
      const { regionRegex, outputs } = partition2;
      if (new RegExp(regionRegex).test(value)) {
        return {
          ...outputs
        };
      }
    }
    const DEFAULT_PARTITION = partitions.find((partition2) => partition2.id === "aws");
    if (!DEFAULT_PARTITION) {
      throw new Error("Provided region was not found in the partition array or regex, and default partition with id 'aws' doesn't exist.");
    }
    return {
      ...DEFAULT_PARTITION.outputs
    };
  }, "partition");
  var getUserAgentPrefix = /* @__PURE__ */ __name(() => selectedUserAgentPrefix, "getUserAgentPrefix");

  // node_modules/@aws-sdk/util-endpoints/dist-es/aws.js
  var awsEndpointFunctions = {
    isVirtualHostableS3Bucket,
    parseArn,
    partition
  };
  customEndpointFunctions.aws = awsEndpointFunctions;

  // node_modules/@aws-sdk/middleware-user-agent/dist-es/check-features.js
  var ACCOUNT_ID_ENDPOINT_REGEX = /\d{12}\.ddb/;
  async function checkFeatures(context, config4, args) {
    const request = args.request;
    if (request?.headers?.["smithy-protocol"] === "rpc-v2-cbor") {
      setFeature(context, "PROTOCOL_RPC_V2_CBOR", "M");
    }
    if (typeof config4.retryStrategy === "function") {
      const retryStrategy = await config4.retryStrategy();
      if (typeof retryStrategy.acquireInitialRetryToken === "function") {
        if (retryStrategy.constructor?.name?.includes("Adaptive")) {
          setFeature(context, "RETRY_MODE_ADAPTIVE", "F");
        } else {
          setFeature(context, "RETRY_MODE_STANDARD", "E");
        }
      } else {
        setFeature(context, "RETRY_MODE_LEGACY", "D");
      }
    }
    if (typeof config4.accountIdEndpointMode === "function") {
      const endpointV2 = context.endpointV2;
      if (String(endpointV2?.url?.hostname).match(ACCOUNT_ID_ENDPOINT_REGEX)) {
        setFeature(context, "ACCOUNT_ID_ENDPOINT", "O");
      }
      switch (await config4.accountIdEndpointMode?.()) {
        case "disabled":
          setFeature(context, "ACCOUNT_ID_MODE_DISABLED", "Q");
          break;
        case "preferred":
          setFeature(context, "ACCOUNT_ID_MODE_PREFERRED", "P");
          break;
        case "required":
          setFeature(context, "ACCOUNT_ID_MODE_REQUIRED", "R");
          break;
      }
    }
    const identity2 = context.__smithy_context?.selectedHttpAuthScheme?.identity;
    if (identity2?.$source) {
      const credentials = identity2;
      if (credentials.accountId) {
        setFeature(context, "RESOLVED_ACCOUNT_ID", "T");
      }
      for (const [key, value] of Object.entries(credentials.$source ?? {})) {
        setFeature(context, key, value);
      }
    }
  }
  __name(checkFeatures, "checkFeatures");

  // node_modules/@aws-sdk/middleware-user-agent/dist-es/constants.js
  var USER_AGENT = "user-agent";
  var X_AMZ_USER_AGENT = "x-amz-user-agent";
  var SPACE = " ";
  var UA_NAME_SEPARATOR = "/";
  var UA_NAME_ESCAPE_REGEX = /[^\!\$\%\&\'\*\+\-\.\^\_\`\|\~\d\w]/g;
  var UA_VALUE_ESCAPE_REGEX = /[^\!\$\%\&\'\*\+\-\.\^\_\`\|\~\d\w\#]/g;
  var UA_ESCAPE_CHAR = "-";

  // node_modules/@aws-sdk/middleware-user-agent/dist-es/encode-features.js
  var BYTE_LIMIT = 1024;
  function encodeFeatures(features) {
    let buffer = "";
    for (const key in features) {
      const val2 = features[key];
      if (buffer.length + val2.length + 1 <= BYTE_LIMIT) {
        if (buffer.length) {
          buffer += "," + val2;
        } else {
          buffer += val2;
        }
        continue;
      }
      break;
    }
    return buffer;
  }
  __name(encodeFeatures, "encodeFeatures");

  // node_modules/@aws-sdk/middleware-user-agent/dist-es/user-agent-middleware.js
  var userAgentMiddleware = /* @__PURE__ */ __name((options) => (next, context) => async (args) => {
    const { request } = args;
    if (!HttpRequest.isInstance(request)) {
      return next(args);
    }
    const { headers } = request;
    const userAgent2 = context?.userAgent?.map(escapeUserAgent) || [];
    const defaultUserAgent = (await options.defaultUserAgentProvider()).map(escapeUserAgent);
    await checkFeatures(context, options, args);
    const awsContext = context;
    defaultUserAgent.push(`m/${encodeFeatures(Object.assign({}, context.__smithy_context?.features, awsContext.__aws_sdk_context?.features))}`);
    const customUserAgent = options?.customUserAgent?.map(escapeUserAgent) || [];
    const appId = await options.userAgentAppId();
    if (appId) {
      defaultUserAgent.push(escapeUserAgent([`app/${appId}`]));
    }
    const prefix = getUserAgentPrefix();
    const sdkUserAgentValue = (prefix ? [prefix] : []).concat([...defaultUserAgent, ...userAgent2, ...customUserAgent]).join(SPACE);
    const normalUAValue = [
      ...defaultUserAgent.filter((section) => section.startsWith("aws-sdk-")),
      ...customUserAgent
    ].join(SPACE);
    if (options.runtime !== "browser") {
      if (normalUAValue) {
        headers[X_AMZ_USER_AGENT] = headers[X_AMZ_USER_AGENT] ? `${headers[USER_AGENT]} ${normalUAValue}` : normalUAValue;
      }
      headers[USER_AGENT] = sdkUserAgentValue;
    } else {
      headers[X_AMZ_USER_AGENT] = sdkUserAgentValue;
    }
    return next({
      ...args,
      request
    });
  }, "userAgentMiddleware");
  var escapeUserAgent = /* @__PURE__ */ __name((userAgentPair) => {
    const name = userAgentPair[0].split(UA_NAME_SEPARATOR).map((part) => part.replace(UA_NAME_ESCAPE_REGEX, UA_ESCAPE_CHAR)).join(UA_NAME_SEPARATOR);
    const version2 = userAgentPair[1]?.replace(UA_VALUE_ESCAPE_REGEX, UA_ESCAPE_CHAR);
    const prefixSeparatorIndex = name.indexOf(UA_NAME_SEPARATOR);
    const prefix = name.substring(0, prefixSeparatorIndex);
    let uaName = name.substring(prefixSeparatorIndex + 1);
    if (prefix === "api") {
      uaName = uaName.toLowerCase();
    }
    return [prefix, uaName, version2].filter((item) => item && item.length > 0).reduce((acc, item, index2) => {
      switch (index2) {
        case 0:
          return item;
        case 1:
          return `${acc}/${item}`;
        default:
          return `${acc}#${item}`;
      }
    }, "");
  }, "escapeUserAgent");
  var getUserAgentMiddlewareOptions = {
    name: "getUserAgentMiddleware",
    step: "build",
    priority: "low",
    tags: ["SET_USER_AGENT", "USER_AGENT"],
    override: true
  };
  var getUserAgentPlugin = /* @__PURE__ */ __name((config4) => ({
    applyToStack: (clientStack) => {
      clientStack.add(userAgentMiddleware(config4), getUserAgentMiddlewareOptions);
    }
  }), "getUserAgentPlugin");

  // node_modules/@smithy/config-resolver/dist-es/endpointsConfig/NodeUseDualstackEndpointConfigOptions.js
  var DEFAULT_USE_DUALSTACK_ENDPOINT = false;

  // node_modules/@smithy/config-resolver/dist-es/endpointsConfig/NodeUseFipsEndpointConfigOptions.js
  var DEFAULT_USE_FIPS_ENDPOINT = false;

  // node_modules/@smithy/config-resolver/dist-es/regionConfig/isFipsRegion.js
  var isFipsRegion = /* @__PURE__ */ __name((region) => typeof region === "string" && (region.startsWith("fips-") || region.endsWith("-fips")), "isFipsRegion");

  // node_modules/@smithy/config-resolver/dist-es/regionConfig/getRealRegion.js
  var getRealRegion = /* @__PURE__ */ __name((region) => isFipsRegion(region) ? ["fips-aws-global", "aws-fips"].includes(region) ? "us-east-1" : region.replace(/fips-(dkr-|prod-)?|-fips/, "") : region, "getRealRegion");

  // node_modules/@smithy/config-resolver/dist-es/regionConfig/resolveRegionConfig.js
  var resolveRegionConfig = /* @__PURE__ */ __name((input) => {
    const { region, useFipsEndpoint } = input;
    if (!region) {
      throw new Error("Region is missing");
    }
    return {
      ...input,
      region: async () => {
        if (typeof region === "string") {
          return getRealRegion(region);
        }
        const providedRegion = await region();
        return getRealRegion(providedRegion);
      },
      useFipsEndpoint: async () => {
        const providedRegion = typeof region === "string" ? region : await region();
        if (isFipsRegion(providedRegion)) {
          return true;
        }
        return typeof useFipsEndpoint !== "function" ? Promise.resolve(!!useFipsEndpoint) : useFipsEndpoint();
      }
    };
  }, "resolveRegionConfig");

  // node_modules/@smithy/eventstream-serde-config-resolver/dist-es/EventStreamSerdeConfig.js
  var resolveEventStreamSerdeConfig = /* @__PURE__ */ __name((input) => ({
    ...input,
    eventStreamMarshaller: input.eventStreamSerdeProvider(input)
  }), "resolveEventStreamSerdeConfig");

  // node_modules/@smithy/middleware-content-length/dist-es/index.js
  var CONTENT_LENGTH_HEADER2 = "content-length";
  function contentLengthMiddleware(bodyLengthChecker) {
    return (next) => async (args) => {
      const request = args.request;
      if (HttpRequest.isInstance(request)) {
        const { body, headers } = request;
        if (body && Object.keys(headers).map((str) => str.toLowerCase()).indexOf(CONTENT_LENGTH_HEADER2) === -1) {
          try {
            const length = bodyLengthChecker(body);
            request.headers = {
              ...request.headers,
              [CONTENT_LENGTH_HEADER2]: String(length)
            };
          } catch (error) {
          }
        }
      }
      return next({
        ...args,
        request
      });
    };
  }
  __name(contentLengthMiddleware, "contentLengthMiddleware");
  var contentLengthMiddlewareOptions = {
    step: "build",
    tags: ["SET_CONTENT_LENGTH", "CONTENT_LENGTH"],
    name: "contentLengthMiddleware",
    override: true
  };
  var getContentLengthPlugin = /* @__PURE__ */ __name((options) => ({
    applyToStack: (clientStack) => {
      clientStack.add(contentLengthMiddleware(options.bodyLengthChecker), contentLengthMiddlewareOptions);
    }
  }), "getContentLengthPlugin");

  // node_modules/@smithy/middleware-endpoint/dist-es/service-customizations/s3.js
  var resolveParamsForS3 = /* @__PURE__ */ __name(async (endpointParams) => {
    const bucket = endpointParams?.Bucket || "";
    if (typeof endpointParams.Bucket === "string") {
      endpointParams.Bucket = bucket.replace(/#/g, encodeURIComponent("#")).replace(/\?/g, encodeURIComponent("?"));
    }
    if (isArnBucketName(bucket)) {
      if (endpointParams.ForcePathStyle === true) {
        throw new Error("Path-style addressing cannot be used with ARN buckets");
      }
    } else if (!isDnsCompatibleBucketName(bucket) || bucket.indexOf(".") !== -1 && !String(endpointParams.Endpoint).startsWith("http:") || bucket.toLowerCase() !== bucket || bucket.length < 3) {
      endpointParams.ForcePathStyle = true;
    }
    if (endpointParams.DisableMultiRegionAccessPoints) {
      endpointParams.disableMultiRegionAccessPoints = true;
      endpointParams.DisableMRAP = true;
    }
    return endpointParams;
  }, "resolveParamsForS3");
  var DOMAIN_PATTERN = /^[a-z0-9][a-z0-9\.\-]{1,61}[a-z0-9]$/;
  var IP_ADDRESS_PATTERN = /(\d+\.){3}\d+/;
  var DOTS_PATTERN = /\.\./;
  var isDnsCompatibleBucketName = /* @__PURE__ */ __name((bucketName) => DOMAIN_PATTERN.test(bucketName) && !IP_ADDRESS_PATTERN.test(bucketName) && !DOTS_PATTERN.test(bucketName), "isDnsCompatibleBucketName");
  var isArnBucketName = /* @__PURE__ */ __name((bucketName) => {
    const [arn, partition2, service, , , bucket] = bucketName.split(":");
    const isArn = arn === "arn" && bucketName.split(":").length >= 6;
    const isValidArn = Boolean(isArn && partition2 && service && bucket);
    if (isArn && !isValidArn) {
      throw new Error(`Invalid ARN: ${bucketName} was an invalid ARN.`);
    }
    return isValidArn;
  }, "isArnBucketName");

  // node_modules/@smithy/middleware-endpoint/dist-es/adaptors/createConfigValueProvider.js
  var createConfigValueProvider = /* @__PURE__ */ __name((configKey, canonicalEndpointParamKey, config4) => {
    const configProvider = /* @__PURE__ */ __name(async () => {
      const configValue = config4[configKey] ?? config4[canonicalEndpointParamKey];
      if (typeof configValue === "function") {
        return configValue();
      }
      return configValue;
    }, "configProvider");
    if (configKey === "credentialScope" || canonicalEndpointParamKey === "CredentialScope") {
      return async () => {
        const credentials = typeof config4.credentials === "function" ? await config4.credentials() : config4.credentials;
        const configValue = credentials?.credentialScope ?? credentials?.CredentialScope;
        return configValue;
      };
    }
    if (configKey === "accountId" || canonicalEndpointParamKey === "AccountId") {
      return async () => {
        const credentials = typeof config4.credentials === "function" ? await config4.credentials() : config4.credentials;
        const configValue = credentials?.accountId ?? credentials?.AccountId;
        return configValue;
      };
    }
    if (configKey === "endpoint" || canonicalEndpointParamKey === "endpoint") {
      return async () => {
        const endpoint = await configProvider();
        if (endpoint && typeof endpoint === "object") {
          if ("url" in endpoint) {
            return endpoint.url.href;
          }
          if ("hostname" in endpoint) {
            const { protocol, hostname, port, path } = endpoint;
            return `${protocol}//${hostname}${port ? ":" + port : ""}${path}`;
          }
        }
        return endpoint;
      };
    }
    return configProvider;
  }, "createConfigValueProvider");

  // node_modules/@smithy/middleware-endpoint/dist-es/adaptors/getEndpointFromConfig.browser.js
  var getEndpointFromConfig = /* @__PURE__ */ __name(async (serviceId) => void 0, "getEndpointFromConfig");

  // node_modules/@smithy/querystring-parser/dist-es/index.js
  function parseQueryString(querystring) {
    const query = {};
    querystring = querystring.replace(/^\?/, "");
    if (querystring) {
      for (const pair of querystring.split("&")) {
        let [key, value = null] = pair.split("=");
        key = decodeURIComponent(key);
        if (value) {
          value = decodeURIComponent(value);
        }
        if (!(key in query)) {
          query[key] = value;
        } else if (Array.isArray(query[key])) {
          query[key].push(value);
        } else {
          query[key] = [query[key], value];
        }
      }
    }
    return query;
  }
  __name(parseQueryString, "parseQueryString");

  // node_modules/@smithy/url-parser/dist-es/index.js
  var parseUrl = /* @__PURE__ */ __name((url) => {
    if (typeof url === "string") {
      return parseUrl(new URL(url));
    }
    const { hostname, pathname, port, protocol, search } = url;
    let query;
    if (search) {
      query = parseQueryString(search);
    }
    return {
      hostname,
      port: port ? parseInt(port) : void 0,
      protocol,
      path: pathname,
      query
    };
  }, "parseUrl");

  // node_modules/@smithy/middleware-endpoint/dist-es/adaptors/toEndpointV1.js
  var toEndpointV1 = /* @__PURE__ */ __name((endpoint) => {
    if (typeof endpoint === "object") {
      if ("url" in endpoint) {
        return parseUrl(endpoint.url);
      }
      return endpoint;
    }
    return parseUrl(endpoint);
  }, "toEndpointV1");

  // node_modules/@smithy/middleware-endpoint/dist-es/adaptors/getEndpointFromInstructions.js
  var getEndpointFromInstructions = /* @__PURE__ */ __name(async (commandInput, instructionsSupplier, clientConfig, context) => {
    if (!clientConfig.endpoint) {
      let endpointFromConfig;
      if (clientConfig.serviceConfiguredEndpoint) {
        endpointFromConfig = await clientConfig.serviceConfiguredEndpoint();
      } else {
        endpointFromConfig = await getEndpointFromConfig(clientConfig.serviceId);
      }
      if (endpointFromConfig) {
        clientConfig.endpoint = () => Promise.resolve(toEndpointV1(endpointFromConfig));
      }
    }
    const endpointParams = await resolveParams(commandInput, instructionsSupplier, clientConfig);
    if (typeof clientConfig.endpointProvider !== "function") {
      throw new Error("config.endpointProvider is not set.");
    }
    const endpoint = clientConfig.endpointProvider(endpointParams, context);
    return endpoint;
  }, "getEndpointFromInstructions");
  var resolveParams = /* @__PURE__ */ __name(async (commandInput, instructionsSupplier, clientConfig) => {
    const endpointParams = {};
    const instructions = instructionsSupplier?.getEndpointParameterInstructions?.() || {};
    for (const [name, instruction] of Object.entries(instructions)) {
      switch (instruction.type) {
        case "staticContextParams":
          endpointParams[name] = instruction.value;
          break;
        case "contextParams":
          endpointParams[name] = commandInput[instruction.name];
          break;
        case "clientContextParams":
        case "builtInParams":
          endpointParams[name] = await createConfigValueProvider(instruction.name, name, clientConfig)();
          break;
        case "operationContextParams":
          endpointParams[name] = instruction.get(commandInput);
          break;
        default:
          throw new Error("Unrecognized endpoint parameter instruction: " + JSON.stringify(instruction));
      }
    }
    if (Object.keys(instructions).length === 0) {
      Object.assign(endpointParams, clientConfig);
    }
    if (String(clientConfig.serviceId).toLowerCase() === "s3") {
      await resolveParamsForS3(endpointParams);
    }
    return endpointParams;
  }, "resolveParams");

  // node_modules/@smithy/middleware-endpoint/dist-es/endpointMiddleware.js
  var endpointMiddleware = /* @__PURE__ */ __name(({ config: config4, instructions }) => {
    return (next, context) => async (args) => {
      if (config4.endpoint) {
        setFeature2(context, "ENDPOINT_OVERRIDE", "N");
      }
      const endpoint = await getEndpointFromInstructions(args.input, {
        getEndpointParameterInstructions() {
          return instructions;
        }
      }, { ...config4 }, context);
      context.endpointV2 = endpoint;
      context.authSchemes = endpoint.properties?.authSchemes;
      const authScheme = context.authSchemes?.[0];
      if (authScheme) {
        context["signing_region"] = authScheme.signingRegion;
        context["signing_service"] = authScheme.signingName;
        const smithyContext = getSmithyContext(context);
        const httpAuthOption = smithyContext?.selectedHttpAuthScheme?.httpAuthOption;
        if (httpAuthOption) {
          httpAuthOption.signingProperties = Object.assign(httpAuthOption.signingProperties || {}, {
            signing_region: authScheme.signingRegion,
            signingRegion: authScheme.signingRegion,
            signing_service: authScheme.signingName,
            signingName: authScheme.signingName,
            signingRegionSet: authScheme.signingRegionSet
          }, authScheme.properties);
        }
      }
      return next({
        ...args
      });
    };
  }, "endpointMiddleware");

  // node_modules/@smithy/middleware-endpoint/dist-es/getEndpointPlugin.js
  var endpointMiddlewareOptions = {
    step: "serialize",
    tags: ["ENDPOINT_PARAMETERS", "ENDPOINT_V2", "ENDPOINT"],
    name: "endpointV2Middleware",
    override: true,
    relation: "before",
    toMiddleware: serializerMiddlewareOption.name
  };
  var getEndpointPlugin = /* @__PURE__ */ __name((config4, instructions) => ({
    applyToStack: (clientStack) => {
      clientStack.addRelativeTo(endpointMiddleware({
        config: config4,
        instructions
      }), endpointMiddlewareOptions);
    }
  }), "getEndpointPlugin");

  // node_modules/@smithy/middleware-endpoint/dist-es/resolveEndpointConfig.js
  var resolveEndpointConfig = /* @__PURE__ */ __name((input) => {
    const tls = input.tls ?? true;
    const { endpoint } = input;
    const customEndpointProvider = endpoint != null ? async () => toEndpointV1(await normalizeProvider(endpoint)()) : void 0;
    const isCustomEndpoint = !!endpoint;
    const resolvedConfig = {
      ...input,
      endpoint: customEndpointProvider,
      tls,
      isCustomEndpoint,
      useDualstackEndpoint: normalizeProvider(input.useDualstackEndpoint ?? false),
      useFipsEndpoint: normalizeProvider(input.useFipsEndpoint ?? false)
    };
    let configuredEndpointPromise = void 0;
    resolvedConfig.serviceConfiguredEndpoint = async () => {
      if (input.serviceId && !configuredEndpointPromise) {
        configuredEndpointPromise = getEndpointFromConfig(input.serviceId);
      }
      return configuredEndpointPromise;
    };
    return resolvedConfig;
  }, "resolveEndpointConfig");

  // node_modules/@smithy/util-retry/dist-es/config.js
  var RETRY_MODES;
  (function(RETRY_MODES2) {
    RETRY_MODES2["STANDARD"] = "standard";
    RETRY_MODES2["ADAPTIVE"] = "adaptive";
  })(RETRY_MODES || (RETRY_MODES = {}));
  var DEFAULT_MAX_ATTEMPTS = 3;
  var DEFAULT_RETRY_MODE = RETRY_MODES.STANDARD;

  // node_modules/@smithy/service-error-classification/dist-es/constants.js
  var THROTTLING_ERROR_CODES = [
    "BandwidthLimitExceeded",
    "EC2ThrottledException",
    "LimitExceededException",
    "PriorRequestNotComplete",
    "ProvisionedThroughputExceededException",
    "RequestLimitExceeded",
    "RequestThrottled",
    "RequestThrottledException",
    "SlowDown",
    "ThrottledException",
    "Throttling",
    "ThrottlingException",
    "TooManyRequestsException",
    "TransactionInProgressException"
  ];
  var TRANSIENT_ERROR_CODES = ["TimeoutError", "RequestTimeout", "RequestTimeoutException"];
  var TRANSIENT_ERROR_STATUS_CODES = [500, 502, 503, 504];
  var NODEJS_TIMEOUT_ERROR_CODES = ["ECONNRESET", "ECONNREFUSED", "EPIPE", "ETIMEDOUT"];

  // node_modules/@smithy/service-error-classification/dist-es/index.js
  var isClockSkewCorrectedError = /* @__PURE__ */ __name((error) => error.$metadata?.clockSkewCorrected, "isClockSkewCorrectedError");
  var isThrottlingError = /* @__PURE__ */ __name((error) => error.$metadata?.httpStatusCode === 429 || THROTTLING_ERROR_CODES.includes(error.name) || error.$retryable?.throttling == true, "isThrottlingError");
  var isTransientError = /* @__PURE__ */ __name((error, depth = 0) => isClockSkewCorrectedError(error) || TRANSIENT_ERROR_CODES.includes(error.name) || NODEJS_TIMEOUT_ERROR_CODES.includes(error?.code || "") || TRANSIENT_ERROR_STATUS_CODES.includes(error.$metadata?.httpStatusCode || 0) || error.cause !== void 0 && depth <= 10 && isTransientError(error.cause, depth + 1), "isTransientError");
  var isServerError = /* @__PURE__ */ __name((error) => {
    if (error.$metadata?.httpStatusCode !== void 0) {
      const statusCode = error.$metadata.httpStatusCode;
      if (500 <= statusCode && statusCode <= 599 && !isTransientError(error)) {
        return true;
      }
      return false;
    }
    return false;
  }, "isServerError");

  // node_modules/@smithy/util-retry/dist-es/DefaultRateLimiter.js
  var DefaultRateLimiter = class _DefaultRateLimiter {
    static {
      __name(this, "DefaultRateLimiter");
    }
    constructor(options) {
      this.currentCapacity = 0;
      this.enabled = false;
      this.lastMaxRate = 0;
      this.measuredTxRate = 0;
      this.requestCount = 0;
      this.lastTimestamp = 0;
      this.timeWindow = 0;
      this.beta = options?.beta ?? 0.7;
      this.minCapacity = options?.minCapacity ?? 1;
      this.minFillRate = options?.minFillRate ?? 0.5;
      this.scaleConstant = options?.scaleConstant ?? 0.4;
      this.smooth = options?.smooth ?? 0.8;
      const currentTimeInSeconds = this.getCurrentTimeInSeconds();
      this.lastThrottleTime = currentTimeInSeconds;
      this.lastTxRateBucket = Math.floor(this.getCurrentTimeInSeconds());
      this.fillRate = this.minFillRate;
      this.maxCapacity = this.minCapacity;
    }
    getCurrentTimeInSeconds() {
      return Date.now() / 1e3;
    }
    async getSendToken() {
      return this.acquireTokenBucket(1);
    }
    async acquireTokenBucket(amount) {
      if (!this.enabled) {
        return;
      }
      this.refillTokenBucket();
      if (amount > this.currentCapacity) {
        const delay = (amount - this.currentCapacity) / this.fillRate * 1e3;
        await new Promise((resolve) => _DefaultRateLimiter.setTimeoutFn(resolve, delay));
      }
      this.currentCapacity = this.currentCapacity - amount;
    }
    refillTokenBucket() {
      const timestamp = this.getCurrentTimeInSeconds();
      if (!this.lastTimestamp) {
        this.lastTimestamp = timestamp;
        return;
      }
      const fillAmount = (timestamp - this.lastTimestamp) * this.fillRate;
      this.currentCapacity = Math.min(this.maxCapacity, this.currentCapacity + fillAmount);
      this.lastTimestamp = timestamp;
    }
    updateClientSendingRate(response) {
      let calculatedRate;
      this.updateMeasuredRate();
      if (isThrottlingError(response)) {
        const rateToUse = !this.enabled ? this.measuredTxRate : Math.min(this.measuredTxRate, this.fillRate);
        this.lastMaxRate = rateToUse;
        this.calculateTimeWindow();
        this.lastThrottleTime = this.getCurrentTimeInSeconds();
        calculatedRate = this.cubicThrottle(rateToUse);
        this.enableTokenBucket();
      } else {
        this.calculateTimeWindow();
        calculatedRate = this.cubicSuccess(this.getCurrentTimeInSeconds());
      }
      const newRate = Math.min(calculatedRate, 2 * this.measuredTxRate);
      this.updateTokenBucketRate(newRate);
    }
    calculateTimeWindow() {
      this.timeWindow = this.getPrecise(Math.pow(this.lastMaxRate * (1 - this.beta) / this.scaleConstant, 1 / 3));
    }
    cubicThrottle(rateToUse) {
      return this.getPrecise(rateToUse * this.beta);
    }
    cubicSuccess(timestamp) {
      return this.getPrecise(this.scaleConstant * Math.pow(timestamp - this.lastThrottleTime - this.timeWindow, 3) + this.lastMaxRate);
    }
    enableTokenBucket() {
      this.enabled = true;
    }
    updateTokenBucketRate(newRate) {
      this.refillTokenBucket();
      this.fillRate = Math.max(newRate, this.minFillRate);
      this.maxCapacity = Math.max(newRate, this.minCapacity);
      this.currentCapacity = Math.min(this.currentCapacity, this.maxCapacity);
    }
    updateMeasuredRate() {
      const t3 = this.getCurrentTimeInSeconds();
      const timeBucket = Math.floor(t3 * 2) / 2;
      this.requestCount++;
      if (timeBucket > this.lastTxRateBucket) {
        const currentRate = this.requestCount / (timeBucket - this.lastTxRateBucket);
        this.measuredTxRate = this.getPrecise(currentRate * this.smooth + this.measuredTxRate * (1 - this.smooth));
        this.requestCount = 0;
        this.lastTxRateBucket = timeBucket;
      }
    }
    getPrecise(num) {
      return parseFloat(num.toFixed(8));
    }
  };
  DefaultRateLimiter.setTimeoutFn = setTimeout;

  // node_modules/@smithy/util-retry/dist-es/constants.js
  var DEFAULT_RETRY_DELAY_BASE = 100;
  var MAXIMUM_RETRY_DELAY = 20 * 1e3;
  var THROTTLING_RETRY_DELAY_BASE = 500;
  var INITIAL_RETRY_TOKENS = 500;
  var RETRY_COST = 5;
  var TIMEOUT_RETRY_COST = 10;
  var NO_RETRY_INCREMENT = 1;
  var INVOCATION_ID_HEADER = "amz-sdk-invocation-id";
  var REQUEST_HEADER = "amz-sdk-request";

  // node_modules/@smithy/util-retry/dist-es/defaultRetryBackoffStrategy.js
  var getDefaultRetryBackoffStrategy = /* @__PURE__ */ __name(() => {
    let delayBase = DEFAULT_RETRY_DELAY_BASE;
    const computeNextBackoffDelay = /* @__PURE__ */ __name((attempts) => {
      return Math.floor(Math.min(MAXIMUM_RETRY_DELAY, Math.random() * 2 ** attempts * delayBase));
    }, "computeNextBackoffDelay");
    const setDelayBase = /* @__PURE__ */ __name((delay) => {
      delayBase = delay;
    }, "setDelayBase");
    return {
      computeNextBackoffDelay,
      setDelayBase
    };
  }, "getDefaultRetryBackoffStrategy");

  // node_modules/@smithy/util-retry/dist-es/defaultRetryToken.js
  var createDefaultRetryToken = /* @__PURE__ */ __name(({ retryDelay, retryCount, retryCost }) => {
    const getRetryCount = /* @__PURE__ */ __name(() => retryCount, "getRetryCount");
    const getRetryDelay = /* @__PURE__ */ __name(() => Math.min(MAXIMUM_RETRY_DELAY, retryDelay), "getRetryDelay");
    const getRetryCost = /* @__PURE__ */ __name(() => retryCost, "getRetryCost");
    return {
      getRetryCount,
      getRetryDelay,
      getRetryCost
    };
  }, "createDefaultRetryToken");

  // node_modules/@smithy/util-retry/dist-es/StandardRetryStrategy.js
  var StandardRetryStrategy = class {
    static {
      __name(this, "StandardRetryStrategy");
    }
    constructor(maxAttempts) {
      this.maxAttempts = maxAttempts;
      this.mode = RETRY_MODES.STANDARD;
      this.capacity = INITIAL_RETRY_TOKENS;
      this.retryBackoffStrategy = getDefaultRetryBackoffStrategy();
      this.maxAttemptsProvider = typeof maxAttempts === "function" ? maxAttempts : async () => maxAttempts;
    }
    async acquireInitialRetryToken(retryTokenScope) {
      return createDefaultRetryToken({
        retryDelay: DEFAULT_RETRY_DELAY_BASE,
        retryCount: 0
      });
    }
    async refreshRetryTokenForRetry(token, errorInfo) {
      const maxAttempts = await this.getMaxAttempts();
      if (this.shouldRetry(token, errorInfo, maxAttempts)) {
        const errorType = errorInfo.errorType;
        this.retryBackoffStrategy.setDelayBase(errorType === "THROTTLING" ? THROTTLING_RETRY_DELAY_BASE : DEFAULT_RETRY_DELAY_BASE);
        const delayFromErrorType = this.retryBackoffStrategy.computeNextBackoffDelay(token.getRetryCount());
        const retryDelay = errorInfo.retryAfterHint ? Math.max(errorInfo.retryAfterHint.getTime() - Date.now() || 0, delayFromErrorType) : delayFromErrorType;
        const capacityCost = this.getCapacityCost(errorType);
        this.capacity -= capacityCost;
        return createDefaultRetryToken({
          retryDelay,
          retryCount: token.getRetryCount() + 1,
          retryCost: capacityCost
        });
      }
      throw new Error("No retry token available");
    }
    recordSuccess(token) {
      this.capacity = Math.max(INITIAL_RETRY_TOKENS, this.capacity + (token.getRetryCost() ?? NO_RETRY_INCREMENT));
    }
    getCapacity() {
      return this.capacity;
    }
    async getMaxAttempts() {
      try {
        return await this.maxAttemptsProvider();
      } catch (error) {
        console.warn(`Max attempts provider could not resolve. Using default of ${DEFAULT_MAX_ATTEMPTS}`);
        return DEFAULT_MAX_ATTEMPTS;
      }
    }
    shouldRetry(tokenToRenew, errorInfo, maxAttempts) {
      const attempts = tokenToRenew.getRetryCount() + 1;
      return attempts < maxAttempts && this.capacity >= this.getCapacityCost(errorInfo.errorType) && this.isRetryableError(errorInfo.errorType);
    }
    getCapacityCost(errorType) {
      return errorType === "TRANSIENT" ? TIMEOUT_RETRY_COST : RETRY_COST;
    }
    isRetryableError(errorType) {
      return errorType === "THROTTLING" || errorType === "TRANSIENT";
    }
  };

  // node_modules/@smithy/util-retry/dist-es/AdaptiveRetryStrategy.js
  var AdaptiveRetryStrategy = class {
    static {
      __name(this, "AdaptiveRetryStrategy");
    }
    constructor(maxAttemptsProvider, options) {
      this.maxAttemptsProvider = maxAttemptsProvider;
      this.mode = RETRY_MODES.ADAPTIVE;
      const { rateLimiter } = options ?? {};
      this.rateLimiter = rateLimiter ?? new DefaultRateLimiter();
      this.standardRetryStrategy = new StandardRetryStrategy(maxAttemptsProvider);
    }
    async acquireInitialRetryToken(retryTokenScope) {
      await this.rateLimiter.getSendToken();
      return this.standardRetryStrategy.acquireInitialRetryToken(retryTokenScope);
    }
    async refreshRetryTokenForRetry(tokenToRenew, errorInfo) {
      this.rateLimiter.updateClientSendingRate(errorInfo);
      return this.standardRetryStrategy.refreshRetryTokenForRetry(tokenToRenew, errorInfo);
    }
    recordSuccess(token) {
      this.rateLimiter.updateClientSendingRate({});
      this.standardRetryStrategy.recordSuccess(token);
    }
  };

  // node_modules/uuid/dist/esm-browser/rng.js
  var getRandomValues;
  var rnds8 = new Uint8Array(16);
  function rng() {
    if (!getRandomValues) {
      getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
      if (!getRandomValues) {
        throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
      }
    }
    return getRandomValues(rnds8);
  }
  __name(rng, "rng");

  // node_modules/uuid/dist/esm-browser/stringify.js
  var byteToHex = [];
  for (let i3 = 0; i3 < 256; ++i3) {
    byteToHex.push((i3 + 256).toString(16).slice(1));
  }
  function unsafeStringify(arr, offset = 0) {
    return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];
  }
  __name(unsafeStringify, "unsafeStringify");

  // node_modules/uuid/dist/esm-browser/native.js
  var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
  var native_default = {
    randomUUID
  };

  // node_modules/uuid/dist/esm-browser/v4.js
  function v4(options, buf, offset) {
    if (native_default.randomUUID && !buf && !options) {
      return native_default.randomUUID();
    }
    options = options || {};
    const rnds = options.random || (options.rng || rng)();
    rnds[6] = rnds[6] & 15 | 64;
    rnds[8] = rnds[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (let i3 = 0; i3 < 16; ++i3) {
        buf[offset + i3] = rnds[i3];
      }
      return buf;
    }
    return unsafeStringify(rnds);
  }
  __name(v4, "v4");
  var v4_default = v4;

  // node_modules/@smithy/middleware-retry/dist-es/util.js
  var asSdkError = /* @__PURE__ */ __name((error) => {
    if (error instanceof Error)
      return error;
    if (error instanceof Object)
      return Object.assign(new Error(), error);
    if (typeof error === "string")
      return new Error(error);
    return new Error(`AWS SDK error wrapper for ${error}`);
  }, "asSdkError");

  // node_modules/@smithy/middleware-retry/dist-es/configurations.js
  var resolveRetryConfig = /* @__PURE__ */ __name((input) => {
    const { retryStrategy } = input;
    const maxAttempts = normalizeProvider(input.maxAttempts ?? DEFAULT_MAX_ATTEMPTS);
    return {
      ...input,
      maxAttempts,
      retryStrategy: async () => {
        if (retryStrategy) {
          return retryStrategy;
        }
        const retryMode = await normalizeProvider(input.retryMode)();
        if (retryMode === RETRY_MODES.ADAPTIVE) {
          return new AdaptiveRetryStrategy(maxAttempts);
        }
        return new StandardRetryStrategy(maxAttempts);
      }
    };
  }, "resolveRetryConfig");

  // node_modules/@smithy/middleware-retry/dist-es/isStreamingPayload/isStreamingPayload.browser.js
  var isStreamingPayload = /* @__PURE__ */ __name((request) => request?.body instanceof ReadableStream, "isStreamingPayload");

  // node_modules/@smithy/middleware-retry/dist-es/retryMiddleware.js
  var retryMiddleware = /* @__PURE__ */ __name((options) => (next, context) => async (args) => {
    let retryStrategy = await options.retryStrategy();
    const maxAttempts = await options.maxAttempts();
    if (isRetryStrategyV2(retryStrategy)) {
      retryStrategy = retryStrategy;
      let retryToken = await retryStrategy.acquireInitialRetryToken(context["partition_id"]);
      let lastError = new Error();
      let attempts = 0;
      let totalRetryDelay = 0;
      const { request } = args;
      const isRequest = HttpRequest.isInstance(request);
      if (isRequest) {
        request.headers[INVOCATION_ID_HEADER] = v4_default();
      }
      while (true) {
        try {
          if (isRequest) {
            request.headers[REQUEST_HEADER] = `attempt=${attempts + 1}; max=${maxAttempts}`;
          }
          const { response, output } = await next(args);
          retryStrategy.recordSuccess(retryToken);
          output.$metadata.attempts = attempts + 1;
          output.$metadata.totalRetryDelay = totalRetryDelay;
          return { response, output };
        } catch (e3) {
          const retryErrorInfo = getRetryErrorInfo(e3);
          lastError = asSdkError(e3);
          if (isRequest && isStreamingPayload(request)) {
            (context.logger instanceof NoOpLogger ? console : context.logger)?.warn("An error was encountered in a non-retryable streaming request.");
            throw lastError;
          }
          try {
            retryToken = await retryStrategy.refreshRetryTokenForRetry(retryToken, retryErrorInfo);
          } catch (refreshError) {
            if (!lastError.$metadata) {
              lastError.$metadata = {};
            }
            lastError.$metadata.attempts = attempts + 1;
            lastError.$metadata.totalRetryDelay = totalRetryDelay;
            throw lastError;
          }
          attempts = retryToken.getRetryCount();
          const delay = retryToken.getRetryDelay();
          totalRetryDelay += delay;
          await new Promise((resolve) => setTimeout(resolve, delay));
        }
      }
    } else {
      retryStrategy = retryStrategy;
      if (retryStrategy?.mode)
        context.userAgent = [...context.userAgent || [], ["cfg/retry-mode", retryStrategy.mode]];
      return retryStrategy.retry(next, args);
    }
  }, "retryMiddleware");
  var isRetryStrategyV2 = /* @__PURE__ */ __name((retryStrategy) => typeof retryStrategy.acquireInitialRetryToken !== "undefined" && typeof retryStrategy.refreshRetryTokenForRetry !== "undefined" && typeof retryStrategy.recordSuccess !== "undefined", "isRetryStrategyV2");
  var getRetryErrorInfo = /* @__PURE__ */ __name((error) => {
    const errorInfo = {
      error,
      errorType: getRetryErrorType(error)
    };
    const retryAfterHint = getRetryAfterHint(error.$response);
    if (retryAfterHint) {
      errorInfo.retryAfterHint = retryAfterHint;
    }
    return errorInfo;
  }, "getRetryErrorInfo");
  var getRetryErrorType = /* @__PURE__ */ __name((error) => {
    if (isThrottlingError(error))
      return "THROTTLING";
    if (isTransientError(error))
      return "TRANSIENT";
    if (isServerError(error))
      return "SERVER_ERROR";
    return "CLIENT_ERROR";
  }, "getRetryErrorType");
  var retryMiddlewareOptions = {
    name: "retryMiddleware",
    tags: ["RETRY"],
    step: "finalizeRequest",
    priority: "high",
    override: true
  };
  var getRetryPlugin = /* @__PURE__ */ __name((options) => ({
    applyToStack: (clientStack) => {
      clientStack.add(retryMiddleware(options), retryMiddlewareOptions);
    }
  }), "getRetryPlugin");
  var getRetryAfterHint = /* @__PURE__ */ __name((response) => {
    if (!HttpResponse.isInstance(response))
      return;
    const retryAfterHeaderName = Object.keys(response.headers).find((key) => key.toLowerCase() === "retry-after");
    if (!retryAfterHeaderName)
      return;
    const retryAfter = response.headers[retryAfterHeaderName];
    const retryAfterSeconds = Number(retryAfter);
    if (!Number.isNaN(retryAfterSeconds))
      return new Date(retryAfterSeconds * 1e3);
    const retryAfterDate = new Date(retryAfter);
    return retryAfterDate;
  }, "getRetryAfterHint");

  // node_modules/@aws-sdk/signature-v4-multi-region/dist-es/signature-v4-crt-container.js
  var signatureV4CrtContainer = {
    CrtSignerV4: null
  };

  // node_modules/@aws-sdk/signature-v4-multi-region/dist-es/SignatureV4MultiRegion.js
  var SignatureV4MultiRegion = class {
    static {
      __name(this, "SignatureV4MultiRegion");
    }
    sigv4aSigner;
    sigv4Signer;
    signerOptions;
    constructor(options) {
      this.sigv4Signer = new SignatureV4S3Express(options);
      this.signerOptions = options;
    }
    async sign(requestToSign, options = {}) {
      if (options.signingRegion === "*") {
        if (this.signerOptions.runtime !== "node")
          throw new Error("This request requires signing with SigV4Asymmetric algorithm. It's only available in Node.js");
        return this.getSigv4aSigner().sign(requestToSign, options);
      }
      return this.sigv4Signer.sign(requestToSign, options);
    }
    async signWithCredentials(requestToSign, credentials, options = {}) {
      if (options.signingRegion === "*") {
        if (this.signerOptions.runtime !== "node")
          throw new Error("This request requires signing with SigV4Asymmetric algorithm. It's only available in Node.js");
        return this.getSigv4aSigner().signWithCredentials(requestToSign, credentials, options);
      }
      return this.sigv4Signer.signWithCredentials(requestToSign, credentials, options);
    }
    async presign(originalRequest, options = {}) {
      if (options.signingRegion === "*") {
        if (this.signerOptions.runtime !== "node")
          throw new Error("This request requires signing with SigV4Asymmetric algorithm. It's only available in Node.js");
        return this.getSigv4aSigner().presign(originalRequest, options);
      }
      return this.sigv4Signer.presign(originalRequest, options);
    }
    async presignWithCredentials(originalRequest, credentials, options = {}) {
      if (options.signingRegion === "*") {
        throw new Error("Method presignWithCredentials is not supported for [signingRegion=*].");
      }
      return this.sigv4Signer.presignWithCredentials(originalRequest, credentials, options);
    }
    getSigv4aSigner() {
      if (!this.sigv4aSigner) {
        let CrtSignerV4 = null;
        try {
          CrtSignerV4 = signatureV4CrtContainer.CrtSignerV4;
          if (typeof CrtSignerV4 !== "function")
            throw new Error();
        } catch (e3) {
          e3.message = `${e3.message}
Please check whether you have installed the "@aws-sdk/signature-v4-crt" package explicitly. 
You must also register the package by calling [require("@aws-sdk/signature-v4-crt");] or an ESM equivalent such as [import "@aws-sdk/signature-v4-crt";]. 
For more information please go to https://github.com/aws/aws-sdk-js-v3#functionality-requiring-aws-common-runtime-crt`;
          throw e3;
        }
        this.sigv4aSigner = new CrtSignerV4({
          ...this.signerOptions,
          signingAlgorithm: 1
        });
      }
      return this.sigv4aSigner;
    }
  };

  // node_modules/@aws-sdk/client-s3/dist-es/endpoint/ruleset.js
  var ci = "required";
  var cj = "type";
  var ck = "conditions";
  var cl = "fn";
  var cm = "argv";
  var cn = "ref";
  var co = "assign";
  var cp = "url";
  var cq = "properties";
  var cr = "backend";
  var cs = "authSchemes";
  var ct = "disableDoubleEncoding";
  var cu = "signingName";
  var cv = "signingRegion";
  var cw = "headers";
  var cx = "signingRegionSet";
  var a = 6;
  var b = false;
  var c = true;
  var d = "isSet";
  var e = "booleanEquals";
  var f = "error";
  var g = "aws.partition";
  var h = "stringEquals";
  var i = "getAttr";
  var j = "name";
  var k = "substring";
  var l = "bucketSuffix";
  var m = "parseURL";
  var n = "{url#scheme}://{url#authority}/{uri_encoded_bucket}{url#path}";
  var o = "endpoint";
  var p = "tree";
  var q = "aws.isVirtualHostableS3Bucket";
  var r = "{url#scheme}://{Bucket}.{url#authority}{url#path}";
  var s = "not";
  var t = "{url#scheme}://{url#authority}{url#path}";
  var u = "hardwareType";
  var v = "regionPrefix";
  var w = "bucketAliasSuffix";
  var x = "outpostId";
  var y = "isValidHostLabel";
  var z = "sigv4a";
  var A = "s3-outposts";
  var B = "s3";
  var C = "{url#scheme}://{url#authority}{url#normalizedPath}{Bucket}";
  var D = "https://{Bucket}.s3-accelerate.{partitionResult#dnsSuffix}";
  var E = "https://{Bucket}.s3.{partitionResult#dnsSuffix}";
  var F = "aws.parseArn";
  var G = "bucketArn";
  var H = "arnType";
  var I = "";
  var J = "s3-object-lambda";
  var K = "accesspoint";
  var L3 = "accessPointName";
  var M = "{url#scheme}://{accessPointName}-{bucketArn#accountId}.{url#authority}{url#path}";
  var N = "mrapPartition";
  var O = "outpostType";
  var P = "arnPrefix";
  var Q = "{url#scheme}://{url#authority}{url#normalizedPath}{uri_encoded_bucket}";
  var R = "https://s3.{partitionResult#dnsSuffix}/{uri_encoded_bucket}";
  var S = "https://s3.{partitionResult#dnsSuffix}";
  var T = { [ci]: false, [cj]: "String" };
  var U = { [ci]: true, "default": false, [cj]: "Boolean" };
  var V = { [ci]: false, [cj]: "Boolean" };
  var W = { [cl]: e, [cm]: [{ [cn]: "Accelerate" }, true] };
  var X = { [cl]: e, [cm]: [{ [cn]: "UseFIPS" }, true] };
  var Y = { [cl]: e, [cm]: [{ [cn]: "UseDualStack" }, true] };
  var Z = { [cl]: d, [cm]: [{ [cn]: "Endpoint" }] };
  var aa = { [cl]: g, [cm]: [{ [cn]: "Region" }], [co]: "partitionResult" };
  var ab = { [cl]: h, [cm]: [{ [cl]: i, [cm]: [{ [cn]: "partitionResult" }, j] }, "aws-cn"] };
  var ac = { [cl]: d, [cm]: [{ [cn]: "Bucket" }] };
  var ad = { [cn]: "Bucket" };
  var ae = { [cl]: m, [cm]: [{ [cn]: "Endpoint" }], [co]: "url" };
  var af = { [cl]: e, [cm]: [{ [cl]: i, [cm]: [{ [cn]: "url" }, "isIp"] }, true] };
  var ag = { [cn]: "url" };
  var ah = { [cl]: "uriEncode", [cm]: [ad], [co]: "uri_encoded_bucket" };
  var ai = { [cr]: "S3Express", [cs]: [{ [ct]: true, [j]: "sigv4", [cu]: "s3express", [cv]: "{Region}" }] };
  var aj = {};
  var ak = { [cl]: q, [cm]: [ad, false] };
  var al = { [f]: "S3Express bucket name is not a valid virtual hostable name.", [cj]: f };
  var am = { [cr]: "S3Express", [cs]: [{ [ct]: true, [j]: "sigv4-s3express", [cu]: "s3express", [cv]: "{Region}" }] };
  var an = { [cl]: d, [cm]: [{ [cn]: "UseS3ExpressControlEndpoint" }] };
  var ao = { [cl]: e, [cm]: [{ [cn]: "UseS3ExpressControlEndpoint" }, true] };
  var ap = { [cl]: s, [cm]: [Z] };
  var aq = { [f]: "Unrecognized S3Express bucket name format.", [cj]: f };
  var ar = { [cl]: s, [cm]: [ac] };
  var as = { [cn]: u };
  var at = { [ck]: [ap], [f]: "Expected a endpoint to be specified but no endpoint was found", [cj]: f };
  var au = { [cs]: [{ [ct]: true, [j]: z, [cu]: A, [cx]: ["*"] }, { [ct]: true, [j]: "sigv4", [cu]: A, [cv]: "{Region}" }] };
  var av = { [cl]: e, [cm]: [{ [cn]: "ForcePathStyle" }, false] };
  var aw = { [cn]: "ForcePathStyle" };
  var ax = { [cl]: e, [cm]: [{ [cn]: "Accelerate" }, false] };
  var ay = { [cl]: h, [cm]: [{ [cn]: "Region" }, "aws-global"] };
  var az = { [cs]: [{ [ct]: true, [j]: "sigv4", [cu]: B, [cv]: "us-east-1" }] };
  var aA = { [cl]: s, [cm]: [ay] };
  var aB = { [cl]: e, [cm]: [{ [cn]: "UseGlobalEndpoint" }, true] };
  var aC = { [cp]: "https://{Bucket}.s3-fips.dualstack.{Region}.{partitionResult#dnsSuffix}", [cq]: { [cs]: [{ [ct]: true, [j]: "sigv4", [cu]: B, [cv]: "{Region}" }] }, [cw]: {} };
  var aD = { [cs]: [{ [ct]: true, [j]: "sigv4", [cu]: B, [cv]: "{Region}" }] };
  var aE = { [cl]: e, [cm]: [{ [cn]: "UseGlobalEndpoint" }, false] };
  var aF = { [cl]: e, [cm]: [{ [cn]: "UseDualStack" }, false] };
  var aG = { [cp]: "https://{Bucket}.s3-fips.{Region}.{partitionResult#dnsSuffix}", [cq]: aD, [cw]: {} };
  var aH = { [cl]: e, [cm]: [{ [cn]: "UseFIPS" }, false] };
  var aI = { [cp]: "https://{Bucket}.s3-accelerate.dualstack.{partitionResult#dnsSuffix}", [cq]: aD, [cw]: {} };
  var aJ = { [cp]: "https://{Bucket}.s3.dualstack.{Region}.{partitionResult#dnsSuffix}", [cq]: aD, [cw]: {} };
  var aK = { [cl]: e, [cm]: [{ [cl]: i, [cm]: [ag, "isIp"] }, false] };
  var aL = { [cp]: C, [cq]: aD, [cw]: {} };
  var aM = { [cp]: r, [cq]: aD, [cw]: {} };
  var aN = { [o]: aM, [cj]: o };
  var aO = { [cp]: D, [cq]: aD, [cw]: {} };
  var aP = { [cp]: "https://{Bucket}.s3.{Region}.{partitionResult#dnsSuffix}", [cq]: aD, [cw]: {} };
  var aQ = { [f]: "Invalid region: region was not a valid DNS name.", [cj]: f };
  var aR = { [cn]: G };
  var aS = { [cn]: H };
  var aT = { [cl]: i, [cm]: [aR, "service"] };
  var aU = { [cn]: L3 };
  var aV = { [ck]: [Y], [f]: "S3 Object Lambda does not support Dual-stack", [cj]: f };
  var aW = { [ck]: [W], [f]: "S3 Object Lambda does not support S3 Accelerate", [cj]: f };
  var aX = { [ck]: [{ [cl]: d, [cm]: [{ [cn]: "DisableAccessPoints" }] }, { [cl]: e, [cm]: [{ [cn]: "DisableAccessPoints" }, true] }], [f]: "Access points are not supported for this operation", [cj]: f };
  var aY = { [ck]: [{ [cl]: d, [cm]: [{ [cn]: "UseArnRegion" }] }, { [cl]: e, [cm]: [{ [cn]: "UseArnRegion" }, false] }, { [cl]: s, [cm]: [{ [cl]: h, [cm]: [{ [cl]: i, [cm]: [aR, "region"] }, "{Region}"] }] }], [f]: "Invalid configuration: region from ARN `{bucketArn#region}` does not match client region `{Region}` and UseArnRegion is `false`", [cj]: f };
  var aZ = { [cl]: i, [cm]: [{ [cn]: "bucketPartition" }, j] };
  var ba = { [cl]: i, [cm]: [aR, "accountId"] };
  var bb = { [cs]: [{ [ct]: true, [j]: "sigv4", [cu]: J, [cv]: "{bucketArn#region}" }] };
  var bc = { [f]: "Invalid ARN: The access point name may only contain a-z, A-Z, 0-9 and `-`. Found: `{accessPointName}`", [cj]: f };
  var bd = { [f]: "Invalid ARN: The account id may only contain a-z, A-Z, 0-9 and `-`. Found: `{bucketArn#accountId}`", [cj]: f };
  var be = { [f]: "Invalid region in ARN: `{bucketArn#region}` (invalid DNS name)", [cj]: f };
  var bf = { [f]: "Client was configured for partition `{partitionResult#name}` but ARN (`{Bucket}`) has `{bucketPartition#name}`", [cj]: f };
  var bg = { [f]: "Invalid ARN: The ARN may only contain a single resource component after `accesspoint`.", [cj]: f };
  var bh = { [f]: "Invalid ARN: Expected a resource of the format `accesspoint:<accesspoint name>` but no name was provided", [cj]: f };
  var bi = { [cs]: [{ [ct]: true, [j]: "sigv4", [cu]: B, [cv]: "{bucketArn#region}" }] };
  var bj = { [cs]: [{ [ct]: true, [j]: z, [cu]: A, [cx]: ["*"] }, { [ct]: true, [j]: "sigv4", [cu]: A, [cv]: "{bucketArn#region}" }] };
  var bk = { [cl]: F, [cm]: [ad] };
  var bl = { [cp]: "https://s3-fips.dualstack.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [cq]: aD, [cw]: {} };
  var bm = { [cp]: "https://s3-fips.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [cq]: aD, [cw]: {} };
  var bn = { [cp]: "https://s3.dualstack.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [cq]: aD, [cw]: {} };
  var bo = { [cp]: Q, [cq]: aD, [cw]: {} };
  var bp = { [cp]: "https://s3.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [cq]: aD, [cw]: {} };
  var bq = { [cn]: "UseObjectLambdaEndpoint" };
  var br = { [cs]: [{ [ct]: true, [j]: "sigv4", [cu]: J, [cv]: "{Region}" }] };
  var bs = { [cp]: "https://s3-fips.dualstack.{Region}.{partitionResult#dnsSuffix}", [cq]: aD, [cw]: {} };
  var bt = { [cp]: "https://s3-fips.{Region}.{partitionResult#dnsSuffix}", [cq]: aD, [cw]: {} };
  var bu = { [cp]: "https://s3.dualstack.{Region}.{partitionResult#dnsSuffix}", [cq]: aD, [cw]: {} };
  var bv = { [cp]: t, [cq]: aD, [cw]: {} };
  var bw = { [cp]: "https://s3.{Region}.{partitionResult#dnsSuffix}", [cq]: aD, [cw]: {} };
  var bx = [{ [cn]: "Region" }];
  var by = [{ [cn]: "Endpoint" }];
  var bz = [ad];
  var bA = [Y];
  var bB = [W];
  var bC = [Z, ae];
  var bD = [{ [cl]: d, [cm]: [{ [cn]: "DisableS3ExpressSessionAuth" }] }, { [cl]: e, [cm]: [{ [cn]: "DisableS3ExpressSessionAuth" }, true] }];
  var bE = [af];
  var bF = [ah];
  var bG = [ak];
  var bH = [X];
  var bI = [{ [cl]: k, [cm]: [ad, 6, 14, true], [co]: "s3expressAvailabilityZoneId" }, { [cl]: k, [cm]: [ad, 14, 16, true], [co]: "s3expressAvailabilityZoneDelim" }, { [cl]: h, [cm]: [{ [cn]: "s3expressAvailabilityZoneDelim" }, "--"] }];
  var bJ = [{ [ck]: [X], [o]: { [cp]: "https://{Bucket}.s3express-fips-{s3expressAvailabilityZoneId}.{Region}.amazonaws.com", [cq]: ai, [cw]: {} }, [cj]: o }, { [o]: { [cp]: "https://{Bucket}.s3express-{s3expressAvailabilityZoneId}.{Region}.amazonaws.com", [cq]: ai, [cw]: {} }, [cj]: o }];
  var bK = [{ [cl]: k, [cm]: [ad, 6, 15, true], [co]: "s3expressAvailabilityZoneId" }, { [cl]: k, [cm]: [ad, 15, 17, true], [co]: "s3expressAvailabilityZoneDelim" }, { [cl]: h, [cm]: [{ [cn]: "s3expressAvailabilityZoneDelim" }, "--"] }];
  var bL = [{ [cl]: k, [cm]: [ad, 6, 19, true], [co]: "s3expressAvailabilityZoneId" }, { [cl]: k, [cm]: [ad, 19, 21, true], [co]: "s3expressAvailabilityZoneDelim" }, { [cl]: h, [cm]: [{ [cn]: "s3expressAvailabilityZoneDelim" }, "--"] }];
  var bM = [{ [cl]: k, [cm]: [ad, 6, 20, true], [co]: "s3expressAvailabilityZoneId" }, { [cl]: k, [cm]: [ad, 20, 22, true], [co]: "s3expressAvailabilityZoneDelim" }, { [cl]: h, [cm]: [{ [cn]: "s3expressAvailabilityZoneDelim" }, "--"] }];
  var bN = [{ [cl]: k, [cm]: [ad, 6, 26, true], [co]: "s3expressAvailabilityZoneId" }, { [cl]: k, [cm]: [ad, 26, 28, true], [co]: "s3expressAvailabilityZoneDelim" }, { [cl]: h, [cm]: [{ [cn]: "s3expressAvailabilityZoneDelim" }, "--"] }];
  var bO = [{ [ck]: [X], [o]: { [cp]: "https://{Bucket}.s3express-fips-{s3expressAvailabilityZoneId}.{Region}.amazonaws.com", [cq]: am, [cw]: {} }, [cj]: o }, { [o]: { [cp]: "https://{Bucket}.s3express-{s3expressAvailabilityZoneId}.{Region}.amazonaws.com", [cq]: am, [cw]: {} }, [cj]: o }];
  var bP = [ac];
  var bQ = [{ [cl]: y, [cm]: [{ [cn]: x }, false] }];
  var bR = [{ [cl]: h, [cm]: [{ [cn]: v }, "beta"] }];
  var bS = ["*"];
  var bT = [aa];
  var bU = [{ [cl]: y, [cm]: [{ [cn]: "Region" }, false] }];
  var bV = [{ [cl]: h, [cm]: [{ [cn]: "Region" }, "us-east-1"] }];
  var bW = [{ [cl]: h, [cm]: [aS, K] }];
  var bX = [{ [cl]: i, [cm]: [aR, "resourceId[1]"], [co]: L3 }, { [cl]: s, [cm]: [{ [cl]: h, [cm]: [aU, I] }] }];
  var bY = [aR, "resourceId[1]"];
  var bZ = [{ [cl]: s, [cm]: [{ [cl]: h, [cm]: [{ [cl]: i, [cm]: [aR, "region"] }, I] }] }];
  var ca = [{ [cl]: s, [cm]: [{ [cl]: d, [cm]: [{ [cl]: i, [cm]: [aR, "resourceId[2]"] }] }] }];
  var cb = [aR, "resourceId[2]"];
  var cc = [{ [cl]: g, [cm]: [{ [cl]: i, [cm]: [aR, "region"] }], [co]: "bucketPartition" }];
  var cd = [{ [cl]: h, [cm]: [aZ, { [cl]: i, [cm]: [{ [cn]: "partitionResult" }, j] }] }];
  var ce = [{ [cl]: y, [cm]: [{ [cl]: i, [cm]: [aR, "region"] }, true] }];
  var cf = [{ [cl]: y, [cm]: [ba, false] }];
  var cg = [{ [cl]: y, [cm]: [aU, false] }];
  var ch = [{ [cl]: y, [cm]: [{ [cn]: "Region" }, true] }];
  var _data = { version: "1.0", parameters: { Bucket: T, Region: T, UseFIPS: U, UseDualStack: U, Endpoint: T, ForcePathStyle: U, Accelerate: U, UseGlobalEndpoint: U, UseObjectLambdaEndpoint: V, Key: T, Prefix: T, CopySource: T, DisableAccessPoints: V, DisableMultiRegionAccessPoints: U, UseArnRegion: V, UseS3ExpressControlEndpoint: V, DisableS3ExpressSessionAuth: V }, rules: [{ [ck]: [{ [cl]: d, [cm]: bx }], rules: [{ [ck]: [W, X], error: "Accelerate cannot be used with FIPS", [cj]: f }, { [ck]: [Y, Z], error: "Cannot set dual-stack in combination with a custom endpoint.", [cj]: f }, { [ck]: [Z, X], error: "A custom endpoint cannot be combined with FIPS", [cj]: f }, { [ck]: [Z, W], error: "A custom endpoint cannot be combined with S3 Accelerate", [cj]: f }, { [ck]: [X, aa, ab], error: "Partition does not support FIPS", [cj]: f }, { [ck]: [ac, { [cl]: k, [cm]: [ad, 0, a, c], [co]: l }, { [cl]: h, [cm]: [{ [cn]: l }, "--x-s3"] }], rules: [{ [ck]: bA, error: "S3Express does not support Dual-stack.", [cj]: f }, { [ck]: bB, error: "S3Express does not support S3 Accelerate.", [cj]: f }, { [ck]: bC, rules: [{ [ck]: bD, rules: [{ [ck]: bE, rules: [{ [ck]: bF, rules: [{ endpoint: { [cp]: n, [cq]: ai, [cw]: aj }, [cj]: o }], [cj]: p }], [cj]: p }, { [ck]: bG, rules: [{ endpoint: { [cp]: r, [cq]: ai, [cw]: aj }, [cj]: o }], [cj]: p }, al], [cj]: p }, { [ck]: bE, rules: [{ [ck]: bF, rules: [{ endpoint: { [cp]: n, [cq]: am, [cw]: aj }, [cj]: o }], [cj]: p }], [cj]: p }, { [ck]: bG, rules: [{ endpoint: { [cp]: r, [cq]: am, [cw]: aj }, [cj]: o }], [cj]: p }, al], [cj]: p }, { [ck]: [an, ao], rules: [{ [ck]: [ah, ap], rules: [{ [ck]: bH, endpoint: { [cp]: "https://s3express-control-fips.{Region}.amazonaws.com/{uri_encoded_bucket}", [cq]: ai, [cw]: aj }, [cj]: o }, { endpoint: { [cp]: "https://s3express-control.{Region}.amazonaws.com/{uri_encoded_bucket}", [cq]: ai, [cw]: aj }, [cj]: o }], [cj]: p }], [cj]: p }, { [ck]: bG, rules: [{ [ck]: bD, rules: [{ [ck]: bI, rules: bJ, [cj]: p }, { [ck]: bK, rules: bJ, [cj]: p }, { [ck]: bL, rules: bJ, [cj]: p }, { [ck]: bM, rules: bJ, [cj]: p }, { [ck]: bN, rules: bJ, [cj]: p }, aq], [cj]: p }, { [ck]: bI, rules: bO, [cj]: p }, { [ck]: bK, rules: bO, [cj]: p }, { [ck]: bL, rules: bO, [cj]: p }, { [ck]: bM, rules: bO, [cj]: p }, { [ck]: bN, rules: bO, [cj]: p }, aq], [cj]: p }, al], [cj]: p }, { [ck]: [ar, an, ao], rules: [{ [ck]: bC, endpoint: { [cp]: t, [cq]: ai, [cw]: aj }, [cj]: o }, { [ck]: bH, endpoint: { [cp]: "https://s3express-control-fips.{Region}.amazonaws.com", [cq]: ai, [cw]: aj }, [cj]: o }, { endpoint: { [cp]: "https://s3express-control.{Region}.amazonaws.com", [cq]: ai, [cw]: aj }, [cj]: o }], [cj]: p }, { [ck]: [ac, { [cl]: k, [cm]: [ad, 49, 50, c], [co]: u }, { [cl]: k, [cm]: [ad, 8, 12, c], [co]: v }, { [cl]: k, [cm]: [ad, 0, 7, c], [co]: w }, { [cl]: k, [cm]: [ad, 32, 49, c], [co]: x }, { [cl]: g, [cm]: bx, [co]: "regionPartition" }, { [cl]: h, [cm]: [{ [cn]: w }, "--op-s3"] }], rules: [{ [ck]: bQ, rules: [{ [ck]: [{ [cl]: h, [cm]: [as, "e"] }], rules: [{ [ck]: bR, rules: [at, { [ck]: bC, endpoint: { [cp]: "https://{Bucket}.ec2.{url#authority}", [cq]: au, [cw]: aj }, [cj]: o }], [cj]: p }, { endpoint: { [cp]: "https://{Bucket}.ec2.s3-outposts.{Region}.{regionPartition#dnsSuffix}", [cq]: au, [cw]: aj }, [cj]: o }], [cj]: p }, { [ck]: [{ [cl]: h, [cm]: [as, "o"] }], rules: [{ [ck]: bR, rules: [at, { [ck]: bC, endpoint: { [cp]: "https://{Bucket}.op-{outpostId}.{url#authority}", [cq]: au, [cw]: aj }, [cj]: o }], [cj]: p }, { endpoint: { [cp]: "https://{Bucket}.op-{outpostId}.s3-outposts.{Region}.{regionPartition#dnsSuffix}", [cq]: au, [cw]: aj }, [cj]: o }], [cj]: p }, { error: 'Unrecognized hardware type: "Expected hardware type o or e but got {hardwareType}"', [cj]: f }], [cj]: p }, { error: "Invalid ARN: The outpost Id must only contain a-z, A-Z, 0-9 and `-`.", [cj]: f }], [cj]: p }, { [ck]: bP, rules: [{ [ck]: [Z, { [cl]: s, [cm]: [{ [cl]: d, [cm]: [{ [cl]: m, [cm]: by }] }] }], error: "Custom endpoint `{Endpoint}` was not a valid URI", [cj]: f }, { [ck]: [av, ak], rules: [{ [ck]: bT, rules: [{ [ck]: bU, rules: [{ [ck]: [W, ab], error: "S3 Accelerate cannot be used in this region", [cj]: f }, { [ck]: [Y, X, ax, ap, ay], endpoint: { [cp]: "https://{Bucket}.s3-fips.dualstack.us-east-1.{partitionResult#dnsSuffix}", [cq]: az, [cw]: aj }, [cj]: o }, { [ck]: [Y, X, ax, ap, aA, aB], rules: [{ endpoint: aC, [cj]: o }], [cj]: p }, { [ck]: [Y, X, ax, ap, aA, aE], endpoint: aC, [cj]: o }, { [ck]: [aF, X, ax, ap, ay], endpoint: { [cp]: "https://{Bucket}.s3-fips.us-east-1.{partitionResult#dnsSuffix}", [cq]: az, [cw]: aj }, [cj]: o }, { [ck]: [aF, X, ax, ap, aA, aB], rules: [{ endpoint: aG, [cj]: o }], [cj]: p }, { [ck]: [aF, X, ax, ap, aA, aE], endpoint: aG, [cj]: o }, { [ck]: [Y, aH, W, ap, ay], endpoint: { [cp]: "https://{Bucket}.s3-accelerate.dualstack.us-east-1.{partitionResult#dnsSuffix}", [cq]: az, [cw]: aj }, [cj]: o }, { [ck]: [Y, aH, W, ap, aA, aB], rules: [{ endpoint: aI, [cj]: o }], [cj]: p }, { [ck]: [Y, aH, W, ap, aA, aE], endpoint: aI, [cj]: o }, { [ck]: [Y, aH, ax, ap, ay], endpoint: { [cp]: "https://{Bucket}.s3.dualstack.us-east-1.{partitionResult#dnsSuffix}", [cq]: az, [cw]: aj }, [cj]: o }, { [ck]: [Y, aH, ax, ap, aA, aB], rules: [{ endpoint: aJ, [cj]: o }], [cj]: p }, { [ck]: [Y, aH, ax, ap, aA, aE], endpoint: aJ, [cj]: o }, { [ck]: [aF, aH, ax, Z, ae, af, ay], endpoint: { [cp]: C, [cq]: az, [cw]: aj }, [cj]: o }, { [ck]: [aF, aH, ax, Z, ae, aK, ay], endpoint: { [cp]: r, [cq]: az, [cw]: aj }, [cj]: o }, { [ck]: [aF, aH, ax, Z, ae, af, aA, aB], rules: [{ [ck]: bV, endpoint: aL, [cj]: o }, { endpoint: aL, [cj]: o }], [cj]: p }, { [ck]: [aF, aH, ax, Z, ae, aK, aA, aB], rules: [{ [ck]: bV, endpoint: aM, [cj]: o }, aN], [cj]: p }, { [ck]: [aF, aH, ax, Z, ae, af, aA, aE], endpoint: aL, [cj]: o }, { [ck]: [aF, aH, ax, Z, ae, aK, aA, aE], endpoint: aM, [cj]: o }, { [ck]: [aF, aH, W, ap, ay], endpoint: { [cp]: D, [cq]: az, [cw]: aj }, [cj]: o }, { [ck]: [aF, aH, W, ap, aA, aB], rules: [{ [ck]: bV, endpoint: aO, [cj]: o }, { endpoint: aO, [cj]: o }], [cj]: p }, { [ck]: [aF, aH, W, ap, aA, aE], endpoint: aO, [cj]: o }, { [ck]: [aF, aH, ax, ap, ay], endpoint: { [cp]: E, [cq]: az, [cw]: aj }, [cj]: o }, { [ck]: [aF, aH, ax, ap, aA, aB], rules: [{ [ck]: bV, endpoint: { [cp]: E, [cq]: aD, [cw]: aj }, [cj]: o }, { endpoint: aP, [cj]: o }], [cj]: p }, { [ck]: [aF, aH, ax, ap, aA, aE], endpoint: aP, [cj]: o }], [cj]: p }, aQ], [cj]: p }], [cj]: p }, { [ck]: [Z, ae, { [cl]: h, [cm]: [{ [cl]: i, [cm]: [ag, "scheme"] }, "http"] }, { [cl]: q, [cm]: [ad, c] }, av, aH, aF, ax], rules: [{ [ck]: bT, rules: [{ [ck]: bU, rules: [aN], [cj]: p }, aQ], [cj]: p }], [cj]: p }, { [ck]: [av, { [cl]: F, [cm]: bz, [co]: G }], rules: [{ [ck]: [{ [cl]: i, [cm]: [aR, "resourceId[0]"], [co]: H }, { [cl]: s, [cm]: [{ [cl]: h, [cm]: [aS, I] }] }], rules: [{ [ck]: [{ [cl]: h, [cm]: [aT, J] }], rules: [{ [ck]: bW, rules: [{ [ck]: bX, rules: [aV, aW, { [ck]: bZ, rules: [aX, { [ck]: ca, rules: [aY, { [ck]: cc, rules: [{ [ck]: bT, rules: [{ [ck]: cd, rules: [{ [ck]: ce, rules: [{ [ck]: [{ [cl]: h, [cm]: [ba, I] }], error: "Invalid ARN: Missing account id", [cj]: f }, { [ck]: cf, rules: [{ [ck]: cg, rules: [{ [ck]: bC, endpoint: { [cp]: M, [cq]: bb, [cw]: aj }, [cj]: o }, { [ck]: bH, endpoint: { [cp]: "https://{accessPointName}-{bucketArn#accountId}.s3-object-lambda-fips.{bucketArn#region}.{bucketPartition#dnsSuffix}", [cq]: bb, [cw]: aj }, [cj]: o }, { endpoint: { [cp]: "https://{accessPointName}-{bucketArn#accountId}.s3-object-lambda.{bucketArn#region}.{bucketPartition#dnsSuffix}", [cq]: bb, [cw]: aj }, [cj]: o }], [cj]: p }, bc], [cj]: p }, bd], [cj]: p }, be], [cj]: p }, bf], [cj]: p }], [cj]: p }], [cj]: p }, bg], [cj]: p }, { error: "Invalid ARN: bucket ARN is missing a region", [cj]: f }], [cj]: p }, bh], [cj]: p }, { error: "Invalid ARN: Object Lambda ARNs only support `accesspoint` arn types, but found: `{arnType}`", [cj]: f }], [cj]: p }, { [ck]: bW, rules: [{ [ck]: bX, rules: [{ [ck]: bZ, rules: [{ [ck]: bW, rules: [{ [ck]: bZ, rules: [aX, { [ck]: ca, rules: [aY, { [ck]: cc, rules: [{ [ck]: bT, rules: [{ [ck]: [{ [cl]: h, [cm]: [aZ, "{partitionResult#name}"] }], rules: [{ [ck]: ce, rules: [{ [ck]: [{ [cl]: h, [cm]: [aT, B] }], rules: [{ [ck]: cf, rules: [{ [ck]: cg, rules: [{ [ck]: bB, error: "Access Points do not support S3 Accelerate", [cj]: f }, { [ck]: [X, Y], endpoint: { [cp]: "https://{accessPointName}-{bucketArn#accountId}.s3-accesspoint-fips.dualstack.{bucketArn#region}.{bucketPartition#dnsSuffix}", [cq]: bi, [cw]: aj }, [cj]: o }, { [ck]: [X, aF], endpoint: { [cp]: "https://{accessPointName}-{bucketArn#accountId}.s3-accesspoint-fips.{bucketArn#region}.{bucketPartition#dnsSuffix}", [cq]: bi, [cw]: aj }, [cj]: o }, { [ck]: [aH, Y], endpoint: { [cp]: "https://{accessPointName}-{bucketArn#accountId}.s3-accesspoint.dualstack.{bucketArn#region}.{bucketPartition#dnsSuffix}", [cq]: bi, [cw]: aj }, [cj]: o }, { [ck]: [aH, aF, Z, ae], endpoint: { [cp]: M, [cq]: bi, [cw]: aj }, [cj]: o }, { [ck]: [aH, aF], endpoint: { [cp]: "https://{accessPointName}-{bucketArn#accountId}.s3-accesspoint.{bucketArn#region}.{bucketPartition#dnsSuffix}", [cq]: bi, [cw]: aj }, [cj]: o }], [cj]: p }, bc], [cj]: p }, bd], [cj]: p }, { error: "Invalid ARN: The ARN was not for the S3 service, found: {bucketArn#service}", [cj]: f }], [cj]: p }, be], [cj]: p }, bf], [cj]: p }], [cj]: p }], [cj]: p }, bg], [cj]: p }], [cj]: p }], [cj]: p }, { [ck]: [{ [cl]: y, [cm]: [aU, c] }], rules: [{ [ck]: bA, error: "S3 MRAP does not support dual-stack", [cj]: f }, { [ck]: bH, error: "S3 MRAP does not support FIPS", [cj]: f }, { [ck]: bB, error: "S3 MRAP does not support S3 Accelerate", [cj]: f }, { [ck]: [{ [cl]: e, [cm]: [{ [cn]: "DisableMultiRegionAccessPoints" }, c] }], error: "Invalid configuration: Multi-Region Access Point ARNs are disabled.", [cj]: f }, { [ck]: [{ [cl]: g, [cm]: bx, [co]: N }], rules: [{ [ck]: [{ [cl]: h, [cm]: [{ [cl]: i, [cm]: [{ [cn]: N }, j] }, { [cl]: i, [cm]: [aR, "partition"] }] }], rules: [{ endpoint: { [cp]: "https://{accessPointName}.accesspoint.s3-global.{mrapPartition#dnsSuffix}", [cq]: { [cs]: [{ [ct]: c, name: z, [cu]: B, [cx]: bS }] }, [cw]: aj }, [cj]: o }], [cj]: p }, { error: "Client was configured for partition `{mrapPartition#name}` but bucket referred to partition `{bucketArn#partition}`", [cj]: f }], [cj]: p }], [cj]: p }, { error: "Invalid Access Point Name", [cj]: f }], [cj]: p }, bh], [cj]: p }, { [ck]: [{ [cl]: h, [cm]: [aT, A] }], rules: [{ [ck]: bA, error: "S3 Outposts does not support Dual-stack", [cj]: f }, { [ck]: bH, error: "S3 Outposts does not support FIPS", [cj]: f }, { [ck]: bB, error: "S3 Outposts does not support S3 Accelerate", [cj]: f }, { [ck]: [{ [cl]: d, [cm]: [{ [cl]: i, [cm]: [aR, "resourceId[4]"] }] }], error: "Invalid Arn: Outpost Access Point ARN contains sub resources", [cj]: f }, { [ck]: [{ [cl]: i, [cm]: bY, [co]: x }], rules: [{ [ck]: bQ, rules: [aY, { [ck]: cc, rules: [{ [ck]: bT, rules: [{ [ck]: cd, rules: [{ [ck]: ce, rules: [{ [ck]: cf, rules: [{ [ck]: [{ [cl]: i, [cm]: cb, [co]: O }], rules: [{ [ck]: [{ [cl]: i, [cm]: [aR, "resourceId[3]"], [co]: L3 }], rules: [{ [ck]: [{ [cl]: h, [cm]: [{ [cn]: O }, K] }], rules: [{ [ck]: bC, endpoint: { [cp]: "https://{accessPointName}-{bucketArn#accountId}.{outpostId}.{url#authority}", [cq]: bj, [cw]: aj }, [cj]: o }, { endpoint: { [cp]: "https://{accessPointName}-{bucketArn#accountId}.{outpostId}.s3-outposts.{bucketArn#region}.{bucketPartition#dnsSuffix}", [cq]: bj, [cw]: aj }, [cj]: o }], [cj]: p }, { error: "Expected an outpost type `accesspoint`, found {outpostType}", [cj]: f }], [cj]: p }, { error: "Invalid ARN: expected an access point name", [cj]: f }], [cj]: p }, { error: "Invalid ARN: Expected a 4-component resource", [cj]: f }], [cj]: p }, bd], [cj]: p }, be], [cj]: p }, bf], [cj]: p }], [cj]: p }], [cj]: p }, { error: "Invalid ARN: The outpost Id may only contain a-z, A-Z, 0-9 and `-`. Found: `{outpostId}`", [cj]: f }], [cj]: p }, { error: "Invalid ARN: The Outpost Id was not set", [cj]: f }], [cj]: p }, { error: "Invalid ARN: Unrecognized format: {Bucket} (type: {arnType})", [cj]: f }], [cj]: p }, { error: "Invalid ARN: No ARN type specified", [cj]: f }], [cj]: p }, { [ck]: [{ [cl]: k, [cm]: [ad, 0, 4, b], [co]: P }, { [cl]: h, [cm]: [{ [cn]: P }, "arn:"] }, { [cl]: s, [cm]: [{ [cl]: d, [cm]: [bk] }] }], error: "Invalid ARN: `{Bucket}` was not a valid ARN", [cj]: f }, { [ck]: [{ [cl]: e, [cm]: [aw, c] }, bk], error: "Path-style addressing cannot be used with ARN buckets", [cj]: f }, { [ck]: bF, rules: [{ [ck]: bT, rules: [{ [ck]: [ax], rules: [{ [ck]: [Y, ap, X, ay], endpoint: { [cp]: "https://s3-fips.dualstack.us-east-1.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [cq]: az, [cw]: aj }, [cj]: o }, { [ck]: [Y, ap, X, aA, aB], rules: [{ endpoint: bl, [cj]: o }], [cj]: p }, { [ck]: [Y, ap, X, aA, aE], endpoint: bl, [cj]: o }, { [ck]: [aF, ap, X, ay], endpoint: { [cp]: "https://s3-fips.us-east-1.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [cq]: az, [cw]: aj }, [cj]: o }, { [ck]: [aF, ap, X, aA, aB], rules: [{ endpoint: bm, [cj]: o }], [cj]: p }, { [ck]: [aF, ap, X, aA, aE], endpoint: bm, [cj]: o }, { [ck]: [Y, ap, aH, ay], endpoint: { [cp]: "https://s3.dualstack.us-east-1.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [cq]: az, [cw]: aj }, [cj]: o }, { [ck]: [Y, ap, aH, aA, aB], rules: [{ endpoint: bn, [cj]: o }], [cj]: p }, { [ck]: [Y, ap, aH, aA, aE], endpoint: bn, [cj]: o }, { [ck]: [aF, Z, ae, aH, ay], endpoint: { [cp]: Q, [cq]: az, [cw]: aj }, [cj]: o }, { [ck]: [aF, Z, ae, aH, aA, aB], rules: [{ [ck]: bV, endpoint: bo, [cj]: o }, { endpoint: bo, [cj]: o }], [cj]: p }, { [ck]: [aF, Z, ae, aH, aA, aE], endpoint: bo, [cj]: o }, { [ck]: [aF, ap, aH, ay], endpoint: { [cp]: R, [cq]: az, [cw]: aj }, [cj]: o }, { [ck]: [aF, ap, aH, aA, aB], rules: [{ [ck]: bV, endpoint: { [cp]: R, [cq]: aD, [cw]: aj }, [cj]: o }, { endpoint: bp, [cj]: o }], [cj]: p }, { [ck]: [aF, ap, aH, aA, aE], endpoint: bp, [cj]: o }], [cj]: p }, { error: "Path-style addressing cannot be used with S3 Accelerate", [cj]: f }], [cj]: p }], [cj]: p }], [cj]: p }, { [ck]: [{ [cl]: d, [cm]: [bq] }, { [cl]: e, [cm]: [bq, c] }], rules: [{ [ck]: bT, rules: [{ [ck]: ch, rules: [aV, aW, { [ck]: bC, endpoint: { [cp]: t, [cq]: br, [cw]: aj }, [cj]: o }, { [ck]: bH, endpoint: { [cp]: "https://s3-object-lambda-fips.{Region}.{partitionResult#dnsSuffix}", [cq]: br, [cw]: aj }, [cj]: o }, { endpoint: { [cp]: "https://s3-object-lambda.{Region}.{partitionResult#dnsSuffix}", [cq]: br, [cw]: aj }, [cj]: o }], [cj]: p }, aQ], [cj]: p }], [cj]: p }, { [ck]: [ar], rules: [{ [ck]: bT, rules: [{ [ck]: ch, rules: [{ [ck]: [X, Y, ap, ay], endpoint: { [cp]: "https://s3-fips.dualstack.us-east-1.{partitionResult#dnsSuffix}", [cq]: az, [cw]: aj }, [cj]: o }, { [ck]: [X, Y, ap, aA, aB], rules: [{ endpoint: bs, [cj]: o }], [cj]: p }, { [ck]: [X, Y, ap, aA, aE], endpoint: bs, [cj]: o }, { [ck]: [X, aF, ap, ay], endpoint: { [cp]: "https://s3-fips.us-east-1.{partitionResult#dnsSuffix}", [cq]: az, [cw]: aj }, [cj]: o }, { [ck]: [X, aF, ap, aA, aB], rules: [{ endpoint: bt, [cj]: o }], [cj]: p }, { [ck]: [X, aF, ap, aA, aE], endpoint: bt, [cj]: o }, { [ck]: [aH, Y, ap, ay], endpoint: { [cp]: "https://s3.dualstack.us-east-1.{partitionResult#dnsSuffix}", [cq]: az, [cw]: aj }, [cj]: o }, { [ck]: [aH, Y, ap, aA, aB], rules: [{ endpoint: bu, [cj]: o }], [cj]: p }, { [ck]: [aH, Y, ap, aA, aE], endpoint: bu, [cj]: o }, { [ck]: [aH, aF, Z, ae, ay], endpoint: { [cp]: t, [cq]: az, [cw]: aj }, [cj]: o }, { [ck]: [aH, aF, Z, ae, aA, aB], rules: [{ [ck]: bV, endpoint: bv, [cj]: o }, { endpoint: bv, [cj]: o }], [cj]: p }, { [ck]: [aH, aF, Z, ae, aA, aE], endpoint: bv, [cj]: o }, { [ck]: [aH, aF, ap, ay], endpoint: { [cp]: S, [cq]: az, [cw]: aj }, [cj]: o }, { [ck]: [aH, aF, ap, aA, aB], rules: [{ [ck]: bV, endpoint: { [cp]: S, [cq]: aD, [cw]: aj }, [cj]: o }, { endpoint: bw, [cj]: o }], [cj]: p }, { [ck]: [aH, aF, ap, aA, aE], endpoint: bw, [cj]: o }], [cj]: p }, aQ], [cj]: p }], [cj]: p }], [cj]: p }, { error: "A region must be set when sending requests to S3.", [cj]: f }] };
  var ruleSet = _data;

  // node_modules/@aws-sdk/client-s3/dist-es/endpoint/endpointResolver.js
  var cache2 = new EndpointCache({
    size: 50,
    params: [
      "Accelerate",
      "Bucket",
      "DisableAccessPoints",
      "DisableMultiRegionAccessPoints",
      "DisableS3ExpressSessionAuth",
      "Endpoint",
      "ForcePathStyle",
      "Region",
      "UseArnRegion",
      "UseDualStack",
      "UseFIPS",
      "UseGlobalEndpoint",
      "UseObjectLambdaEndpoint",
      "UseS3ExpressControlEndpoint"
    ]
  });
  var defaultEndpointResolver = /* @__PURE__ */ __name((endpointParams, context = {}) => {
    return cache2.get(endpointParams, () => resolveEndpoint(ruleSet, {
      endpointParams,
      logger: context.logger
    }));
  }, "defaultEndpointResolver");
  customEndpointFunctions.aws = awsEndpointFunctions;

  // node_modules/@aws-sdk/client-s3/dist-es/auth/httpAuthSchemeProvider.js
  var createEndpointRuleSetHttpAuthSchemeParametersProvider = /* @__PURE__ */ __name((defaultHttpAuthSchemeParametersProvider) => async (config4, context, input) => {
    if (!input) {
      throw new Error(`Could not find \`input\` for \`defaultEndpointRuleSetHttpAuthSchemeParametersProvider\``);
    }
    const defaultParameters = await defaultHttpAuthSchemeParametersProvider(config4, context, input);
    const instructionsFn = getSmithyContext(context)?.commandInstance?.constructor?.getEndpointParameterInstructions;
    if (!instructionsFn) {
      throw new Error(`getEndpointParameterInstructions() is not defined on \`${context.commandName}\``);
    }
    const endpointParameters = await resolveParams(input, { getEndpointParameterInstructions: instructionsFn }, config4);
    return Object.assign(defaultParameters, endpointParameters);
  }, "createEndpointRuleSetHttpAuthSchemeParametersProvider");
  var _defaultS3HttpAuthSchemeParametersProvider = /* @__PURE__ */ __name(async (config4, context, input) => {
    return {
      operation: getSmithyContext(context).operation,
      region: await normalizeProvider(config4.region)() || (() => {
        throw new Error("expected `region` to be configured for `aws.auth#sigv4`");
      })()
    };
  }, "_defaultS3HttpAuthSchemeParametersProvider");
  var defaultS3HttpAuthSchemeParametersProvider = createEndpointRuleSetHttpAuthSchemeParametersProvider(_defaultS3HttpAuthSchemeParametersProvider);
  function createAwsAuthSigv4HttpAuthOption(authParameters) {
    return {
      schemeId: "aws.auth#sigv4",
      signingProperties: {
        name: "s3",
        region: authParameters.region
      },
      propertiesExtractor: (config4, context) => ({
        signingProperties: {
          config: config4,
          context
        }
      })
    };
  }
  __name(createAwsAuthSigv4HttpAuthOption, "createAwsAuthSigv4HttpAuthOption");
  function createAwsAuthSigv4aHttpAuthOption(authParameters) {
    return {
      schemeId: "aws.auth#sigv4a",
      signingProperties: {
        name: "s3",
        region: authParameters.region
      },
      propertiesExtractor: (config4, context) => ({
        signingProperties: {
          config: config4,
          context
        }
      })
    };
  }
  __name(createAwsAuthSigv4aHttpAuthOption, "createAwsAuthSigv4aHttpAuthOption");
  var createEndpointRuleSetHttpAuthSchemeProvider = /* @__PURE__ */ __name((defaultEndpointResolver2, defaultHttpAuthSchemeResolver, createHttpAuthOptionFunctions) => {
    const endpointRuleSetHttpAuthSchemeProvider = /* @__PURE__ */ __name((authParameters) => {
      const endpoint = defaultEndpointResolver2(authParameters);
      const authSchemes = endpoint.properties?.authSchemes;
      if (!authSchemes) {
        return defaultHttpAuthSchemeResolver(authParameters);
      }
      const options = [];
      for (const scheme of authSchemes) {
        const { name: resolvedName, properties = {}, ...rest } = scheme;
        const name = resolvedName.toLowerCase();
        if (resolvedName !== name) {
          console.warn(`HttpAuthScheme has been normalized with lowercasing: \`${resolvedName}\` to \`${name}\``);
        }
        let schemeId;
        if (name === "sigv4a") {
          schemeId = "aws.auth#sigv4a";
          const sigv4Present = authSchemes.find((s3) => {
            const name2 = s3.name.toLowerCase();
            return name2 !== "sigv4a" && name2.startsWith("sigv4");
          });
          if (!signatureV4CrtContainer.CrtSignerV4 && sigv4Present) {
            continue;
          }
        } else if (name.startsWith("sigv4")) {
          schemeId = "aws.auth#sigv4";
        } else {
          throw new Error(`Unknown HttpAuthScheme found in \`@smithy.rules#endpointRuleSet\`: \`${name}\``);
        }
        const createOption = createHttpAuthOptionFunctions[schemeId];
        if (!createOption) {
          throw new Error(`Could not find HttpAuthOption create function for \`${schemeId}\``);
        }
        const option2 = createOption(authParameters);
        option2.schemeId = schemeId;
        option2.signingProperties = { ...option2.signingProperties || {}, ...rest, ...properties };
        options.push(option2);
      }
      return options;
    }, "endpointRuleSetHttpAuthSchemeProvider");
    return endpointRuleSetHttpAuthSchemeProvider;
  }, "createEndpointRuleSetHttpAuthSchemeProvider");
  var _defaultS3HttpAuthSchemeProvider = /* @__PURE__ */ __name((authParameters) => {
    const options = [];
    switch (authParameters.operation) {
      default: {
        options.push(createAwsAuthSigv4HttpAuthOption(authParameters));
        options.push(createAwsAuthSigv4aHttpAuthOption(authParameters));
      }
    }
    return options;
  }, "_defaultS3HttpAuthSchemeProvider");
  var defaultS3HttpAuthSchemeProvider = createEndpointRuleSetHttpAuthSchemeProvider(defaultEndpointResolver, _defaultS3HttpAuthSchemeProvider, {
    "aws.auth#sigv4": createAwsAuthSigv4HttpAuthOption,
    "aws.auth#sigv4a": createAwsAuthSigv4aHttpAuthOption
  });
  var resolveHttpAuthSchemeConfig = /* @__PURE__ */ __name((config4) => {
    const config_0 = resolveAwsSdkSigV4Config(config4);
    const config_1 = resolveAwsSdkSigV4AConfig(config_0);
    return {
      ...config_1
    };
  }, "resolveHttpAuthSchemeConfig");

  // node_modules/@aws-sdk/client-s3/dist-es/endpoint/EndpointParameters.js
  var resolveClientEndpointParameters = /* @__PURE__ */ __name((options) => {
    return {
      ...options,
      useFipsEndpoint: options.useFipsEndpoint ?? false,
      useDualstackEndpoint: options.useDualstackEndpoint ?? false,
      forcePathStyle: options.forcePathStyle ?? false,
      useAccelerateEndpoint: options.useAccelerateEndpoint ?? false,
      useGlobalEndpoint: options.useGlobalEndpoint ?? false,
      disableMultiregionAccessPoints: options.disableMultiregionAccessPoints ?? false,
      defaultSigningName: "s3"
    };
  }, "resolveClientEndpointParameters");
  var commonParams = {
    ForcePathStyle: { type: "clientContextParams", name: "forcePathStyle" },
    UseArnRegion: { type: "clientContextParams", name: "useArnRegion" },
    DisableMultiRegionAccessPoints: { type: "clientContextParams", name: "disableMultiregionAccessPoints" },
    Accelerate: { type: "clientContextParams", name: "useAccelerateEndpoint" },
    DisableS3ExpressSessionAuth: { type: "clientContextParams", name: "disableS3ExpressSessionAuth" },
    UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
    UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
    Endpoint: { type: "builtInParams", name: "endpoint" },
    Region: { type: "builtInParams", name: "region" },
    UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
  };

  // node_modules/@aws-sdk/client-s3/dist-es/models/S3ServiceException.js
  var S3ServiceException = class _S3ServiceException extends ServiceException {
    static {
      __name(this, "S3ServiceException");
    }
    constructor(options) {
      super(options);
      Object.setPrototypeOf(this, _S3ServiceException.prototype);
    }
  };

  // node_modules/@aws-sdk/client-s3/dist-es/models/models_0.js
  var NoSuchUpload = class _NoSuchUpload extends S3ServiceException {
    static {
      __name(this, "NoSuchUpload");
    }
    name = "NoSuchUpload";
    $fault = "client";
    constructor(opts) {
      super({
        name: "NoSuchUpload",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, _NoSuchUpload.prototype);
    }
  };
  var ObjectNotInActiveTierError = class _ObjectNotInActiveTierError extends S3ServiceException {
    static {
      __name(this, "ObjectNotInActiveTierError");
    }
    name = "ObjectNotInActiveTierError";
    $fault = "client";
    constructor(opts) {
      super({
        name: "ObjectNotInActiveTierError",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, _ObjectNotInActiveTierError.prototype);
    }
  };
  var BucketAlreadyExists = class _BucketAlreadyExists extends S3ServiceException {
    static {
      __name(this, "BucketAlreadyExists");
    }
    name = "BucketAlreadyExists";
    $fault = "client";
    constructor(opts) {
      super({
        name: "BucketAlreadyExists",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, _BucketAlreadyExists.prototype);
    }
  };
  var BucketAlreadyOwnedByYou = class _BucketAlreadyOwnedByYou extends S3ServiceException {
    static {
      __name(this, "BucketAlreadyOwnedByYou");
    }
    name = "BucketAlreadyOwnedByYou";
    $fault = "client";
    constructor(opts) {
      super({
        name: "BucketAlreadyOwnedByYou",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, _BucketAlreadyOwnedByYou.prototype);
    }
  };
  var NoSuchBucket = class _NoSuchBucket extends S3ServiceException {
    static {
      __name(this, "NoSuchBucket");
    }
    name = "NoSuchBucket";
    $fault = "client";
    constructor(opts) {
      super({
        name: "NoSuchBucket",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, _NoSuchBucket.prototype);
    }
  };
  var AnalyticsFilter;
  (function(AnalyticsFilter2) {
    AnalyticsFilter2.visit = (value, visitor) => {
      if (value.Prefix !== void 0)
        return visitor.Prefix(value.Prefix);
      if (value.Tag !== void 0)
        return visitor.Tag(value.Tag);
      if (value.And !== void 0)
        return visitor.And(value.And);
      return visitor._(value.$unknown[0], value.$unknown[1]);
    };
  })(AnalyticsFilter || (AnalyticsFilter = {}));
  var MetricsFilter;
  (function(MetricsFilter2) {
    MetricsFilter2.visit = (value, visitor) => {
      if (value.Prefix !== void 0)
        return visitor.Prefix(value.Prefix);
      if (value.Tag !== void 0)
        return visitor.Tag(value.Tag);
      if (value.AccessPointArn !== void 0)
        return visitor.AccessPointArn(value.AccessPointArn);
      if (value.And !== void 0)
        return visitor.And(value.And);
      return visitor._(value.$unknown[0], value.$unknown[1]);
    };
  })(MetricsFilter || (MetricsFilter = {}));
  var InvalidObjectState = class _InvalidObjectState extends S3ServiceException {
    static {
      __name(this, "InvalidObjectState");
    }
    name = "InvalidObjectState";
    $fault = "client";
    StorageClass;
    AccessTier;
    constructor(opts) {
      super({
        name: "InvalidObjectState",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, _InvalidObjectState.prototype);
      this.StorageClass = opts.StorageClass;
      this.AccessTier = opts.AccessTier;
    }
  };
  var NoSuchKey = class _NoSuchKey extends S3ServiceException {
    static {
      __name(this, "NoSuchKey");
    }
    name = "NoSuchKey";
    $fault = "client";
    constructor(opts) {
      super({
        name: "NoSuchKey",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, _NoSuchKey.prototype);
    }
  };
  var NotFound = class _NotFound extends S3ServiceException {
    static {
      __name(this, "NotFound");
    }
    name = "NotFound";
    $fault = "client";
    constructor(opts) {
      super({
        name: "NotFound",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, _NotFound.prototype);
    }
  };
  var SessionCredentialsFilterSensitiveLog = /* @__PURE__ */ __name((obj) => ({
    ...obj,
    ...obj.SecretAccessKey && { SecretAccessKey: SENSITIVE_STRING },
    ...obj.SessionToken && { SessionToken: SENSITIVE_STRING }
  }), "SessionCredentialsFilterSensitiveLog");
  var CreateSessionOutputFilterSensitiveLog = /* @__PURE__ */ __name((obj) => ({
    ...obj,
    ...obj.SSEKMSKeyId && { SSEKMSKeyId: SENSITIVE_STRING },
    ...obj.SSEKMSEncryptionContext && { SSEKMSEncryptionContext: SENSITIVE_STRING },
    ...obj.Credentials && { Credentials: SessionCredentialsFilterSensitiveLog(obj.Credentials) }
  }), "CreateSessionOutputFilterSensitiveLog");
  var CreateSessionRequestFilterSensitiveLog = /* @__PURE__ */ __name((obj) => ({
    ...obj,
    ...obj.SSEKMSKeyId && { SSEKMSKeyId: SENSITIVE_STRING },
    ...obj.SSEKMSEncryptionContext && { SSEKMSEncryptionContext: SENSITIVE_STRING }
  }), "CreateSessionRequestFilterSensitiveLog");

  // node_modules/@aws-sdk/client-s3/dist-es/models/models_1.js
  var EncryptionTypeMismatch = class _EncryptionTypeMismatch extends S3ServiceException {
    static {
      __name(this, "EncryptionTypeMismatch");
    }
    name = "EncryptionTypeMismatch";
    $fault = "client";
    constructor(opts) {
      super({
        name: "EncryptionTypeMismatch",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, _EncryptionTypeMismatch.prototype);
    }
  };
  var InvalidRequest = class _InvalidRequest extends S3ServiceException {
    static {
      __name(this, "InvalidRequest");
    }
    name = "InvalidRequest";
    $fault = "client";
    constructor(opts) {
      super({
        name: "InvalidRequest",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, _InvalidRequest.prototype);
    }
  };
  var InvalidWriteOffset = class _InvalidWriteOffset extends S3ServiceException {
    static {
      __name(this, "InvalidWriteOffset");
    }
    name = "InvalidWriteOffset";
    $fault = "client";
    constructor(opts) {
      super({
        name: "InvalidWriteOffset",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, _InvalidWriteOffset.prototype);
    }
  };
  var TooManyParts = class _TooManyParts extends S3ServiceException {
    static {
      __name(this, "TooManyParts");
    }
    name = "TooManyParts";
    $fault = "client";
    constructor(opts) {
      super({
        name: "TooManyParts",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, _TooManyParts.prototype);
    }
  };
  var ObjectAlreadyInActiveTierError = class _ObjectAlreadyInActiveTierError extends S3ServiceException {
    static {
      __name(this, "ObjectAlreadyInActiveTierError");
    }
    name = "ObjectAlreadyInActiveTierError";
    $fault = "client";
    constructor(opts) {
      super({
        name: "ObjectAlreadyInActiveTierError",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, _ObjectAlreadyInActiveTierError.prototype);
    }
  };
  var SelectObjectContentEventStream;
  (function(SelectObjectContentEventStream2) {
    SelectObjectContentEventStream2.visit = (value, visitor) => {
      if (value.Records !== void 0)
        return visitor.Records(value.Records);
      if (value.Stats !== void 0)
        return visitor.Stats(value.Stats);
      if (value.Progress !== void 0)
        return visitor.Progress(value.Progress);
      if (value.Cont !== void 0)
        return visitor.Cont(value.Cont);
      if (value.End !== void 0)
        return visitor.End(value.End);
      return visitor._(value.$unknown[0], value.$unknown[1]);
    };
  })(SelectObjectContentEventStream || (SelectObjectContentEventStream = {}));
  var PutObjectOutputFilterSensitiveLog = /* @__PURE__ */ __name((obj) => ({
    ...obj,
    ...obj.SSEKMSKeyId && { SSEKMSKeyId: SENSITIVE_STRING },
    ...obj.SSEKMSEncryptionContext && { SSEKMSEncryptionContext: SENSITIVE_STRING }
  }), "PutObjectOutputFilterSensitiveLog");
  var PutObjectRequestFilterSensitiveLog = /* @__PURE__ */ __name((obj) => ({
    ...obj,
    ...obj.SSECustomerKey && { SSECustomerKey: SENSITIVE_STRING },
    ...obj.SSEKMSKeyId && { SSEKMSKeyId: SENSITIVE_STRING },
    ...obj.SSEKMSEncryptionContext && { SSEKMSEncryptionContext: SENSITIVE_STRING }
  }), "PutObjectRequestFilterSensitiveLog");

  // node_modules/@aws-sdk/client-s3/dist-es/protocols/Aws_restXml.js
  var se_CreateSessionCommand = /* @__PURE__ */ __name(async (input, context) => {
    const b3 = requestBuilder(input, context);
    const headers = map({}, isSerializableHeaderValue, {
      [_xacsm]: input[_SM],
      [_xasse]: input[_SSE],
      [_xasseakki]: input[_SSEKMSKI],
      [_xassec]: input[_SSEKMSEC],
      [_xassebke]: [() => isSerializableHeaderValue(input[_BKE]), () => input[_BKE].toString()]
    });
    b3.bp("/");
    b3.p("Bucket", () => input.Bucket, "{Bucket}", false);
    const query = map({
      [_s]: [, ""]
    });
    let body;
    b3.m("GET").h(headers).q(query).b(body);
    return b3.build();
  }, "se_CreateSessionCommand");
  var se_PutObjectCommand = /* @__PURE__ */ __name(async (input, context) => {
    const b3 = requestBuilder(input, context);
    const headers = map({}, isSerializableHeaderValue, {
      [_ct]: input[_CTo] || "application/octet-stream",
      [_xaa]: input[_ACL],
      [_cc]: input[_CC],
      [_cd]: input[_CD],
      [_ce]: input[_CE],
      [_cl]: input[_CL],
      [_cl_]: [() => isSerializableHeaderValue(input[_CLo]), () => input[_CLo].toString()],
      [_cm]: input[_CMD],
      [_xasca]: input[_CA],
      [_xacc]: input[_CCRC],
      [_xacc_]: input[_CCRCC],
      [_xacc__]: input[_CCRCNVME],
      [_xacs]: input[_CSHA],
      [_xacs_]: input[_CSHAh],
      [_e]: [() => isSerializableHeaderValue(input[_E]), () => dateToUtcString(input[_E]).toString()],
      [_im]: input[_IM],
      [_inm]: input[_INM],
      [_xagfc]: input[_GFC],
      [_xagr]: input[_GR],
      [_xagra]: input[_GRACP],
      [_xagwa]: input[_GWACP],
      [_xawob]: [() => isSerializableHeaderValue(input[_WOB]), () => input[_WOB].toString()],
      [_xasse]: input[_SSE],
      [_xasc]: input[_SC],
      [_xawrl]: input[_WRL],
      [_xasseca]: input[_SSECA],
      [_xasseck]: input[_SSECK],
      [_xasseckm]: input[_SSECKMD],
      [_xasseakki]: input[_SSEKMSKI],
      [_xassec]: input[_SSEKMSEC],
      [_xassebke]: [() => isSerializableHeaderValue(input[_BKE]), () => input[_BKE].toString()],
      [_xarp]: input[_RP],
      [_xat]: input[_T],
      [_xaolm]: input[_OLM],
      [_xaolrud]: [() => isSerializableHeaderValue(input[_OLRUD]), () => serializeDateTime(input[_OLRUD]).toString()],
      [_xaollh]: input[_OLLHS],
      [_xaebo]: input[_EBO],
      ...input.Metadata !== void 0 && Object.keys(input.Metadata).reduce((acc, suffix) => {
        acc[`x-amz-meta-${suffix.toLowerCase()}`] = input.Metadata[suffix];
        return acc;
      }, {})
    });
    b3.bp("/{Key+}");
    b3.p("Bucket", () => input.Bucket, "{Bucket}", false);
    b3.p("Key", () => input.Key, "{Key+}", true);
    const query = map({
      [_xi]: [, "PutObject"]
    });
    let body;
    let contents;
    if (input.Body !== void 0) {
      contents = input.Body;
      body = contents;
    }
    b3.m("PUT").h(headers).q(query).b(body);
    return b3.build();
  }, "se_PutObjectCommand");
  var de_CreateSessionCommand = /* @__PURE__ */ __name(async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
      return de_CommandError(output, context);
    }
    const contents = map({
      $metadata: deserializeMetadata2(output),
      [_SSE]: [, output.headers[_xasse]],
      [_SSEKMSKI]: [, output.headers[_xasseakki]],
      [_SSEKMSEC]: [, output.headers[_xassec]],
      [_BKE]: [() => void 0 !== output.headers[_xassebke], () => parseBoolean(output.headers[_xassebke])]
    });
    const data = expectNonNull(expectObject(await parseXmlBody(output.body, context)), "body");
    if (data[_C] != null) {
      contents[_C] = de_SessionCredentials(data[_C], context);
    }
    return contents;
  }, "de_CreateSessionCommand");
  var de_PutObjectCommand = /* @__PURE__ */ __name(async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
      return de_CommandError(output, context);
    }
    const contents = map({
      $metadata: deserializeMetadata2(output),
      [_Exp]: [, output.headers[_xae]],
      [_ETa]: [, output.headers[_eta]],
      [_CCRC]: [, output.headers[_xacc]],
      [_CCRCC]: [, output.headers[_xacc_]],
      [_CCRCNVME]: [, output.headers[_xacc__]],
      [_CSHA]: [, output.headers[_xacs]],
      [_CSHAh]: [, output.headers[_xacs_]],
      [_CT]: [, output.headers[_xact]],
      [_SSE]: [, output.headers[_xasse]],
      [_VI]: [, output.headers[_xavi]],
      [_SSECA]: [, output.headers[_xasseca]],
      [_SSECKMD]: [, output.headers[_xasseckm]],
      [_SSEKMSKI]: [, output.headers[_xasseakki]],
      [_SSEKMSEC]: [, output.headers[_xassec]],
      [_BKE]: [() => void 0 !== output.headers[_xassebke], () => parseBoolean(output.headers[_xassebke])],
      [_Si]: [() => void 0 !== output.headers[_xaos], () => strictParseLong(output.headers[_xaos])],
      [_RC]: [, output.headers[_xarc]]
    });
    await collectBody(output.body, context);
    return contents;
  }, "de_PutObjectCommand");
  var de_CommandError = /* @__PURE__ */ __name(async (output, context) => {
    const parsedOutput = {
      ...output,
      body: await parseXmlErrorBody(output.body, context)
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
      case "NoSuchUpload":
      case "com.amazonaws.s3#NoSuchUpload":
        throw await de_NoSuchUploadRes(parsedOutput, context);
      case "ObjectNotInActiveTierError":
      case "com.amazonaws.s3#ObjectNotInActiveTierError":
        throw await de_ObjectNotInActiveTierErrorRes(parsedOutput, context);
      case "BucketAlreadyExists":
      case "com.amazonaws.s3#BucketAlreadyExists":
        throw await de_BucketAlreadyExistsRes(parsedOutput, context);
      case "BucketAlreadyOwnedByYou":
      case "com.amazonaws.s3#BucketAlreadyOwnedByYou":
        throw await de_BucketAlreadyOwnedByYouRes(parsedOutput, context);
      case "NoSuchBucket":
      case "com.amazonaws.s3#NoSuchBucket":
        throw await de_NoSuchBucketRes(parsedOutput, context);
      case "InvalidObjectState":
      case "com.amazonaws.s3#InvalidObjectState":
        throw await de_InvalidObjectStateRes(parsedOutput, context);
      case "NoSuchKey":
      case "com.amazonaws.s3#NoSuchKey":
        throw await de_NoSuchKeyRes(parsedOutput, context);
      case "NotFound":
      case "com.amazonaws.s3#NotFound":
        throw await de_NotFoundRes(parsedOutput, context);
      case "EncryptionTypeMismatch":
      case "com.amazonaws.s3#EncryptionTypeMismatch":
        throw await de_EncryptionTypeMismatchRes(parsedOutput, context);
      case "InvalidRequest":
      case "com.amazonaws.s3#InvalidRequest":
        throw await de_InvalidRequestRes(parsedOutput, context);
      case "InvalidWriteOffset":
      case "com.amazonaws.s3#InvalidWriteOffset":
        throw await de_InvalidWriteOffsetRes(parsedOutput, context);
      case "TooManyParts":
      case "com.amazonaws.s3#TooManyParts":
        throw await de_TooManyPartsRes(parsedOutput, context);
      case "ObjectAlreadyInActiveTierError":
      case "com.amazonaws.s3#ObjectAlreadyInActiveTierError":
        throw await de_ObjectAlreadyInActiveTierErrorRes(parsedOutput, context);
      default:
        const parsedBody = parsedOutput.body;
        return throwDefaultError2({
          output,
          parsedBody,
          errorCode
        });
    }
  }, "de_CommandError");
  var throwDefaultError2 = withBaseException(S3ServiceException);
  var de_BucketAlreadyExistsRes = /* @__PURE__ */ __name(async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const exception = new BucketAlreadyExists({
      $metadata: deserializeMetadata2(parsedOutput),
      ...contents
    });
    return decorateServiceException(exception, parsedOutput.body);
  }, "de_BucketAlreadyExistsRes");
  var de_BucketAlreadyOwnedByYouRes = /* @__PURE__ */ __name(async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const exception = new BucketAlreadyOwnedByYou({
      $metadata: deserializeMetadata2(parsedOutput),
      ...contents
    });
    return decorateServiceException(exception, parsedOutput.body);
  }, "de_BucketAlreadyOwnedByYouRes");
  var de_EncryptionTypeMismatchRes = /* @__PURE__ */ __name(async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const exception = new EncryptionTypeMismatch({
      $metadata: deserializeMetadata2(parsedOutput),
      ...contents
    });
    return decorateServiceException(exception, parsedOutput.body);
  }, "de_EncryptionTypeMismatchRes");
  var de_InvalidObjectStateRes = /* @__PURE__ */ __name(async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    if (data[_AT] != null) {
      contents[_AT] = expectString(data[_AT]);
    }
    if (data[_SC] != null) {
      contents[_SC] = expectString(data[_SC]);
    }
    const exception = new InvalidObjectState({
      $metadata: deserializeMetadata2(parsedOutput),
      ...contents
    });
    return decorateServiceException(exception, parsedOutput.body);
  }, "de_InvalidObjectStateRes");
  var de_InvalidRequestRes = /* @__PURE__ */ __name(async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const exception = new InvalidRequest({
      $metadata: deserializeMetadata2(parsedOutput),
      ...contents
    });
    return decorateServiceException(exception, parsedOutput.body);
  }, "de_InvalidRequestRes");
  var de_InvalidWriteOffsetRes = /* @__PURE__ */ __name(async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const exception = new InvalidWriteOffset({
      $metadata: deserializeMetadata2(parsedOutput),
      ...contents
    });
    return decorateServiceException(exception, parsedOutput.body);
  }, "de_InvalidWriteOffsetRes");
  var de_NoSuchBucketRes = /* @__PURE__ */ __name(async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const exception = new NoSuchBucket({
      $metadata: deserializeMetadata2(parsedOutput),
      ...contents
    });
    return decorateServiceException(exception, parsedOutput.body);
  }, "de_NoSuchBucketRes");
  var de_NoSuchKeyRes = /* @__PURE__ */ __name(async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const exception = new NoSuchKey({
      $metadata: deserializeMetadata2(parsedOutput),
      ...contents
    });
    return decorateServiceException(exception, parsedOutput.body);
  }, "de_NoSuchKeyRes");
  var de_NoSuchUploadRes = /* @__PURE__ */ __name(async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const exception = new NoSuchUpload({
      $metadata: deserializeMetadata2(parsedOutput),
      ...contents
    });
    return decorateServiceException(exception, parsedOutput.body);
  }, "de_NoSuchUploadRes");
  var de_NotFoundRes = /* @__PURE__ */ __name(async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const exception = new NotFound({
      $metadata: deserializeMetadata2(parsedOutput),
      ...contents
    });
    return decorateServiceException(exception, parsedOutput.body);
  }, "de_NotFoundRes");
  var de_ObjectAlreadyInActiveTierErrorRes = /* @__PURE__ */ __name(async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const exception = new ObjectAlreadyInActiveTierError({
      $metadata: deserializeMetadata2(parsedOutput),
      ...contents
    });
    return decorateServiceException(exception, parsedOutput.body);
  }, "de_ObjectAlreadyInActiveTierErrorRes");
  var de_ObjectNotInActiveTierErrorRes = /* @__PURE__ */ __name(async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const exception = new ObjectNotInActiveTierError({
      $metadata: deserializeMetadata2(parsedOutput),
      ...contents
    });
    return decorateServiceException(exception, parsedOutput.body);
  }, "de_ObjectNotInActiveTierErrorRes");
  var de_TooManyPartsRes = /* @__PURE__ */ __name(async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const exception = new TooManyParts({
      $metadata: deserializeMetadata2(parsedOutput),
      ...contents
    });
    return decorateServiceException(exception, parsedOutput.body);
  }, "de_TooManyPartsRes");
  var de_SessionCredentials = /* @__PURE__ */ __name((output, context) => {
    const contents = {};
    if (output[_AKI] != null) {
      contents[_AKI] = expectString(output[_AKI]);
    }
    if (output[_SAK] != null) {
      contents[_SAK] = expectString(output[_SAK]);
    }
    if (output[_ST] != null) {
      contents[_ST] = expectString(output[_ST]);
    }
    if (output[_Exp] != null) {
      contents[_Exp] = expectNonNull(parseRfc3339DateTimeWithOffset(output[_Exp]));
    }
    return contents;
  }, "de_SessionCredentials");
  var deserializeMetadata2 = /* @__PURE__ */ __name((output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"]
  }), "deserializeMetadata");
  var _ACL = "ACL";
  var _AKI = "AccessKeyId";
  var _AT = "AccessTier";
  var _BKE = "BucketKeyEnabled";
  var _C = "Credentials";
  var _CA = "ChecksumAlgorithm";
  var _CC = "CacheControl";
  var _CCRC = "ChecksumCRC32";
  var _CCRCC = "ChecksumCRC32C";
  var _CCRCNVME = "ChecksumCRC64NVME";
  var _CD = "ContentDisposition";
  var _CE = "ContentEncoding";
  var _CL = "ContentLanguage";
  var _CLo = "ContentLength";
  var _CMD = "ContentMD5";
  var _CSHA = "ChecksumSHA1";
  var _CSHAh = "ChecksumSHA256";
  var _CT = "ChecksumType";
  var _CTo = "ContentType";
  var _E = "Expires";
  var _EBO = "ExpectedBucketOwner";
  var _ETa = "ETag";
  var _Exp = "Expiration";
  var _GFC = "GrantFullControl";
  var _GR = "GrantRead";
  var _GRACP = "GrantReadACP";
  var _GWACP = "GrantWriteACP";
  var _IM = "IfMatch";
  var _INM = "IfNoneMatch";
  var _OLLHS = "ObjectLockLegalHoldStatus";
  var _OLM = "ObjectLockMode";
  var _OLRUD = "ObjectLockRetainUntilDate";
  var _RC = "RequestCharged";
  var _RP = "RequestPayer";
  var _SAK = "SecretAccessKey";
  var _SC = "StorageClass";
  var _SM = "SessionMode";
  var _SSE = "ServerSideEncryption";
  var _SSECA = "SSECustomerAlgorithm";
  var _SSECK = "SSECustomerKey";
  var _SSECKMD = "SSECustomerKeyMD5";
  var _SSEKMSEC = "SSEKMSEncryptionContext";
  var _SSEKMSKI = "SSEKMSKeyId";
  var _ST = "SessionToken";
  var _Si = "Size";
  var _T = "Tagging";
  var _VI = "VersionId";
  var _WOB = "WriteOffsetBytes";
  var _WRL = "WebsiteRedirectLocation";
  var _cc = "cache-control";
  var _cd = "content-disposition";
  var _ce = "content-encoding";
  var _cl = "content-language";
  var _cl_ = "content-length";
  var _cm = "content-md5";
  var _ct = "content-type";
  var _e = "expires";
  var _eta = "etag";
  var _im = "if-match";
  var _inm = "if-none-match";
  var _s = "session";
  var _xaa = "x-amz-acl";
  var _xacc = "x-amz-checksum-crc32";
  var _xacc_ = "x-amz-checksum-crc32c";
  var _xacc__ = "x-amz-checksum-crc64nvme";
  var _xacs = "x-amz-checksum-sha1";
  var _xacs_ = "x-amz-checksum-sha256";
  var _xacsm = "x-amz-create-session-mode";
  var _xact = "x-amz-checksum-type";
  var _xae = "x-amz-expiration";
  var _xaebo = "x-amz-expected-bucket-owner";
  var _xagfc = "x-amz-grant-full-control";
  var _xagr = "x-amz-grant-read";
  var _xagra = "x-amz-grant-read-acp";
  var _xagwa = "x-amz-grant-write-acp";
  var _xaollh = "x-amz-object-lock-legal-hold";
  var _xaolm = "x-amz-object-lock-mode";
  var _xaolrud = "x-amz-object-lock-retain-until-date";
  var _xaos = "x-amz-object-size";
  var _xarc = "x-amz-request-charged";
  var _xarp = "x-amz-request-payer";
  var _xasc = "x-amz-storage-class";
  var _xasca = "x-amz-sdk-checksum-algorithm";
  var _xasse = "x-amz-server-side-encryption";
  var _xasseakki = "x-amz-server-side-encryption-aws-kms-key-id";
  var _xassebke = "x-amz-server-side-encryption-bucket-key-enabled";
  var _xassec = "x-amz-server-side-encryption-context";
  var _xasseca = "x-amz-server-side-encryption-customer-algorithm";
  var _xasseck = "x-amz-server-side-encryption-customer-key";
  var _xasseckm = "x-amz-server-side-encryption-customer-key-md5";
  var _xat = "x-amz-tagging";
  var _xavi = "x-amz-version-id";
  var _xawob = "x-amz-write-offset-bytes";
  var _xawrl = "x-amz-website-redirect-location";
  var _xi = "x-id";

  // node_modules/@aws-sdk/client-s3/dist-es/commands/CreateSessionCommand.js
  var CreateSessionCommand = class extends Command.classBuilder().ep({
    ...commonParams,
    DisableS3ExpressSessionAuth: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" }
  }).m(function(Command2, cs2, config4, o3) {
    return [
      getSerdePlugin(config4, this.serialize, this.deserialize),
      getEndpointPlugin(config4, Command2.getEndpointParameterInstructions()),
      getThrow200ExceptionsPlugin(config4)
    ];
  }).s("AmazonS3", "CreateSession", {}).n("S3Client", "CreateSessionCommand").f(CreateSessionRequestFilterSensitiveLog, CreateSessionOutputFilterSensitiveLog).ser(se_CreateSessionCommand).de(de_CreateSessionCommand).build() {
    static {
      __name(this, "CreateSessionCommand");
    }
  };

  // node_modules/@aws-sdk/client-s3/package.json
  var package_default = {
    name: "@aws-sdk/client-s3",
    description: "AWS SDK for JavaScript S3 Client for Node.js, Browser and React Native",
    version: "3.758.0",
    scripts: {
      build: "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
      "build:cjs": "node ../../scripts/compilation/inline client-s3",
      "build:es": "tsc -p tsconfig.es.json",
      "build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
      "build:types": "tsc -p tsconfig.types.json",
      "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
      clean: "rimraf ./dist-* && rimraf *.tsbuildinfo",
      "extract:docs": "api-extractor run --local",
      "generate:client": "node ../../scripts/generate-clients/single-service --solo s3",
      test: "yarn g:vitest run",
      "test:browser": "node ./test/browser-build/esbuild && yarn g:vitest run -c vitest.config.browser.ts",
      "test:browser:watch": "node ./test/browser-build/esbuild && yarn g:vitest watch -c vitest.config.browser.ts",
      "test:e2e": "yarn g:vitest run -c vitest.config.e2e.ts && yarn test:browser",
      "test:e2e:watch": "yarn g:vitest watch -c vitest.config.e2e.ts",
      "test:watch": "yarn g:vitest watch"
    },
    main: "./dist-cjs/index.js",
    types: "./dist-types/index.d.ts",
    module: "./dist-es/index.js",
    sideEffects: false,
    dependencies: {
      "@aws-crypto/sha1-browser": "5.2.0",
      "@aws-crypto/sha256-browser": "5.2.0",
      "@aws-crypto/sha256-js": "5.2.0",
      "@aws-sdk/core": "3.758.0",
      "@aws-sdk/credential-provider-node": "3.758.0",
      "@aws-sdk/middleware-bucket-endpoint": "3.734.0",
      "@aws-sdk/middleware-expect-continue": "3.734.0",
      "@aws-sdk/middleware-flexible-checksums": "3.758.0",
      "@aws-sdk/middleware-host-header": "3.734.0",
      "@aws-sdk/middleware-location-constraint": "3.734.0",
      "@aws-sdk/middleware-logger": "3.734.0",
      "@aws-sdk/middleware-recursion-detection": "3.734.0",
      "@aws-sdk/middleware-sdk-s3": "3.758.0",
      "@aws-sdk/middleware-ssec": "3.734.0",
      "@aws-sdk/middleware-user-agent": "3.758.0",
      "@aws-sdk/region-config-resolver": "3.734.0",
      "@aws-sdk/signature-v4-multi-region": "3.758.0",
      "@aws-sdk/types": "3.734.0",
      "@aws-sdk/util-endpoints": "3.743.0",
      "@aws-sdk/util-user-agent-browser": "3.734.0",
      "@aws-sdk/util-user-agent-node": "3.758.0",
      "@aws-sdk/xml-builder": "3.734.0",
      "@smithy/config-resolver": "^4.0.1",
      "@smithy/core": "^3.1.5",
      "@smithy/eventstream-serde-browser": "^4.0.1",
      "@smithy/eventstream-serde-config-resolver": "^4.0.1",
      "@smithy/eventstream-serde-node": "^4.0.1",
      "@smithy/fetch-http-handler": "^5.0.1",
      "@smithy/hash-blob-browser": "^4.0.1",
      "@smithy/hash-node": "^4.0.1",
      "@smithy/hash-stream-node": "^4.0.1",
      "@smithy/invalid-dependency": "^4.0.1",
      "@smithy/md5-js": "^4.0.1",
      "@smithy/middleware-content-length": "^4.0.1",
      "@smithy/middleware-endpoint": "^4.0.6",
      "@smithy/middleware-retry": "^4.0.7",
      "@smithy/middleware-serde": "^4.0.2",
      "@smithy/middleware-stack": "^4.0.1",
      "@smithy/node-config-provider": "^4.0.1",
      "@smithy/node-http-handler": "^4.0.3",
      "@smithy/protocol-http": "^5.0.1",
      "@smithy/smithy-client": "^4.1.6",
      "@smithy/types": "^4.1.0",
      "@smithy/url-parser": "^4.0.1",
      "@smithy/util-base64": "^4.0.0",
      "@smithy/util-body-length-browser": "^4.0.0",
      "@smithy/util-body-length-node": "^4.0.0",
      "@smithy/util-defaults-mode-browser": "^4.0.7",
      "@smithy/util-defaults-mode-node": "^4.0.7",
      "@smithy/util-endpoints": "^3.0.1",
      "@smithy/util-middleware": "^4.0.1",
      "@smithy/util-retry": "^4.0.1",
      "@smithy/util-stream": "^4.1.2",
      "@smithy/util-utf8": "^4.0.0",
      "@smithy/util-waiter": "^4.0.2",
      tslib: "^2.6.2"
    },
    devDependencies: {
      "@aws-sdk/signature-v4-crt": "3.758.0",
      "@tsconfig/node18": "18.2.4",
      "@types/node": "^18.19.69",
      concurrently: "7.0.0",
      "downlevel-dts": "0.10.1",
      rimraf: "3.0.2",
      typescript: "~5.2.2"
    },
    engines: {
      node: ">=18.0.0"
    },
    typesVersions: {
      "<4.0": {
        "dist-types/*": [
          "dist-types/ts3.4/*"
        ]
      }
    },
    files: [
      "dist-*/**"
    ],
    author: {
      name: "AWS SDK for JavaScript Team",
      url: "https://aws.amazon.com/javascript/"
    },
    license: "Apache-2.0",
    browser: {
      "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.browser"
    },
    "react-native": {
      "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.native"
    },
    homepage: "https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-s3",
    repository: {
      type: "git",
      url: "https://github.com/aws/aws-sdk-js-v3.git",
      directory: "clients/client-s3"
    }
  };

  // node_modules/@aws-crypto/sha1-browser/node_modules/@smithy/util-utf8/dist-es/fromUtf8.browser.js
  var fromUtf84 = /* @__PURE__ */ __name((input) => new TextEncoder().encode(input), "fromUtf8");

  // node_modules/@aws-crypto/sha1-browser/build/module/isEmptyData.js
  function isEmptyData2(data) {
    if (typeof data === "string") {
      return data.length === 0;
    }
    return data.byteLength === 0;
  }
  __name(isEmptyData2, "isEmptyData");

  // node_modules/@aws-crypto/sha1-browser/build/module/constants.js
  var SHA_1_HASH = { name: "SHA-1" };
  var SHA_1_HMAC_ALGO = {
    name: "HMAC",
    hash: SHA_1_HASH
  };
  var EMPTY_DATA_SHA_1 = new Uint8Array([
    218,
    57,
    163,
    238,
    94,
    107,
    75,
    13,
    50,
    85,
    191,
    239,
    149,
    96,
    24,
    144,
    175,
    216,
    7,
    9
  ]);

  // node_modules/@aws-sdk/util-locate-window/dist-es/index.js
  var fallbackWindow = {};
  function locateWindow() {
    if (typeof window !== "undefined") {
      return window;
    } else if (typeof self !== "undefined") {
      return self;
    }
    return fallbackWindow;
  }
  __name(locateWindow, "locateWindow");

  // node_modules/@aws-crypto/sha1-browser/build/module/webCryptoSha1.js
  var Sha1 = (
    /** @class */
    function() {
      function Sha13(secret) {
        this.toHash = new Uint8Array(0);
        if (secret !== void 0) {
          this.key = new Promise(function(resolve, reject) {
            locateWindow().crypto.subtle.importKey("raw", convertToBuffer2(secret), SHA_1_HMAC_ALGO, false, ["sign"]).then(resolve, reject);
          });
          this.key.catch(function() {
          });
        }
      }
      __name(Sha13, "Sha1");
      Sha13.prototype.update = function(data) {
        if (isEmptyData2(data)) {
          return;
        }
        var update = convertToBuffer2(data);
        var typedArray = new Uint8Array(this.toHash.byteLength + update.byteLength);
        typedArray.set(this.toHash, 0);
        typedArray.set(update, this.toHash.byteLength);
        this.toHash = typedArray;
      };
      Sha13.prototype.digest = function() {
        var _this = this;
        if (this.key) {
          return this.key.then(function(key) {
            return locateWindow().crypto.subtle.sign(SHA_1_HMAC_ALGO, key, _this.toHash).then(function(data) {
              return new Uint8Array(data);
            });
          });
        }
        if (isEmptyData2(this.toHash)) {
          return Promise.resolve(EMPTY_DATA_SHA_1);
        }
        return Promise.resolve().then(function() {
          return locateWindow().crypto.subtle.digest(SHA_1_HASH, _this.toHash);
        }).then(function(data) {
          return Promise.resolve(new Uint8Array(data));
        });
      };
      Sha13.prototype.reset = function() {
        this.toHash = new Uint8Array(0);
      };
      return Sha13;
    }()
  );
  function convertToBuffer2(data) {
    if (typeof data === "string") {
      return fromUtf84(data);
    }
    if (ArrayBuffer.isView(data)) {
      return new Uint8Array(data.buffer, data.byteOffset, data.byteLength / Uint8Array.BYTES_PER_ELEMENT);
    }
    return new Uint8Array(data);
  }
  __name(convertToBuffer2, "convertToBuffer");

  // node_modules/@aws-crypto/supports-web-crypto/build/module/supportsWebCrypto.js
  var subtleCryptoMethods = [
    "decrypt",
    "digest",
    "encrypt",
    "exportKey",
    "generateKey",
    "importKey",
    "sign",
    "verify"
  ];
  function supportsWebCrypto(window2) {
    if (supportsSecureRandom(window2) && typeof window2.crypto.subtle === "object") {
      var subtle = window2.crypto.subtle;
      return supportsSubtleCrypto(subtle);
    }
    return false;
  }
  __name(supportsWebCrypto, "supportsWebCrypto");
  function supportsSecureRandom(window2) {
    if (typeof window2 === "object" && typeof window2.crypto === "object") {
      var getRandomValues2 = window2.crypto.getRandomValues;
      return typeof getRandomValues2 === "function";
    }
    return false;
  }
  __name(supportsSecureRandom, "supportsSecureRandom");
  function supportsSubtleCrypto(subtle) {
    return subtle && subtleCryptoMethods.every(function(methodName) {
      return typeof subtle[methodName] === "function";
    });
  }
  __name(supportsSubtleCrypto, "supportsSubtleCrypto");

  // node_modules/@aws-crypto/sha1-browser/build/module/crossPlatformSha1.js
  var Sha12 = (
    /** @class */
    function() {
      function Sha13(secret) {
        if (supportsWebCrypto(locateWindow())) {
          this.hash = new Sha1(secret);
        } else {
          throw new Error("SHA1 not supported");
        }
      }
      __name(Sha13, "Sha1");
      Sha13.prototype.update = function(data, encoding) {
        this.hash.update(convertToBuffer(data));
      };
      Sha13.prototype.digest = function() {
        return this.hash.digest();
      };
      Sha13.prototype.reset = function() {
        this.hash.reset();
      };
      return Sha13;
    }()
  );

  // node_modules/@aws-crypto/sha256-browser/build/module/constants.js
  var SHA_256_HASH = { name: "SHA-256" };
  var SHA_256_HMAC_ALGO = {
    name: "HMAC",
    hash: SHA_256_HASH
  };
  var EMPTY_DATA_SHA_256 = new Uint8Array([
    227,
    176,
    196,
    66,
    152,
    252,
    28,
    20,
    154,
    251,
    244,
    200,
    153,
    111,
    185,
    36,
    39,
    174,
    65,
    228,
    100,
    155,
    147,
    76,
    164,
    149,
    153,
    27,
    120,
    82,
    184,
    85
  ]);

  // node_modules/@aws-crypto/sha256-browser/build/module/webCryptoSha256.js
  var Sha256 = (
    /** @class */
    function() {
      function Sha2564(secret) {
        this.toHash = new Uint8Array(0);
        this.secret = secret;
        this.reset();
      }
      __name(Sha2564, "Sha256");
      Sha2564.prototype.update = function(data) {
        if (isEmptyData(data)) {
          return;
        }
        var update = convertToBuffer(data);
        var typedArray = new Uint8Array(this.toHash.byteLength + update.byteLength);
        typedArray.set(this.toHash, 0);
        typedArray.set(update, this.toHash.byteLength);
        this.toHash = typedArray;
      };
      Sha2564.prototype.digest = function() {
        var _this = this;
        if (this.key) {
          return this.key.then(function(key) {
            return locateWindow().crypto.subtle.sign(SHA_256_HMAC_ALGO, key, _this.toHash).then(function(data) {
              return new Uint8Array(data);
            });
          });
        }
        if (isEmptyData(this.toHash)) {
          return Promise.resolve(EMPTY_DATA_SHA_256);
        }
        return Promise.resolve().then(function() {
          return locateWindow().crypto.subtle.digest(SHA_256_HASH, _this.toHash);
        }).then(function(data) {
          return Promise.resolve(new Uint8Array(data));
        });
      };
      Sha2564.prototype.reset = function() {
        var _this = this;
        this.toHash = new Uint8Array(0);
        if (this.secret && this.secret !== void 0) {
          this.key = new Promise(function(resolve, reject) {
            locateWindow().crypto.subtle.importKey("raw", convertToBuffer(_this.secret), SHA_256_HMAC_ALGO, false, ["sign"]).then(resolve, reject);
          });
          this.key.catch(function() {
          });
        }
      };
      return Sha2564;
    }()
  );

  // node_modules/@aws-crypto/sha256-js/build/module/constants.js
  var BLOCK_SIZE = 64;
  var DIGEST_LENGTH = 32;
  var KEY = new Uint32Array([
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ]);
  var INIT = [
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
  ];
  var MAX_HASHABLE_LENGTH = Math.pow(2, 53) - 1;

  // node_modules/@aws-crypto/sha256-js/build/module/RawSha256.js
  var RawSha256 = (
    /** @class */
    function() {
      function RawSha2562() {
        this.state = Int32Array.from(INIT);
        this.temp = new Int32Array(64);
        this.buffer = new Uint8Array(64);
        this.bufferLength = 0;
        this.bytesHashed = 0;
        this.finished = false;
      }
      __name(RawSha2562, "RawSha256");
      RawSha2562.prototype.update = function(data) {
        if (this.finished) {
          throw new Error("Attempted to update an already finished hash.");
        }
        var position = 0;
        var byteLength = data.byteLength;
        this.bytesHashed += byteLength;
        if (this.bytesHashed * 8 > MAX_HASHABLE_LENGTH) {
          throw new Error("Cannot hash more than 2^53 - 1 bits");
        }
        while (byteLength > 0) {
          this.buffer[this.bufferLength++] = data[position++];
          byteLength--;
          if (this.bufferLength === BLOCK_SIZE) {
            this.hashBuffer();
            this.bufferLength = 0;
          }
        }
      };
      RawSha2562.prototype.digest = function() {
        if (!this.finished) {
          var bitsHashed = this.bytesHashed * 8;
          var bufferView = new DataView(this.buffer.buffer, this.buffer.byteOffset, this.buffer.byteLength);
          var undecoratedLength = this.bufferLength;
          bufferView.setUint8(this.bufferLength++, 128);
          if (undecoratedLength % BLOCK_SIZE >= BLOCK_SIZE - 8) {
            for (var i3 = this.bufferLength; i3 < BLOCK_SIZE; i3++) {
              bufferView.setUint8(i3, 0);
            }
            this.hashBuffer();
            this.bufferLength = 0;
          }
          for (var i3 = this.bufferLength; i3 < BLOCK_SIZE - 8; i3++) {
            bufferView.setUint8(i3, 0);
          }
          bufferView.setUint32(BLOCK_SIZE - 8, Math.floor(bitsHashed / 4294967296), true);
          bufferView.setUint32(BLOCK_SIZE - 4, bitsHashed);
          this.hashBuffer();
          this.finished = true;
        }
        var out = new Uint8Array(DIGEST_LENGTH);
        for (var i3 = 0; i3 < 8; i3++) {
          out[i3 * 4] = this.state[i3] >>> 24 & 255;
          out[i3 * 4 + 1] = this.state[i3] >>> 16 & 255;
          out[i3 * 4 + 2] = this.state[i3] >>> 8 & 255;
          out[i3 * 4 + 3] = this.state[i3] >>> 0 & 255;
        }
        return out;
      };
      RawSha2562.prototype.hashBuffer = function() {
        var _a = this, buffer = _a.buffer, state = _a.state;
        var state0 = state[0], state1 = state[1], state2 = state[2], state3 = state[3], state4 = state[4], state5 = state[5], state6 = state[6], state7 = state[7];
        for (var i3 = 0; i3 < BLOCK_SIZE; i3++) {
          if (i3 < 16) {
            this.temp[i3] = (buffer[i3 * 4] & 255) << 24 | (buffer[i3 * 4 + 1] & 255) << 16 | (buffer[i3 * 4 + 2] & 255) << 8 | buffer[i3 * 4 + 3] & 255;
          } else {
            var u3 = this.temp[i3 - 2];
            var t1_1 = (u3 >>> 17 | u3 << 15) ^ (u3 >>> 19 | u3 << 13) ^ u3 >>> 10;
            u3 = this.temp[i3 - 15];
            var t2_1 = (u3 >>> 7 | u3 << 25) ^ (u3 >>> 18 | u3 << 14) ^ u3 >>> 3;
            this.temp[i3] = (t1_1 + this.temp[i3 - 7] | 0) + (t2_1 + this.temp[i3 - 16] | 0);
          }
          var t1 = (((state4 >>> 6 | state4 << 26) ^ (state4 >>> 11 | state4 << 21) ^ (state4 >>> 25 | state4 << 7)) + (state4 & state5 ^ ~state4 & state6) | 0) + (state7 + (KEY[i3] + this.temp[i3] | 0) | 0) | 0;
          var t22 = ((state0 >>> 2 | state0 << 30) ^ (state0 >>> 13 | state0 << 19) ^ (state0 >>> 22 | state0 << 10)) + (state0 & state1 ^ state0 & state2 ^ state1 & state2) | 0;
          state7 = state6;
          state6 = state5;
          state5 = state4;
          state4 = state3 + t1 | 0;
          state3 = state2;
          state2 = state1;
          state1 = state0;
          state0 = t1 + t22 | 0;
        }
        state[0] += state0;
        state[1] += state1;
        state[2] += state2;
        state[3] += state3;
        state[4] += state4;
        state[5] += state5;
        state[6] += state6;
        state[7] += state7;
      };
      return RawSha2562;
    }()
  );

  // node_modules/@aws-crypto/sha256-js/build/module/jsSha256.js
  var Sha2562 = (
    /** @class */
    function() {
      function Sha2564(secret) {
        this.secret = secret;
        this.hash = new RawSha256();
        this.reset();
      }
      __name(Sha2564, "Sha256");
      Sha2564.prototype.update = function(toHash) {
        if (isEmptyData(toHash) || this.error) {
          return;
        }
        try {
          this.hash.update(convertToBuffer(toHash));
        } catch (e3) {
          this.error = e3;
        }
      };
      Sha2564.prototype.digestSync = function() {
        if (this.error) {
          throw this.error;
        }
        if (this.outer) {
          if (!this.outer.finished) {
            this.outer.update(this.hash.digest());
          }
          return this.outer.digest();
        }
        return this.hash.digest();
      };
      Sha2564.prototype.digest = function() {
        return __awaiter(this, void 0, void 0, function() {
          return __generator(this, function(_a) {
            return [2, this.digestSync()];
          });
        });
      };
      Sha2564.prototype.reset = function() {
        this.hash = new RawSha256();
        if (this.secret) {
          this.outer = new RawSha256();
          var inner = bufferFromSecret(this.secret);
          var outer = new Uint8Array(BLOCK_SIZE);
          outer.set(inner);
          for (var i3 = 0; i3 < BLOCK_SIZE; i3++) {
            inner[i3] ^= 54;
            outer[i3] ^= 92;
          }
          this.hash.update(inner);
          this.outer.update(outer);
          for (var i3 = 0; i3 < inner.byteLength; i3++) {
            inner[i3] = 0;
          }
        }
      };
      return Sha2564;
    }()
  );
  function bufferFromSecret(secret) {
    var input = convertToBuffer(secret);
    if (input.byteLength > BLOCK_SIZE) {
      var bufferHash = new RawSha256();
      bufferHash.update(input);
      input = bufferHash.digest();
    }
    var buffer = new Uint8Array(BLOCK_SIZE);
    buffer.set(input);
    return buffer;
  }
  __name(bufferFromSecret, "bufferFromSecret");

  // node_modules/@aws-crypto/sha256-browser/build/module/crossPlatformSha256.js
  var Sha2563 = (
    /** @class */
    function() {
      function Sha2564(secret) {
        if (supportsWebCrypto(locateWindow())) {
          this.hash = new Sha256(secret);
        } else {
          this.hash = new Sha2562(secret);
        }
      }
      __name(Sha2564, "Sha256");
      Sha2564.prototype.update = function(data, encoding) {
        this.hash.update(convertToBuffer(data));
      };
      Sha2564.prototype.digest = function() {
        return this.hash.digest();
      };
      Sha2564.prototype.reset = function() {
        this.hash.reset();
      };
      return Sha2564;
    }()
  );

  // node_modules/@aws-sdk/util-user-agent-browser/dist-es/index.js
  var import_bowser = __toESM(require_es5());
  var createDefaultUserAgentProvider = /* @__PURE__ */ __name(({ serviceId, clientVersion }) => async (config4) => {
    const parsedUA = typeof window !== "undefined" && window?.navigator?.userAgent ? import_bowser.default.parse(window.navigator.userAgent) : void 0;
    const sections = [
      ["aws-sdk-js", clientVersion],
      ["ua", "2.1"],
      [`os/${parsedUA?.os?.name || "other"}`, parsedUA?.os?.version],
      ["lang/js"],
      ["md/browser", `${parsedUA?.browser?.name ?? "unknown"}_${parsedUA?.browser?.version ?? "unknown"}`]
    ];
    if (serviceId) {
      sections.push([`api/${serviceId}`, clientVersion]);
    }
    const appId = await config4?.userAgentAppId?.();
    if (appId) {
      sections.push([`app/${appId}`]);
    }
    return sections;
  }, "createDefaultUserAgentProvider");

  // node_modules/@smithy/eventstream-codec/dist-es/Int64.js
  var Int642 = class _Int64 {
    static {
      __name(this, "Int64");
    }
    constructor(bytes) {
      this.bytes = bytes;
      if (bytes.byteLength !== 8) {
        throw new Error("Int64 buffers must be exactly 8 bytes");
      }
    }
    static fromNumber(number) {
      if (number > 9223372036854776e3 || number < -9223372036854776e3) {
        throw new Error(`${number} is too large (or, if negative, too small) to represent as an Int64`);
      }
      const bytes = new Uint8Array(8);
      for (let i3 = 7, remaining = Math.abs(Math.round(number)); i3 > -1 && remaining > 0; i3--, remaining /= 256) {
        bytes[i3] = remaining;
      }
      if (number < 0) {
        negate2(bytes);
      }
      return new _Int64(bytes);
    }
    valueOf() {
      const bytes = this.bytes.slice(0);
      const negative = bytes[0] & 128;
      if (negative) {
        negate2(bytes);
      }
      return parseInt(toHex(bytes), 16) * (negative ? -1 : 1);
    }
    toString() {
      return String(this.valueOf());
    }
  };
  function negate2(bytes) {
    for (let i3 = 0; i3 < 8; i3++) {
      bytes[i3] ^= 255;
    }
    for (let i3 = 7; i3 > -1; i3--) {
      bytes[i3]++;
      if (bytes[i3] !== 0)
        break;
    }
  }
  __name(negate2, "negate");

  // node_modules/@smithy/eventstream-codec/dist-es/HeaderMarshaller.js
  var HeaderMarshaller = class {
    static {
      __name(this, "HeaderMarshaller");
    }
    constructor(toUtf82, fromUtf85) {
      this.toUtf8 = toUtf82;
      this.fromUtf8 = fromUtf85;
    }
    format(headers) {
      const chunks = [];
      for (const headerName of Object.keys(headers)) {
        const bytes = this.fromUtf8(headerName);
        chunks.push(Uint8Array.from([bytes.byteLength]), bytes, this.formatHeaderValue(headers[headerName]));
      }
      const out = new Uint8Array(chunks.reduce((carry, bytes) => carry + bytes.byteLength, 0));
      let position = 0;
      for (const chunk of chunks) {
        out.set(chunk, position);
        position += chunk.byteLength;
      }
      return out;
    }
    formatHeaderValue(header) {
      switch (header.type) {
        case "boolean":
          return Uint8Array.from([header.value ? 0 : 1]);
        case "byte":
          return Uint8Array.from([2, header.value]);
        case "short":
          const shortView = new DataView(new ArrayBuffer(3));
          shortView.setUint8(0, 3);
          shortView.setInt16(1, header.value, false);
          return new Uint8Array(shortView.buffer);
        case "integer":
          const intView = new DataView(new ArrayBuffer(5));
          intView.setUint8(0, 4);
          intView.setInt32(1, header.value, false);
          return new Uint8Array(intView.buffer);
        case "long":
          const longBytes = new Uint8Array(9);
          longBytes[0] = 5;
          longBytes.set(header.value.bytes, 1);
          return longBytes;
        case "binary":
          const binView = new DataView(new ArrayBuffer(3 + header.value.byteLength));
          binView.setUint8(0, 6);
          binView.setUint16(1, header.value.byteLength, false);
          const binBytes = new Uint8Array(binView.buffer);
          binBytes.set(header.value, 3);
          return binBytes;
        case "string":
          const utf8Bytes = this.fromUtf8(header.value);
          const strView = new DataView(new ArrayBuffer(3 + utf8Bytes.byteLength));
          strView.setUint8(0, 7);
          strView.setUint16(1, utf8Bytes.byteLength, false);
          const strBytes = new Uint8Array(strView.buffer);
          strBytes.set(utf8Bytes, 3);
          return strBytes;
        case "timestamp":
          const tsBytes = new Uint8Array(9);
          tsBytes[0] = 8;
          tsBytes.set(Int642.fromNumber(header.value.valueOf()).bytes, 1);
          return tsBytes;
        case "uuid":
          if (!UUID_PATTERN2.test(header.value)) {
            throw new Error(`Invalid UUID received: ${header.value}`);
          }
          const uuidBytes = new Uint8Array(17);
          uuidBytes[0] = 9;
          uuidBytes.set(fromHex(header.value.replace(/\-/g, "")), 1);
          return uuidBytes;
      }
    }
    parse(headers) {
      const out = {};
      let position = 0;
      while (position < headers.byteLength) {
        const nameLength = headers.getUint8(position++);
        const name = this.toUtf8(new Uint8Array(headers.buffer, headers.byteOffset + position, nameLength));
        position += nameLength;
        switch (headers.getUint8(position++)) {
          case 0:
            out[name] = {
              type: BOOLEAN_TAG,
              value: true
            };
            break;
          case 1:
            out[name] = {
              type: BOOLEAN_TAG,
              value: false
            };
            break;
          case 2:
            out[name] = {
              type: BYTE_TAG,
              value: headers.getInt8(position++)
            };
            break;
          case 3:
            out[name] = {
              type: SHORT_TAG,
              value: headers.getInt16(position, false)
            };
            position += 2;
            break;
          case 4:
            out[name] = {
              type: INT_TAG,
              value: headers.getInt32(position, false)
            };
            position += 4;
            break;
          case 5:
            out[name] = {
              type: LONG_TAG,
              value: new Int642(new Uint8Array(headers.buffer, headers.byteOffset + position, 8))
            };
            position += 8;
            break;
          case 6:
            const binaryLength = headers.getUint16(position, false);
            position += 2;
            out[name] = {
              type: BINARY_TAG,
              value: new Uint8Array(headers.buffer, headers.byteOffset + position, binaryLength)
            };
            position += binaryLength;
            break;
          case 7:
            const stringLength = headers.getUint16(position, false);
            position += 2;
            out[name] = {
              type: STRING_TAG,
              value: this.toUtf8(new Uint8Array(headers.buffer, headers.byteOffset + position, stringLength))
            };
            position += stringLength;
            break;
          case 8:
            out[name] = {
              type: TIMESTAMP_TAG,
              value: new Date(new Int642(new Uint8Array(headers.buffer, headers.byteOffset + position, 8)).valueOf())
            };
            position += 8;
            break;
          case 9:
            const uuidBytes = new Uint8Array(headers.buffer, headers.byteOffset + position, 16);
            position += 16;
            out[name] = {
              type: UUID_TAG,
              value: `${toHex(uuidBytes.subarray(0, 4))}-${toHex(uuidBytes.subarray(4, 6))}-${toHex(uuidBytes.subarray(6, 8))}-${toHex(uuidBytes.subarray(8, 10))}-${toHex(uuidBytes.subarray(10))}`
            };
            break;
          default:
            throw new Error(`Unrecognized header type tag`);
        }
      }
      return out;
    }
  };
  var HEADER_VALUE_TYPE2;
  (function(HEADER_VALUE_TYPE3) {
    HEADER_VALUE_TYPE3[HEADER_VALUE_TYPE3["boolTrue"] = 0] = "boolTrue";
    HEADER_VALUE_TYPE3[HEADER_VALUE_TYPE3["boolFalse"] = 1] = "boolFalse";
    HEADER_VALUE_TYPE3[HEADER_VALUE_TYPE3["byte"] = 2] = "byte";
    HEADER_VALUE_TYPE3[HEADER_VALUE_TYPE3["short"] = 3] = "short";
    HEADER_VALUE_TYPE3[HEADER_VALUE_TYPE3["integer"] = 4] = "integer";
    HEADER_VALUE_TYPE3[HEADER_VALUE_TYPE3["long"] = 5] = "long";
    HEADER_VALUE_TYPE3[HEADER_VALUE_TYPE3["byteArray"] = 6] = "byteArray";
    HEADER_VALUE_TYPE3[HEADER_VALUE_TYPE3["string"] = 7] = "string";
    HEADER_VALUE_TYPE3[HEADER_VALUE_TYPE3["timestamp"] = 8] = "timestamp";
    HEADER_VALUE_TYPE3[HEADER_VALUE_TYPE3["uuid"] = 9] = "uuid";
  })(HEADER_VALUE_TYPE2 || (HEADER_VALUE_TYPE2 = {}));
  var BOOLEAN_TAG = "boolean";
  var BYTE_TAG = "byte";
  var SHORT_TAG = "short";
  var INT_TAG = "integer";
  var LONG_TAG = "long";
  var BINARY_TAG = "binary";
  var STRING_TAG = "string";
  var TIMESTAMP_TAG = "timestamp";
  var UUID_TAG = "uuid";
  var UUID_PATTERN2 = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/;

  // node_modules/@smithy/eventstream-codec/dist-es/splitMessage.js
  var PRELUDE_MEMBER_LENGTH = 4;
  var PRELUDE_LENGTH = PRELUDE_MEMBER_LENGTH * 2;
  var CHECKSUM_LENGTH = 4;
  var MINIMUM_MESSAGE_LENGTH = PRELUDE_LENGTH + CHECKSUM_LENGTH * 2;
  function splitMessage({ byteLength, byteOffset, buffer }) {
    if (byteLength < MINIMUM_MESSAGE_LENGTH) {
      throw new Error("Provided message too short to accommodate event stream message overhead");
    }
    const view = new DataView(buffer, byteOffset, byteLength);
    const messageLength = view.getUint32(0, false);
    if (byteLength !== messageLength) {
      throw new Error("Reported message length does not match received message length");
    }
    const headerLength = view.getUint32(PRELUDE_MEMBER_LENGTH, false);
    const expectedPreludeChecksum = view.getUint32(PRELUDE_LENGTH, false);
    const expectedMessageChecksum = view.getUint32(byteLength - CHECKSUM_LENGTH, false);
    const checksummer = new Crc32().update(new Uint8Array(buffer, byteOffset, PRELUDE_LENGTH));
    if (expectedPreludeChecksum !== checksummer.digest()) {
      throw new Error(`The prelude checksum specified in the message (${expectedPreludeChecksum}) does not match the calculated CRC32 checksum (${checksummer.digest()})`);
    }
    checksummer.update(new Uint8Array(buffer, byteOffset + PRELUDE_LENGTH, byteLength - (PRELUDE_LENGTH + CHECKSUM_LENGTH)));
    if (expectedMessageChecksum !== checksummer.digest()) {
      throw new Error(`The message checksum (${checksummer.digest()}) did not match the expected value of ${expectedMessageChecksum}`);
    }
    return {
      headers: new DataView(buffer, byteOffset + PRELUDE_LENGTH + CHECKSUM_LENGTH, headerLength),
      body: new Uint8Array(buffer, byteOffset + PRELUDE_LENGTH + CHECKSUM_LENGTH + headerLength, messageLength - headerLength - (PRELUDE_LENGTH + CHECKSUM_LENGTH + CHECKSUM_LENGTH))
    };
  }
  __name(splitMessage, "splitMessage");

  // node_modules/@smithy/eventstream-codec/dist-es/EventStreamCodec.js
  var EventStreamCodec = class {
    static {
      __name(this, "EventStreamCodec");
    }
    constructor(toUtf82, fromUtf85) {
      this.headerMarshaller = new HeaderMarshaller(toUtf82, fromUtf85);
      this.messageBuffer = [];
      this.isEndOfStream = false;
    }
    feed(message) {
      this.messageBuffer.push(this.decode(message));
    }
    endOfStream() {
      this.isEndOfStream = true;
    }
    getMessage() {
      const message = this.messageBuffer.pop();
      const isEndOfStream = this.isEndOfStream;
      return {
        getMessage() {
          return message;
        },
        isEndOfStream() {
          return isEndOfStream;
        }
      };
    }
    getAvailableMessages() {
      const messages = this.messageBuffer;
      this.messageBuffer = [];
      const isEndOfStream = this.isEndOfStream;
      return {
        getMessages() {
          return messages;
        },
        isEndOfStream() {
          return isEndOfStream;
        }
      };
    }
    encode({ headers: rawHeaders, body }) {
      const headers = this.headerMarshaller.format(rawHeaders);
      const length = headers.byteLength + body.byteLength + 16;
      const out = new Uint8Array(length);
      const view = new DataView(out.buffer, out.byteOffset, out.byteLength);
      const checksum = new Crc32();
      view.setUint32(0, length, false);
      view.setUint32(4, headers.byteLength, false);
      view.setUint32(8, checksum.update(out.subarray(0, 8)).digest(), false);
      out.set(headers, 12);
      out.set(body, headers.byteLength + 12);
      view.setUint32(length - 4, checksum.update(out.subarray(8, length - 4)).digest(), false);
      return out;
    }
    decode(message) {
      const { headers, body } = splitMessage(message);
      return { headers: this.headerMarshaller.parse(headers), body };
    }
    formatHeaders(rawHeaders) {
      return this.headerMarshaller.format(rawHeaders);
    }
  };

  // node_modules/@smithy/eventstream-codec/dist-es/MessageDecoderStream.js
  var MessageDecoderStream = class {
    static {
      __name(this, "MessageDecoderStream");
    }
    constructor(options) {
      this.options = options;
    }
    [Symbol.asyncIterator]() {
      return this.asyncIterator();
    }
    async *asyncIterator() {
      for await (const bytes of this.options.inputStream) {
        const decoded = this.options.decoder.decode(bytes);
        yield decoded;
      }
    }
  };

  // node_modules/@smithy/eventstream-codec/dist-es/MessageEncoderStream.js
  var MessageEncoderStream = class {
    static {
      __name(this, "MessageEncoderStream");
    }
    constructor(options) {
      this.options = options;
    }
    [Symbol.asyncIterator]() {
      return this.asyncIterator();
    }
    async *asyncIterator() {
      for await (const msg of this.options.messageStream) {
        const encoded = this.options.encoder.encode(msg);
        yield encoded;
      }
      if (this.options.includeEndFrame) {
        yield new Uint8Array(0);
      }
    }
  };

  // node_modules/@smithy/eventstream-codec/dist-es/SmithyMessageDecoderStream.js
  var SmithyMessageDecoderStream = class {
    static {
      __name(this, "SmithyMessageDecoderStream");
    }
    constructor(options) {
      this.options = options;
    }
    [Symbol.asyncIterator]() {
      return this.asyncIterator();
    }
    async *asyncIterator() {
      for await (const message of this.options.messageStream) {
        const deserialized = await this.options.deserializer(message);
        if (deserialized === void 0)
          continue;
        yield deserialized;
      }
    }
  };

  // node_modules/@smithy/eventstream-codec/dist-es/SmithyMessageEncoderStream.js
  var SmithyMessageEncoderStream = class {
    static {
      __name(this, "SmithyMessageEncoderStream");
    }
    constructor(options) {
      this.options = options;
    }
    [Symbol.asyncIterator]() {
      return this.asyncIterator();
    }
    async *asyncIterator() {
      for await (const chunk of this.options.inputStream) {
        const payloadBuf = this.options.serializer(chunk);
        yield payloadBuf;
      }
    }
  };

  // node_modules/@smithy/eventstream-serde-universal/dist-es/getChunkedStream.js
  function getChunkedStream(source) {
    let currentMessageTotalLength = 0;
    let currentMessagePendingLength = 0;
    let currentMessage = null;
    let messageLengthBuffer = null;
    const allocateMessage = /* @__PURE__ */ __name((size) => {
      if (typeof size !== "number") {
        throw new Error("Attempted to allocate an event message where size was not a number: " + size);
      }
      currentMessageTotalLength = size;
      currentMessagePendingLength = 4;
      currentMessage = new Uint8Array(size);
      const currentMessageView = new DataView(currentMessage.buffer);
      currentMessageView.setUint32(0, size, false);
    }, "allocateMessage");
    const iterator = /* @__PURE__ */ __name(async function* () {
      const sourceIterator = source[Symbol.asyncIterator]();
      while (true) {
        const { value, done } = await sourceIterator.next();
        if (done) {
          if (!currentMessageTotalLength) {
            return;
          } else if (currentMessageTotalLength === currentMessagePendingLength) {
            yield currentMessage;
          } else {
            throw new Error("Truncated event message received.");
          }
          return;
        }
        const chunkLength = value.length;
        let currentOffset = 0;
        while (currentOffset < chunkLength) {
          if (!currentMessage) {
            const bytesRemaining = chunkLength - currentOffset;
            if (!messageLengthBuffer) {
              messageLengthBuffer = new Uint8Array(4);
            }
            const numBytesForTotal = Math.min(4 - currentMessagePendingLength, bytesRemaining);
            messageLengthBuffer.set(value.slice(currentOffset, currentOffset + numBytesForTotal), currentMessagePendingLength);
            currentMessagePendingLength += numBytesForTotal;
            currentOffset += numBytesForTotal;
            if (currentMessagePendingLength < 4) {
              break;
            }
            allocateMessage(new DataView(messageLengthBuffer.buffer).getUint32(0, false));
            messageLengthBuffer = null;
          }
          const numBytesToWrite = Math.min(currentMessageTotalLength - currentMessagePendingLength, chunkLength - currentOffset);
          currentMessage.set(value.slice(currentOffset, currentOffset + numBytesToWrite), currentMessagePendingLength);
          currentMessagePendingLength += numBytesToWrite;
          currentOffset += numBytesToWrite;
          if (currentMessageTotalLength && currentMessageTotalLength === currentMessagePendingLength) {
            yield currentMessage;
            currentMessage = null;
            currentMessageTotalLength = 0;
            currentMessagePendingLength = 0;
          }
        }
      }
    }, "iterator");
    return {
      [Symbol.asyncIterator]: iterator
    };
  }
  __name(getChunkedStream, "getChunkedStream");

  // node_modules/@smithy/eventstream-serde-universal/dist-es/getUnmarshalledStream.js
  function getMessageUnmarshaller(deserializer, toUtf82) {
    return async function(message) {
      const { value: messageType } = message.headers[":message-type"];
      if (messageType === "error") {
        const unmodeledError = new Error(message.headers[":error-message"].value || "UnknownError");
        unmodeledError.name = message.headers[":error-code"].value;
        throw unmodeledError;
      } else if (messageType === "exception") {
        const code = message.headers[":exception-type"].value;
        const exception = { [code]: message };
        const deserializedException = await deserializer(exception);
        if (deserializedException.$unknown) {
          const error = new Error(toUtf82(message.body));
          error.name = code;
          throw error;
        }
        throw deserializedException[code];
      } else if (messageType === "event") {
        const event = {
          [message.headers[":event-type"].value]: message
        };
        const deserialized = await deserializer(event);
        if (deserialized.$unknown)
          return;
        return deserialized;
      } else {
        throw Error(`Unrecognizable event type: ${message.headers[":event-type"].value}`);
      }
    };
  }
  __name(getMessageUnmarshaller, "getMessageUnmarshaller");

  // node_modules/@smithy/eventstream-serde-universal/dist-es/EventStreamMarshaller.js
  var EventStreamMarshaller = class {
    static {
      __name(this, "EventStreamMarshaller");
    }
    constructor({ utf8Encoder, utf8Decoder }) {
      this.eventStreamCodec = new EventStreamCodec(utf8Encoder, utf8Decoder);
      this.utfEncoder = utf8Encoder;
    }
    deserialize(body, deserializer) {
      const inputStream = getChunkedStream(body);
      return new SmithyMessageDecoderStream({
        messageStream: new MessageDecoderStream({ inputStream, decoder: this.eventStreamCodec }),
        deserializer: getMessageUnmarshaller(deserializer, this.utfEncoder)
      });
    }
    serialize(inputStream, serializer) {
      return new MessageEncoderStream({
        messageStream: new SmithyMessageEncoderStream({ inputStream, serializer }),
        encoder: this.eventStreamCodec,
        includeEndFrame: true
      });
    }
  };

  // node_modules/@smithy/eventstream-serde-browser/dist-es/utils.js
  var readableStreamtoIterable = /* @__PURE__ */ __name((readableStream) => ({
    [Symbol.asyncIterator]: async function* () {
      const reader = readableStream.getReader();
      try {
        while (true) {
          const { done, value } = await reader.read();
          if (done)
            return;
          yield value;
        }
      } finally {
        reader.releaseLock();
      }
    }
  }), "readableStreamtoIterable");
  var iterableToReadableStream = /* @__PURE__ */ __name((asyncIterable) => {
    const iterator = asyncIterable[Symbol.asyncIterator]();
    return new ReadableStream({
      async pull(controller) {
        const { done, value } = await iterator.next();
        if (done) {
          return controller.close();
        }
        controller.enqueue(value);
      }
    });
  }, "iterableToReadableStream");

  // node_modules/@smithy/eventstream-serde-browser/dist-es/EventStreamMarshaller.js
  var EventStreamMarshaller2 = class {
    static {
      __name(this, "EventStreamMarshaller");
    }
    constructor({ utf8Encoder, utf8Decoder }) {
      this.universalMarshaller = new EventStreamMarshaller({
        utf8Decoder,
        utf8Encoder
      });
    }
    deserialize(body, deserializer) {
      const bodyIterable = isReadableStream2(body) ? readableStreamtoIterable(body) : body;
      return this.universalMarshaller.deserialize(bodyIterable, deserializer);
    }
    serialize(input, serializer) {
      const serialziedIterable = this.universalMarshaller.serialize(input, serializer);
      return typeof ReadableStream === "function" ? iterableToReadableStream(serialziedIterable) : serialziedIterable;
    }
  };
  var isReadableStream2 = /* @__PURE__ */ __name((body) => typeof ReadableStream === "function" && body instanceof ReadableStream, "isReadableStream");

  // node_modules/@smithy/eventstream-serde-browser/dist-es/provider.js
  var eventStreamSerdeProvider = /* @__PURE__ */ __name((options) => new EventStreamMarshaller2(options), "eventStreamSerdeProvider");

  // node_modules/@smithy/chunked-blob-reader/dist-es/index.js
  async function blobReader(blob, onChunk, chunkSize = 1024 * 1024) {
    const size = blob.size;
    let totalBytesRead = 0;
    while (totalBytesRead < size) {
      const slice = blob.slice(totalBytesRead, Math.min(size, totalBytesRead + chunkSize));
      onChunk(new Uint8Array(await slice.arrayBuffer()));
      totalBytesRead += slice.size;
    }
  }
  __name(blobReader, "blobReader");

  // node_modules/@smithy/hash-blob-browser/dist-es/index.js
  var blobHasher = /* @__PURE__ */ __name(async function blobHasher2(hashCtor, blob) {
    const hash = new hashCtor();
    await blobReader(blob, (chunk) => {
      hash.update(chunk);
    });
    return hash.digest();
  }, "blobHasher");

  // node_modules/@smithy/invalid-dependency/dist-es/invalidProvider.js
  var invalidProvider = /* @__PURE__ */ __name((message) => () => Promise.reject(message), "invalidProvider");

  // node_modules/@smithy/md5-js/dist-es/constants.js
  var BLOCK_SIZE2 = 64;
  var DIGEST_LENGTH2 = 16;
  var INIT2 = [1732584193, 4023233417, 2562383102, 271733878];

  // node_modules/@smithy/md5-js/dist-es/index.js
  var Md5 = class {
    static {
      __name(this, "Md5");
    }
    constructor() {
      this.reset();
    }
    update(sourceData) {
      if (isEmptyData3(sourceData)) {
        return;
      } else if (this.finished) {
        throw new Error("Attempted to update an already finished hash.");
      }
      const data = convertToBuffer3(sourceData);
      let position = 0;
      let { byteLength } = data;
      this.bytesHashed += byteLength;
      while (byteLength > 0) {
        this.buffer.setUint8(this.bufferLength++, data[position++]);
        byteLength--;
        if (this.bufferLength === BLOCK_SIZE2) {
          this.hashBuffer();
          this.bufferLength = 0;
        }
      }
    }
    async digest() {
      if (!this.finished) {
        const { buffer, bufferLength: undecoratedLength, bytesHashed } = this;
        const bitsHashed = bytesHashed * 8;
        buffer.setUint8(this.bufferLength++, 128);
        if (undecoratedLength % BLOCK_SIZE2 >= BLOCK_SIZE2 - 8) {
          for (let i3 = this.bufferLength; i3 < BLOCK_SIZE2; i3++) {
            buffer.setUint8(i3, 0);
          }
          this.hashBuffer();
          this.bufferLength = 0;
        }
        for (let i3 = this.bufferLength; i3 < BLOCK_SIZE2 - 8; i3++) {
          buffer.setUint8(i3, 0);
        }
        buffer.setUint32(BLOCK_SIZE2 - 8, bitsHashed >>> 0, true);
        buffer.setUint32(BLOCK_SIZE2 - 4, Math.floor(bitsHashed / 4294967296), true);
        this.hashBuffer();
        this.finished = true;
      }
      const out = new DataView(new ArrayBuffer(DIGEST_LENGTH2));
      for (let i3 = 0; i3 < 4; i3++) {
        out.setUint32(i3 * 4, this.state[i3], true);
      }
      return new Uint8Array(out.buffer, out.byteOffset, out.byteLength);
    }
    hashBuffer() {
      const { buffer, state } = this;
      let a3 = state[0], b3 = state[1], c3 = state[2], d3 = state[3];
      a3 = ff(a3, b3, c3, d3, buffer.getUint32(0, true), 7, 3614090360);
      d3 = ff(d3, a3, b3, c3, buffer.getUint32(4, true), 12, 3905402710);
      c3 = ff(c3, d3, a3, b3, buffer.getUint32(8, true), 17, 606105819);
      b3 = ff(b3, c3, d3, a3, buffer.getUint32(12, true), 22, 3250441966);
      a3 = ff(a3, b3, c3, d3, buffer.getUint32(16, true), 7, 4118548399);
      d3 = ff(d3, a3, b3, c3, buffer.getUint32(20, true), 12, 1200080426);
      c3 = ff(c3, d3, a3, b3, buffer.getUint32(24, true), 17, 2821735955);
      b3 = ff(b3, c3, d3, a3, buffer.getUint32(28, true), 22, 4249261313);
      a3 = ff(a3, b3, c3, d3, buffer.getUint32(32, true), 7, 1770035416);
      d3 = ff(d3, a3, b3, c3, buffer.getUint32(36, true), 12, 2336552879);
      c3 = ff(c3, d3, a3, b3, buffer.getUint32(40, true), 17, 4294925233);
      b3 = ff(b3, c3, d3, a3, buffer.getUint32(44, true), 22, 2304563134);
      a3 = ff(a3, b3, c3, d3, buffer.getUint32(48, true), 7, 1804603682);
      d3 = ff(d3, a3, b3, c3, buffer.getUint32(52, true), 12, 4254626195);
      c3 = ff(c3, d3, a3, b3, buffer.getUint32(56, true), 17, 2792965006);
      b3 = ff(b3, c3, d3, a3, buffer.getUint32(60, true), 22, 1236535329);
      a3 = gg(a3, b3, c3, d3, buffer.getUint32(4, true), 5, 4129170786);
      d3 = gg(d3, a3, b3, c3, buffer.getUint32(24, true), 9, 3225465664);
      c3 = gg(c3, d3, a3, b3, buffer.getUint32(44, true), 14, 643717713);
      b3 = gg(b3, c3, d3, a3, buffer.getUint32(0, true), 20, 3921069994);
      a3 = gg(a3, b3, c3, d3, buffer.getUint32(20, true), 5, 3593408605);
      d3 = gg(d3, a3, b3, c3, buffer.getUint32(40, true), 9, 38016083);
      c3 = gg(c3, d3, a3, b3, buffer.getUint32(60, true), 14, 3634488961);
      b3 = gg(b3, c3, d3, a3, buffer.getUint32(16, true), 20, 3889429448);
      a3 = gg(a3, b3, c3, d3, buffer.getUint32(36, true), 5, 568446438);
      d3 = gg(d3, a3, b3, c3, buffer.getUint32(56, true), 9, 3275163606);
      c3 = gg(c3, d3, a3, b3, buffer.getUint32(12, true), 14, 4107603335);
      b3 = gg(b3, c3, d3, a3, buffer.getUint32(32, true), 20, 1163531501);
      a3 = gg(a3, b3, c3, d3, buffer.getUint32(52, true), 5, 2850285829);
      d3 = gg(d3, a3, b3, c3, buffer.getUint32(8, true), 9, 4243563512);
      c3 = gg(c3, d3, a3, b3, buffer.getUint32(28, true), 14, 1735328473);
      b3 = gg(b3, c3, d3, a3, buffer.getUint32(48, true), 20, 2368359562);
      a3 = hh(a3, b3, c3, d3, buffer.getUint32(20, true), 4, 4294588738);
      d3 = hh(d3, a3, b3, c3, buffer.getUint32(32, true), 11, 2272392833);
      c3 = hh(c3, d3, a3, b3, buffer.getUint32(44, true), 16, 1839030562);
      b3 = hh(b3, c3, d3, a3, buffer.getUint32(56, true), 23, 4259657740);
      a3 = hh(a3, b3, c3, d3, buffer.getUint32(4, true), 4, 2763975236);
      d3 = hh(d3, a3, b3, c3, buffer.getUint32(16, true), 11, 1272893353);
      c3 = hh(c3, d3, a3, b3, buffer.getUint32(28, true), 16, 4139469664);
      b3 = hh(b3, c3, d3, a3, buffer.getUint32(40, true), 23, 3200236656);
      a3 = hh(a3, b3, c3, d3, buffer.getUint32(52, true), 4, 681279174);
      d3 = hh(d3, a3, b3, c3, buffer.getUint32(0, true), 11, 3936430074);
      c3 = hh(c3, d3, a3, b3, buffer.getUint32(12, true), 16, 3572445317);
      b3 = hh(b3, c3, d3, a3, buffer.getUint32(24, true), 23, 76029189);
      a3 = hh(a3, b3, c3, d3, buffer.getUint32(36, true), 4, 3654602809);
      d3 = hh(d3, a3, b3, c3, buffer.getUint32(48, true), 11, 3873151461);
      c3 = hh(c3, d3, a3, b3, buffer.getUint32(60, true), 16, 530742520);
      b3 = hh(b3, c3, d3, a3, buffer.getUint32(8, true), 23, 3299628645);
      a3 = ii(a3, b3, c3, d3, buffer.getUint32(0, true), 6, 4096336452);
      d3 = ii(d3, a3, b3, c3, buffer.getUint32(28, true), 10, 1126891415);
      c3 = ii(c3, d3, a3, b3, buffer.getUint32(56, true), 15, 2878612391);
      b3 = ii(b3, c3, d3, a3, buffer.getUint32(20, true), 21, 4237533241);
      a3 = ii(a3, b3, c3, d3, buffer.getUint32(48, true), 6, 1700485571);
      d3 = ii(d3, a3, b3, c3, buffer.getUint32(12, true), 10, 2399980690);
      c3 = ii(c3, d3, a3, b3, buffer.getUint32(40, true), 15, 4293915773);
      b3 = ii(b3, c3, d3, a3, buffer.getUint32(4, true), 21, 2240044497);
      a3 = ii(a3, b3, c3, d3, buffer.getUint32(32, true), 6, 1873313359);
      d3 = ii(d3, a3, b3, c3, buffer.getUint32(60, true), 10, 4264355552);
      c3 = ii(c3, d3, a3, b3, buffer.getUint32(24, true), 15, 2734768916);
      b3 = ii(b3, c3, d3, a3, buffer.getUint32(52, true), 21, 1309151649);
      a3 = ii(a3, b3, c3, d3, buffer.getUint32(16, true), 6, 4149444226);
      d3 = ii(d3, a3, b3, c3, buffer.getUint32(44, true), 10, 3174756917);
      c3 = ii(c3, d3, a3, b3, buffer.getUint32(8, true), 15, 718787259);
      b3 = ii(b3, c3, d3, a3, buffer.getUint32(36, true), 21, 3951481745);
      state[0] = a3 + state[0] & 4294967295;
      state[1] = b3 + state[1] & 4294967295;
      state[2] = c3 + state[2] & 4294967295;
      state[3] = d3 + state[3] & 4294967295;
    }
    reset() {
      this.state = Uint32Array.from(INIT2);
      this.buffer = new DataView(new ArrayBuffer(BLOCK_SIZE2));
      this.bufferLength = 0;
      this.bytesHashed = 0;
      this.finished = false;
    }
  };
  function cmn(q3, a3, b3, x3, s3, t3) {
    a3 = (a3 + q3 & 4294967295) + (x3 + t3 & 4294967295) & 4294967295;
    return (a3 << s3 | a3 >>> 32 - s3) + b3 & 4294967295;
  }
  __name(cmn, "cmn");
  function ff(a3, b3, c3, d3, x3, s3, t3) {
    return cmn(b3 & c3 | ~b3 & d3, a3, b3, x3, s3, t3);
  }
  __name(ff, "ff");
  function gg(a3, b3, c3, d3, x3, s3, t3) {
    return cmn(b3 & d3 | c3 & ~d3, a3, b3, x3, s3, t3);
  }
  __name(gg, "gg");
  function hh(a3, b3, c3, d3, x3, s3, t3) {
    return cmn(b3 ^ c3 ^ d3, a3, b3, x3, s3, t3);
  }
  __name(hh, "hh");
  function ii(a3, b3, c3, d3, x3, s3, t3) {
    return cmn(c3 ^ (b3 | ~d3), a3, b3, x3, s3, t3);
  }
  __name(ii, "ii");
  function isEmptyData3(data) {
    if (typeof data === "string") {
      return data.length === 0;
    }
    return data.byteLength === 0;
  }
  __name(isEmptyData3, "isEmptyData");
  function convertToBuffer3(data) {
    if (typeof data === "string") {
      return fromUtf8(data);
    }
    if (ArrayBuffer.isView(data)) {
      return new Uint8Array(data.buffer, data.byteOffset, data.byteLength / Uint8Array.BYTES_PER_ELEMENT);
    }
    return new Uint8Array(data);
  }
  __name(convertToBuffer3, "convertToBuffer");

  // node_modules/@smithy/util-body-length-browser/dist-es/calculateBodyLength.js
  var TEXT_ENCODER = typeof TextEncoder == "function" ? new TextEncoder() : null;
  var calculateBodyLength = /* @__PURE__ */ __name((body) => {
    if (typeof body === "string") {
      if (TEXT_ENCODER) {
        return TEXT_ENCODER.encode(body).byteLength;
      }
      let len = body.length;
      for (let i3 = len - 1; i3 >= 0; i3--) {
        const code = body.charCodeAt(i3);
        if (code > 127 && code <= 2047)
          len++;
        else if (code > 2047 && code <= 65535)
          len += 2;
        if (code >= 56320 && code <= 57343)
          i3--;
      }
      return len;
    } else if (typeof body.byteLength === "number") {
      return body.byteLength;
    } else if (typeof body.size === "number") {
      return body.size;
    }
    throw new Error(`Body Length computation failed for ${body}`);
  }, "calculateBodyLength");

  // node_modules/@aws-sdk/client-s3/dist-es/runtimeConfig.shared.js
  var getRuntimeConfig = /* @__PURE__ */ __name((config4) => {
    return {
      apiVersion: "2006-03-01",
      base64Decoder: config4?.base64Decoder ?? fromBase64,
      base64Encoder: config4?.base64Encoder ?? toBase64,
      disableHostPrefix: config4?.disableHostPrefix ?? false,
      endpointProvider: config4?.endpointProvider ?? defaultEndpointResolver,
      extensions: config4?.extensions ?? [],
      getAwsChunkedEncodingStream: config4?.getAwsChunkedEncodingStream ?? getAwsChunkedEncodingStream,
      httpAuthSchemeProvider: config4?.httpAuthSchemeProvider ?? defaultS3HttpAuthSchemeProvider,
      httpAuthSchemes: config4?.httpAuthSchemes ?? [
        {
          schemeId: "aws.auth#sigv4",
          identityProvider: (ipc) => ipc.getIdentityProvider("aws.auth#sigv4"),
          signer: new AwsSdkSigV4Signer()
        },
        {
          schemeId: "aws.auth#sigv4a",
          identityProvider: (ipc) => ipc.getIdentityProvider("aws.auth#sigv4a"),
          signer: new AwsSdkSigV4ASigner()
        }
      ],
      logger: config4?.logger ?? new NoOpLogger(),
      sdkStreamMixin: config4?.sdkStreamMixin ?? sdkStreamMixin,
      serviceId: config4?.serviceId ?? "S3",
      signerConstructor: config4?.signerConstructor ?? SignatureV4MultiRegion,
      signingEscapePath: config4?.signingEscapePath ?? false,
      urlParser: config4?.urlParser ?? parseUrl,
      useArnRegion: config4?.useArnRegion ?? false,
      utf8Decoder: config4?.utf8Decoder ?? fromUtf8,
      utf8Encoder: config4?.utf8Encoder ?? toUtf8
    };
  }, "getRuntimeConfig");

  // node_modules/@smithy/util-defaults-mode-browser/dist-es/resolveDefaultsModeConfig.js
  var import_bowser2 = __toESM(require_es5());

  // node_modules/@smithy/util-defaults-mode-browser/dist-es/constants.js
  var DEFAULTS_MODE_OPTIONS = ["in-region", "cross-region", "mobile", "standard", "legacy"];

  // node_modules/@smithy/util-defaults-mode-browser/dist-es/resolveDefaultsModeConfig.js
  var resolveDefaultsModeConfig = /* @__PURE__ */ __name(({ defaultsMode } = {}) => memoize(async () => {
    const mode = typeof defaultsMode === "function" ? await defaultsMode() : defaultsMode;
    switch (mode?.toLowerCase()) {
      case "auto":
        return Promise.resolve(isMobileBrowser() ? "mobile" : "standard");
      case "mobile":
      case "in-region":
      case "cross-region":
      case "standard":
      case "legacy":
        return Promise.resolve(mode?.toLocaleLowerCase());
      case void 0:
        return Promise.resolve("legacy");
      default:
        throw new Error(`Invalid parameter for "defaultsMode", expect ${DEFAULTS_MODE_OPTIONS.join(", ")}, got ${mode}`);
    }
  }), "resolveDefaultsModeConfig");
  var isMobileBrowser = /* @__PURE__ */ __name(() => {
    const parsedUA = typeof window !== "undefined" && window?.navigator?.userAgent ? import_bowser2.default.parse(window.navigator.userAgent) : void 0;
    const platform = parsedUA?.platform?.type;
    return platform === "tablet" || platform === "mobile";
  }, "isMobileBrowser");

  // node_modules/@aws-sdk/client-s3/dist-es/runtimeConfig.browser.js
  var getRuntimeConfig2 = /* @__PURE__ */ __name((config4) => {
    const defaultsMode = resolveDefaultsModeConfig(config4);
    const defaultConfigProvider = /* @__PURE__ */ __name(() => defaultsMode().then(loadConfigsForDefaultMode), "defaultConfigProvider");
    const clientSharedValues = getRuntimeConfig(config4);
    return {
      ...clientSharedValues,
      ...config4,
      runtime: "browser",
      defaultsMode,
      bodyLengthChecker: config4?.bodyLengthChecker ?? calculateBodyLength,
      credentialDefaultProvider: config4?.credentialDefaultProvider ?? ((_2) => () => Promise.reject(new Error("Credential is missing"))),
      defaultUserAgentProvider: config4?.defaultUserAgentProvider ?? createDefaultUserAgentProvider({ serviceId: clientSharedValues.serviceId, clientVersion: package_default.version }),
      eventStreamSerdeProvider: config4?.eventStreamSerdeProvider ?? eventStreamSerdeProvider,
      maxAttempts: config4?.maxAttempts ?? DEFAULT_MAX_ATTEMPTS,
      md5: config4?.md5 ?? Md5,
      region: config4?.region ?? invalidProvider("Region is missing"),
      requestHandler: FetchHttpHandler.create(config4?.requestHandler ?? defaultConfigProvider),
      retryMode: config4?.retryMode ?? (async () => (await defaultConfigProvider()).retryMode || DEFAULT_RETRY_MODE),
      sha1: config4?.sha1 ?? Sha12,
      sha256: config4?.sha256 ?? Sha2563,
      streamCollector: config4?.streamCollector ?? streamCollector,
      streamHasher: config4?.streamHasher ?? blobHasher,
      useDualstackEndpoint: config4?.useDualstackEndpoint ?? (() => Promise.resolve(DEFAULT_USE_DUALSTACK_ENDPOINT)),
      useFipsEndpoint: config4?.useFipsEndpoint ?? (() => Promise.resolve(DEFAULT_USE_FIPS_ENDPOINT))
    };
  }, "getRuntimeConfig");

  // node_modules/@aws-sdk/region-config-resolver/dist-es/extensions/index.js
  var getAwsRegionExtensionConfiguration = /* @__PURE__ */ __name((runtimeConfig) => {
    let runtimeConfigRegion = /* @__PURE__ */ __name(async () => {
      if (runtimeConfig.region === void 0) {
        throw new Error("Region is missing from runtimeConfig");
      }
      const region = runtimeConfig.region;
      if (typeof region === "string") {
        return region;
      }
      return region();
    }, "runtimeConfigRegion");
    return {
      setRegion(region) {
        runtimeConfigRegion = region;
      },
      region() {
        return runtimeConfigRegion;
      }
    };
  }, "getAwsRegionExtensionConfiguration");
  var resolveAwsRegionExtensionConfiguration = /* @__PURE__ */ __name((awsRegionExtensionConfiguration) => {
    return {
      region: awsRegionExtensionConfiguration.region()
    };
  }, "resolveAwsRegionExtensionConfiguration");

  // node_modules/@aws-sdk/client-s3/dist-es/auth/httpAuthExtensionConfiguration.js
  var getHttpAuthExtensionConfiguration = /* @__PURE__ */ __name((runtimeConfig) => {
    const _httpAuthSchemes = runtimeConfig.httpAuthSchemes;
    let _httpAuthSchemeProvider = runtimeConfig.httpAuthSchemeProvider;
    let _credentials = runtimeConfig.credentials;
    return {
      setHttpAuthScheme(httpAuthScheme) {
        const index2 = _httpAuthSchemes.findIndex((scheme) => scheme.schemeId === httpAuthScheme.schemeId);
        if (index2 === -1) {
          _httpAuthSchemes.push(httpAuthScheme);
        } else {
          _httpAuthSchemes.splice(index2, 1, httpAuthScheme);
        }
      },
      httpAuthSchemes() {
        return _httpAuthSchemes;
      },
      setHttpAuthSchemeProvider(httpAuthSchemeProvider) {
        _httpAuthSchemeProvider = httpAuthSchemeProvider;
      },
      httpAuthSchemeProvider() {
        return _httpAuthSchemeProvider;
      },
      setCredentials(credentials) {
        _credentials = credentials;
      },
      credentials() {
        return _credentials;
      }
    };
  }, "getHttpAuthExtensionConfiguration");
  var resolveHttpAuthRuntimeConfig = /* @__PURE__ */ __name((config4) => {
    return {
      httpAuthSchemes: config4.httpAuthSchemes(),
      httpAuthSchemeProvider: config4.httpAuthSchemeProvider(),
      credentials: config4.credentials()
    };
  }, "resolveHttpAuthRuntimeConfig");

  // node_modules/@aws-sdk/client-s3/dist-es/runtimeExtensions.js
  var asPartial = /* @__PURE__ */ __name((t3) => t3, "asPartial");
  var resolveRuntimeExtensions = /* @__PURE__ */ __name((runtimeConfig, extensions) => {
    const extensionConfiguration = {
      ...asPartial(getAwsRegionExtensionConfiguration(runtimeConfig)),
      ...asPartial(getDefaultExtensionConfiguration(runtimeConfig)),
      ...asPartial(getHttpHandlerExtensionConfiguration(runtimeConfig)),
      ...asPartial(getHttpAuthExtensionConfiguration(runtimeConfig))
    };
    extensions.forEach((extension) => extension.configure(extensionConfiguration));
    return {
      ...runtimeConfig,
      ...resolveAwsRegionExtensionConfiguration(extensionConfiguration),
      ...resolveDefaultRuntimeConfig(extensionConfiguration),
      ...resolveHttpHandlerRuntimeConfig(extensionConfiguration),
      ...resolveHttpAuthRuntimeConfig(extensionConfiguration)
    };
  }, "resolveRuntimeExtensions");

  // node_modules/@aws-sdk/client-s3/dist-es/S3Client.js
  var S3Client = class extends Client {
    static {
      __name(this, "S3Client");
    }
    config;
    constructor(...[configuration]) {
      const _config_0 = getRuntimeConfig2(configuration || {});
      const _config_1 = resolveClientEndpointParameters(_config_0);
      const _config_2 = resolveUserAgentConfig(_config_1);
      const _config_3 = resolveFlexibleChecksumsConfig(_config_2);
      const _config_4 = resolveRetryConfig(_config_3);
      const _config_5 = resolveRegionConfig(_config_4);
      const _config_6 = resolveHostHeaderConfig(_config_5);
      const _config_7 = resolveEndpointConfig(_config_6);
      const _config_8 = resolveEventStreamSerdeConfig(_config_7);
      const _config_9 = resolveHttpAuthSchemeConfig(_config_8);
      const _config_10 = resolveS3Config(_config_9, { session: [() => this, CreateSessionCommand] });
      const _config_11 = resolveRuntimeExtensions(_config_10, configuration?.extensions || []);
      super(_config_11);
      this.config = _config_11;
      this.middlewareStack.use(getUserAgentPlugin(this.config));
      this.middlewareStack.use(getRetryPlugin(this.config));
      this.middlewareStack.use(getContentLengthPlugin(this.config));
      this.middlewareStack.use(getHostHeaderPlugin(this.config));
      this.middlewareStack.use(getLoggerPlugin(this.config));
      this.middlewareStack.use(getRecursionDetectionPlugin(this.config));
      this.middlewareStack.use(getHttpAuthSchemeEndpointRuleSetPlugin(this.config, {
        httpAuthSchemeParametersProvider: defaultS3HttpAuthSchemeParametersProvider,
        identityProviderConfigProvider: async (config4) => new DefaultIdentityProviderConfig({
          "aws.auth#sigv4": config4.credentials,
          "aws.auth#sigv4a": config4.credentials
        })
      }));
      this.middlewareStack.use(getHttpSigningPlugin(this.config));
      this.middlewareStack.use(getValidateBucketNamePlugin(this.config));
      this.middlewareStack.use(getAddExpectContinuePlugin(this.config));
      this.middlewareStack.use(getRegionRedirectMiddlewarePlugin(this.config));
      this.middlewareStack.use(getS3ExpressPlugin(this.config));
      this.middlewareStack.use(getS3ExpressHttpSigningPlugin(this.config));
    }
    destroy() {
      super.destroy();
    }
  };

  // node_modules/@aws-sdk/middleware-ssec/dist-es/index.js
  function ssecMiddleware(options) {
    return (next) => async (args) => {
      const input = { ...args.input };
      const properties = [
        {
          target: "SSECustomerKey",
          hash: "SSECustomerKeyMD5"
        },
        {
          target: "CopySourceSSECustomerKey",
          hash: "CopySourceSSECustomerKeyMD5"
        }
      ];
      for (const prop of properties) {
        const value = input[prop.target];
        if (value) {
          let valueForHash;
          if (typeof value === "string") {
            if (isValidBase64EncodedSSECustomerKey(value, options)) {
              valueForHash = options.base64Decoder(value);
            } else {
              valueForHash = options.utf8Decoder(value);
              input[prop.target] = options.base64Encoder(valueForHash);
            }
          } else {
            valueForHash = ArrayBuffer.isView(value) ? new Uint8Array(value.buffer, value.byteOffset, value.byteLength) : new Uint8Array(value);
            input[prop.target] = options.base64Encoder(valueForHash);
          }
          const hash = new options.md5();
          hash.update(valueForHash);
          input[prop.hash] = options.base64Encoder(await hash.digest());
        }
      }
      return next({
        ...args,
        input
      });
    };
  }
  __name(ssecMiddleware, "ssecMiddleware");
  var ssecMiddlewareOptions = {
    name: "ssecMiddleware",
    step: "initialize",
    tags: ["SSE"],
    override: true
  };
  var getSsecPlugin = /* @__PURE__ */ __name((config4) => ({
    applyToStack: (clientStack) => {
      clientStack.add(ssecMiddleware(config4), ssecMiddlewareOptions);
    }
  }), "getSsecPlugin");
  function isValidBase64EncodedSSECustomerKey(str, options) {
    const base64Regex = /^(?:[A-Za-z0-9+/]{4})*([A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/;
    if (!base64Regex.test(str))
      return false;
    try {
      const decodedBytes = options.base64Decoder(str);
      return decodedBytes.length === 32;
    } catch {
      return false;
    }
  }
  __name(isValidBase64EncodedSSECustomerKey, "isValidBase64EncodedSSECustomerKey");

  // node_modules/@aws-sdk/client-s3/dist-es/commands/PutObjectCommand.js
  var PutObjectCommand = class extends Command.classBuilder().ep({
    ...commonParams,
    Bucket: { type: "contextParams", name: "Bucket" },
    Key: { type: "contextParams", name: "Key" }
  }).m(function(Command2, cs2, config4, o3) {
    return [
      getSerdePlugin(config4, this.serialize, this.deserialize),
      getEndpointPlugin(config4, Command2.getEndpointParameterInstructions()),
      getFlexibleChecksumsPlugin(config4, {
        requestAlgorithmMember: { httpHeader: "x-amz-sdk-checksum-algorithm", name: "ChecksumAlgorithm" },
        requestChecksumRequired: false
      }),
      getCheckContentLengthHeaderPlugin(config4),
      getThrow200ExceptionsPlugin(config4),
      getSsecPlugin(config4)
    ];
  }).s("AmazonS3", "PutObject", {}).n("S3Client", "PutObjectCommand").f(PutObjectRequestFilterSensitiveLog, PutObjectOutputFilterSensitiveLog).ser(se_PutObjectCommand).de(de_PutObjectCommand).build() {
    static {
      __name(this, "PutObjectCommand");
    }
  };

  // app/javascript/digital-ocean-uploader.js
  var DigitalOceanUploader = class {
    static {
      __name(this, "DigitalOceanUploader");
    }
    constructor() {
      this.s3Client = new S3Client({
        endpoint: "https://fra1.digitaloceanspaces.com",
        forcePathStyle: false,
        region: "fra1",
        credentials: {
          accessKeyId: window.imageClientId,
          secretAccessKey: window.imageClientSecret
        }
      });
    }
    upload(file) {
      const client = this.s3Client;
      return new Promise(function(resolve, reject) {
        const reader = new FileReader();
        reader.onload = function(e3) {
          (async function() {
            const command = new PutObjectCommand({
              Bucket: window.imageBucketId,
              Key: `rich-text-uploads/${file.name}`,
              Body: reader.result,
              ContentType: file.type,
              ACL: "public-read"
            });
            try {
              const response = await client.send(command);
              resolve(`https://bidders-highway.fra1.digitaloceanspaces.com/rich-text-uploads/${file.name}`);
            } catch (err) {
              console.error("Upload failed");
              reject("failed");
            }
          })();
        };
        reader.readAsArrayBuffer(file);
      });
    }
  };
  var uploader = new DigitalOceanUploader();
  var digital_ocean_uploader_default = uploader;

  // app/javascript/controllers/rich_text_editor_controller.js
  quill_default.register("modules/htmlEditButton", import_quill_html_edit_button.default);
  quill_default.register("modules/imageUploader", quill_imageuploader_default);
  var toolbarOptions = [
    [{ header: [1, 2, 3, false] }],
    ["bold", "italic"],
    [{ "list": "bullet" }, { "list": "ordered" }],
    ["clean"],
    ["image"]
  ];
  var RichTextEditorController = class extends Controller {
    static {
      __name(this, "RichTextEditorController");
    }
    static targets = ["field"];
    connect() {
      const field = this.fieldTarget;
      this.quill = new quill_default(
        this.querySelector(".quill"),
        {
          theme: "snow",
          modules: {
            htmlEditButton: {},
            imageUploader: { upload: digital_ocean_uploader_default.upload.bind(digital_ocean_uploader_default) },
            toolbar: toolbarOptions
          }
        }
      );
      this.quill.on("text-change", (delta, oldDelta, source) => {
        this.fieldTarget.value = this.quill.root.innerHTML;
      });
    }
    disconnect() {
      delete this.quill;
    }
  };

  // app/javascript/controllers/select_all_controller.js
  var SelectAllController = class extends Controller {
    static {
      __name(this, "SelectAllController");
    }
    static targets = ["resource"];
    change(e3) {
      const event = new Event("change");
      this.resourceTargets.forEach((target) => target.checked = e3.target.checked);
      this.resourceTargets[0].dispatchEvent(event);
    }
  };

  // app/javascript/controllers/slugonator_controller.js
  var SlugonatorController = class extends Controller {
    static {
      __name(this, "SlugonatorController");
    }
    static targets = ["slug"];
    onChange(e3) {
      this.slugTarget.value = this.slugonate(e3.target.value);
    }
    slugonate(str) {
      return str.toLowerCase().normalize("NFD").replaceAll(/[\u0300-\u036f]/g, "").replaceAll(/[.,!@#$%^&*()]/g, "").replaceAll(" ", "-");
    }
  };

  // node_modules/@yaireo/tagify/dist/tagify.esm.js
  var t2 = "&#8203;";
  function e2(t3, e3) {
    (null == e3 || e3 > t3.length) && (e3 = t3.length);
    for (var i3 = 0, n3 = new Array(e3); i3 < e3; i3++)
      n3[i3] = t3[i3];
    return n3;
  }
  __name(e2, "e");
  function i2(t3) {
    return function(t4) {
      if (Array.isArray(t4))
        return e2(t4);
    }(t3) || function(t4) {
      if ("undefined" != typeof Symbol && null != t4[Symbol.iterator] || null != t4["@@iterator"])
        return Array.from(t4);
    }(t3) || function(t4, i3) {
      if (!t4)
        return;
      if ("string" == typeof t4)
        return e2(t4, i3);
      var n3 = Object.prototype.toString.call(t4).slice(8, -1);
      "Object" === n3 && t4.constructor && (n3 = t4.constructor.name);
      if ("Map" === n3 || "Set" === n3)
        return Array.from(n3);
      if ("Arguments" === n3 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n3))
        return e2(t4, i3);
    }(t3) || function() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }();
  }
  __name(i2, "i");
  var n2 = { isEnabled: function() {
    var t3;
    return null === (t3 = window.TAGIFY_DEBUG) || void 0 === t3 || t3;
  }, log: function() {
    for (var t3 = arguments.length, e3 = new Array(t3), n3 = 0; n3 < t3; n3++)
      e3[n3] = arguments[n3];
    var s3;
    this.isEnabled() && (s3 = console).log.apply(s3, ["[Tagify]:"].concat(i2(e3)));
  }, warn: function() {
    for (var t3 = arguments.length, e3 = new Array(t3), n3 = 0; n3 < t3; n3++)
      e3[n3] = arguments[n3];
    var s3;
    this.isEnabled() && (s3 = console).warn.apply(s3, ["[Tagify]:"].concat(i2(e3)));
  } };
  var s2 = /* @__PURE__ */ __name(function(t3, e3, i3, n3) {
    return t3 = "" + t3, e3 = "" + e3, n3 && (t3 = t3.trim(), e3 = e3.trim()), i3 ? t3 == e3 : t3.toLowerCase() == e3.toLowerCase();
  }, "s");
  var a2 = /* @__PURE__ */ __name(function(t3, e3) {
    return t3 && Array.isArray(t3) && t3.map(function(t4) {
      return o2(t4, e3);
    });
  }, "a");
  function o2(t3, e3) {
    var i3, n3 = {};
    for (i3 in t3)
      e3.indexOf(i3) < 0 && (n3[i3] = t3[i3]);
    return n3;
  }
  __name(o2, "o");
  function r2(t3) {
    var e3 = document.createElement("div");
    return t3.replace(/\&#?[0-9a-z]+;/gi, function(t4) {
      return e3.innerHTML = t4, e3.innerText;
    });
  }
  __name(r2, "r");
  function l2(t3) {
    return new DOMParser().parseFromString(t3.trim(), "text/html").body.firstElementChild;
  }
  __name(l2, "l");
  function d2(t3, e3) {
    for (e3 = e3 || "previous"; t3 = t3[e3 + "Sibling"]; )
      if (3 == t3.nodeType)
        return t3;
  }
  __name(d2, "d");
  function c2(t3) {
    return "string" == typeof t3 ? t3.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/`|'/g, "&#039;") : t3;
  }
  __name(c2, "c");
  function u2(t3) {
    var e3 = Object.prototype.toString.call(t3).split(" ")[1].slice(0, -1);
    return t3 === Object(t3) && "Array" != e3 && "Function" != e3 && "RegExp" != e3 && "HTMLUnknownElement" != e3;
  }
  __name(u2, "u");
  function g2(t3, e3, i3) {
    var n3, s3;
    function a3(t4, e4) {
      for (var i4 in e4)
        if (e4.hasOwnProperty(i4)) {
          if (u2(e4[i4])) {
            u2(t4[i4]) ? a3(t4[i4], e4[i4]) : t4[i4] = Object.assign({}, e4[i4]);
            continue;
          }
          if (Array.isArray(e4[i4])) {
            t4[i4] = Object.assign([], e4[i4]);
            continue;
          }
          t4[i4] = e4[i4];
        }
    }
    __name(a3, "a");
    return n3 = t3, (null != (s3 = Object) && "undefined" != typeof Symbol && s3[Symbol.hasInstance] ? s3[Symbol.hasInstance](n3) : n3 instanceof s3) || (t3 = {}), a3(t3, e3), i3 && a3(t3, i3), t3;
  }
  __name(g2, "g");
  function h2() {
    var t3 = [], e3 = {}, i3 = true, n3 = false, s3 = void 0;
    try {
      for (var a3, o3 = arguments[Symbol.iterator](); !(i3 = (a3 = o3.next()).done); i3 = true) {
        var r3 = a3.value, l3 = true, d3 = false, c3 = void 0;
        try {
          for (var g3, h3 = r3[Symbol.iterator](); !(l3 = (g3 = h3.next()).done); l3 = true) {
            var p3 = g3.value;
            u2(p3) ? e3[p3.value] || (t3.push(p3), e3[p3.value] = 1) : t3.includes(p3) || t3.push(p3);
          }
        } catch (t4) {
          d3 = true, c3 = t4;
        } finally {
          try {
            l3 || null == h3.return || h3.return();
          } finally {
            if (d3)
              throw c3;
          }
        }
      }
    } catch (t4) {
      n3 = true, s3 = t4;
    } finally {
      try {
        i3 || null == o3.return || o3.return();
      } finally {
        if (n3)
          throw s3;
      }
    }
    return t3;
  }
  __name(h2, "h");
  function p2(t3) {
    return String.prototype.normalize ? "string" == typeof t3 ? t3.normalize("NFD").replace(/[\u0300-\u036f]/g, "") : void 0 : t3;
  }
  __name(p2, "p");
  var f2 = /* @__PURE__ */ __name(function() {
    return /(?=.*chrome)(?=.*android)/i.test(navigator.userAgent);
  }, "f");
  function m2() {
    return ("10000000-1000-4000-8000" + -1e11).replace(/[018]/g, function(t3) {
      return (t3 ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> t3 / 4).toString(16);
    });
  }
  __name(m2, "m");
  function v2(t3) {
    return t3 && t3.classList && t3.classList.contains(this.settings.classNames.tag);
  }
  __name(v2, "v");
  function b2(t3) {
    return t3 && t3.closest(this.settings.classNames.tagSelector);
  }
  __name(b2, "b");
  function w2(t3, e3) {
    var i3 = window.getSelection();
    return e3 = e3 || i3.getRangeAt(0), "string" == typeof t3 && (t3 = document.createTextNode(t3)), e3 && (e3.deleteContents(), e3.insertNode(t3)), t3;
  }
  __name(w2, "w");
  function y2(t3, e3, i3) {
    return t3 ? (e3 && (t3.__tagifyTagData = i3 ? e3 : g2({}, t3.__tagifyTagData || {}, e3)), t3.__tagifyTagData) : (n2.warn("tag element doesn't exist", { tagElm: t3, data: e3 }), e3);
  }
  __name(y2, "y");
  function T2(t3) {
    if (t3 && t3.parentNode) {
      var e3 = t3, i3 = window.getSelection(), n3 = i3.getRangeAt(0);
      i3.rangeCount && (n3.setStartAfter(e3), n3.collapse(true), i3.removeAllRanges(), i3.addRange(n3));
    }
  }
  __name(T2, "T");
  function O2(t3, e3) {
    t3.forEach(function(t4) {
      if (y2(t4.previousSibling) || !t4.previousSibling) {
        var i3 = document.createTextNode("\u200B");
        t4.before(i3), e3 && T2(i3);
      }
    });
  }
  __name(O2, "O");
  var x2 = { delimiters: ",", pattern: null, tagTextProp: "value", maxTags: 1 / 0, callbacks: {}, addTagOnBlur: true, addTagOn: ["blur", "tab", "enter"], onChangeAfterBlur: true, duplicates: false, whitelist: [], blacklist: [], enforceWhitelist: false, userInput: true, focusable: true, keepInvalidTags: false, createInvalidTags: true, mixTagsAllowedAfter: /,|\.|\:|\s/, mixTagsInterpolator: ["[[", "]]"], backspace: true, skipInvalid: false, pasteAsTags: true, editTags: { clicks: 2, keepInvalid: true }, transformTag: function() {
  }, trim: true, a11y: { focusableTags: false }, mixMode: { insertAfterTag: "\xA0" }, autoComplete: { enabled: true, rightKey: false, tabKey: false }, classNames: { namespace: "tagify", mixMode: "tagify--mix", selectMode: "tagify--select", input: "tagify__input", focus: "tagify--focus", tagNoAnimation: "tagify--noAnim", tagInvalid: "tagify--invalid", tagNotAllowed: "tagify--notAllowed", scopeLoading: "tagify--loading", hasMaxTags: "tagify--hasMaxTags", hasNoTags: "tagify--noTags", empty: "tagify--empty", inputInvalid: "tagify__input--invalid", dropdown: "tagify__dropdown", dropdownWrapper: "tagify__dropdown__wrapper", dropdownHeader: "tagify__dropdown__header", dropdownFooter: "tagify__dropdown__footer", dropdownItem: "tagify__dropdown__item", dropdownItemActive: "tagify__dropdown__item--active", dropdownItemHidden: "tagify__dropdown__item--hidden", dropdownInital: "tagify__dropdown--initial", tag: "tagify__tag", tagText: "tagify__tag-text", tagX: "tagify__tag__removeBtn", tagLoading: "tagify__tag--loading", tagEditing: "tagify__tag--editable", tagFlash: "tagify__tag--flash", tagHide: "tagify__tag--hide" }, dropdown: { classname: "", enabled: 2, maxItems: 10, searchKeys: ["value", "searchBy"], fuzzySearch: true, caseSensitive: false, accentedSearch: true, includeSelectedTags: false, escapeHTML: true, highlightFirst: true, closeOnSelect: true, clearOnSelect: true, position: "all", appendTarget: null }, hooks: { beforeRemoveTag: function() {
    return Promise.resolve();
  }, beforePaste: function() {
    return Promise.resolve();
  }, suggestionClick: function() {
    return Promise.resolve();
  }, beforeKeyDown: function() {
    return Promise.resolve();
  } } };
  function D2(t3, e3, i3) {
    return e3 in t3 ? Object.defineProperty(t3, e3, { value: i3, enumerable: true, configurable: true, writable: true }) : t3[e3] = i3, t3;
  }
  __name(D2, "D");
  function S2(t3) {
    for (var e3 = 1; e3 < arguments.length; e3++) {
      var i3 = null != arguments[e3] ? arguments[e3] : {}, n3 = Object.keys(i3);
      "function" == typeof Object.getOwnPropertySymbols && (n3 = n3.concat(Object.getOwnPropertySymbols(i3).filter(function(t4) {
        return Object.getOwnPropertyDescriptor(i3, t4).enumerable;
      }))), n3.forEach(function(e4) {
        D2(t3, e4, i3[e4]);
      });
    }
    return t3;
  }
  __name(S2, "S");
  function I2(t3, e3) {
    return e3 = null != e3 ? e3 : {}, Object.getOwnPropertyDescriptors ? Object.defineProperties(t3, Object.getOwnPropertyDescriptors(e3)) : function(t4, e4) {
      var i3 = Object.keys(t4);
      if (Object.getOwnPropertySymbols) {
        var n3 = Object.getOwnPropertySymbols(t4);
        e4 && (n3 = n3.filter(function(e5) {
          return Object.getOwnPropertyDescriptor(t4, e5).enumerable;
        })), i3.push.apply(i3, n3);
      }
      return i3;
    }(Object(e3)).forEach(function(i3) {
      Object.defineProperty(t3, i3, Object.getOwnPropertyDescriptor(e3, i3));
    }), t3;
  }
  __name(I2, "I");
  function M2(t3, e3) {
    (null == e3 || e3 > t3.length) && (e3 = t3.length);
    for (var i3 = 0, n3 = new Array(e3); i3 < e3; i3++)
      n3[i3] = t3[i3];
    return n3;
  }
  __name(M2, "M");
  function E2(t3, e3, i3) {
    return e3 in t3 ? Object.defineProperty(t3, e3, { value: i3, enumerable: true, configurable: true, writable: true }) : t3[e3] = i3, t3;
  }
  __name(E2, "E");
  function N2(t3) {
    return function(t4) {
      if (Array.isArray(t4))
        return M2(t4);
    }(t3) || function(t4) {
      if ("undefined" != typeof Symbol && null != t4[Symbol.iterator] || null != t4["@@iterator"])
        return Array.from(t4);
    }(t3) || function(t4, e3) {
      if (!t4)
        return;
      if ("string" == typeof t4)
        return M2(t4, e3);
      var i3 = Object.prototype.toString.call(t4).slice(8, -1);
      "Object" === i3 && t4.constructor && (i3 = t4.constructor.name);
      if ("Map" === i3 || "Set" === i3)
        return Array.from(i3);
      if ("Arguments" === i3 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i3))
        return M2(t4, e3);
    }(t3) || function() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }();
  }
  __name(N2, "N");
  function _() {
    for (var t3 in this.dropdown = {}, this._dropdown)
      this.dropdown[t3] = "function" == typeof this._dropdown[t3] ? this._dropdown[t3].bind(this) : this._dropdown[t3];
    this.dropdown.refs(), this.DOM.dropdown.__tagify = this;
  }
  __name(_, "_");
  var A2;
  var C2;
  var k2;
  var L4 = (A2 = function(t3) {
    for (var e3 = 1; e3 < arguments.length; e3++) {
      var i3 = null != arguments[e3] ? arguments[e3] : {}, n3 = Object.keys(i3);
      "function" == typeof Object.getOwnPropertySymbols && (n3 = n3.concat(Object.getOwnPropertySymbols(i3).filter(function(t4) {
        return Object.getOwnPropertyDescriptor(i3, t4).enumerable;
      }))), n3.forEach(function(e4) {
        E2(t3, e4, i3[e4]);
      });
    }
    return t3;
  }({}, { events: { binding: function() {
    var t3 = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0], e3 = this.dropdown.events.callbacks, i3 = this.listeners.dropdown = this.listeners.dropdown || { position: this.dropdown.position.bind(this, null), onKeyDown: e3.onKeyDown.bind(this), onMouseOver: e3.onMouseOver.bind(this), onMouseLeave: e3.onMouseLeave.bind(this), onClick: e3.onClick.bind(this), onScroll: e3.onScroll.bind(this) }, n3 = t3 ? "addEventListener" : "removeEventListener";
    "manual" != this.settings.dropdown.position && (document[n3]("scroll", i3.position, true), window[n3]("resize", i3.position), window[n3]("keydown", i3.onKeyDown)), this.DOM.dropdown[n3]("mouseover", i3.onMouseOver), this.DOM.dropdown[n3]("mouseleave", i3.onMouseLeave), this.DOM.dropdown[n3]("mousedown", i3.onClick), this.DOM.dropdown.content[n3]("scroll", i3.onScroll);
  }, callbacks: { onKeyDown: function(t3) {
    var e3 = this;
    if (this.state.hasFocus && !this.state.composing) {
      var i3 = this.settings, s3 = this.DOM.dropdown.querySelector(i3.classNames.dropdownItemActiveSelector), a3 = this.dropdown.getSuggestionDataByNode(s3), o3 = "mix" == i3.mode, r3 = "select" == i3.mode;
      i3.hooks.beforeKeyDown(t3, { tagify: this }).then(function(l3) {
        switch (t3.key) {
          case "ArrowDown":
          case "ArrowUp":
          case "Down":
          case "Up":
            t3.preventDefault();
            var d3 = e3.dropdown.getAllSuggestionsRefs(), c3 = "ArrowUp" == t3.key || "Up" == t3.key;
            s3 && (s3 = e3.dropdown.getNextOrPrevOption(s3, !c3)), s3 && s3.matches(i3.classNames.dropdownItemSelector) || (s3 = d3[c3 ? d3.length - 1 : 0]), e3.dropdown.highlightOption(s3, true);
            break;
          case "Escape":
          case "Esc":
            e3.dropdown.hide();
            break;
          case "ArrowRight":
            if (e3.state.actions.ArrowLeft)
              return;
          case "Tab":
            var u3 = !i3.autoComplete.rightKey || !i3.autoComplete.tabKey;
            if (!o3 && !r3 && s3 && u3 && !e3.state.editing) {
              t3.preventDefault();
              var g3 = e3.dropdown.getMappedValue(a3);
              return e3.input.autocomplete.set.call(e3, g3), false;
            }
            return true;
          case "Enter":
            t3.preventDefault(), i3.hooks.suggestionClick(t3, { tagify: e3, tagData: a3, suggestionElm: s3 }).then(function() {
              if (s3)
                return e3.dropdown.selectOption(s3), s3 = e3.dropdown.getNextOrPrevOption(s3, !c3), void e3.dropdown.highlightOption(s3);
              e3.dropdown.hide(), o3 || e3.addTags(e3.state.inputText.trim(), true);
            }).catch(function(t4) {
              return n2.warn(t4);
            });
            break;
          case "Backspace":
            if (o3 || e3.state.editing.scope)
              return;
            var h3 = e3.input.raw.call(e3);
            "" != h3 && 8203 != h3.charCodeAt(0) || (true === i3.backspace ? e3.removeTags() : "edit" == i3.backspace && setTimeout(e3.editTag.bind(e3), 0));
        }
      });
    }
  }, onMouseOver: function(t3) {
    var e3 = t3.target.closest(this.settings.classNames.dropdownItemSelector);
    this.dropdown.highlightOption(e3);
  }, onMouseLeave: function(t3) {
    this.dropdown.highlightOption();
  }, onClick: function(t3) {
    var e3 = this;
    if (0 == t3.button && t3.target != this.DOM.dropdown && t3.target != this.DOM.dropdown.content) {
      var i3 = t3.target.closest(this.settings.classNames.dropdownItemSelector), s3 = this.dropdown.getSuggestionDataByNode(i3);
      this.state.actions.selectOption = true, setTimeout(function() {
        return e3.state.actions.selectOption = false;
      }, 50), this.settings.hooks.suggestionClick(t3, { tagify: this, tagData: s3, suggestionElm: i3 }).then(function() {
        i3 ? e3.dropdown.selectOption(i3, t3) : e3.dropdown.hide();
      }).catch(function(t4) {
        return n2.warn(t4);
      });
    }
  }, onScroll: function(t3) {
    var e3 = t3.target, i3 = e3.scrollTop / (e3.scrollHeight - e3.parentNode.clientHeight) * 100;
    this.trigger("dropdown:scroll", { percentage: Math.round(i3) });
  } } }, refilter: function(t3) {
    t3 = t3 || this.state.dropdown.query || "", this.suggestedListItems = this.dropdown.filterListItems(t3), this.dropdown.fill(), this.suggestedListItems.length || this.dropdown.hide(), this.trigger("dropdown:updated", this.DOM.dropdown);
  }, getSuggestionDataByNode: function(t3) {
    var e3 = t3 && t3.getAttribute("value");
    return this.suggestedListItems.find(function(t4) {
      return t4.value == e3;
    }) || null;
  }, getNextOrPrevOption: function(t3) {
    var e3 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], i3 = this.dropdown.getAllSuggestionsRefs(), n3 = i3.findIndex(function(e4) {
      return e4 === t3;
    });
    return e3 ? i3[n3 + 1] : i3[n3 - 1];
  }, highlightOption: function(t3, e3) {
    var i3, n3 = this.settings.classNames.dropdownItemActive;
    if (this.state.ddItemElm && (this.state.ddItemElm.classList.remove(n3), this.state.ddItemElm.removeAttribute("aria-selected")), !t3)
      return this.state.ddItemData = null, this.state.ddItemElm = null, void this.input.autocomplete.suggest.call(this);
    i3 = this.dropdown.getSuggestionDataByNode(t3), this.state.ddItemData = i3, this.state.ddItemElm = t3, t3.classList.add(n3), t3.setAttribute("aria-selected", true), e3 && (t3.parentNode.scrollTop = t3.clientHeight + t3.offsetTop - t3.parentNode.clientHeight), this.settings.autoComplete && (this.input.autocomplete.suggest.call(this, i3), this.dropdown.position());
  }, selectOption: function(t3, e3) {
    var i3 = this, n3 = this.settings, s3 = n3.dropdown, a3 = s3.clearOnSelect, o3 = s3.closeOnSelect;
    if (!t3)
      return this.addTags(this.state.inputText, true), void (o3 && this.dropdown.hide());
    e3 = e3 || {};
    var r3 = t3.getAttribute("value"), l3 = "noMatch" == r3, d3 = "mix" == n3.mode, c3 = this.suggestedListItems.find(function(t4) {
      var e4;
      return (null !== (e4 = t4.value) && void 0 !== e4 ? e4 : t4) == r3;
    });
    if (this.trigger("dropdown:select", { data: c3, elm: t3, event: e3 }), r3 && (c3 || l3)) {
      if (this.state.editing) {
        var u3 = this.normalizeTags([c3])[0];
        c3 = n3.transformTag.call(this, u3) || u3, this.onEditTagDone(null, g2({ __isValid: true }, c3));
      } else
        this[d3 ? "addMixTags" : "addTags"]([c3 || this.input.raw.call(this)], a3);
      (d3 || this.DOM.input.parentNode) && (setTimeout(function() {
        i3.DOM.input.focus(), i3.toggleFocusClass(true);
      }), o3 && setTimeout(this.dropdown.hide.bind(this)), t3.addEventListener("transitionend", function() {
        i3.dropdown.fillHeaderFooter(), setTimeout(function() {
          t3.remove(), i3.dropdown.refilter();
        }, 100);
      }, { once: true }), t3.classList.add(this.settings.classNames.dropdownItemHidden));
    } else
      o3 && setTimeout(this.dropdown.hide.bind(this));
  }, selectAll: function(t3) {
    this.suggestedListItems.length = 0, this.dropdown.hide(), this.dropdown.filterListItems("");
    var e3 = this.dropdown.filterListItems("");
    return t3 || (e3 = this.state.dropdown.suggestions), this.addTags(e3, true), this;
  }, filterListItems: function(t3, e3) {
    var i3, n3, s3, a3, o3, r3, l3 = /* @__PURE__ */ __name(function() {
      var t4, l4, d4 = void 0, c4 = void 0;
      t4 = m3[w3], n3 = (null != (l4 = Object) && "undefined" != typeof Symbol && l4[Symbol.hasInstance] ? l4[Symbol.hasInstance](t4) : t4 instanceof l4) ? m3[w3] : { value: m3[w3] };
      var v5, y3 = !Object.keys(n3).some(function(t5) {
        return b3.includes(t5);
      }) ? ["value"] : b3;
      g3.fuzzySearch && !e3.exact ? (a3 = y3.reduce(function(t5, e4) {
        return t5 + " " + (n3[e4] || "");
      }, "").toLowerCase().trim(), g3.accentedSearch && (a3 = p2(a3), r3 = p2(r3)), d4 = 0 == a3.indexOf(r3), c4 = a3 === r3, v5 = a3, s3 = r3.toLowerCase().split(" ").every(function(t5) {
        return v5.includes(t5.toLowerCase());
      })) : (d4 = true, s3 = y3.some(function(t5) {
        var i4 = "" + (n3[t5] || "");
        return g3.accentedSearch && (i4 = p2(i4), r3 = p2(r3)), g3.caseSensitive || (i4 = i4.toLowerCase()), c4 = i4 === r3, e3.exact ? i4 === r3 : 0 == i4.indexOf(r3);
      })), o3 = !g3.includeSelectedTags && i3.isTagDuplicate(u2(n3) ? n3.value : n3), s3 && !o3 && (c4 && d4 ? f3.push(n3) : "startsWith" == g3.sortby && d4 ? h3.unshift(n3) : h3.push(n3));
    }, "l"), d3 = this, c3 = this.settings, g3 = c3.dropdown, h3 = (e3 = e3 || {}, []), f3 = [], m3 = c3.whitelist, v3 = g3.maxItems >= 0 ? g3.maxItems : 1 / 0, b3 = g3.searchKeys, w3 = 0;
    if (!(t3 = "select" == c3.mode && this.value.length && this.value[0][c3.tagTextProp] == t3 ? "" : t3) || !b3.length)
      return h3 = g3.includeSelectedTags ? m3 : m3.filter(function(t4) {
        return !d3.isTagDuplicate(u2(t4) ? t4.value : t4);
      }), this.state.dropdown.suggestions = h3, h3.slice(0, v3);
    for (r3 = g3.caseSensitive ? "" + t3 : ("" + t3).toLowerCase(); w3 < m3.length; w3++)
      i3 = this, l3();
    return this.state.dropdown.suggestions = f3.concat(h3), "function" == typeof g3.sortby ? g3.sortby(f3.concat(h3), r3) : f3.concat(h3).slice(0, v3);
  }, getMappedValue: function(t3) {
    var e3 = this.settings.dropdown.mapValueTo;
    return e3 ? "function" == typeof e3 ? e3(t3) : t3[e3] || t3.value : t3.value;
  }, createListHTML: function(t3) {
    var e3 = this;
    return g2([], t3).map(function(t4, i3) {
      "string" != typeof t4 && "number" != typeof t4 || (t4 = { value: t4 });
      var n3 = e3.dropdown.getMappedValue(t4);
      return n3 = "string" == typeof n3 && e3.settings.dropdown.escapeHTML ? c2(n3) : n3, e3.settings.templates.dropdownItem.apply(e3, [I2(S2({}, t4), { mappedValue: n3 }), e3]);
    }).join("");
  } }), C2 = null != (C2 = { refs: function() {
    this.DOM.dropdown = this.parseTemplate("dropdown", [this.settings]), this.DOM.dropdown.content = this.DOM.dropdown.querySelector("[data-selector='tagify-suggestions-wrapper']");
  }, getHeaderRef: function() {
    return this.DOM.dropdown.querySelector("[data-selector='tagify-suggestions-header']");
  }, getFooterRef: function() {
    return this.DOM.dropdown.querySelector("[data-selector='tagify-suggestions-footer']");
  }, getAllSuggestionsRefs: function() {
    return N2(this.DOM.dropdown.content.querySelectorAll(this.settings.classNames.dropdownItemSelector));
  }, show: function(t3) {
    var e3, i3, n3, a3 = this, o3 = this.settings, r3 = "mix" == o3.mode && !o3.enforceWhitelist, l3 = !o3.whitelist || !o3.whitelist.length, d3 = "manual" == o3.dropdown.position;
    if (t3 = void 0 === t3 ? this.state.inputText : t3, !(l3 && !r3 && !o3.templates.dropdownItemNoMatch || false === o3.dropdown.enable || this.state.isLoading || this.settings.readonly)) {
      if (clearTimeout(this.dropdownHide__bindEventsTimeout), this.suggestedListItems = this.dropdown.filterListItems(t3), t3 && !this.suggestedListItems.length && (this.trigger("dropdown:noMatch", t3), o3.templates.dropdownItemNoMatch && (n3 = o3.templates.dropdownItemNoMatch.call(this, { value: t3 }))), !n3) {
        if (this.suggestedListItems.length)
          t3 && r3 && !this.state.editing.scope && !s2(this.suggestedListItems[0].value, t3) && this.suggestedListItems.unshift({ value: t3 });
        else {
          if (!t3 || !r3 || this.state.editing.scope)
            return this.input.autocomplete.suggest.call(this), void this.dropdown.hide();
          this.suggestedListItems = [{ value: t3 }];
        }
        i3 = "" + (u2(e3 = this.suggestedListItems[0]) ? e3.value : e3), o3.autoComplete && i3 && 0 == i3.indexOf(t3) && this.input.autocomplete.suggest.call(this, e3);
      }
      this.dropdown.fill(n3), o3.dropdown.highlightFirst && this.dropdown.highlightOption(this.DOM.dropdown.content.querySelector(o3.classNames.dropdownItemSelector)), this.state.dropdown.visible || setTimeout(this.dropdown.events.binding.bind(this)), this.state.dropdown.visible = t3 || true, this.state.dropdown.query = t3, this.setStateSelection(), d3 || setTimeout(function() {
        a3.dropdown.position(), a3.dropdown.render();
      }), setTimeout(function() {
        a3.trigger("dropdown:show", a3.DOM.dropdown);
      });
    }
  }, hide: function(t3) {
    var e3 = this, i3 = this.DOM, n3 = i3.scope, s3 = i3.dropdown, a3 = "manual" == this.settings.dropdown.position && !t3;
    if (s3 && document.body.contains(s3) && !a3)
      return window.removeEventListener("resize", this.dropdown.position), this.dropdown.events.binding.call(this, false), n3.setAttribute("aria-expanded", false), s3.parentNode.removeChild(s3), setTimeout(function() {
        e3.state.dropdown.visible = false;
      }, 100), this.state.dropdown.query = this.state.ddItemData = this.state.ddItemElm = this.state.selection = null, this.state.tag && this.state.tag.value.length && (this.state.flaggedTags[this.state.tag.baseOffset] = this.state.tag), this.trigger("dropdown:hide", s3), this;
  }, toggle: function(t3) {
    this.dropdown[this.state.dropdown.visible && !t3 ? "hide" : "show"]();
  }, getAppendTarget: function() {
    var t3 = this.settings.dropdown;
    return "function" == typeof t3.appendTarget ? t3.appendTarget() : t3.appendTarget;
  }, render: function() {
    var t3, e3, i3, n3 = this, s3 = (t3 = this.DOM.dropdown, (i3 = t3.cloneNode(true)).style.cssText = "position:fixed; top:-9999px; opacity:0", document.body.appendChild(i3), e3 = i3.clientHeight, i3.parentNode.removeChild(i3), e3), a3 = this.settings, o3 = "number" == typeof a3.dropdown.enabled && a3.dropdown.enabled >= 0, r3 = this.dropdown.getAppendTarget();
    return o3 ? (this.DOM.scope.setAttribute("aria-expanded", true), document.body.contains(this.DOM.dropdown) || (this.DOM.dropdown.classList.add(a3.classNames.dropdownInital), this.dropdown.position(s3), r3.appendChild(this.DOM.dropdown), setTimeout(function() {
      return n3.DOM.dropdown.classList.remove(a3.classNames.dropdownInital);
    })), this) : this;
  }, fill: function(t3) {
    t3 = "string" == typeof t3 ? t3 : this.dropdown.createListHTML(t3 || this.suggestedListItems);
    var e3, i3 = this.settings.templates.dropdownContent.call(this, t3);
    this.DOM.dropdown.content.innerHTML = (e3 = i3) ? e3.replace(/\>[\r\n ]+\</g, "><").split(/>\s+</).join("><").trim() : "";
  }, fillHeaderFooter: function() {
    var t3 = this.dropdown.filterListItems(this.state.dropdown.query), e3 = this.parseTemplate("dropdownHeader", [t3]), i3 = this.parseTemplate("dropdownFooter", [t3]), n3 = this.dropdown.getHeaderRef(), s3 = this.dropdown.getFooterRef();
    e3 && (null == n3 || n3.parentNode.replaceChild(e3, n3)), i3 && (null == s3 || s3.parentNode.replaceChild(i3, s3));
  }, position: function(t3) {
    var e3 = this.settings.dropdown, i3 = this.dropdown.getAppendTarget();
    if ("manual" != e3.position && i3) {
      var n3, s3, a3, o3, r3, l3, d3, c3, u3, g3 = this.DOM.dropdown, h3 = e3.RTL, p3 = i3 === document.body, f3 = i3 === this.DOM.scope, m3 = p3 ? window.pageYOffset : i3.scrollTop, v3 = document.fullscreenElement || document.webkitFullscreenElement || document.documentElement, b3 = v3.clientHeight, w3 = Math.max(v3.clientWidth || 0, window.innerWidth || 0) > 480 ? e3.position : "all", y3 = this.DOM["input" == w3 ? "input" : "scope"];
      if (t3 = t3 || g3.clientHeight, this.state.dropdown.visible) {
        if ("text" == w3 ? (a3 = (n3 = function() {
          var t4 = document.getSelection();
          if (t4.rangeCount) {
            var e4, i4, n4 = t4.getRangeAt(0), s4 = n4.startContainer, a4 = n4.startOffset;
            if (a4 > 0)
              return (i4 = document.createRange()).setStart(s4, a4 - 1), i4.setEnd(s4, a4), { left: (e4 = i4.getBoundingClientRect()).right, top: e4.top, bottom: e4.bottom };
            if (s4.getBoundingClientRect)
              return s4.getBoundingClientRect();
          }
          return { left: -9999, top: -9999 };
        }()).bottom, s3 = n3.top, o3 = n3.left, r3 = "auto") : (l3 = function(t4) {
          var e4 = 0, i4 = 0;
          for (t4 = t4.parentNode; t4 && t4 != v3; )
            e4 += t4.offsetTop || 0, i4 += t4.offsetLeft || 0, t4 = t4.parentNode;
          return { top: e4, left: i4 };
        }(i3), n3 = y3.getBoundingClientRect(), s3 = f3 ? -1 : n3.top - l3.top, a3 = (f3 ? n3.height : n3.bottom - l3.top) - 1, o3 = f3 ? -1 : n3.left - l3.left, r3 = n3.width + "px"), !p3) {
          var T3 = function() {
            for (var t4 = 0, i4 = e3.appendTarget.parentNode; i4; )
              t4 += i4.scrollTop || 0, i4 = i4.parentNode;
            return t4;
          }();
          s3 += T3, a3 += T3;
        }
        var O3;
        s3 = Math.floor(s3), a3 = Math.ceil(a3), c3 = ((d3 = null !== (O3 = e3.placeAbove) && void 0 !== O3 ? O3 : b3 - n3.bottom < t3) ? s3 : a3) + m3, u3 = "left: ".concat(o3 + (h3 && n3.width || 0) + window.pageXOffset, "px;"), g3.style.cssText = "".concat(u3, "; top: ").concat(c3, "px; min-width: ").concat(r3, "; max-width: ").concat(r3), g3.setAttribute("placement", d3 ? "top" : "bottom"), g3.setAttribute("position", w3);
      }
    }
  } }) ? C2 : {}, Object.getOwnPropertyDescriptors ? Object.defineProperties(A2, Object.getOwnPropertyDescriptors(C2)) : function(t3, e3) {
    var i3 = Object.keys(t3);
    if (Object.getOwnPropertySymbols) {
      var n3 = Object.getOwnPropertySymbols(t3);
      e3 && (n3 = n3.filter(function(e4) {
        return Object.getOwnPropertyDescriptor(t3, e4).enumerable;
      })), i3.push.apply(i3, n3);
    }
    return i3;
  }(Object(C2)).forEach(function(t3) {
    Object.defineProperty(A2, t3, Object.getOwnPropertyDescriptor(C2, t3));
  }), A2);
  var j2 = "@yaireo/tagify/";
  var P2 = { empty: "empty", exceed: "number of tags exceeded", pattern: "pattern mismatch", duplicate: "already exists", notAllowed: "not allowed" };
  var V2 = { wrapper: function(e3, i3) {
    return '<tags class="'.concat(i3.classNames.namespace, " ").concat(i3.mode ? "".concat(i3.classNames[i3.mode + "Mode"]) : "", " ").concat(e3.className, '"\n                    ').concat(i3.readonly ? "readonly" : "", "\n                    ").concat(i3.disabled ? "disabled" : "", "\n                    ").concat(i3.required ? "required" : "", "\n                    ").concat("select" === i3.mode ? "spellcheck='false'" : "", '\n                    tabIndex="-1">\n                    ').concat(this.settings.templates.input.call(this), "\n                ").concat(t2, "\n        </tags>");
  }, input: function() {
    var e3 = this.settings, i3 = e3.placeholder || t2;
    return "<span ".concat(!e3.readonly && e3.userInput ? "contenteditable" : "", ' tabIndex="0" data-placeholder="').concat(i3, '" aria-placeholder="').concat(e3.placeholder || "", '"\n                    class="').concat(e3.classNames.input, '"\n                    role="textbox"\n                    aria-autocomplete="both"\n                    aria-multiline="').concat("mix" == e3.mode, '"></span>');
  }, tag: function(t3, e3) {
    var i3 = e3.settings;
    return '<tag title="'.concat(t3.title || t3.value, `"
                    contenteditable='false'
                    spellcheck='false'
                    tabIndex="`).concat(i3.a11y.focusableTags ? 0 : -1, '"\n                    class="').concat(i3.classNames.tag, " ").concat(t3.class || "", '"\n                    ').concat(this.getAttributes(t3), `>
            <x title='' tabIndex="`).concat(i3.a11y.focusableTags ? 0 : -1, '" class="').concat(i3.classNames.tagX, `" role='button' aria-label='remove tag'></x>
            <div>
                <span `).concat("select" === i3.mode && i3.userInput ? "contenteditable='true'" : "", ' class="').concat(i3.classNames.tagText, '">').concat(t3[i3.tagTextProp] || t3.value, "</span>\n            </div>\n        </tag>");
  }, dropdown: function(t3) {
    var e3 = t3.dropdown, i3 = "manual" == e3.position;
    return '<div class="'.concat(i3 ? "" : t3.classNames.dropdown, " ").concat(e3.classname, '" role="listbox" aria-labelledby="dropdown" dir="').concat(e3.RTL ? "rtl" : "", `">
                    <div data-selector='tagify-suggestions-wrapper' class="`).concat(t3.classNames.dropdownWrapper, '"></div>\n                </div>');
  }, dropdownContent: function(t3) {
    var e3 = this.settings.templates, i3 = this.state.dropdown.suggestions;
    return "\n            ".concat(e3.dropdownHeader.call(this, i3), "\n            ").concat(t3, "\n            ").concat(e3.dropdownFooter.call(this, i3), "\n        ");
  }, dropdownItem: function(t3) {
    return "<div ".concat(this.getAttributes(t3), "\n                    class='").concat(this.settings.classNames.dropdownItem, " ").concat(t3.class || "", `'
                    tabindex="0"
                    role="option">`).concat(t3.mappedValue || t3.value, "</div>");
  }, dropdownHeader: function(t3) {
    return `<header data-selector='tagify-suggestions-header' class="`.concat(this.settings.classNames.dropdownHeader, '"></header>');
  }, dropdownFooter: function(t3) {
    var e3 = t3.length - this.settings.dropdown.maxItems;
    return e3 > 0 ? `<footer data-selector='tagify-suggestions-footer' class="`.concat(this.settings.classNames.dropdownFooter, '">\n                ').concat(e3, " more items. Refine your search.\n            </footer>") : "";
  }, dropdownItemNoMatch: null };
  function F2(t3, e3) {
    (null == e3 || e3 > t3.length) && (e3 = t3.length);
    for (var i3 = 0, n3 = new Array(e3); i3 < e3; i3++)
      n3[i3] = t3[i3];
    return n3;
  }
  __name(F2, "F");
  function R2(t3, e3) {
    return null != e3 && "undefined" != typeof Symbol && e3[Symbol.hasInstance] ? !!e3[Symbol.hasInstance](t3) : t3 instanceof e3;
  }
  __name(R2, "R");
  function H2(t3, e3) {
    return function(t4) {
      if (Array.isArray(t4))
        return t4;
    }(t3) || function(t4, e4) {
      var i3 = null == t4 ? null : "undefined" != typeof Symbol && t4[Symbol.iterator] || t4["@@iterator"];
      if (null != i3) {
        var n3, s3, a3 = [], o3 = true, r3 = false;
        try {
          for (i3 = i3.call(t4); !(o3 = (n3 = i3.next()).done) && (a3.push(n3.value), !e4 || a3.length !== e4); o3 = true)
            ;
        } catch (t5) {
          r3 = true, s3 = t5;
        } finally {
          try {
            o3 || null == i3.return || i3.return();
          } finally {
            if (r3)
              throw s3;
          }
        }
        return a3;
      }
    }(t3, e3) || function(t4, e4) {
      if (!t4)
        return;
      if ("string" == typeof t4)
        return F2(t4, e4);
      var i3 = Object.prototype.toString.call(t4).slice(8, -1);
      "Object" === i3 && t4.constructor && (i3 = t4.constructor.name);
      if ("Map" === i3 || "Set" === i3)
        return Array.from(i3);
      if ("Arguments" === i3 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i3))
        return F2(t4, e4);
    }(t3, e3) || function() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }();
  }
  __name(H2, "H");
  function B2(t3, e3) {
    (null == e3 || e3 > t3.length) && (e3 = t3.length);
    for (var i3 = 0, n3 = new Array(e3); i3 < e3; i3++)
      n3[i3] = t3[i3];
    return n3;
  }
  __name(B2, "B");
  function W2(t3, e3, i3) {
    return e3 in t3 ? Object.defineProperty(t3, e3, { value: i3, enumerable: true, configurable: true, writable: true }) : t3[e3] = i3, t3;
  }
  __name(W2, "W");
  function U2(t3, e3) {
    return null != e3 && "undefined" != typeof Symbol && e3[Symbol.hasInstance] ? !!e3[Symbol.hasInstance](t3) : t3 instanceof e3;
  }
  __name(U2, "U");
  function q2(t3, e3) {
    return e3 = null != e3 ? e3 : {}, Object.getOwnPropertyDescriptors ? Object.defineProperties(t3, Object.getOwnPropertyDescriptors(e3)) : function(t4, e4) {
      var i3 = Object.keys(t4);
      if (Object.getOwnPropertySymbols) {
        var n3 = Object.getOwnPropertySymbols(t4);
        e4 && (n3 = n3.filter(function(e5) {
          return Object.getOwnPropertyDescriptor(t4, e5).enumerable;
        })), i3.push.apply(i3, n3);
      }
      return i3;
    }(Object(e3)).forEach(function(i3) {
      Object.defineProperty(t3, i3, Object.getOwnPropertyDescriptor(e3, i3));
    }), t3;
  }
  __name(q2, "q");
  function K2(t3) {
    return function(t4) {
      if (Array.isArray(t4))
        return B2(t4);
    }(t3) || function(t4) {
      if ("undefined" != typeof Symbol && null != t4[Symbol.iterator] || null != t4["@@iterator"])
        return Array.from(t4);
    }(t3) || function(t4, e3) {
      if (!t4)
        return;
      if ("string" == typeof t4)
        return B2(t4, e3);
      var i3 = Object.prototype.toString.call(t4).slice(8, -1);
      "Object" === i3 && t4.constructor && (i3 = t4.constructor.name);
      if ("Map" === i3 || "Set" === i3)
        return Array.from(i3);
      if ("Arguments" === i3 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i3))
        return B2(t4, e3);
    }(t3) || function() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }();
  }
  __name(K2, "K");
  var z2 = { customBinding: function() {
    var t3 = this;
    this.customEventsList.forEach(function(e3) {
      t3.on(e3, t3.settings.callbacks[e3]);
    });
  }, binding: function() {
    var t3, e3 = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0], i3 = this.settings, n3 = this.events.callbacks, s3 = e3 ? "addEventListener" : "removeEventListener";
    if (!this.state.mainEvents || !e3) {
      for (var a3 in this.state.mainEvents = e3, e3 && !this.listeners.main && (this.events.bindGlobal.call(this), this.settings.isJQueryPlugin && jQuery(this.DOM.originalInput).on("tagify.removeAllTags", this.removeAllTags.bind(this))), t3 = this.listeners.main = this.listeners.main || { keydown: ["input", n3.onKeydown.bind(this)], click: ["scope", n3.onClickScope.bind(this)], dblclick: "select" != i3.mode && ["scope", n3.onDoubleClickScope.bind(this)], paste: ["input", n3.onPaste.bind(this)], drop: ["input", n3.onDrop.bind(this)], compositionstart: ["input", n3.onCompositionStart.bind(this)], compositionend: ["input", n3.onCompositionEnd.bind(this)] })
        t3[a3] && this.DOM[t3[a3][0]][s3](a3, t3[a3][1]);
      var o3 = this.listeners.main.inputMutationObserver || new MutationObserver(n3.onInputDOMChange.bind(this));
      o3.disconnect(), "mix" == i3.mode && o3.observe(this.DOM.input, { childList: true }), this.events.bindOriginaInputListener.call(this);
    }
  }, bindOriginaInputListener: function(t3) {
    var e3 = (t3 || 0) + 500;
    this.listeners.main && (clearInterval(this.listeners.main.originalInputValueObserverInterval), this.listeners.main.originalInputValueObserverInterval = setInterval(this.events.callbacks.observeOriginalInputValue.bind(this), e3));
  }, bindGlobal: function(t3) {
    var e3, i3 = this.events.callbacks, n3 = t3 ? "removeEventListener" : "addEventListener";
    if (this.listeners && (t3 || !this.listeners.global)) {
      this.listeners.global = this.listeners.global || [{ type: this.isIE ? "keydown" : "input", target: this.DOM.input, cb: i3[this.isIE ? "onInputIE" : "onInput"].bind(this) }, { type: "keydown", target: window, cb: i3.onWindowKeyDown.bind(this) }, { type: "focusin", target: this.DOM.scope, cb: i3.onFocusBlur.bind(this) }, { type: "focusout", target: this.DOM.scope, cb: i3.onFocusBlur.bind(this) }, { type: "click", target: document, cb: i3.onClickAnywhere.bind(this), useCapture: true }];
      var s3 = true, a3 = false, o3 = void 0;
      try {
        for (var r3, l3 = this.listeners.global[Symbol.iterator](); !(s3 = (r3 = l3.next()).done); s3 = true)
          (e3 = r3.value).target[n3](e3.type, e3.cb, !!e3.useCapture);
      } catch (t4) {
        a3 = true, o3 = t4;
      } finally {
        try {
          s3 || null == l3.return || l3.return();
        } finally {
          if (a3)
            throw o3;
        }
      }
    }
  }, unbindGlobal: function() {
    this.events.bindGlobal.call(this, true);
  }, callbacks: { onFocusBlur: function(t3) {
    var e3, i3, n3, s3 = b2.call(this, t3.target), a3 = v2.call(this, t3.target), o3 = "focusin" == t3.type, r3 = "focusout" == t3.type;
    null === (e3 = t3.target) || void 0 === e3 || e3.closest(this.settings.classNames.tagTextSelector), s3 && o3 && !a3 && this.toggleFocusClass(this.state.hasFocus = +/* @__PURE__ */ new Date());
    var l3 = this.settings, d3 = t3.target ? this.trim(this.DOM.input.textContent) : "", c3 = null === (n3 = this.value) || void 0 === n3 || null === (i3 = n3[0]) || void 0 === i3 ? void 0 : i3[l3.tagTextProp], u3 = l3.dropdown.enabled >= 0, g3 = { relatedTarget: t3.relatedTarget }, h3 = this.state.actions.selectOption && (u3 || !l3.dropdown.closeOnSelect), p3 = this.state.actions.addNew && u3;
    if (r3) {
      if (t3.relatedTarget === this.DOM.scope)
        return this.dropdown.hide(), void this.DOM.input.focus();
      this.postUpdate();
    }
    if (!h3 && !p3)
      if (o3 || s3 ? (this.state.hasFocus = +/* @__PURE__ */ new Date(), this.toggleFocusClass(this.state.hasFocus)) : this.state.hasFocus = false, "mix" != l3.mode) {
        if (o3) {
          if (!l3.focusable)
            return;
          var f3 = 0 === l3.dropdown.enabled && !this.state.dropdown.visible;
          return this.toggleFocusClass(true), this.trigger("focus", g3), void (!f3 || a3 && "select" !== l3.mode || this.dropdown.show(this.value.length ? "" : void 0));
        }
        if (r3) {
          if (this.trigger("blur", g3), this.loading(false), "select" == l3.mode) {
            if (this.value.length) {
              var m3 = this.getTagElms()[0];
              d3 = this.trim(m3.textContent);
            }
            c3 === d3 && (d3 = "");
          }
          d3 && !this.state.actions.selectOption && l3.addTagOnBlur && l3.addTagOn.includes("blur") && this.addTags(d3, true);
        }
        s3 || (this.DOM.input.removeAttribute("style"), this.dropdown.hide());
      } else
        o3 ? this.trigger("focus", g3) : r3 && (this.trigger("blur", g3), this.loading(false), this.dropdown.hide(), this.state.dropdown.visible = void 0, this.setStateSelection());
  }, onCompositionStart: function(t3) {
    this.state.composing = true;
  }, onCompositionEnd: function(t3) {
    this.state.composing = false;
  }, onWindowKeyDown: function(t3) {
    var e3, i3 = this.settings, n3 = document.activeElement, s3 = b2.call(this, n3) && this.DOM.scope.contains(document.activeElement), a3 = s3 && n3.hasAttribute("readonly");
    if (this.state.hasFocus || s3 && !a3) {
      e3 = n3.nextElementSibling;
      var o3 = t3.target.classList.contains(i3.classNames.tagX);
      switch (t3.key) {
        case "Backspace":
          i3.readonly || this.state.editing || (this.removeTags(n3), (e3 || this.DOM.input).focus());
          break;
        case "Enter":
          if (o3)
            return void this.removeTags(t3.target.parentNode);
          i3.a11y.focusableTags && v2.call(this, n3) && setTimeout(this.editTag.bind(this), 0, n3);
          break;
        case "ArrowDown":
          this.state.dropdown.visible || "mix" == i3.mode || this.dropdown.show();
      }
    }
  }, onKeydown: function(t3) {
    var e3 = this, i3 = this.settings;
    if (!this.state.composing && i3.userInput) {
      "select" == i3.mode && i3.enforceWhitelist && this.value.length && "Tab" != t3.key && t3.preventDefault();
      var n3 = this.trim(t3.target.textContent);
      this.trigger("keydown", { event: t3 }), i3.hooks.beforeKeyDown(t3, { tagify: this }).then(function(s3) {
        if ("mix" == i3.mode) {
          switch (t3.key) {
            case "Left":
            case "ArrowLeft":
              e3.state.actions.ArrowLeft = true;
              break;
            case "Delete":
            case "Backspace":
              if (e3.state.editing)
                return;
              var a3 = document.getSelection(), o3 = "Delete" == t3.key && a3.anchorOffset == (a3.anchorNode.length || 0), l3 = a3.anchorNode.previousSibling, c3 = 1 == a3.anchorNode.nodeType || !a3.anchorOffset && l3 && 1 == l3.nodeType && a3.anchorNode.previousSibling;
              r2(e3.DOM.input.innerHTML);
              var u3, g3, h3, p3 = e3.getTagElms(), m3 = 1 === a3.anchorNode.length && a3.anchorNode.nodeValue == String.fromCharCode(8203);
              if ("edit" == i3.backspace && c3)
                return u3 = 1 == a3.anchorNode.nodeType ? null : a3.anchorNode.previousElementSibling, setTimeout(e3.editTag.bind(e3), 0, u3), void t3.preventDefault();
              if (f2() && U2(c3, Element))
                return h3 = d2(c3), c3.hasAttribute("readonly") || c3.remove(), e3.DOM.input.focus(), void setTimeout(function() {
                  T2(h3), e3.DOM.input.click();
                });
              if ("BR" == a3.anchorNode.nodeName)
                return;
              if ((o3 || c3) && 1 == a3.anchorNode.nodeType ? g3 = 0 == a3.anchorOffset ? o3 ? p3[0] : null : p3[Math.min(p3.length, a3.anchorOffset) - 1] : o3 ? g3 = a3.anchorNode.nextElementSibling : U2(c3, Element) && (g3 = c3), 3 == a3.anchorNode.nodeType && !a3.anchorNode.nodeValue && a3.anchorNode.previousElementSibling && t3.preventDefault(), (c3 || o3) && !i3.backspace)
                return void t3.preventDefault();
              if ("Range" != a3.type && !a3.anchorOffset && a3.anchorNode == e3.DOM.input && "Delete" != t3.key)
                return void t3.preventDefault();
              if ("Range" != a3.type && g3 && g3.hasAttribute("readonly"))
                return void T2(d2(g3));
              "Delete" == t3.key && m3 && y2(a3.anchorNode.nextSibling) && e3.removeTags(a3.anchorNode.nextSibling), clearTimeout(k2), k2 = setTimeout(function() {
                var t4 = document.getSelection();
                r2(e3.DOM.input.innerHTML), !o3 && t4.anchorNode.previousSibling, e3.value = [].map.call(p3, function(t5, i4) {
                  var n4 = y2(t5);
                  if (t5.parentNode || n4.readonly)
                    return n4;
                  e3.trigger("remove", { tag: t5, index: i4, data: n4 });
                }).filter(function(t5) {
                  return t5;
                });
              }, 20);
          }
          return true;
        }
        var v3 = "manual" == i3.dropdown.position;
        switch (t3.key) {
          case "Backspace":
            "select" == i3.mode && i3.enforceWhitelist && e3.value.length ? e3.removeTags() : e3.state.dropdown.visible && "manual" != i3.dropdown.position || "" != t3.target.textContent && 8203 != n3.charCodeAt(0) || (true === i3.backspace ? e3.removeTags() : "edit" == i3.backspace && setTimeout(e3.editTag.bind(e3), 0));
            break;
          case "Esc":
          case "Escape":
            if (e3.state.dropdown.visible)
              return;
            t3.target.blur();
            break;
          case "Down":
          case "ArrowDown":
            e3.state.dropdown.visible || e3.dropdown.show();
            break;
          case "ArrowRight":
            var b3 = e3.state.inputSuggestion || e3.state.ddItemData;
            if (b3 && i3.autoComplete.rightKey)
              return void e3.addTags([b3], true);
            break;
          case "Tab":
            var w3 = "select" == i3.mode;
            if (!n3 || w3)
              return true;
            t3.preventDefault();
          case "Enter":
            if (e3.state.dropdown.visible && !v3)
              return;
            t3.preventDefault(), setTimeout(function() {
              e3.state.dropdown.visible && !v3 || e3.state.actions.selectOption || !i3.addTagOn.includes(t3.key.toLowerCase()) || e3.addTags(n3, true);
            });
        }
      }).catch(function(t4) {
        return t4;
      });
    }
  }, onInput: function(t3) {
    this.postUpdate();
    var e3 = this.settings;
    if ("mix" == e3.mode)
      return this.events.callbacks.onMixTagsInput.call(this, t3);
    var i3 = this.input.normalize.call(this, void 0, { trim: false }), n3 = i3.length >= e3.dropdown.enabled, s3 = { value: i3, inputElm: this.DOM.input }, a3 = this.validateTag({ value: i3 });
    "select" == e3.mode && this.toggleScopeValidation(a3), s3.isValid = a3, this.state.inputText != i3 && (this.input.set.call(this, i3, false), -1 != i3.search(e3.delimiters) ? this.addTags(i3) && this.input.set.call(this) : e3.dropdown.enabled >= 0 && this.dropdown[n3 ? "show" : "hide"](i3), this.trigger("input", s3));
  }, onMixTagsInput: function(t3) {
    var e3, i3, n3, s3, a3, o3, r3, l3, d3 = this, c3 = this.settings, u3 = this.value.length, h3 = this.getTagElms(), p3 = document.createDocumentFragment(), m3 = window.getSelection().getRangeAt(0), v3 = [].map.call(h3, function(t4) {
      return y2(t4).value;
    });
    if ("deleteContentBackward" == t3.inputType && f2() && this.events.callbacks.onKeydown.call(this, { target: t3.target, key: "Backspace" }), O2(this.getTagElms()), this.value.slice().forEach(function(t4) {
      t4.readonly && !v3.includes(t4.value) && p3.appendChild(d3.createTagElem(t4));
    }), p3.childNodes.length && (m3.insertNode(p3), this.setRangeAtStartEnd(false, p3.lastChild)), h3.length != u3)
      return this.value = [].map.call(this.getTagElms(), function(t4) {
        return y2(t4);
      }), void this.update({ withoutChangeEvent: true });
    if (this.hasMaxTags())
      return true;
    if (window.getSelection && (o3 = window.getSelection()).rangeCount > 0 && 3 == o3.anchorNode.nodeType) {
      if ((m3 = o3.getRangeAt(0).cloneRange()).collapse(true), m3.setStart(o3.focusNode, 0), n3 = (e3 = m3.toString().slice(0, m3.endOffset)).split(c3.pattern).length - 1, (i3 = e3.match(c3.pattern)) && (s3 = e3.slice(e3.lastIndexOf(i3[i3.length - 1]))), s3) {
        if (this.state.actions.ArrowLeft = false, this.state.tag = { prefix: s3.match(c3.pattern)[0], value: s3.replace(c3.pattern, "") }, this.state.tag.baseOffset = o3.baseOffset - this.state.tag.value.length, l3 = this.state.tag.value.match(c3.delimiters))
          return this.state.tag.value = this.state.tag.value.replace(c3.delimiters, ""), this.state.tag.delimiters = l3[0], this.addTags(this.state.tag.value, c3.dropdown.clearOnSelect), void this.dropdown.hide();
        a3 = this.state.tag.value.length >= c3.dropdown.enabled;
        try {
          r3 = (r3 = this.state.flaggedTags[this.state.tag.baseOffset]).prefix == this.state.tag.prefix && r3.value[0] == this.state.tag.value[0], this.state.flaggedTags[this.state.tag.baseOffset] && !this.state.tag.value && delete this.state.flaggedTags[this.state.tag.baseOffset];
        } catch (t4) {
        }
        (r3 || n3 < this.state.mixMode.matchedPatternCount) && (a3 = false);
      } else
        this.state.flaggedTags = {};
      this.state.mixMode.matchedPatternCount = n3;
    }
    setTimeout(function() {
      d3.update({ withoutChangeEvent: true }), d3.trigger("input", g2({}, d3.state.tag, { textContent: d3.DOM.input.textContent })), d3.state.tag && d3.dropdown[a3 ? "show" : "hide"](d3.state.tag.value);
    }, 10);
  }, onInputIE: function(t3) {
    var e3 = this;
    setTimeout(function() {
      e3.events.callbacks.onInput.call(e3, t3);
    });
  }, observeOriginalInputValue: function() {
    this.DOM.originalInput.parentNode || this.destroy(), this.DOM.originalInput.value != this.DOM.originalInput.tagifyValue && this.loadOriginalValues();
  }, onClickAnywhere: function(t3) {
    t3.target == this.DOM.scope || this.DOM.scope.contains(t3.target) || (this.toggleFocusClass(false), this.state.hasFocus = false, t3.target.closest(".tagify__dropdown") && t3.target.closest(".tagify__dropdown").__tagify != this && this.dropdown.hide());
  }, onClickScope: function(t3) {
    var e3 = this.settings, i3 = t3.target.closest("." + e3.classNames.tag), n3 = t3.target === this.DOM.scope, s3 = +/* @__PURE__ */ new Date() - this.state.hasFocus;
    if (n3 && "select" != e3.mode)
      this.DOM.input.focus();
    else {
      if (!t3.target.classList.contains(e3.classNames.tagX))
        return i3 && !this.state.editing ? (this.trigger("click", { tag: i3, index: this.getNodeIndex(i3), data: y2(i3), event: t3 }), void (1 !== e3.editTags && 1 !== e3.editTags.clicks && "select" != e3.mode || this.events.callbacks.onDoubleClickScope.call(this, t3))) : void (t3.target == this.DOM.input && ("mix" == e3.mode && this.fixFirefoxLastTagNoCaret(), s3 > 500 || !e3.focusable) ? this.state.dropdown.visible ? this.dropdown.hide() : 0 === e3.dropdown.enabled && "mix" != e3.mode && this.dropdown.show(this.value.length ? "" : void 0) : "select" != e3.mode || 0 !== e3.dropdown.enabled || this.state.dropdown.visible || (this.events.callbacks.onDoubleClickScope.call(this, q2(function(t4) {
          for (var e4 = 1; e4 < arguments.length; e4++) {
            var i4 = null != arguments[e4] ? arguments[e4] : {}, n4 = Object.keys(i4);
            "function" == typeof Object.getOwnPropertySymbols && (n4 = n4.concat(Object.getOwnPropertySymbols(i4).filter(function(t5) {
              return Object.getOwnPropertyDescriptor(i4, t5).enumerable;
            }))), n4.forEach(function(e5) {
              W2(t4, e5, i4[e5]);
            });
          }
          return t4;
        }({}, t3), { target: this.getTagElms()[0] })), !e3.userInput && this.dropdown.show()));
      this.removeTags(t3.target.parentNode);
    }
  }, onPaste: function(t3) {
    var e3 = this;
    t3.preventDefault();
    var i3, n3, s3, a3 = this.settings;
    if ("select" == a3.mode && a3.enforceWhitelist || !a3.userInput)
      return false;
    a3.readonly || (n3 = t3.clipboardData || window.clipboardData, s3 = n3.getData("Text"), a3.hooks.beforePaste(t3, { tagify: this, pastedText: s3, clipboardData: n3 }).then(function(a4) {
      void 0 === a4 && (a4 = s3), a4 && (e3.injectAtCaret(a4, window.getSelection().getRangeAt(0)), "mix" == e3.settings.mode ? e3.events.callbacks.onMixTagsInput.call(e3, t3) : e3.settings.pasteAsTags ? i3 = e3.addTags(e3.state.inputText + a4, true) : (e3.state.inputText = a4, e3.dropdown.show(a4))), e3.trigger("paste", { event: t3, pastedText: s3, clipboardData: n3, tagsElems: i3 });
    }).catch(function(t4) {
      return t4;
    }));
  }, onDrop: function(t3) {
    t3.preventDefault();
  }, onEditTagInput: function(t3, e3) {
    var i3, n3 = t3.closest("." + this.settings.classNames.tag), s3 = this.getNodeIndex(n3), a3 = y2(n3), o3 = this.input.normalize.call(this, t3), r3 = (W2(i3 = {}, this.settings.tagTextProp, o3), W2(i3, "__tagId", a3.__tagId), i3), l3 = this.validateTag(r3);
    this.editTagChangeDetected(g2(a3, r3)) || true !== t3.originalIsValid || (l3 = true), n3.classList.toggle(this.settings.classNames.tagInvalid, true !== l3), a3.__isValid = l3, n3.title = true === l3 ? a3.title || a3.value : l3, o3.length >= this.settings.dropdown.enabled && (this.state.editing && (this.state.editing.value = o3), this.dropdown.show(o3)), this.trigger("edit:input", { tag: n3, index: s3, data: g2({}, this.value[s3], { newValue: o3 }), event: e3 });
  }, onEditTagPaste: function(t3, e3) {
    var i3 = (e3.clipboardData || window.clipboardData).getData("Text");
    e3.preventDefault();
    var n3 = w2(i3);
    this.setRangeAtStartEnd(false, n3);
  }, onEditTagClick: function(t3, e3) {
    this.events.callbacks.onClickScope.call(this, e3);
  }, onEditTagFocus: function(t3) {
    this.state.editing = { scope: t3, input: t3.querySelector("[contenteditable]") };
  }, onEditTagBlur: function(t3, e3) {
    var i3 = v2.call(this, e3.relatedTarget);
    if ("select" == this.settings.mode && i3 && e3.relatedTarget.contains(e3.target))
      this.dropdown.hide();
    else if (this.state.editing && (this.state.hasFocus || this.toggleFocusClass(), this.DOM.scope.contains(t3))) {
      var n3, s3, a3, o3 = this.settings, r3 = t3.closest("." + o3.classNames.tag), l3 = y2(r3), d3 = this.input.normalize.call(this, t3), c3 = (W2(n3 = {}, o3.tagTextProp, d3), W2(n3, "__tagId", l3.__tagId), n3), u3 = l3.__originalData, h3 = this.editTagChangeDetected(g2(l3, c3)), p3 = this.validateTag(c3);
      if (d3)
        if (h3) {
          var f3;
          if (s3 = this.hasMaxTags(), a3 = g2({}, u3, (W2(f3 = {}, o3.tagTextProp, this.trim(d3)), W2(f3, "__isValid", p3), f3)), o3.transformTag.call(this, a3, u3), true !== (p3 = (!s3 || true === u3.__isValid) && this.validateTag(a3))) {
            if (this.trigger("invalid", { data: a3, tag: r3, message: p3 }), o3.editTags.keepInvalid)
              return;
            o3.keepInvalidTags ? a3.__isValid = p3 : a3 = u3;
          } else
            o3.keepInvalidTags && (delete a3.title, delete a3["aria-invalid"], delete a3.class);
          this.onEditTagDone(r3, a3);
        } else
          this.onEditTagDone(r3, u3);
      else
        this.onEditTagDone(r3);
    }
  }, onEditTagkeydown: function(t3, e3) {
    if (!this.state.composing)
      switch (this.trigger("edit:keydown", { event: t3 }), t3.key) {
        case "Esc":
        case "Escape":
          this.state.editing = false, !!e3.__tagifyTagData.__originalData.value ? e3.parentNode.replaceChild(e3.__tagifyTagData.__originalHTML, e3) : e3.remove();
          break;
        case "Enter":
        case "Tab":
          t3.preventDefault();
          setTimeout(function() {
            return t3.target.blur();
          }, 0);
      }
  }, onDoubleClickScope: function(t3) {
    var e3, i3, n3 = t3.target.closest("." + this.settings.classNames.tag), s3 = y2(n3), a3 = this.settings;
    n3 && false !== s3.editable && (e3 = n3.classList.contains(this.settings.classNames.tagEditing), i3 = n3.hasAttribute("readonly"), a3.readonly || e3 || i3 || !this.settings.editTags || !a3.userInput || (this.events.callbacks.onEditTagFocus.call(this, n3), this.editTag(n3)), this.toggleFocusClass(true), "select" != a3.mode && this.trigger("dblclick", { tag: n3, index: this.getNodeIndex(n3), data: y2(n3) }));
  }, onInputDOMChange: function(t3) {
    var e3 = this;
    t3.forEach(function(t4) {
      t4.addedNodes.forEach(function(t5) {
        if ("<div><br></div>" == t5.outerHTML)
          t5.replaceWith(document.createElement("br"));
        else if (1 == t5.nodeType && t5.querySelector(e3.settings.classNames.tagSelector)) {
          var i4, n3 = document.createTextNode("");
          3 == t5.childNodes[0].nodeType && "BR" != t5.previousSibling.nodeName && (n3 = document.createTextNode("\n")), (i4 = t5).replaceWith.apply(i4, K2([n3].concat(K2(K2(t5.childNodes).slice(0, -1))))), T2(n3);
        } else if (v2.call(e3, t5)) {
          var s3;
          if (3 != (null === (s3 = t5.previousSibling) || void 0 === s3 ? void 0 : s3.nodeType) || t5.previousSibling.textContent || t5.previousSibling.remove(), t5.previousSibling && "BR" == t5.previousSibling.nodeName) {
            t5.previousSibling.replaceWith("\n\u200B");
            for (var a3 = t5.nextSibling, o3 = ""; a3; )
              o3 += a3.textContent, a3 = a3.nextSibling;
            o3.trim() && T2(t5.previousSibling);
          } else
            t5.previousSibling && !y2(t5.previousSibling) || t5.before("\u200B");
        }
      }), t4.removedNodes.forEach(function(t5) {
        t5 && "BR" == t5.nodeName && v2.call(e3, i3) && (e3.removeTags(i3), e3.fixFirefoxLastTagNoCaret());
      });
    });
    var i3 = this.DOM.input.lastChild;
    i3 && "" == i3.nodeValue && i3.remove(), i3 && "BR" == i3.nodeName || this.DOM.input.appendChild(document.createElement("br"));
  } } };
  function X2(t3, e3) {
    (null == e3 || e3 > t3.length) && (e3 = t3.length);
    for (var i3 = 0, n3 = new Array(e3); i3 < e3; i3++)
      n3[i3] = t3[i3];
    return n3;
  }
  __name(X2, "X");
  function J2(t3, e3, i3) {
    return e3 in t3 ? Object.defineProperty(t3, e3, { value: i3, enumerable: true, configurable: true, writable: true }) : t3[e3] = i3, t3;
  }
  __name(J2, "J");
  function G2(t3, e3) {
    return null != e3 && "undefined" != typeof Symbol && e3[Symbol.hasInstance] ? !!e3[Symbol.hasInstance](t3) : t3 instanceof e3;
  }
  __name(G2, "G");
  function $(t3) {
    for (var e3 = 1; e3 < arguments.length; e3++) {
      var i3 = null != arguments[e3] ? arguments[e3] : {}, n3 = Object.keys(i3);
      "function" == typeof Object.getOwnPropertySymbols && (n3 = n3.concat(Object.getOwnPropertySymbols(i3).filter(function(t4) {
        return Object.getOwnPropertyDescriptor(i3, t4).enumerable;
      }))), n3.forEach(function(e4) {
        J2(t3, e4, i3[e4]);
      });
    }
    return t3;
  }
  __name($, "$");
  function Q2(t3) {
    return function(t4) {
      if (Array.isArray(t4))
        return X2(t4);
    }(t3) || function(t4) {
      if ("undefined" != typeof Symbol && null != t4[Symbol.iterator] || null != t4["@@iterator"])
        return Array.from(t4);
    }(t3) || function(t4, e3) {
      if (!t4)
        return;
      if ("string" == typeof t4)
        return X2(t4, e3);
      var i3 = Object.prototype.toString.call(t4).slice(8, -1);
      "Object" === i3 && t4.constructor && (i3 = t4.constructor.name);
      if ("Map" === i3 || "Set" === i3)
        return Array.from(i3);
      if ("Arguments" === i3 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i3))
        return X2(t4, e3);
    }(t3) || function() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }();
  }
  __name(Q2, "Q");
  function Y2(t3, e3) {
    if (!t3) {
      n2.warn("input element not found", t3);
      var i3 = new Proxy(this, { get: function() {
        return function() {
          return i3;
        };
      } });
      return i3;
    }
    if (t3.__tagify)
      return n2.warn("input element is already Tagified - Same instance is returned.", t3), t3.__tagify;
    var s3;
    g2(this, function(t4) {
      var e4 = document.createTextNode(""), i4 = {};
      function s4(t5, i5, n3) {
        n3 && i5.split(/\s+/g).forEach(function(i6) {
          return e4[t5 + "EventListener"].call(e4, i6, n3);
        });
      }
      __name(s4, "s");
      return { removeAllCustomListeners: function() {
        Object.entries(i4).forEach(function(t5) {
          var e5 = H2(t5, 2), i5 = e5[0];
          e5[1].forEach(function(t6) {
            return s4("remove", i5, t6);
          });
        }), i4 = {};
      }, off: function(t5, e5) {
        return t5 && (e5 ? s4("remove", t5, e5) : t5.split(/\s+/g).forEach(function(t6) {
          var e6;
          null === (e6 = i4[t6]) || void 0 === e6 || e6.forEach(function(e7) {
            return s4("remove", t6, e7);
          }), delete i4[t6];
        })), this;
      }, on: function(t5, e5) {
        return e5 && "function" == typeof e5 && (t5.split(/\s+/g).forEach(function(t6) {
          Array.isArray(i4[t6]) ? i4[t6].push(e5) : i4[t6] = [e5];
        }), s4("add", t5, e5)), this;
      }, trigger: function(i5, s5, a3) {
        var o3;
        if (a3 = a3 || { cloneData: true }, i5)
          if (t4.settings.isJQueryPlugin)
            "remove" == i5 && (i5 = "removeTag"), jQuery(t4.DOM.originalInput).triggerHandler(i5, [s5]);
          else {
            try {
              var r3 = "object" == typeof s5 ? s5 : { value: s5 };
              if ((r3 = a3.cloneData ? g2({}, r3) : r3).tagify = this, s5.event && (r3.event = this.cloneEvent(s5.event)), R2(s5, Object))
                for (var l3 in s5)
                  R2(s5[l3], HTMLElement) && (r3[l3] = s5[l3]);
              o3 = new CustomEvent(i5, { detail: r3 });
            } catch (t5) {
              n2.warn(t5);
            }
            e4.dispatchEvent(o3);
          }
      } };
    }(this)), this.isFirefox = /firefox|fxios/i.test(navigator.userAgent) && !/seamonkey/i.test(navigator.userAgent), this.isIE = window.document.documentMode, e3 = e3 || {}, this.getPersistedData = (s3 = e3.id, function(t4) {
      var e4, i4 = "/" + t4;
      if (1 == localStorage.getItem(j2 + s3 + "/v", 1))
        try {
          e4 = JSON.parse(localStorage[j2 + s3 + i4]);
        } catch (t5) {
        }
      return e4;
    }), this.setPersistedData = function(t4) {
      return t4 ? (localStorage.setItem(j2 + t4 + "/v", 1), function(e4, i4) {
        var n3 = "/" + i4, s4 = JSON.stringify(e4);
        e4 && i4 && (localStorage.setItem(j2 + t4 + n3, s4), dispatchEvent(new Event("storage")));
      }) : function() {
      };
    }(e3.id), this.clearPersistedData = /* @__PURE__ */ function(t4) {
      return function(e4) {
        var i4 = j2 + "/" + t4 + "/";
        if (e4)
          localStorage.removeItem(i4 + e4);
        else
          for (var n3 in localStorage)
            n3.includes(i4) && localStorage.removeItem(n3);
      };
    }(e3.id), this.applySettings(t3, e3), this.state = { inputText: "", editing: false, composing: false, actions: {}, mixMode: {}, dropdown: {}, flaggedTags: {} }, this.value = [], this.listeners = {}, this.DOM = {}, this.build(t3), _.call(this), this.getCSSVars(), this.loadOriginalValues(), this.events.customBinding.call(this), this.events.binding.call(this), t3.autofocus && this.DOM.input.focus(), t3.__tagify = this;
  }
  __name(Y2, "Y");
  Y2.prototype = { _dropdown: L4, placeCaretAfterNode: T2, getSetTagData: y2, helpers: { sameStr: s2, removeCollectionProp: a2, omit: o2, isObject: u2, parseHTML: l2, escapeHTML: c2, extend: g2, concatWithoutDups: h2, getUID: m2, isNodeTag: v2 }, customEventsList: ["change", "add", "remove", "invalid", "input", "paste", "click", "keydown", "focus", "blur", "edit:input", "edit:beforeUpdate", "edit:updated", "edit:start", "edit:keydown", "dropdown:show", "dropdown:hide", "dropdown:select", "dropdown:updated", "dropdown:noMatch", "dropdown:scroll"], dataProps: ["__isValid", "__removed", "__originalData", "__originalHTML", "__tagId"], trim: function(t3) {
    return this.settings.trim && t3 && "string" == typeof t3 ? t3.trim() : t3;
  }, parseHTML: l2, templates: V2, parseTemplate: function(t3, e3) {
    return l2((t3 = this.settings.templates[t3] || t3).apply(this, e3));
  }, set whitelist(t3) {
    var e3 = t3 && Array.isArray(t3);
    this.settings.whitelist = e3 ? t3 : [], this.setPersistedData(e3 ? t3 : [], "whitelist");
  }, get whitelist() {
    return this.settings.whitelist;
  }, set userInput(t3) {
    this.settings.userInput = !!t3, this.setContentEditable(!!t3);
  }, get userInput() {
    return this.settings.userInput;
  }, generateClassSelectors: function(t3) {
    var e3 = /* @__PURE__ */ __name(function(e4) {
      var i4 = e4;
      Object.defineProperty(t3, i4 + "Selector", { get: function() {
        return "." + this[i4].split(" ")[0];
      } });
    }, "e");
    for (var i3 in t3)
      e3(i3);
  }, applySettings: function(t3, e3) {
    var i3, n3;
    x2.templates = this.templates;
    var s3 = g2({}, x2, "mix" == e3.mode ? { dropdown: { position: "text" } } : {}), a3 = this.settings = g2({}, s3, e3);
    if (a3.disabled = t3.hasAttribute("disabled"), a3.readonly = a3.readonly || t3.hasAttribute("readonly"), a3.placeholder = c2(t3.getAttribute("placeholder") || a3.placeholder || ""), a3.required = t3.hasAttribute("required"), this.generateClassSelectors(a3.classNames), void 0 === a3.dropdown.includeSelectedTags && (a3.dropdown.includeSelectedTags = a3.duplicates), this.isIE && (a3.autoComplete = false), ["whitelist", "blacklist"].forEach(function(e4) {
      var i4 = t3.getAttribute("data-" + e4);
      i4 && G2(i4 = i4.split(a3.delimiters), Array) && (a3[e4] = i4);
    }), "autoComplete" in e3 && !u2(e3.autoComplete) && (a3.autoComplete = x2.autoComplete, a3.autoComplete.enabled = e3.autoComplete), "mix" == a3.mode && (a3.pattern = a3.pattern || /@/, a3.autoComplete.rightKey = true, a3.delimiters = e3.delimiters || null, a3.tagTextProp && !a3.dropdown.searchKeys.includes(a3.tagTextProp) && a3.dropdown.searchKeys.push(a3.tagTextProp)), t3.pattern)
      try {
        a3.pattern = new RegExp(t3.pattern);
      } catch (t4) {
      }
    if (a3.delimiters) {
      a3._delimiters = a3.delimiters;
      try {
        a3.delimiters = new RegExp(this.settings.delimiters, "g");
      } catch (t4) {
      }
    }
    a3.disabled && (a3.userInput = false), this.TEXTS = $({}, P2, a3.texts || {}), ("select" != a3.mode || (null === (i3 = e3.dropdown) || void 0 === i3 ? void 0 : i3.enabled)) && a3.userInput || (a3.dropdown.enabled = 0), a3.dropdown.appendTarget = (null === (n3 = e3.dropdown) || void 0 === n3 ? void 0 : n3.appendTarget) || document.body;
    var o3 = this.getPersistedData("whitelist");
    Array.isArray(o3) && (this.whitelist = Array.isArray(a3.whitelist) ? h2(a3.whitelist, o3) : o3);
  }, getAttributes: function(t3) {
    var e3, i3 = this.getCustomAttributes(t3), n3 = "";
    for (e3 in i3)
      n3 += " " + e3 + (void 0 !== t3[e3] ? '="'.concat(i3[e3], '"') : "");
    return n3;
  }, getCustomAttributes: function(t3) {
    if (!u2(t3))
      return "";
    var e3, i3 = {};
    for (e3 in t3)
      "__" != e3.slice(0, 2) && "class" != e3 && t3.hasOwnProperty(e3) && void 0 !== t3[e3] && (i3[e3] = c2(t3[e3]));
    return i3;
  }, setStateSelection: function() {
    var t3 = window.getSelection(), e3 = { anchorOffset: t3.anchorOffset, anchorNode: t3.anchorNode, range: t3.getRangeAt && t3.rangeCount && t3.getRangeAt(0) };
    return this.state.selection = e3, e3;
  }, getCSSVars: function() {
    var t3, e3, i3, n3 = getComputedStyle(this.DOM.scope, null);
    this.CSSVars = { tagHideTransition: (t3 = function(t4) {
      if (!t4)
        return {};
      var e4 = (t4 = t4.trim().split(" ")[0]).split(/\d+/g).filter(function(t5) {
        return t5;
      }).pop().trim();
      return { value: +t4.split(e4).filter(function(t5) {
        return t5;
      })[0].trim(), unit: e4 };
    }((i3 = "tag-hide-transition", n3.getPropertyValue("--" + i3))), e3 = t3.value, "s" == t3.unit ? 1e3 * e3 : e3) };
  }, build: function(t3) {
    var e3 = this.DOM, i3 = t3.closest("label");
    this.settings.mixMode.integrated ? (e3.originalInput = null, e3.scope = t3, e3.input = t3) : (e3.originalInput = t3, e3.originalInput_tabIndex = t3.tabIndex, e3.scope = this.parseTemplate("wrapper", [t3, this.settings]), e3.input = e3.scope.querySelector(this.settings.classNames.inputSelector), t3.parentNode.insertBefore(e3.scope, t3), t3.tabIndex = -1), i3 && i3.setAttribute("for", "");
  }, destroy: function() {
    this.events.unbindGlobal.call(this), this.DOM.scope.parentNode.removeChild(this.DOM.scope), this.DOM.originalInput.tabIndex = this.DOM.originalInput_tabIndex, delete this.DOM.originalInput.__tagify, this.dropdown.hide(true), this.removeAllCustomListeners(), clearTimeout(this.dropdownHide__bindEventsTimeout), clearInterval(this.listeners.main.originalInputValueObserverInterval);
  }, loadOriginalValues: function(t3) {
    var e3, i3 = this.settings;
    if (this.state.blockChangeEvent = true, void 0 === t3) {
      var n3 = this.getPersistedData("value");
      t3 = n3 && !this.DOM.originalInput.value ? n3 : i3.mixMode.integrated ? this.DOM.input.textContent : this.DOM.originalInput.value;
    }
    if (this.removeAllTags(), t3)
      if ("mix" == i3.mode)
        this.parseMixTags(t3), (e3 = this.DOM.input.lastChild) && "BR" == e3.tagName || this.DOM.input.insertAdjacentHTML("beforeend", "<br>");
      else {
        try {
          G2(JSON.parse(t3), Array) && (t3 = JSON.parse(t3));
        } catch (t4) {
        }
        this.addTags(t3, true).forEach(function(t4) {
          return t4 && t4.classList.add(i3.classNames.tagNoAnimation);
        });
      }
    else
      this.postUpdate();
    this.state.lastOriginalValueReported = i3.mixMode.integrated ? "" : this.DOM.originalInput.value;
  }, cloneEvent: function(t3) {
    var e3 = {};
    for (var i3 in t3)
      "path" != i3 && (e3[i3] = t3[i3]);
    return e3;
  }, loading: function(t3) {
    return this.state.isLoading = t3, this.DOM.scope.classList[t3 ? "add" : "remove"](this.settings.classNames.scopeLoading), this;
  }, tagLoading: function(t3, e3) {
    return t3 && t3.classList[e3 ? "add" : "remove"](this.settings.classNames.tagLoading), this;
  }, toggleClass: function(t3, e3) {
    "string" == typeof t3 && this.DOM.scope.classList.toggle(t3, e3);
  }, toggleScopeValidation: function(t3) {
    var e3 = true === t3 || void 0 === t3;
    !this.settings.required && t3 && t3 === this.TEXTS.empty && (e3 = true), this.toggleClass(this.settings.classNames.tagInvalid, !e3), this.DOM.scope.title = e3 ? "" : t3;
  }, toggleFocusClass: function(t3) {
    this.toggleClass(this.settings.classNames.focus, !!t3);
  }, setPlaceholder: function(t3) {
    var e3 = this;
    ["data", "aria"].forEach(function(i3) {
      return e3.DOM.input.setAttribute("".concat(i3, "-placeholder"), t3);
    });
  }, triggerChangeEvent: function() {
    if (!this.settings.mixMode.integrated) {
      var t3 = this.DOM.originalInput, e3 = this.state.lastOriginalValueReported !== t3.value, i3 = new CustomEvent("change", { bubbles: true });
      e3 && (this.state.lastOriginalValueReported = t3.value, i3.simulated = true, t3._valueTracker && t3._valueTracker.setValue(Math.random()), t3.dispatchEvent(i3), this.trigger("change", this.state.lastOriginalValueReported), t3.value = this.state.lastOriginalValueReported);
    }
  }, events: z2, fixFirefoxLastTagNoCaret: function() {
  }, setRangeAtStartEnd: function(t3, e3) {
    if (e3) {
      t3 = "number" == typeof t3 ? t3 : !!t3, e3 = e3.lastChild || e3;
      var i3 = document.getSelection();
      if (G2(i3.focusNode, Element) && !this.DOM.input.contains(i3.focusNode))
        return true;
      try {
        i3.rangeCount >= 1 && ["Start", "End"].forEach(function(n3) {
          return i3.getRangeAt(0)["set" + n3](e3, t3 || e3.length);
        });
      } catch (t4) {
        console.warn(t4);
      }
    }
  }, insertAfterTag: function(t3, e3) {
    if (e3 = e3 || this.settings.mixMode.insertAfterTag, t3 && t3.parentNode && e3)
      return e3 = "string" == typeof e3 ? document.createTextNode(e3) : e3, t3.parentNode.insertBefore(e3, t3.nextSibling), e3;
  }, editTagChangeDetected: function(t3) {
    var e3 = t3.__originalData;
    for (var i3 in e3)
      if (!this.dataProps.includes(i3) && t3[i3] != e3[i3])
        return true;
    return false;
  }, getTagTextNode: function(t3) {
    return t3.querySelector(this.settings.classNames.tagTextSelector);
  }, setTagTextNode: function(t3, e3) {
    this.getTagTextNode(t3).innerHTML = c2(e3);
  }, editTag: function(t3, e3) {
    var i3 = this;
    t3 = t3 || this.getLastTag(), e3 = e3 || {};
    var s3 = this.settings, a3 = this.getTagTextNode(t3), o3 = this.getNodeIndex(t3), r3 = y2(t3), l3 = this.events.callbacks, d3 = true, c3 = "select" == s3.mode;
    if (!c3 && this.dropdown.hide(), a3) {
      if (!G2(r3, Object) || !("editable" in r3) || r3.editable)
        return r3 = y2(t3, { __originalData: g2({}, r3), __originalHTML: t3.cloneNode(true) }), y2(r3.__originalHTML, r3.__originalData), a3.setAttribute("contenteditable", true), t3.classList.add(s3.classNames.tagEditing), a3.addEventListener("click", l3.onEditTagClick.bind(this, t3)), a3.addEventListener("blur", l3.onEditTagBlur.bind(this, this.getTagTextNode(t3))), a3.addEventListener("input", l3.onEditTagInput.bind(this, a3)), a3.addEventListener("paste", l3.onEditTagPaste.bind(this, a3)), a3.addEventListener("keydown", function(e4) {
          return l3.onEditTagkeydown.call(i3, e4, t3);
        }), a3.addEventListener("compositionstart", l3.onCompositionStart.bind(this)), a3.addEventListener("compositionend", l3.onCompositionEnd.bind(this)), e3.skipValidation || (d3 = this.editTagToggleValidity(t3)), a3.originalIsValid = d3, this.trigger("edit:start", { tag: t3, index: o3, data: r3, isValid: d3 }), a3.focus(), !c3 && this.setRangeAtStartEnd(false, a3), 0 === s3.dropdown.enabled && !c3 && this.dropdown.show(), this.state.hasFocus = true, this;
    } else
      n2.warn("Cannot find element in Tag template: .", s3.classNames.tagTextSelector);
  }, editTagToggleValidity: function(t3, e3) {
    var i3;
    if (e3 = e3 || y2(t3))
      return (i3 = !("__isValid" in e3) || true === e3.__isValid) || this.removeTagsFromValue(t3), this.update(), t3.classList.toggle(this.settings.classNames.tagNotAllowed, !i3), e3.__isValid = i3, e3.__isValid;
    n2.warn("tag has no data: ", t3, e3);
  }, onEditTagDone: function(t3, e3) {
    t3 = t3 || this.state.editing.scope, e3 = e3 || {};
    var i3, n3, s3 = { tag: t3, index: this.getNodeIndex(t3), previousData: y2(t3), data: e3 }, a3 = this.settings;
    this.trigger("edit:beforeUpdate", s3, { cloneData: false }), this.state.editing = false, delete e3.__originalData, delete e3.__originalHTML, t3 && (void 0 !== (n3 = e3[a3.tagTextProp]) ? null === (i3 = (n3 += "").trim) || void 0 === i3 ? void 0 : i3.call(n3) : a3.tagTextProp in e3 ? void 0 : e3.value) ? (t3 = this.replaceTag(t3, e3), this.editTagToggleValidity(t3, e3), a3.a11y.focusableTags ? t3.focus() : "select" != a3.mode && T2(t3)) : t3 && this.removeTags(t3), this.trigger("edit:updated", s3), this.dropdown.hide(), this.settings.keepInvalidTags && this.reCheckInvalidTags();
  }, replaceTag: function(t3, e3) {
    e3 && "" !== e3.value && void 0 !== e3.value || (e3 = t3.__tagifyTagData), e3.__isValid && 1 != e3.__isValid && g2(e3, this.getInvalidTagAttrs(e3, e3.__isValid));
    var i3 = this.createTagElem(e3);
    return t3.parentNode.replaceChild(i3, t3), this.updateValueByDOMTags(), i3;
  }, updateValueByDOMTags: function() {
    var t3 = this;
    this.value.length = 0, [].forEach.call(this.getTagElms(), function(e3) {
      e3.classList.contains(t3.settings.classNames.tagNotAllowed.split(" ")[0]) || t3.value.push(y2(e3));
    }), this.update();
  }, injectAtCaret: function(t3, e3) {
    var i3;
    if (!(e3 = e3 || (null === (i3 = this.state.selection) || void 0 === i3 ? void 0 : i3.range)) && t3)
      return this.appendMixTags(t3), this;
    var n3 = w2(t3, e3);
    return this.setRangeAtStartEnd(false, n3), this.updateValueByDOMTags(), this.update(), this;
  }, input: { set: function() {
    var t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "", e3 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], i3 = this.settings.dropdown.closeOnSelect;
    this.state.inputText = t3, e3 && (this.DOM.input.innerHTML = c2("" + t3)), !t3 && i3 && this.dropdown.hide.bind(this), this.input.autocomplete.suggest.call(this), this.input.validate.call(this);
  }, raw: function() {
    return this.DOM.input.textContent;
  }, validate: function() {
    var t3 = !this.state.inputText || true === this.validateTag({ value: this.state.inputText });
    return this.DOM.input.classList.toggle(this.settings.classNames.inputInvalid, !t3), t3;
  }, normalize: function(t3, e3) {
    var i3 = t3 || this.DOM.input, n3 = [];
    i3.childNodes.forEach(function(t4) {
      return 3 == t4.nodeType && n3.push(t4.nodeValue);
    }), n3 = n3.join("\n");
    try {
      n3 = n3.replace(/(?:\r\n|\r|\n)/g, this.settings.delimiters.source.charAt(0));
    } catch (t4) {
    }
    return n3 = n3.replace(/\s/g, " "), (null == e3 ? void 0 : e3.trim) ? this.trim(n3) : n3;
  }, autocomplete: { suggest: function(t3) {
    if (this.settings.autoComplete.enabled) {
      "object" != typeof (t3 = t3 || { value: "" }) && (t3 = { value: t3 });
      var e3 = this.dropdown.getMappedValue(t3);
      if ("number" != typeof e3) {
        var i3 = this.state.inputText.toLowerCase(), n3 = e3.substr(0, this.state.inputText.length).toLowerCase(), s3 = e3.substring(this.state.inputText.length);
        e3 && this.state.inputText && n3 == i3 ? (this.DOM.input.setAttribute("data-suggest", s3), this.state.inputSuggestion = t3) : (this.DOM.input.removeAttribute("data-suggest"), delete this.state.inputSuggestion);
      }
    }
  }, set: function(t3) {
    var e3 = this.DOM.input.getAttribute("data-suggest"), i3 = t3 || (e3 ? this.state.inputText + e3 : null);
    return !!i3 && ("mix" == this.settings.mode ? this.replaceTextWithNode(document.createTextNode(this.state.tag.prefix + i3)) : (this.input.set.call(this, i3), this.setRangeAtStartEnd(false, this.DOM.input)), this.input.autocomplete.suggest.call(this), this.dropdown.hide(), true);
  } } }, getTagIdx: function(t3) {
    return this.value.findIndex(function(e3) {
      return e3.__tagId == (t3 || {}).__tagId;
    });
  }, getNodeIndex: function(t3) {
    var e3 = 0;
    if (t3)
      for (; t3 = t3.previousElementSibling; )
        e3++;
    return e3;
  }, getTagElms: function() {
    for (var t3 = arguments.length, e3 = new Array(t3), i3 = 0; i3 < t3; i3++)
      e3[i3] = arguments[i3];
    var n3 = "." + Q2(this.settings.classNames.tag.split(" ")).concat(Q2(e3)).join(".");
    return [].slice.call(this.DOM.scope.querySelectorAll(n3));
  }, getLastTag: function() {
    var t3 = this.settings.classNames, e3 = this.DOM.scope.querySelectorAll("".concat(t3.tagSelector, ":not(.").concat(t3.tagHide, "):not([readonly])"));
    return e3[e3.length - 1];
  }, isTagDuplicate: function(t3, e3, i3) {
    var n3 = 0;
    if ("select" == this.settings.mode)
      return false;
    var a3 = true, o3 = false, r3 = void 0;
    try {
      for (var l3, d3 = this.value[Symbol.iterator](); !(a3 = (l3 = d3.next()).done); a3 = true) {
        var c3 = l3.value;
        s2(this.trim("" + t3), c3.value, e3) && i3 != c3.__tagId && n3++;
      }
    } catch (t4) {
      o3 = true, r3 = t4;
    } finally {
      try {
        a3 || null == d3.return || d3.return();
      } finally {
        if (o3)
          throw r3;
      }
    }
    return n3;
  }, getTagIndexByValue: function(t3) {
    var e3 = this, i3 = [], n3 = this.settings.dropdown.caseSensitive;
    return this.getTagElms().forEach(function(a3, o3) {
      a3.__tagifyTagData && s2(e3.trim(a3.__tagifyTagData.value), t3, n3) && i3.push(o3);
    }), i3;
  }, getTagElmByValue: function(t3) {
    var e3 = this.getTagIndexByValue(t3)[0];
    return this.getTagElms()[e3];
  }, flashTag: function(t3) {
    var e3 = this;
    t3 && (t3.classList.add(this.settings.classNames.tagFlash), setTimeout(function() {
      t3.classList.remove(e3.settings.classNames.tagFlash);
    }, 100));
  }, isTagBlacklisted: function(t3) {
    return t3 = this.trim(t3.toLowerCase()), this.settings.blacklist.filter(function(e3) {
      return ("" + e3).toLowerCase() == t3;
    }).length;
  }, isTagWhitelisted: function(t3) {
    return !!this.getWhitelistItem(t3);
  }, getWhitelistItem: function(t3, e3, i3) {
    e3 = e3 || "value";
    var n3, a3 = this.settings;
    return (i3 = i3 || a3.whitelist).some(function(i4) {
      var o3 = "object" == typeof i4 ? i4[e3] || i4.value : i4;
      if (s2(o3, t3, a3.dropdown.caseSensitive, a3.trim))
        return n3 = "object" == typeof i4 ? i4 : { value: i4 }, true;
    }), n3 || "value" != e3 || "value" == a3.tagTextProp || (n3 = this.getWhitelistItem(t3, a3.tagTextProp, i3)), n3;
  }, validateTag: function(t3) {
    var e3 = this.settings, i3 = "value" in t3 ? "value" : e3.tagTextProp, n3 = this.trim(t3[i3] + "");
    return (t3[i3] + "").trim() ? "mix" != e3.mode && e3.pattern && G2(e3.pattern, RegExp) && !e3.pattern.test(n3) ? this.TEXTS.pattern : !e3.duplicates && this.isTagDuplicate(n3, e3.dropdown.caseSensitive, t3.__tagId) ? this.TEXTS.duplicate : this.isTagBlacklisted(n3) || e3.enforceWhitelist && !this.isTagWhitelisted(n3) ? this.TEXTS.notAllowed : !e3.validate || e3.validate(t3) : this.TEXTS.empty;
  }, getInvalidTagAttrs: function(t3, e3) {
    return { "aria-invalid": true, class: "".concat(t3.class || "", " ").concat(this.settings.classNames.tagNotAllowed).trim(), title: e3 };
  }, hasMaxTags: function() {
    return this.value.length >= this.settings.maxTags && this.TEXTS.exceed;
  }, setReadonly: function(t3, e3) {
    var i3 = this.settings;
    this.DOM.scope.contains(document.activeElement) && document.activeElement.blur(), i3[e3 || "readonly"] = t3, this.DOM.scope[(t3 ? "set" : "remove") + "Attribute"](e3 || "readonly", true), this.settings.userInput = true, this.setContentEditable(!t3);
  }, setContentEditable: function(t3) {
    this.DOM.input.contentEditable = t3, this.DOM.input.tabIndex = t3 ? 0 : -1;
  }, setDisabled: function(t3) {
    this.setReadonly(t3, "disabled");
  }, normalizeTags: function(t3) {
    var e3 = this, i3 = this.settings, n3 = i3.whitelist, s3 = i3.delimiters, a3 = i3.mode, o3 = i3.tagTextProp, r3 = [], l3 = !!n3 && G2(n3[0], Object), d3 = Array.isArray(t3), c3 = d3 && t3[0].value, h3 = /* @__PURE__ */ __name(function(t4) {
      return (t4 + "").split(s3).reduce(function(t5, i4) {
        var n4, s4 = e3.trim(i4);
        return s4 && t5.push((J2(n4 = {}, o3, s4), J2(n4, "value", s4), n4)), t5;
      }, []);
    }, "h");
    if ("number" == typeof t3 && (t3 = t3.toString()), "string" == typeof t3) {
      if (!t3.trim())
        return [];
      t3 = h3(t3);
    } else
      d3 && (t3 = t3.reduce(function(t4, i4) {
        if (u2(i4)) {
          var n4 = g2({}, i4);
          n4[o3] = e3.trim(n4[o3]), n4[o3] && t4.push(n4);
        } else if (i4) {
          var s4;
          (s4 = t4).push.apply(s4, Q2(h3(i4)));
        }
        return t4;
      }, []));
    return l3 && !c3 && (t3.forEach(function(t4) {
      var i4 = r3.map(function(t5) {
        return t5.value;
      }), n4 = e3.dropdown.filterListItems.call(e3, t4[o3], { exact: true });
      e3.settings.duplicates || (n4 = n4.filter(function(t5) {
        return !i4.includes(t5.value);
      }));
      var s4 = n4.length > 1 ? e3.getWhitelistItem(t4[o3], o3, n4) : n4[0];
      s4 && G2(s4, Object) ? r3.push(s4) : "mix" != a3 && (null == t4.value && (t4.value = t4[o3]), r3.push(t4));
    }), r3.length && (t3 = r3)), t3;
  }, parseMixTags: function(t3) {
    var e3 = this, i3 = this.settings, n3 = i3.mixTagsInterpolator, s3 = i3.duplicates, a3 = i3.transformTag, o3 = i3.enforceWhitelist, r3 = i3.maxTags, l3 = i3.tagTextProp, d3 = [];
    t3 = t3.split(n3[0]).map(function(t4, i4) {
      var c4, u3, g3, h3 = t4.split(n3[1]), p3 = h3[0], f3 = d3.length == r3;
      try {
        if (p3 == +p3)
          throw Error;
        u3 = JSON.parse(p3);
      } catch (t5) {
        u3 = e3.normalizeTags(p3)[0] || { value: p3 };
      }
      if (a3.call(e3, u3), f3 || !(h3.length > 1) || o3 && !e3.isTagWhitelisted(u3.value) || !s3 && e3.isTagDuplicate(u3.value)) {
        if (t4)
          return i4 ? n3[0] + t4 : t4;
      } else
        u3[c4 = u3[l3] ? l3 : "value"] = e3.trim(u3[c4]), g3 = e3.createTagElem(u3), d3.push(u3), g3.classList.add(e3.settings.classNames.tagNoAnimation), h3[0] = g3.outerHTML, e3.value.push(u3);
      return h3.join("");
    }).join(""), this.DOM.input.innerHTML = t3, this.DOM.input.appendChild(document.createTextNode("")), this.DOM.input.normalize();
    var c3 = this.getTagElms();
    return c3.forEach(function(t4, e4) {
      return y2(t4, d3[e4]);
    }), this.update({ withoutChangeEvent: true }), O2(c3, this.state.hasFocus), t3;
  }, replaceTextWithNode: function(t3, e3) {
    if (this.state.tag || e3) {
      e3 = e3 || this.state.tag.prefix + this.state.tag.value;
      var i3, n3, s3 = this.state.selection || window.getSelection(), a3 = s3.anchorNode, o3 = this.state.tag.delimiters ? this.state.tag.delimiters.length : 0;
      return a3.splitText(s3.anchorOffset - o3), -1 == (i3 = a3.nodeValue.lastIndexOf(e3)) ? true : (n3 = a3.splitText(i3), t3 && a3.parentNode.replaceChild(t3, n3), true);
    }
  }, prepareNewTagNode: function(t3, e3) {
    e3 = e3 || {};
    var i3 = this.settings, n3 = [], s3 = {}, a3 = Object.assign({}, t3, { value: t3.value + "" });
    if (t3 = Object.assign({}, a3), i3.transformTag.call(this, t3), t3.__isValid = this.hasMaxTags() || this.validateTag(t3), true !== t3.__isValid) {
      if (e3.skipInvalid)
        return;
      if (g2(s3, this.getInvalidTagAttrs(t3, t3.__isValid), { __preInvalidData: a3 }), t3.__isValid == this.TEXTS.duplicate && this.flashTag(this.getTagElmByValue(t3.value)), !i3.createInvalidTags)
        return void n3.push(t3.value);
    }
    return "readonly" in t3 && (t3.readonly ? s3["aria-readonly"] = true : delete t3.readonly), { tagElm: this.createTagElem(t3, s3), tagData: t3, aggregatedInvalidInput: n3 };
  }, postProcessNewTagNode: function(t3, e3) {
    var i3 = this, n3 = this.settings, s3 = e3.__isValid;
    s3 && true === s3 ? (this.value.push(e3), this.trigger("add", { tag: t3, index: this.value.length - 1, data: e3 })) : (this.trigger("invalid", { data: e3, index: this.value.length, tag: t3, message: s3 }), n3.keepInvalidTags || setTimeout(function() {
      return i3.removeTags(t3, true);
    }, 1e3)), this.dropdown.position();
  }, selectTag: function(t3, e3) {
    var i3 = this;
    if (!this.settings.enforceWhitelist || this.isTagWhitelisted(e3.value)) {
      this.state.actions.selectOption && setTimeout(function() {
        return i3.setRangeAtStartEnd(false, i3.DOM.input);
      });
      var n3 = this.getLastTag();
      return n3 ? this.replaceTag(n3, e3) : this.appendTag(t3), this.value[0] = e3, this.update(), this.trigger("add", { tag: t3, data: e3 }), [t3];
    }
  }, addEmptyTag: function(t3) {
    var e3 = g2({ value: "" }, t3 || {}), i3 = this.createTagElem(e3);
    y2(i3, e3), this.appendTag(i3), this.editTag(i3, { skipValidation: true }), this.toggleFocusClass(true);
  }, addTags: function(t3, e3, i3) {
    var n3 = this, s3 = [], a3 = this.settings, o3 = [], r3 = document.createDocumentFragment();
    if (!t3 || 0 == t3.length)
      return s3;
    switch (t3 = this.normalizeTags(t3), a3.mode) {
      case "mix":
        return this.addMixTags(t3);
      case "select":
        e3 = false, this.removeAllTags();
    }
    return this.DOM.input.removeAttribute("style"), t3.forEach(function(t4) {
      var e4 = n3.prepareNewTagNode(t4, { skipInvalid: i3 || a3.skipInvalid });
      if (e4) {
        var l3 = e4.tagElm;
        if (t4 = e4.tagData, o3 = e4.aggregatedInvalidInput, s3.push(l3), "select" == a3.mode)
          return n3.selectTag(l3, t4);
        r3.appendChild(l3), n3.postProcessNewTagNode(l3, t4);
      }
    }), this.appendTag(r3), this.update(), t3.length && e3 && (this.input.set.call(this, a3.createInvalidTags ? "" : o3.join(a3._delimiters)), this.setRangeAtStartEnd(false, this.DOM.input)), a3.dropdown.enabled && this.dropdown.refilter(), s3;
  }, addMixTags: function(t3) {
    var e3 = this;
    if ((t3 = this.normalizeTags(t3))[0].prefix || this.state.tag)
      return this.prefixedTextToTag(t3[0]);
    var i3 = document.createDocumentFragment();
    return t3.forEach(function(t4) {
      var n3 = e3.prepareNewTagNode(t4);
      i3.appendChild(n3.tagElm), e3.insertAfterTag(n3.tagElm), e3.postProcessNewTagNode(n3.tagElm, n3.tagData);
    }), this.appendMixTags(i3), i3.children;
  }, appendMixTags: function(t3) {
    var e3 = !!this.state.selection;
    e3 ? this.injectAtCaret(t3) : (this.DOM.input.focus(), (e3 = this.setStateSelection()).range.setStart(this.DOM.input, e3.range.endOffset), e3.range.setEnd(this.DOM.input, e3.range.endOffset), this.DOM.input.appendChild(t3), this.updateValueByDOMTags(), this.update());
  }, prefixedTextToTag: function(t3) {
    var e3, i3, n3, s3 = this, a3 = this.settings, o3 = null === (e3 = this.state.tag) || void 0 === e3 ? void 0 : e3.delimiters;
    if (t3.prefix = t3.prefix || this.state.tag ? this.state.tag.prefix : (a3.pattern.source || a3.pattern)[0], n3 = this.prepareNewTagNode(t3), i3 = n3.tagElm, this.replaceTextWithNode(i3) || this.DOM.input.appendChild(i3), setTimeout(function() {
      return i3.classList.add(s3.settings.classNames.tagNoAnimation);
    }, 300), this.value.push(n3.tagData), this.update(), !o3) {
      var r3 = this.insertAfterTag(i3) || i3;
      setTimeout(T2, 0, r3);
    }
    return this.state.tag = null, this.postProcessNewTagNode(i3, n3.tagData), i3;
  }, appendTag: function(t3) {
    var e3 = this.DOM, i3 = e3.input;
    e3.scope.insertBefore(t3, i3);
  }, createTagElem: function(t3, e3) {
    t3.__tagId = m2();
    var i3, n3 = g2({}, t3, $({ value: c2(t3.value + "") }, e3));
    return function(t4) {
      for (var e4, i4 = document.createNodeIterator(t4, NodeFilter.SHOW_TEXT, null, false); e4 = i4.nextNode(); )
        e4.textContent.trim() || e4.parentNode.removeChild(e4);
    }(i3 = this.parseTemplate("tag", [n3, this])), y2(i3, t3), i3;
  }, reCheckInvalidTags: function() {
    var t3 = this, e3 = this.settings;
    this.getTagElms(e3.classNames.tagNotAllowed).forEach(function(i3, n3) {
      var s3 = y2(i3), a3 = t3.hasMaxTags(), o3 = t3.validateTag(s3), r3 = true === o3 && !a3;
      if ("select" == e3.mode && t3.toggleScopeValidation(o3), r3)
        return s3 = s3.__preInvalidData ? s3.__preInvalidData : { value: s3.value }, t3.replaceTag(i3, s3);
      i3.title = a3 || o3;
    });
  }, removeTags: function(t3, e3, i3) {
    var n3, s3 = this, a3 = this.settings;
    if (t3 = t3 && G2(t3, HTMLElement) ? [t3] : G2(t3, Array) ? t3 : t3 ? [t3] : [this.getLastTag()].filter(function(t4) {
      return t4;
    }), n3 = t3.reduce(function(t4, e4) {
      e4 && "string" == typeof e4 && (e4 = s3.getTagElmByValue(e4));
      var i4 = y2(e4);
      return e4 && i4 && !i4.readonly && t4.push({ node: e4, idx: s3.getTagIdx(i4), data: y2(e4, { __removed: true }) }), t4;
    }, []), i3 = "number" == typeof i3 ? i3 : this.CSSVars.tagHideTransition, "select" == a3.mode && (i3 = 0, this.input.set.call(this)), 1 == n3.length && "select" != a3.mode && n3[0].node.classList.contains(a3.classNames.tagNotAllowed) && (e3 = true), n3.length)
      return a3.hooks.beforeRemoveTag(n3, { tagify: this }).then(function() {
        var t4 = /* @__PURE__ */ __name(function(t5) {
          t5.node.parentNode && (t5.node.parentNode.removeChild(t5.node), e3 ? a3.keepInvalidTags && this.trigger("remove", { tag: t5.node, index: t5.idx }) : (this.trigger("remove", { tag: t5.node, index: t5.idx, data: t5.data }), this.dropdown.refilter(), this.dropdown.position(), this.DOM.input.normalize(), a3.keepInvalidTags && this.reCheckInvalidTags()));
        }, "t");
        i3 && i3 > 10 && 1 == n3.length ? function(e4) {
          e4.node.style.width = parseFloat(window.getComputedStyle(e4.node).width) + "px", document.body.clientTop, e4.node.classList.add(a3.classNames.tagHide), setTimeout(t4.bind(this), i3, e4);
        }.call(s3, n3[0]) : n3.forEach(t4.bind(s3)), e3 || (s3.removeTagsFromValue(n3.map(function(t5) {
          return t5.node;
        })), s3.update(), "select" == a3.mode && a3.userInput && s3.setContentEditable(true));
      }).catch(function(t4) {
      });
  }, removeTagsFromDOM: function() {
    this.getTagElms().forEach(function(t3) {
      return t3.remove();
    });
  }, removeTagsFromValue: function(t3) {
    var e3 = this;
    (t3 = Array.isArray(t3) ? t3 : [t3]).forEach(function(t4) {
      var i3 = y2(t4), n3 = e3.getTagIdx(i3);
      n3 > -1 && e3.value.splice(n3, 1);
    });
  }, removeAllTags: function(t3) {
    var e3 = this;
    t3 = t3 || {}, this.value = [], "mix" == this.settings.mode ? this.DOM.input.innerHTML = "" : this.removeTagsFromDOM(), this.dropdown.refilter(), this.dropdown.position(), this.state.dropdown.visible && setTimeout(function() {
      e3.DOM.input.focus();
    }), "select" == this.settings.mode && (this.input.set.call(this), this.settings.userInput && this.setContentEditable(true)), this.update(t3);
  }, postUpdate: function() {
    this.state.blockChangeEvent = false;
    var t3, e3, i3 = this.settings, n3 = i3.classNames, s3 = "mix" == i3.mode ? i3.mixMode.integrated ? this.DOM.input.textContent : this.DOM.originalInput.value.trim() : this.value.length + this.input.raw.call(this).length;
    (this.toggleClass(n3.hasMaxTags, this.value.length >= i3.maxTags), this.toggleClass(n3.hasNoTags, !this.value.length), this.toggleClass(n3.empty, !s3), "select" == i3.mode) && this.toggleScopeValidation(null === (e3 = this.value) || void 0 === e3 || null === (t3 = e3[0]) || void 0 === t3 ? void 0 : t3.__isValid);
  }, setOriginalInputValue: function(t3) {
    var e3 = this.DOM.originalInput;
    this.settings.mixMode.integrated || (e3.value = t3, e3.tagifyValue = e3.value, this.setPersistedData(t3, "value"));
  }, update: function(t3) {
    clearTimeout(this.debouncedUpdateTimeout), this.debouncedUpdateTimeout = setTimeout(function() {
      var e3 = this.getInputValue();
      this.setOriginalInputValue(e3), this.settings.onChangeAfterBlur && (t3 || {}).withoutChangeEvent || this.state.blockChangeEvent || this.triggerChangeEvent();
      this.postUpdate();
    }.bind(this), 100), this.events.bindOriginaInputListener.call(this, 100);
  }, getInputValue: function() {
    var t3 = this.getCleanValue();
    return "mix" == this.settings.mode ? this.getMixedTagsAsString(t3) : t3.length ? this.settings.originalInputValueFormat ? this.settings.originalInputValueFormat(t3) : JSON.stringify(t3) : "";
  }, getCleanValue: function(t3) {
    return a2(t3 || this.value, this.dataProps);
  }, getMixedTagsAsString: function() {
    var t3 = "", e3 = this, i3 = this.settings, n3 = i3.originalInputValueFormat || JSON.stringify, s3 = i3.mixTagsInterpolator;
    return (/* @__PURE__ */ __name(function i4(a3) {
      a3.childNodes.forEach(function(a4) {
        if (1 == a4.nodeType) {
          var r3 = y2(a4);
          if ("BR" == a4.tagName && (t3 += "\r\n"), r3 && v2.call(e3, a4)) {
            if (r3.__removed)
              return;
            t3 += s3[0] + n3(o2(r3, e3.dataProps)) + s3[1];
          } else
            a4.getAttribute("style") || ["B", "I", "U"].includes(a4.tagName) ? t3 += a4.textContent : "DIV" != a4.tagName && "P" != a4.tagName || (t3 += "\r\n", i4(a4));
        } else
          t3 += a4.textContent;
      });
    }, "i"))(this.DOM.input), t3;
  } }, Y2.prototype.removeTag = Y2.prototype.removeTags;

  // app/javascript/controllers/tag_field_controller.js
  var TagFieldController = class extends Controller {
    static {
      __name(this, "TagFieldController");
    }
    connect() {
      this.tagify = new Y2(this.querySelector("textarea"), this.opticons());
    }
    opticons() {
      const options = JSON.parse(this.dataset["tagify"] || "{}");
      return Object.assign({ originalInputValueFormat: this.mapValue }, options);
    }
    mapValue(valuesArr) {
      return valuesArr.map((item) => item.value).join(",");
    }
  };

  // ../highway/app/javascript/admin/toggle_forms_controller.js
  var ToggleFormsController = class extends Controller2 {
    static {
      __name(this, "ToggleFormsController");
    }
    connect() {
      this.toggler = document.getElementById(this.dataset["toggler"]);
      this.toggleTarget = document.getElementById(this.dataset["toggleTarget"]);
      this.toggler.addEventListener("change", this.onChange.bind(this), false);
      this.onChange();
    }
    onChange(e3) {
      if (this.toggler.value == this.dataset["toggleValue"]) {
        this.toggleTarget.classList.remove("hidden");
      } else {
        this.toggleTarget.classList.add("hidden");
      }
    }
  };

  // app/javascript/schladming.js
  application.register(AdminCleaveController);
  application.register(AdminTabController);
  application.register(BackToScopeController);
  application.register(BatchActionController);
  application.register(ClickableRowController);
  application.register(CommissionCalculatorController);
  application.register(DateSelectController);
  application.register(DatetimeSelectController);
  application.register(DraggableController);
  application.register(GeoSearchController);
  application.register(GlobalSearchController);
  application.register(HamburgerMenuController);
  application.register(ImagePreviewController);
  application.register(LeadDialogController);
  application.register(LeadFiltersController);
  application.register(LeadGroupController);
  application.register(LeafletController);
  application.register(PastClosedAtController);
  application.register(RelationSearchController);
  application.register(ReserveGuardController);
  application.register(RichTextEditorController);
  application.register(SelectAllController);
  application.register(SlugonatorController);
  application.register(TagFieldController);
  application.register(ToggleFormsController);
  application.start();
})();
/*! Bundled license information:

leaflet/dist/leaflet-src.js:
  (* @preserve
   * Leaflet 1.9.4, a JS library for interactive maps. https://leafletjs.com
   * (c) 2010-2023 Vladimir Agafonkin, (c) 2010-2011 CloudMade
   *)

@hotwired/turbo/dist/turbo.es2017-esm.js:
  (*!
  Turbo 8.0.4
  Copyright © 2024 37signals LLC
   *)

js-cookie/dist/js.cookie.mjs:
  (*! js-cookie v3.0.5 | MIT *)

sortablejs/modular/sortable.core.esm.js:
  (**!
   * Sortable 1.15.6
   * @author	RubaXa   <trash@rubaxa.org>
   * @author	owenm    <owen23355@gmail.com>
   * @license MIT
   *)

lodash-es/lodash.js:
  (**
   * @license
   * Lodash (Custom Build) <https://lodash.com/>
   * Build: `lodash modularize exports="es" -o ./`
   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   *)
*/
//# sourceMappingURL=schladming.js.map
